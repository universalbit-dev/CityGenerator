/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@svgdotjs/svg.js/dist/svg.esm.js":
/*!*******************************************************!*\
  !*** ./node_modules/@svgdotjs/svg.js/dist/svg.esm.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ A),
/* harmony export */   Animator: () => (/* binding */ Animator),
/* harmony export */   Array: () => (/* binding */ SVGArray),
/* harmony export */   Box: () => (/* binding */ Box),
/* harmony export */   Circle: () => (/* binding */ Circle),
/* harmony export */   ClipPath: () => (/* binding */ ClipPath),
/* harmony export */   Color: () => (/* binding */ Color),
/* harmony export */   Container: () => (/* binding */ Container),
/* harmony export */   Controller: () => (/* binding */ Controller),
/* harmony export */   Defs: () => (/* binding */ Defs),
/* harmony export */   Dom: () => (/* binding */ Dom),
/* harmony export */   Ease: () => (/* binding */ Ease),
/* harmony export */   Element: () => (/* binding */ Element),
/* harmony export */   Ellipse: () => (/* binding */ Ellipse),
/* harmony export */   EventTarget: () => (/* binding */ EventTarget),
/* harmony export */   ForeignObject: () => (/* binding */ ForeignObject),
/* harmony export */   Fragment: () => (/* binding */ Fragment),
/* harmony export */   G: () => (/* binding */ G),
/* harmony export */   Gradient: () => (/* binding */ Gradient),
/* harmony export */   Image: () => (/* binding */ Image),
/* harmony export */   Line: () => (/* binding */ Line),
/* harmony export */   List: () => (/* binding */ List),
/* harmony export */   Marker: () => (/* binding */ Marker),
/* harmony export */   Mask: () => (/* binding */ Mask),
/* harmony export */   Matrix: () => (/* binding */ Matrix),
/* harmony export */   Morphable: () => (/* binding */ Morphable),
/* harmony export */   NonMorphable: () => (/* binding */ NonMorphable),
/* harmony export */   Number: () => (/* binding */ SVGNumber),
/* harmony export */   ObjectBag: () => (/* binding */ ObjectBag),
/* harmony export */   PID: () => (/* binding */ PID),
/* harmony export */   Path: () => (/* binding */ Path),
/* harmony export */   PathArray: () => (/* binding */ PathArray),
/* harmony export */   Pattern: () => (/* binding */ Pattern),
/* harmony export */   Point: () => (/* binding */ Point),
/* harmony export */   PointArray: () => (/* binding */ PointArray),
/* harmony export */   Polygon: () => (/* binding */ Polygon),
/* harmony export */   Polyline: () => (/* binding */ Polyline),
/* harmony export */   Queue: () => (/* binding */ Queue),
/* harmony export */   Rect: () => (/* binding */ Rect),
/* harmony export */   Runner: () => (/* binding */ Runner),
/* harmony export */   SVG: () => (/* binding */ SVG),
/* harmony export */   Shape: () => (/* binding */ Shape),
/* harmony export */   Spring: () => (/* binding */ Spring),
/* harmony export */   Stop: () => (/* binding */ Stop),
/* harmony export */   Style: () => (/* binding */ Style),
/* harmony export */   Svg: () => (/* binding */ Svg),
/* harmony export */   Symbol: () => (/* binding */ Symbol),
/* harmony export */   Text: () => (/* binding */ Text),
/* harmony export */   TextPath: () => (/* binding */ TextPath),
/* harmony export */   Timeline: () => (/* binding */ Timeline),
/* harmony export */   TransformBag: () => (/* binding */ TransformBag),
/* harmony export */   Tspan: () => (/* binding */ Tspan),
/* harmony export */   Use: () => (/* binding */ Use),
/* harmony export */   adopt: () => (/* binding */ adopt),
/* harmony export */   assignNewId: () => (/* binding */ assignNewId),
/* harmony export */   clearEvents: () => (/* binding */ clearEvents),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   defaults: () => (/* binding */ defaults),
/* harmony export */   dispatch: () => (/* binding */ dispatch),
/* harmony export */   easing: () => (/* binding */ easing),
/* harmony export */   eid: () => (/* binding */ eid),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   find: () => (/* binding */ baseFind),
/* harmony export */   getClass: () => (/* binding */ getClass),
/* harmony export */   getEventTarget: () => (/* binding */ getEventTarget),
/* harmony export */   getEvents: () => (/* binding */ getEvents),
/* harmony export */   getWindow: () => (/* binding */ getWindow),
/* harmony export */   makeInstance: () => (/* binding */ makeInstance),
/* harmony export */   makeMorphable: () => (/* binding */ makeMorphable),
/* harmony export */   mockAdopt: () => (/* binding */ mockAdopt),
/* harmony export */   namespaces: () => (/* binding */ namespaces),
/* harmony export */   nodeOrNew: () => (/* binding */ nodeOrNew),
/* harmony export */   off: () => (/* binding */ off),
/* harmony export */   on: () => (/* binding */ on),
/* harmony export */   parser: () => (/* binding */ parser),
/* harmony export */   regex: () => (/* binding */ regex),
/* harmony export */   register: () => (/* binding */ register),
/* harmony export */   registerMorphableType: () => (/* binding */ registerMorphableType),
/* harmony export */   registerWindow: () => (/* binding */ registerWindow),
/* harmony export */   restoreWindow: () => (/* binding */ restoreWindow),
/* harmony export */   root: () => (/* binding */ root),
/* harmony export */   saveWindow: () => (/* binding */ saveWindow),
/* harmony export */   utils: () => (/* binding */ utils),
/* harmony export */   windowEvents: () => (/* binding */ windowEvents),
/* harmony export */   withWindow: () => (/* binding */ withWindow),
/* harmony export */   wrapWithAttrCheck: () => (/* binding */ wrapWithAttrCheck)
/* harmony export */ });
/*!
* @svgdotjs/svg.js - A lightweight library for manipulating and animating SVG.
* @version 3.2.0
* https://svgjs.dev/
*
* @copyright Wout Fierens <wout@mick-wout.com>
* @license MIT
*
* BUILT: Mon Jun 12 2023 10:34:51 GMT+0200 (Central European Summer Time)
*/;
const methods$1 = {};
const names = [];
function registerMethods(name, m) {
  if (Array.isArray(name)) {
    for (const _name of name) {
      registerMethods(_name, m);
    }

    return;
  }

  if (typeof name === 'object') {
    for (const _name in name) {
      registerMethods(_name, name[_name]);
    }

    return;
  }

  addMethodNames(Object.getOwnPropertyNames(m));
  methods$1[name] = Object.assign(methods$1[name] || {}, m);
}
function getMethodsFor(name) {
  return methods$1[name] || {};
}
function getMethodNames() {
  return [...new Set(names)];
}
function addMethodNames(_names) {
  names.push(..._names);
}

// Map function
function map(array, block) {
  let i;
  const il = array.length;
  const result = [];

  for (i = 0; i < il; i++) {
    result.push(block(array[i]));
  }

  return result;
} // Filter function

function filter(array, block) {
  let i;
  const il = array.length;
  const result = [];

  for (i = 0; i < il; i++) {
    if (block(array[i])) {
      result.push(array[i]);
    }
  }

  return result;
} // Degrees to radians

function radians(d) {
  return d % 360 * Math.PI / 180;
} // Radians to degrees

function degrees(r) {
  return r * 180 / Math.PI % 360;
} // Convert dash-separated-string to camelCase

function camelCase(s) {
  return s.toLowerCase().replace(/-(.)/g, function (m, g) {
    return g.toUpperCase();
  });
} // Convert camel cased string to dash separated

function unCamelCase(s) {
  return s.replace(/([A-Z])/g, function (m, g) {
    return '-' + g.toLowerCase();
  });
} // Capitalize first letter of a string

function capitalize(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
} // Calculate proportional width and height values when necessary

function proportionalSize(element, width, height, box) {
  if (width == null || height == null) {
    box = box || element.bbox();

    if (width == null) {
      width = box.width / box.height * height;
    } else if (height == null) {
      height = box.height / box.width * width;
    }
  }

  return {
    width: width,
    height: height
  };
}
/**
 * This function adds support for string origins.
 * It searches for an origin in o.origin o.ox and o.originX.
 * This way, origin: {x: 'center', y: 50} can be passed as well as ox: 'center', oy: 50
**/

function getOrigin(o, element) {
  const origin = o.origin; // First check if origin is in ox or originX

  let ox = o.ox != null ? o.ox : o.originX != null ? o.originX : 'center';
  let oy = o.oy != null ? o.oy : o.originY != null ? o.originY : 'center'; // Then check if origin was used and overwrite in that case

  if (origin != null) {
    [ox, oy] = Array.isArray(origin) ? origin : typeof origin === 'object' ? [origin.x, origin.y] : [origin, origin];
  } // Make sure to only call bbox when actually needed


  const condX = typeof ox === 'string';
  const condY = typeof oy === 'string';

  if (condX || condY) {
    const {
      height,
      width,
      x,
      y
    } = element.bbox(); // And only overwrite if string was passed for this specific axis

    if (condX) {
      ox = ox.includes('left') ? x : ox.includes('right') ? x + width : x + width / 2;
    }

    if (condY) {
      oy = oy.includes('top') ? y : oy.includes('bottom') ? y + height : y + height / 2;
    }
  } // Return the origin as it is if it wasn't a string


  return [ox, oy];
}

var utils = {
  __proto__: null,
  map: map,
  filter: filter,
  radians: radians,
  degrees: degrees,
  camelCase: camelCase,
  unCamelCase: unCamelCase,
  capitalize: capitalize,
  proportionalSize: proportionalSize,
  getOrigin: getOrigin
};

// Default namespaces
const svg = 'http://www.w3.org/2000/svg';
const html = 'http://www.w3.org/1999/xhtml';
const xmlns = 'http://www.w3.org/2000/xmlns/';
const xlink = 'http://www.w3.org/1999/xlink';
const svgjs = 'http://svgjs.dev/svgjs';

var namespaces = {
  __proto__: null,
  svg: svg,
  html: html,
  xmlns: xmlns,
  xlink: xlink,
  svgjs: svgjs
};

const globals = {
  window: typeof window === 'undefined' ? null : window,
  document: typeof document === 'undefined' ? null : document
};
function registerWindow(win = null, doc = null) {
  globals.window = win;
  globals.document = doc;
}
const save = {};
function saveWindow() {
  save.window = globals.window;
  save.document = globals.document;
}
function restoreWindow() {
  globals.window = save.window;
  globals.document = save.document;
}
function withWindow(win, fn) {
  saveWindow();
  registerWindow(win, win.document);
  fn(win, win.document);
  restoreWindow();
}
function getWindow() {
  return globals.window;
}

class Base {// constructor (node/*, {extensions = []} */) {
  //   // this.tags = []
  //   //
  //   // for (let extension of extensions) {
  //   //   extension.setup.call(this, node)
  //   //   this.tags.push(extension.name)
  //   // }
  // }
}

const elements = {};
const root = '___SYMBOL___ROOT___'; // Method for element creation

function create(name, ns = svg) {
  // create element
  return globals.document.createElementNS(ns, name);
}
function makeInstance(element, isHTML = false) {
  if (element instanceof Base) return element;

  if (typeof element === 'object') {
    return adopter(element);
  }

  if (element == null) {
    return new elements[root]();
  }

  if (typeof element === 'string' && element.charAt(0) !== '<') {
    return adopter(globals.document.querySelector(element));
  } // Make sure, that HTML elements are created with the correct namespace


  const wrapper = isHTML ? globals.document.createElement('div') : create('svg');
  wrapper.innerHTML = element; // We can use firstChild here because we know,
  // that the first char is < and thus an element

  element = adopter(wrapper.firstChild); // make sure, that element doesn't have its wrapper attached

  wrapper.removeChild(wrapper.firstChild);
  return element;
}
function nodeOrNew(name, node) {
  return node && node.ownerDocument && node instanceof node.ownerDocument.defaultView.Node ? node : create(name);
} // Adopt existing svg elements

function adopt(node) {
  // check for presence of node
  if (!node) return null; // make sure a node isn't already adopted

  if (node.instance instanceof Base) return node.instance;

  if (node.nodeName === '#document-fragment') {
    return new elements.Fragment(node);
  } // initialize variables


  let className = capitalize(node.nodeName || 'Dom'); // Make sure that gradients are adopted correctly

  if (className === 'LinearGradient' || className === 'RadialGradient') {
    className = 'Gradient'; // Fallback to Dom if element is not known
  } else if (!elements[className]) {
    className = 'Dom';
  }

  return new elements[className](node);
}
let adopter = adopt;
function mockAdopt(mock = adopt) {
  adopter = mock;
}
function register(element, name = element.name, asRoot = false) {
  elements[name] = element;
  if (asRoot) elements[root] = element;
  addMethodNames(Object.getOwnPropertyNames(element.prototype));
  return element;
}
function getClass(name) {
  return elements[name];
} // Element id sequence

let did = 1000; // Get next named element id

function eid(name) {
  return 'Svgjs' + capitalize(name) + did++;
} // Deep new id assignment

function assignNewId(node) {
  // do the same for SVG child nodes as well
  for (let i = node.children.length - 1; i >= 0; i--) {
    assignNewId(node.children[i]);
  }

  if (node.id) {
    node.id = eid(node.nodeName);
    return node;
  }

  return node;
} // Method for extending objects

function extend(modules, methods) {
  let key, i;
  modules = Array.isArray(modules) ? modules : [modules];

  for (i = modules.length - 1; i >= 0; i--) {
    for (key in methods) {
      modules[i].prototype[key] = methods[key];
    }
  }
}
function wrapWithAttrCheck(fn) {
  return function (...args) {
    const o = args[args.length - 1];

    if (o && o.constructor === Object && !(o instanceof Array)) {
      return fn.apply(this, args.slice(0, -1)).attr(o);
    } else {
      return fn.apply(this, args);
    }
  };
}

function siblings() {
  return this.parent().children();
} // Get the current position siblings

function position() {
  return this.parent().index(this);
} // Get the next element (will return null if there is none)

function next() {
  return this.siblings()[this.position() + 1];
} // Get the next element (will return null if there is none)

function prev() {
  return this.siblings()[this.position() - 1];
} // Send given element one step forward

function forward() {
  const i = this.position();
  const p = this.parent(); // move node one step forward

  p.add(this.remove(), i + 1);
  return this;
} // Send given element one step backward

function backward() {
  const i = this.position();
  const p = this.parent();
  p.add(this.remove(), i ? i - 1 : 0);
  return this;
} // Send given element all the way to the front

function front() {
  const p = this.parent(); // Move node forward

  p.add(this.remove());
  return this;
} // Send given element all the way to the back

function back() {
  const p = this.parent(); // Move node back

  p.add(this.remove(), 0);
  return this;
} // Inserts a given element before the targeted element

function before(element) {
  element = makeInstance(element);
  element.remove();
  const i = this.position();
  this.parent().add(element, i);
  return this;
} // Inserts a given element after the targeted element

function after(element) {
  element = makeInstance(element);
  element.remove();
  const i = this.position();
  this.parent().add(element, i + 1);
  return this;
}
function insertBefore(element) {
  element = makeInstance(element);
  element.before(this);
  return this;
}
function insertAfter(element) {
  element = makeInstance(element);
  element.after(this);
  return this;
}
registerMethods('Dom', {
  siblings,
  position,
  next,
  prev,
  forward,
  backward,
  front,
  back,
  before,
  after,
  insertBefore,
  insertAfter
});

// Parse unit value
const numberAndUnit = /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i; // Parse hex value

const hex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i; // Parse rgb value

const rgb = /rgb\((\d+),(\d+),(\d+)\)/; // Parse reference id

const reference = /(#[a-z_][a-z0-9\-_]*)/i; // splits a transformation chain

const transforms = /\)\s*,?\s*/; // Whitespace

const whitespace = /\s/g; // Test hex value

const isHex = /^#[a-f0-9]{3}$|^#[a-f0-9]{6}$/i; // Test rgb value

const isRgb = /^rgb\(/; // Test for blank string

const isBlank = /^(\s+)?$/; // Test for numeric string

const isNumber = /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i; // Test for image url

const isImage = /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i; // split at whitespace and comma

const delimiter = /[\s,]+/; // Test for path letter

const isPathLetter = /[MLHVCSQTAZ]/i;

var regex = {
  __proto__: null,
  numberAndUnit: numberAndUnit,
  hex: hex,
  rgb: rgb,
  reference: reference,
  transforms: transforms,
  whitespace: whitespace,
  isHex: isHex,
  isRgb: isRgb,
  isBlank: isBlank,
  isNumber: isNumber,
  isImage: isImage,
  delimiter: delimiter,
  isPathLetter: isPathLetter
};

function classes() {
  const attr = this.attr('class');
  return attr == null ? [] : attr.trim().split(delimiter);
} // Return true if class exists on the node, false otherwise

function hasClass(name) {
  return this.classes().indexOf(name) !== -1;
} // Add class to the node

function addClass(name) {
  if (!this.hasClass(name)) {
    const array = this.classes();
    array.push(name);
    this.attr('class', array.join(' '));
  }

  return this;
} // Remove class from the node

function removeClass(name) {
  if (this.hasClass(name)) {
    this.attr('class', this.classes().filter(function (c) {
      return c !== name;
    }).join(' '));
  }

  return this;
} // Toggle the presence of a class on the node

function toggleClass(name) {
  return this.hasClass(name) ? this.removeClass(name) : this.addClass(name);
}
registerMethods('Dom', {
  classes,
  hasClass,
  addClass,
  removeClass,
  toggleClass
});

function css(style, val) {
  const ret = {};

  if (arguments.length === 0) {
    // get full style as object
    this.node.style.cssText.split(/\s*;\s*/).filter(function (el) {
      return !!el.length;
    }).forEach(function (el) {
      const t = el.split(/\s*:\s*/);
      ret[t[0]] = t[1];
    });
    return ret;
  }

  if (arguments.length < 2) {
    // get style properties as array
    if (Array.isArray(style)) {
      for (const name of style) {
        const cased = camelCase(name);
        ret[name] = this.node.style[cased];
      }

      return ret;
    } // get style for property


    if (typeof style === 'string') {
      return this.node.style[camelCase(style)];
    } // set styles in object


    if (typeof style === 'object') {
      for (const name in style) {
        // set empty string if null/undefined/'' was given
        this.node.style[camelCase(name)] = style[name] == null || isBlank.test(style[name]) ? '' : style[name];
      }
    }
  } // set style for property


  if (arguments.length === 2) {
    this.node.style[camelCase(style)] = val == null || isBlank.test(val) ? '' : val;
  }

  return this;
} // Show element

function show() {
  return this.css('display', '');
} // Hide element

function hide() {
  return this.css('display', 'none');
} // Is element visible?

function visible() {
  return this.css('display') !== 'none';
}
registerMethods('Dom', {
  css,
  show,
  hide,
  visible
});

function data(a, v, r) {
  if (a == null) {
    // get an object of attributes
    return this.data(map(filter(this.node.attributes, el => el.nodeName.indexOf('data-') === 0), el => el.nodeName.slice(5)));
  } else if (a instanceof Array) {
    const data = {};

    for (const key of a) {
      data[key] = this.data(key);
    }

    return data;
  } else if (typeof a === 'object') {
    for (v in a) {
      this.data(v, a[v]);
    }
  } else if (arguments.length < 2) {
    try {
      return JSON.parse(this.attr('data-' + a));
    } catch (e) {
      return this.attr('data-' + a);
    }
  } else {
    this.attr('data-' + a, v === null ? null : r === true || typeof v === 'string' || typeof v === 'number' ? v : JSON.stringify(v));
  }

  return this;
}
registerMethods('Dom', {
  data
});

function remember(k, v) {
  // remember every item in an object individually
  if (typeof arguments[0] === 'object') {
    for (const key in k) {
      this.remember(key, k[key]);
    }
  } else if (arguments.length === 1) {
    // retrieve memory
    return this.memory()[k];
  } else {
    // store memory
    this.memory()[k] = v;
  }

  return this;
} // Erase a given memory

function forget() {
  if (arguments.length === 0) {
    this._memory = {};
  } else {
    for (let i = arguments.length - 1; i >= 0; i--) {
      delete this.memory()[arguments[i]];
    }
  }

  return this;
} // This triggers creation of a new hidden class which is not performant
// However, this function is not rarely used so it will not happen frequently
// Return local memory object

function memory() {
  return this._memory = this._memory || {};
}
registerMethods('Dom', {
  remember,
  forget,
  memory
});

function sixDigitHex(hex) {
  return hex.length === 4 ? ['#', hex.substring(1, 2), hex.substring(1, 2), hex.substring(2, 3), hex.substring(2, 3), hex.substring(3, 4), hex.substring(3, 4)].join('') : hex;
}

function componentHex(component) {
  const integer = Math.round(component);
  const bounded = Math.max(0, Math.min(255, integer));
  const hex = bounded.toString(16);
  return hex.length === 1 ? '0' + hex : hex;
}

function is(object, space) {
  for (let i = space.length; i--;) {
    if (object[space[i]] == null) {
      return false;
    }
  }

  return true;
}

function getParameters(a, b) {
  const params = is(a, 'rgb') ? {
    _a: a.r,
    _b: a.g,
    _c: a.b,
    _d: 0,
    space: 'rgb'
  } : is(a, 'xyz') ? {
    _a: a.x,
    _b: a.y,
    _c: a.z,
    _d: 0,
    space: 'xyz'
  } : is(a, 'hsl') ? {
    _a: a.h,
    _b: a.s,
    _c: a.l,
    _d: 0,
    space: 'hsl'
  } : is(a, 'lab') ? {
    _a: a.l,
    _b: a.a,
    _c: a.b,
    _d: 0,
    space: 'lab'
  } : is(a, 'lch') ? {
    _a: a.l,
    _b: a.c,
    _c: a.h,
    _d: 0,
    space: 'lch'
  } : is(a, 'cmyk') ? {
    _a: a.c,
    _b: a.m,
    _c: a.y,
    _d: a.k,
    space: 'cmyk'
  } : {
    _a: 0,
    _b: 0,
    _c: 0,
    space: 'rgb'
  };
  params.space = b || params.space;
  return params;
}

function cieSpace(space) {
  if (space === 'lab' || space === 'xyz' || space === 'lch') {
    return true;
  } else {
    return false;
  }
}

function hueToRgb(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}

class Color {
  constructor(...inputs) {
    this.init(...inputs);
  } // Test if given value is a color


  static isColor(color) {
    return color && (color instanceof Color || this.isRgb(color) || this.test(color));
  } // Test if given value is an rgb object


  static isRgb(color) {
    return color && typeof color.r === 'number' && typeof color.g === 'number' && typeof color.b === 'number';
  }
  /*
  Generating random colors
  */


  static random(mode = 'vibrant', t, u) {
    // Get the math modules
    const {
      random,
      round,
      sin,
      PI: pi
    } = Math; // Run the correct generator

    if (mode === 'vibrant') {
      const l = (81 - 57) * random() + 57;
      const c = (83 - 45) * random() + 45;
      const h = 360 * random();
      const color = new Color(l, c, h, 'lch');
      return color;
    } else if (mode === 'sine') {
      t = t == null ? random() : t;
      const r = round(80 * sin(2 * pi * t / 0.5 + 0.01) + 150);
      const g = round(50 * sin(2 * pi * t / 0.5 + 4.6) + 200);
      const b = round(100 * sin(2 * pi * t / 0.5 + 2.3) + 150);
      const color = new Color(r, g, b);
      return color;
    } else if (mode === 'pastel') {
      const l = (94 - 86) * random() + 86;
      const c = (26 - 9) * random() + 9;
      const h = 360 * random();
      const color = new Color(l, c, h, 'lch');
      return color;
    } else if (mode === 'dark') {
      const l = 10 + 10 * random();
      const c = (125 - 75) * random() + 86;
      const h = 360 * random();
      const color = new Color(l, c, h, 'lch');
      return color;
    } else if (mode === 'rgb') {
      const r = 255 * random();
      const g = 255 * random();
      const b = 255 * random();
      const color = new Color(r, g, b);
      return color;
    } else if (mode === 'lab') {
      const l = 100 * random();
      const a = 256 * random() - 128;
      const b = 256 * random() - 128;
      const color = new Color(l, a, b, 'lab');
      return color;
    } else if (mode === 'grey') {
      const grey = 255 * random();
      const color = new Color(grey, grey, grey);
      return color;
    } else {
      throw new Error('Unsupported random color mode');
    }
  } // Test if given value is a color string


  static test(color) {
    return typeof color === 'string' && (isHex.test(color) || isRgb.test(color));
  }

  cmyk() {
    // Get the rgb values for the current color
    const {
      _a,
      _b,
      _c
    } = this.rgb();
    const [r, g, b] = [_a, _b, _c].map(v => v / 255); // Get the cmyk values in an unbounded format

    const k = Math.min(1 - r, 1 - g, 1 - b);

    if (k === 1) {
      // Catch the black case
      return new Color(0, 0, 0, 1, 'cmyk');
    }

    const c = (1 - r - k) / (1 - k);
    const m = (1 - g - k) / (1 - k);
    const y = (1 - b - k) / (1 - k); // Construct the new color

    const color = new Color(c, m, y, k, 'cmyk');
    return color;
  }

  hsl() {
    // Get the rgb values
    const {
      _a,
      _b,
      _c
    } = this.rgb();
    const [r, g, b] = [_a, _b, _c].map(v => v / 255); // Find the maximum and minimum values to get the lightness

    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const l = (max + min) / 2; // If the r, g, v values are identical then we are grey

    const isGrey = max === min; // Calculate the hue and saturation

    const delta = max - min;
    const s = isGrey ? 0 : l > 0.5 ? delta / (2 - max - min) : delta / (max + min);
    const h = isGrey ? 0 : max === r ? ((g - b) / delta + (g < b ? 6 : 0)) / 6 : max === g ? ((b - r) / delta + 2) / 6 : max === b ? ((r - g) / delta + 4) / 6 : 0; // Construct and return the new color

    const color = new Color(360 * h, 100 * s, 100 * l, 'hsl');
    return color;
  }

  init(a = 0, b = 0, c = 0, d = 0, space = 'rgb') {
    // This catches the case when a falsy value is passed like ''
    a = !a ? 0 : a; // Reset all values in case the init function is rerun with new color space

    if (this.space) {
      for (const component in this.space) {
        delete this[this.space[component]];
      }
    }

    if (typeof a === 'number') {
      // Allow for the case that we don't need d...
      space = typeof d === 'string' ? d : space;
      d = typeof d === 'string' ? 0 : d; // Assign the values straight to the color

      Object.assign(this, {
        _a: a,
        _b: b,
        _c: c,
        _d: d,
        space
      }); // If the user gave us an array, make the color from it
    } else if (a instanceof Array) {
      this.space = b || (typeof a[3] === 'string' ? a[3] : a[4]) || 'rgb';
      Object.assign(this, {
        _a: a[0],
        _b: a[1],
        _c: a[2],
        _d: a[3] || 0
      });
    } else if (a instanceof Object) {
      // Set the object up and assign its values directly
      const values = getParameters(a, b);
      Object.assign(this, values);
    } else if (typeof a === 'string') {
      if (isRgb.test(a)) {
        const noWhitespace = a.replace(whitespace, '');
        const [_a, _b, _c] = rgb.exec(noWhitespace).slice(1, 4).map(v => parseInt(v));
        Object.assign(this, {
          _a,
          _b,
          _c,
          _d: 0,
          space: 'rgb'
        });
      } else if (isHex.test(a)) {
        const hexParse = v => parseInt(v, 16);

        const [, _a, _b, _c] = hex.exec(sixDigitHex(a)).map(hexParse);
        Object.assign(this, {
          _a,
          _b,
          _c,
          _d: 0,
          space: 'rgb'
        });
      } else throw Error('Unsupported string format, can\'t construct Color');
    } // Now add the components as a convenience


    const {
      _a,
      _b,
      _c,
      _d
    } = this;
    const components = this.space === 'rgb' ? {
      r: _a,
      g: _b,
      b: _c
    } : this.space === 'xyz' ? {
      x: _a,
      y: _b,
      z: _c
    } : this.space === 'hsl' ? {
      h: _a,
      s: _b,
      l: _c
    } : this.space === 'lab' ? {
      l: _a,
      a: _b,
      b: _c
    } : this.space === 'lch' ? {
      l: _a,
      c: _b,
      h: _c
    } : this.space === 'cmyk' ? {
      c: _a,
      m: _b,
      y: _c,
      k: _d
    } : {};
    Object.assign(this, components);
  }

  lab() {
    // Get the xyz color
    const {
      x,
      y,
      z
    } = this.xyz(); // Get the lab components

    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z); // Construct and return a new color

    const color = new Color(l, a, b, 'lab');
    return color;
  }

  lch() {
    // Get the lab color directly
    const {
      l,
      a,
      b
    } = this.lab(); // Get the chromaticity and the hue using polar coordinates

    const c = Math.sqrt(a ** 2 + b ** 2);
    let h = 180 * Math.atan2(b, a) / Math.PI;

    if (h < 0) {
      h *= -1;
      h = 360 - h;
    } // Make a new color and return it


    const color = new Color(l, c, h, 'lch');
    return color;
  }
  /*
  Conversion Methods
  */


  rgb() {
    if (this.space === 'rgb') {
      return this;
    } else if (cieSpace(this.space)) {
      // Convert to the xyz color space
      let {
        x,
        y,
        z
      } = this;

      if (this.space === 'lab' || this.space === 'lch') {
        // Get the values in the lab space
        let {
          l,
          a,
          b
        } = this;

        if (this.space === 'lch') {
          const {
            c,
            h
          } = this;
          const dToR = Math.PI / 180;
          a = c * Math.cos(dToR * h);
          b = c * Math.sin(dToR * h);
        } // Undo the nonlinear function


        const yL = (l + 16) / 116;
        const xL = a / 500 + yL;
        const zL = yL - b / 200; // Get the xyz values

        const ct = 16 / 116;
        const mx = 0.008856;
        const nm = 7.787;
        x = 0.95047 * (xL ** 3 > mx ? xL ** 3 : (xL - ct) / nm);
        y = 1.00000 * (yL ** 3 > mx ? yL ** 3 : (yL - ct) / nm);
        z = 1.08883 * (zL ** 3 > mx ? zL ** 3 : (zL - ct) / nm);
      } // Convert xyz to unbounded rgb values


      const rU = x * 3.2406 + y * -1.5372 + z * -0.4986;
      const gU = x * -0.9689 + y * 1.8758 + z * 0.0415;
      const bU = x * 0.0557 + y * -0.2040 + z * 1.0570; // Convert the values to true rgb values

      const pow = Math.pow;
      const bd = 0.0031308;
      const r = rU > bd ? 1.055 * pow(rU, 1 / 2.4) - 0.055 : 12.92 * rU;
      const g = gU > bd ? 1.055 * pow(gU, 1 / 2.4) - 0.055 : 12.92 * gU;
      const b = bU > bd ? 1.055 * pow(bU, 1 / 2.4) - 0.055 : 12.92 * bU; // Make and return the color

      const color = new Color(255 * r, 255 * g, 255 * b);
      return color;
    } else if (this.space === 'hsl') {
      // https://bgrins.github.io/TinyColor/docs/tinycolor.html
      // Get the current hsl values
      let {
        h,
        s,
        l
      } = this;
      h /= 360;
      s /= 100;
      l /= 100; // If we are grey, then just make the color directly

      if (s === 0) {
        l *= 255;
        const color = new Color(l, l, l);
        return color;
      } // TODO I have no idea what this does :D If you figure it out, tell me!


      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q; // Get the rgb values

      const r = 255 * hueToRgb(p, q, h + 1 / 3);
      const g = 255 * hueToRgb(p, q, h);
      const b = 255 * hueToRgb(p, q, h - 1 / 3); // Make a new color

      const color = new Color(r, g, b);
      return color;
    } else if (this.space === 'cmyk') {
      // https://gist.github.com/felipesabino/5066336
      // Get the normalised cmyk values
      const {
        c,
        m,
        y,
        k
      } = this; // Get the rgb values

      const r = 255 * (1 - Math.min(1, c * (1 - k) + k));
      const g = 255 * (1 - Math.min(1, m * (1 - k) + k));
      const b = 255 * (1 - Math.min(1, y * (1 - k) + k)); // Form the color and return it

      const color = new Color(r, g, b);
      return color;
    } else {
      return this;
    }
  }

  toArray() {
    const {
      _a,
      _b,
      _c,
      _d,
      space
    } = this;
    return [_a, _b, _c, _d, space];
  }

  toHex() {
    const [r, g, b] = this._clamped().map(componentHex);

    return `#${r}${g}${b}`;
  }

  toRgb() {
    const [rV, gV, bV] = this._clamped();

    const string = `rgb(${rV},${gV},${bV})`;
    return string;
  }

  toString() {
    return this.toHex();
  }

  xyz() {
    // Normalise the red, green and blue values
    const {
      _a: r255,
      _b: g255,
      _c: b255
    } = this.rgb();
    const [r, g, b] = [r255, g255, b255].map(v => v / 255); // Convert to the lab rgb space

    const rL = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    const gL = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    const bL = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92; // Convert to the xyz color space without bounding the values

    const xU = (rL * 0.4124 + gL * 0.3576 + bL * 0.1805) / 0.95047;
    const yU = (rL * 0.2126 + gL * 0.7152 + bL * 0.0722) / 1.00000;
    const zU = (rL * 0.0193 + gL * 0.1192 + bL * 0.9505) / 1.08883; // Get the proper xyz values by applying the bounding

    const x = xU > 0.008856 ? Math.pow(xU, 1 / 3) : 7.787 * xU + 16 / 116;
    const y = yU > 0.008856 ? Math.pow(yU, 1 / 3) : 7.787 * yU + 16 / 116;
    const z = zU > 0.008856 ? Math.pow(zU, 1 / 3) : 7.787 * zU + 16 / 116; // Make and return the color

    const color = new Color(x, y, z, 'xyz');
    return color;
  }
  /*
  Input and Output methods
  */


  _clamped() {
    const {
      _a,
      _b,
      _c
    } = this.rgb();
    const {
      max,
      min,
      round
    } = Math;

    const format = v => max(0, min(round(v), 255));

    return [_a, _b, _c].map(format);
  }
  /*
  Constructing colors
  */


}

class Point {
  // Initialize
  constructor(...args) {
    this.init(...args);
  } // Clone point


  clone() {
    return new Point(this);
  }

  init(x, y) {
    const base = {
      x: 0,
      y: 0
    }; // ensure source as object

    const source = Array.isArray(x) ? {
      x: x[0],
      y: x[1]
    } : typeof x === 'object' ? {
      x: x.x,
      y: x.y
    } : {
      x: x,
      y: y
    }; // merge source

    this.x = source.x == null ? base.x : source.x;
    this.y = source.y == null ? base.y : source.y;
    return this;
  }

  toArray() {
    return [this.x, this.y];
  }

  transform(m) {
    return this.clone().transformO(m);
  } // Transform point with matrix


  transformO(m) {
    if (!Matrix.isMatrixLike(m)) {
      m = new Matrix(m);
    }

    const {
      x,
      y
    } = this; // Perform the matrix multiplication

    this.x = m.a * x + m.c * y + m.e;
    this.y = m.b * x + m.d * y + m.f;
    return this;
  }

}
function point(x, y) {
  return new Point(x, y).transformO(this.screenCTM().inverseO());
}

function closeEnough(a, b, threshold) {
  return Math.abs(b - a) < (threshold || 1e-6);
}

class Matrix {
  constructor(...args) {
    this.init(...args);
  }

  static formatTransforms(o) {
    // Get all of the parameters required to form the matrix
    const flipBoth = o.flip === 'both' || o.flip === true;
    const flipX = o.flip && (flipBoth || o.flip === 'x') ? -1 : 1;
    const flipY = o.flip && (flipBoth || o.flip === 'y') ? -1 : 1;
    const skewX = o.skew && o.skew.length ? o.skew[0] : isFinite(o.skew) ? o.skew : isFinite(o.skewX) ? o.skewX : 0;
    const skewY = o.skew && o.skew.length ? o.skew[1] : isFinite(o.skew) ? o.skew : isFinite(o.skewY) ? o.skewY : 0;
    const scaleX = o.scale && o.scale.length ? o.scale[0] * flipX : isFinite(o.scale) ? o.scale * flipX : isFinite(o.scaleX) ? o.scaleX * flipX : flipX;
    const scaleY = o.scale && o.scale.length ? o.scale[1] * flipY : isFinite(o.scale) ? o.scale * flipY : isFinite(o.scaleY) ? o.scaleY * flipY : flipY;
    const shear = o.shear || 0;
    const theta = o.rotate || o.theta || 0;
    const origin = new Point(o.origin || o.around || o.ox || o.originX, o.oy || o.originY);
    const ox = origin.x;
    const oy = origin.y; // We need Point to be invalid if nothing was passed because we cannot default to 0 here. That is why NaN

    const position = new Point(o.position || o.px || o.positionX || NaN, o.py || o.positionY || NaN);
    const px = position.x;
    const py = position.y;
    const translate = new Point(o.translate || o.tx || o.translateX, o.ty || o.translateY);
    const tx = translate.x;
    const ty = translate.y;
    const relative = new Point(o.relative || o.rx || o.relativeX, o.ry || o.relativeY);
    const rx = relative.x;
    const ry = relative.y; // Populate all of the values

    return {
      scaleX,
      scaleY,
      skewX,
      skewY,
      shear,
      theta,
      rx,
      ry,
      tx,
      ty,
      ox,
      oy,
      px,
      py
    };
  }

  static fromArray(a) {
    return {
      a: a[0],
      b: a[1],
      c: a[2],
      d: a[3],
      e: a[4],
      f: a[5]
    };
  }

  static isMatrixLike(o) {
    return o.a != null || o.b != null || o.c != null || o.d != null || o.e != null || o.f != null;
  } // left matrix, right matrix, target matrix which is overwritten


  static matrixMultiply(l, r, o) {
    // Work out the product directly
    const a = l.a * r.a + l.c * r.b;
    const b = l.b * r.a + l.d * r.b;
    const c = l.a * r.c + l.c * r.d;
    const d = l.b * r.c + l.d * r.d;
    const e = l.e + l.a * r.e + l.c * r.f;
    const f = l.f + l.b * r.e + l.d * r.f; // make sure to use local variables because l/r and o could be the same

    o.a = a;
    o.b = b;
    o.c = c;
    o.d = d;
    o.e = e;
    o.f = f;
    return o;
  }

  around(cx, cy, matrix) {
    return this.clone().aroundO(cx, cy, matrix);
  } // Transform around a center point


  aroundO(cx, cy, matrix) {
    const dx = cx || 0;
    const dy = cy || 0;
    return this.translateO(-dx, -dy).lmultiplyO(matrix).translateO(dx, dy);
  } // Clones this matrix


  clone() {
    return new Matrix(this);
  } // Decomposes this matrix into its affine parameters


  decompose(cx = 0, cy = 0) {
    // Get the parameters from the matrix
    const a = this.a;
    const b = this.b;
    const c = this.c;
    const d = this.d;
    const e = this.e;
    const f = this.f; // Figure out if the winding direction is clockwise or counterclockwise

    const determinant = a * d - b * c;
    const ccw = determinant > 0 ? 1 : -1; // Since we only shear in x, we can use the x basis to get the x scale
    // and the rotation of the resulting matrix

    const sx = ccw * Math.sqrt(a * a + b * b);
    const thetaRad = Math.atan2(ccw * b, ccw * a);
    const theta = 180 / Math.PI * thetaRad;
    const ct = Math.cos(thetaRad);
    const st = Math.sin(thetaRad); // We can then solve the y basis vector simultaneously to get the other
    // two affine parameters directly from these parameters

    const lam = (a * c + b * d) / determinant;
    const sy = c * sx / (lam * a - b) || d * sx / (lam * b + a); // Use the translations

    const tx = e - cx + cx * ct * sx + cy * (lam * ct * sx - st * sy);
    const ty = f - cy + cx * st * sx + cy * (lam * st * sx + ct * sy); // Construct the decomposition and return it

    return {
      // Return the affine parameters
      scaleX: sx,
      scaleY: sy,
      shear: lam,
      rotate: theta,
      translateX: tx,
      translateY: ty,
      originX: cx,
      originY: cy,
      // Return the matrix parameters
      a: this.a,
      b: this.b,
      c: this.c,
      d: this.d,
      e: this.e,
      f: this.f
    };
  } // Check if two matrices are equal


  equals(other) {
    if (other === this) return true;
    const comp = new Matrix(other);
    return closeEnough(this.a, comp.a) && closeEnough(this.b, comp.b) && closeEnough(this.c, comp.c) && closeEnough(this.d, comp.d) && closeEnough(this.e, comp.e) && closeEnough(this.f, comp.f);
  } // Flip matrix on x or y, at a given offset


  flip(axis, around) {
    return this.clone().flipO(axis, around);
  }

  flipO(axis, around) {
    return axis === 'x' ? this.scaleO(-1, 1, around, 0) : axis === 'y' ? this.scaleO(1, -1, 0, around) : this.scaleO(-1, -1, axis, around || axis); // Define an x, y flip point
  } // Initialize


  init(source) {
    const base = Matrix.fromArray([1, 0, 0, 1, 0, 0]); // ensure source as object

    source = source instanceof Element ? source.matrixify() : typeof source === 'string' ? Matrix.fromArray(source.split(delimiter).map(parseFloat)) : Array.isArray(source) ? Matrix.fromArray(source) : typeof source === 'object' && Matrix.isMatrixLike(source) ? source : typeof source === 'object' ? new Matrix().transform(source) : arguments.length === 6 ? Matrix.fromArray([].slice.call(arguments)) : base; // Merge the source matrix with the base matrix

    this.a = source.a != null ? source.a : base.a;
    this.b = source.b != null ? source.b : base.b;
    this.c = source.c != null ? source.c : base.c;
    this.d = source.d != null ? source.d : base.d;
    this.e = source.e != null ? source.e : base.e;
    this.f = source.f != null ? source.f : base.f;
    return this;
  }

  inverse() {
    return this.clone().inverseO();
  } // Inverses matrix


  inverseO() {
    // Get the current parameters out of the matrix
    const a = this.a;
    const b = this.b;
    const c = this.c;
    const d = this.d;
    const e = this.e;
    const f = this.f; // Invert the 2x2 matrix in the top left

    const det = a * d - b * c;
    if (!det) throw new Error('Cannot invert ' + this); // Calculate the top 2x2 matrix

    const na = d / det;
    const nb = -b / det;
    const nc = -c / det;
    const nd = a / det; // Apply the inverted matrix to the top right

    const ne = -(na * e + nc * f);
    const nf = -(nb * e + nd * f); // Construct the inverted matrix

    this.a = na;
    this.b = nb;
    this.c = nc;
    this.d = nd;
    this.e = ne;
    this.f = nf;
    return this;
  }

  lmultiply(matrix) {
    return this.clone().lmultiplyO(matrix);
  }

  lmultiplyO(matrix) {
    const r = this;
    const l = matrix instanceof Matrix ? matrix : new Matrix(matrix);
    return Matrix.matrixMultiply(l, r, this);
  } // Left multiplies by the given matrix


  multiply(matrix) {
    return this.clone().multiplyO(matrix);
  }

  multiplyO(matrix) {
    // Get the matrices
    const l = this;
    const r = matrix instanceof Matrix ? matrix : new Matrix(matrix);
    return Matrix.matrixMultiply(l, r, this);
  } // Rotate matrix


  rotate(r, cx, cy) {
    return this.clone().rotateO(r, cx, cy);
  }

  rotateO(r, cx = 0, cy = 0) {
    // Convert degrees to radians
    r = radians(r);
    const cos = Math.cos(r);
    const sin = Math.sin(r);
    const {
      a,
      b,
      c,
      d,
      e,
      f
    } = this;
    this.a = a * cos - b * sin;
    this.b = b * cos + a * sin;
    this.c = c * cos - d * sin;
    this.d = d * cos + c * sin;
    this.e = e * cos - f * sin + cy * sin - cx * cos + cx;
    this.f = f * cos + e * sin - cx * sin - cy * cos + cy;
    return this;
  } // Scale matrix


  scale(x, y, cx, cy) {
    return this.clone().scaleO(...arguments);
  }

  scaleO(x, y = x, cx = 0, cy = 0) {
    // Support uniform scaling
    if (arguments.length === 3) {
      cy = cx;
      cx = y;
      y = x;
    }

    const {
      a,
      b,
      c,
      d,
      e,
      f
    } = this;
    this.a = a * x;
    this.b = b * y;
    this.c = c * x;
    this.d = d * y;
    this.e = e * x - cx * x + cx;
    this.f = f * y - cy * y + cy;
    return this;
  } // Shear matrix


  shear(a, cx, cy) {
    return this.clone().shearO(a, cx, cy);
  }

  shearO(lx, cx = 0, cy = 0) {
    const {
      a,
      b,
      c,
      d,
      e,
      f
    } = this;
    this.a = a + b * lx;
    this.c = c + d * lx;
    this.e = e + f * lx - cy * lx;
    return this;
  } // Skew Matrix


  skew(x, y, cx, cy) {
    return this.clone().skewO(...arguments);
  }

  skewO(x, y = x, cx = 0, cy = 0) {
    // support uniformal skew
    if (arguments.length === 3) {
      cy = cx;
      cx = y;
      y = x;
    } // Convert degrees to radians


    x = radians(x);
    y = radians(y);
    const lx = Math.tan(x);
    const ly = Math.tan(y);
    const {
      a,
      b,
      c,
      d,
      e,
      f
    } = this;
    this.a = a + b * lx;
    this.b = b + a * ly;
    this.c = c + d * lx;
    this.d = d + c * ly;
    this.e = e + f * lx - cy * lx;
    this.f = f + e * ly - cx * ly;
    return this;
  } // SkewX


  skewX(x, cx, cy) {
    return this.skew(x, 0, cx, cy);
  } // SkewY


  skewY(y, cx, cy) {
    return this.skew(0, y, cx, cy);
  }

  toArray() {
    return [this.a, this.b, this.c, this.d, this.e, this.f];
  } // Convert matrix to string


  toString() {
    return 'matrix(' + this.a + ',' + this.b + ',' + this.c + ',' + this.d + ',' + this.e + ',' + this.f + ')';
  } // Transform a matrix into another matrix by manipulating the space


  transform(o) {
    // Check if o is a matrix and then left multiply it directly
    if (Matrix.isMatrixLike(o)) {
      const matrix = new Matrix(o);
      return matrix.multiplyO(this);
    } // Get the proposed transformations and the current transformations


    const t = Matrix.formatTransforms(o);
    const current = this;
    const {
      x: ox,
      y: oy
    } = new Point(t.ox, t.oy).transform(current); // Construct the resulting matrix

    const transformer = new Matrix().translateO(t.rx, t.ry).lmultiplyO(current).translateO(-ox, -oy).scaleO(t.scaleX, t.scaleY).skewO(t.skewX, t.skewY).shearO(t.shear).rotateO(t.theta).translateO(ox, oy); // If we want the origin at a particular place, we force it there

    if (isFinite(t.px) || isFinite(t.py)) {
      const origin = new Point(ox, oy).transform(transformer); // TODO: Replace t.px with isFinite(t.px)
      // Doesn't work because t.px is also 0 if it wasn't passed

      const dx = isFinite(t.px) ? t.px - origin.x : 0;
      const dy = isFinite(t.py) ? t.py - origin.y : 0;
      transformer.translateO(dx, dy);
    } // Translate now after positioning


    transformer.translateO(t.tx, t.ty);
    return transformer;
  } // Translate matrix


  translate(x, y) {
    return this.clone().translateO(x, y);
  }

  translateO(x, y) {
    this.e += x || 0;
    this.f += y || 0;
    return this;
  }

  valueOf() {
    return {
      a: this.a,
      b: this.b,
      c: this.c,
      d: this.d,
      e: this.e,
      f: this.f
    };
  }

}
function ctm() {
  return new Matrix(this.node.getCTM());
}
function screenCTM() {
  /* https://bugzilla.mozilla.org/show_bug.cgi?id=1344537
     This is needed because FF does not return the transformation matrix
     for the inner coordinate system when getScreenCTM() is called on nested svgs.
     However all other Browsers do that */
  if (typeof this.isRoot === 'function' && !this.isRoot()) {
    const rect = this.rect(1, 1);
    const m = rect.node.getScreenCTM();
    rect.remove();
    return new Matrix(m);
  }

  return new Matrix(this.node.getScreenCTM());
}
register(Matrix, 'Matrix');

function parser() {
  // Reuse cached element if possible
  if (!parser.nodes) {
    const svg = makeInstance().size(2, 0);
    svg.node.style.cssText = ['opacity: 0', 'position: absolute', 'left: -100%', 'top: -100%', 'overflow: hidden'].join(';');
    svg.attr('focusable', 'false');
    svg.attr('aria-hidden', 'true');
    const path = svg.path().node;
    parser.nodes = {
      svg,
      path
    };
  }

  if (!parser.nodes.svg.node.parentNode) {
    const b = globals.document.body || globals.document.documentElement;
    parser.nodes.svg.addTo(b);
  }

  return parser.nodes;
}

function isNulledBox(box) {
  return !box.width && !box.height && !box.x && !box.y;
}
function domContains(node) {
  return node === globals.document || (globals.document.documentElement.contains || function (node) {
    // This is IE - it does not support contains() for top-level SVGs
    while (node.parentNode) {
      node = node.parentNode;
    }

    return node === globals.document;
  }).call(globals.document.documentElement, node);
}
class Box {
  constructor(...args) {
    this.init(...args);
  }

  addOffset() {
    // offset by window scroll position, because getBoundingClientRect changes when window is scrolled
    this.x += globals.window.pageXOffset;
    this.y += globals.window.pageYOffset;
    return new Box(this);
  }

  init(source) {
    const base = [0, 0, 0, 0];
    source = typeof source === 'string' ? source.split(delimiter).map(parseFloat) : Array.isArray(source) ? source : typeof source === 'object' ? [source.left != null ? source.left : source.x, source.top != null ? source.top : source.y, source.width, source.height] : arguments.length === 4 ? [].slice.call(arguments) : base;
    this.x = source[0] || 0;
    this.y = source[1] || 0;
    this.width = this.w = source[2] || 0;
    this.height = this.h = source[3] || 0; // Add more bounding box properties

    this.x2 = this.x + this.w;
    this.y2 = this.y + this.h;
    this.cx = this.x + this.w / 2;
    this.cy = this.y + this.h / 2;
    return this;
  }

  isNulled() {
    return isNulledBox(this);
  } // Merge rect box with another, return a new instance


  merge(box) {
    const x = Math.min(this.x, box.x);
    const y = Math.min(this.y, box.y);
    const width = Math.max(this.x + this.width, box.x + box.width) - x;
    const height = Math.max(this.y + this.height, box.y + box.height) - y;
    return new Box(x, y, width, height);
  }

  toArray() {
    return [this.x, this.y, this.width, this.height];
  }

  toString() {
    return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height;
  }

  transform(m) {
    if (!(m instanceof Matrix)) {
      m = new Matrix(m);
    }

    let xMin = Infinity;
    let xMax = -Infinity;
    let yMin = Infinity;
    let yMax = -Infinity;
    const pts = [new Point(this.x, this.y), new Point(this.x2, this.y), new Point(this.x, this.y2), new Point(this.x2, this.y2)];
    pts.forEach(function (p) {
      p = p.transform(m);
      xMin = Math.min(xMin, p.x);
      xMax = Math.max(xMax, p.x);
      yMin = Math.min(yMin, p.y);
      yMax = Math.max(yMax, p.y);
    });
    return new Box(xMin, yMin, xMax - xMin, yMax - yMin);
  }

}

function getBox(el, getBBoxFn, retry) {
  let box;

  try {
    // Try to get the box with the provided function
    box = getBBoxFn(el.node); // If the box is worthless and not even in the dom, retry
    // by throwing an error here...

    if (isNulledBox(box) && !domContains(el.node)) {
      throw new Error('Element not in the dom');
    }
  } catch (e) {
    // ... and calling the retry handler here
    box = retry(el);
  }

  return box;
}

function bbox() {
  // Function to get bbox is getBBox()
  const getBBox = node => node.getBBox(); // Take all measures so that a stupid browser renders the element
  // so we can get the bbox from it when we try again


  const retry = el => {
    try {
      const clone = el.clone().addTo(parser().svg).show();
      const box = clone.node.getBBox();
      clone.remove();
      return box;
    } catch (e) {
      // We give up...
      throw new Error(`Getting bbox of element "${el.node.nodeName}" is not possible: ${e.toString()}`);
    }
  };

  const box = getBox(this, getBBox, retry);
  const bbox = new Box(box);
  return bbox;
}
function rbox(el) {
  const getRBox = node => node.getBoundingClientRect();

  const retry = el => {
    // There is no point in trying tricks here because if we insert the element into the dom ourselves
    // it obviously will be at the wrong position
    throw new Error(`Getting rbox of element "${el.node.nodeName}" is not possible`);
  };

  const box = getBox(this, getRBox, retry);
  const rbox = new Box(box); // If an element was passed, we want the bbox in the coordinate system of that element

  if (el) {
    return rbox.transform(el.screenCTM().inverseO());
  } // Else we want it in absolute screen coordinates
  // Therefore we need to add the scrollOffset


  return rbox.addOffset();
} // Checks whether the given point is inside the bounding box

function inside(x, y) {
  const box = this.bbox();
  return x > box.x && y > box.y && x < box.x + box.width && y < box.y + box.height;
}
registerMethods({
  viewbox: {
    viewbox(x, y, width, height) {
      // act as getter
      if (x == null) return new Box(this.attr('viewBox')); // act as setter

      return this.attr('viewBox', new Box(x, y, width, height));
    },

    zoom(level, point) {
      // Its best to rely on the attributes here and here is why:
      // clientXYZ: Doesn't work on non-root svgs because they dont have a CSSBox (silly!)
      // getBoundingClientRect: Doesn't work because Chrome just ignores width and height of nested svgs completely
      //                        that means, their clientRect is always as big as the content.
      //                        Furthermore this size is incorrect if the element is further transformed by its parents
      // computedStyle: Only returns meaningful values if css was used with px. We dont go this route here!
      // getBBox: returns the bounding box of its content - that doesn't help!
      let {
        width,
        height
      } = this.attr(['width', 'height']); // Width and height is a string when a number with a unit is present which we can't use
      // So we try clientXYZ

      if (!width && !height || typeof width === 'string' || typeof height === 'string') {
        width = this.node.clientWidth;
        height = this.node.clientHeight;
      } // Giving up...


      if (!width || !height) {
        throw new Error('Impossible to get absolute width and height. Please provide an absolute width and height attribute on the zooming element');
      }

      const v = this.viewbox();
      const zoomX = width / v.width;
      const zoomY = height / v.height;
      const zoom = Math.min(zoomX, zoomY);

      if (level == null) {
        return zoom;
      }

      let zoomAmount = zoom / level; // Set the zoomAmount to the highest value which is safe to process and recover from
      // The * 100 is a bit of wiggle room for the matrix transformation

      if (zoomAmount === Infinity) zoomAmount = Number.MAX_SAFE_INTEGER / 100;
      point = point || new Point(width / 2 / zoomX + v.x, height / 2 / zoomY + v.y);
      const box = new Box(v).transform(new Matrix({
        scale: zoomAmount,
        origin: point
      }));
      return this.viewbox(box);
    }

  }
});
register(Box, 'Box');

class List extends Array {
  constructor(arr = [], ...args) {
    super(arr, ...args);
    if (typeof arr === 'number') return this;
    this.length = 0;
    this.push(...arr);
  }

}
extend([List], {
  each(fnOrMethodName, ...args) {
    if (typeof fnOrMethodName === 'function') {
      return this.map((el, i, arr) => {
        return fnOrMethodName.call(el, el, i, arr);
      });
    } else {
      return this.map(el => {
        return el[fnOrMethodName](...args);
      });
    }
  },

  toArray() {
    return Array.prototype.concat.apply([], this);
  }

});
const reserved = ['toArray', 'constructor', 'each'];

List.extend = function (methods) {
  methods = methods.reduce((obj, name) => {
    // Don't overwrite own methods
    if (reserved.includes(name)) return obj; // Don't add private methods

    if (name[0] === '_') return obj; // Relay every call to each()

    obj[name] = function (...attrs) {
      return this.each(name, ...attrs);
    };

    return obj;
  }, {});
  extend([List], methods);
};

function baseFind(query, parent) {
  return new List(map((parent || globals.document).querySelectorAll(query), function (node) {
    return adopt(node);
  }));
} // Scoped find method

function find(query) {
  return baseFind(query, this.node);
}
function findOne(query) {
  return adopt(this.node.querySelector(query));
}

let listenerId = 0;
const windowEvents = {};
function getEvents(instance) {
  let n = instance.getEventHolder(); // We dont want to save events in global space

  if (n === globals.window) n = windowEvents;
  if (!n.events) n.events = {};
  return n.events;
}
function getEventTarget(instance) {
  return instance.getEventTarget();
}
function clearEvents(instance) {
  let n = instance.getEventHolder();
  if (n === globals.window) n = windowEvents;
  if (n.events) n.events = {};
} // Add event binder in the SVG namespace

function on(node, events, listener, binding, options) {
  const l = listener.bind(binding || node);
  const instance = makeInstance(node);
  const bag = getEvents(instance);
  const n = getEventTarget(instance); // events can be an array of events or a string of events

  events = Array.isArray(events) ? events : events.split(delimiter); // add id to listener

  if (!listener._svgjsListenerId) {
    listener._svgjsListenerId = ++listenerId;
  }

  events.forEach(function (event) {
    const ev = event.split('.')[0];
    const ns = event.split('.')[1] || '*'; // ensure valid object

    bag[ev] = bag[ev] || {};
    bag[ev][ns] = bag[ev][ns] || {}; // reference listener

    bag[ev][ns][listener._svgjsListenerId] = l; // add listener

    n.addEventListener(ev, l, options || false);
  });
} // Add event unbinder in the SVG namespace

function off(node, events, listener, options) {
  const instance = makeInstance(node);
  const bag = getEvents(instance);
  const n = getEventTarget(instance); // listener can be a function or a number

  if (typeof listener === 'function') {
    listener = listener._svgjsListenerId;
    if (!listener) return;
  } // events can be an array of events or a string or undefined


  events = Array.isArray(events) ? events : (events || '').split(delimiter);
  events.forEach(function (event) {
    const ev = event && event.split('.')[0];
    const ns = event && event.split('.')[1];
    let namespace, l;

    if (listener) {
      // remove listener reference
      if (bag[ev] && bag[ev][ns || '*']) {
        // removeListener
        n.removeEventListener(ev, bag[ev][ns || '*'][listener], options || false);
        delete bag[ev][ns || '*'][listener];
      }
    } else if (ev && ns) {
      // remove all listeners for a namespaced event
      if (bag[ev] && bag[ev][ns]) {
        for (l in bag[ev][ns]) {
          off(n, [ev, ns].join('.'), l);
        }

        delete bag[ev][ns];
      }
    } else if (ns) {
      // remove all listeners for a specific namespace
      for (event in bag) {
        for (namespace in bag[event]) {
          if (ns === namespace) {
            off(n, [event, ns].join('.'));
          }
        }
      }
    } else if (ev) {
      // remove all listeners for the event
      if (bag[ev]) {
        for (namespace in bag[ev]) {
          off(n, [ev, namespace].join('.'));
        }

        delete bag[ev];
      }
    } else {
      // remove all listeners on a given node
      for (event in bag) {
        off(n, event);
      }

      clearEvents(instance);
    }
  });
}
function dispatch(node, event, data, options) {
  const n = getEventTarget(node); // Dispatch event

  if (event instanceof globals.window.Event) {
    n.dispatchEvent(event);
  } else {
    event = new globals.window.CustomEvent(event, {
      detail: data,
      cancelable: true,
      ...options
    });
    n.dispatchEvent(event);
  }

  return event;
}

class EventTarget extends Base {
  addEventListener() {}

  dispatch(event, data, options) {
    return dispatch(this, event, data, options);
  }

  dispatchEvent(event) {
    const bag = this.getEventHolder().events;
    if (!bag) return true;
    const events = bag[event.type];

    for (const i in events) {
      for (const j in events[i]) {
        events[i][j](event);
      }
    }

    return !event.defaultPrevented;
  } // Fire given event


  fire(event, data, options) {
    this.dispatch(event, data, options);
    return this;
  }

  getEventHolder() {
    return this;
  }

  getEventTarget() {
    return this;
  } // Unbind event from listener


  off(event, listener, options) {
    off(this, event, listener, options);
    return this;
  } // Bind given event to listener


  on(event, listener, binding, options) {
    on(this, event, listener, binding, options);
    return this;
  }

  removeEventListener() {}

}
register(EventTarget, 'EventTarget');

function noop() {} // Default animation values

const timeline = {
  duration: 400,
  ease: '>',
  delay: 0
}; // Default attribute values

const attrs = {
  // fill and stroke
  'fill-opacity': 1,
  'stroke-opacity': 1,
  'stroke-width': 0,
  'stroke-linejoin': 'miter',
  'stroke-linecap': 'butt',
  fill: '#000000',
  stroke: '#000000',
  opacity: 1,
  // position
  x: 0,
  y: 0,
  cx: 0,
  cy: 0,
  // size
  width: 0,
  height: 0,
  // radius
  r: 0,
  rx: 0,
  ry: 0,
  // gradient
  offset: 0,
  'stop-opacity': 1,
  'stop-color': '#000000',
  // text
  'text-anchor': 'start'
};

var defaults = {
  __proto__: null,
  noop: noop,
  timeline: timeline,
  attrs: attrs
};

class SVGArray extends Array {
  constructor(...args) {
    super(...args);
    this.init(...args);
  }

  clone() {
    return new this.constructor(this);
  }

  init(arr) {
    // This catches the case, that native map tries to create an array with new Array(1)
    if (typeof arr === 'number') return this;
    this.length = 0;
    this.push(...this.parse(arr));
    return this;
  } // Parse whitespace separated string


  parse(array = []) {
    // If already is an array, no need to parse it
    if (array instanceof Array) return array;
    return array.trim().split(delimiter).map(parseFloat);
  }

  toArray() {
    return Array.prototype.concat.apply([], this);
  }

  toSet() {
    return new Set(this);
  }

  toString() {
    return this.join(' ');
  } // Flattens the array if needed


  valueOf() {
    const ret = [];
    ret.push(...this);
    return ret;
  }

}

class SVGNumber {
  // Initialize
  constructor(...args) {
    this.init(...args);
  }

  convert(unit) {
    return new SVGNumber(this.value, unit);
  } // Divide number


  divide(number) {
    number = new SVGNumber(number);
    return new SVGNumber(this / number, this.unit || number.unit);
  }

  init(value, unit) {
    unit = Array.isArray(value) ? value[1] : unit;
    value = Array.isArray(value) ? value[0] : value; // initialize defaults

    this.value = 0;
    this.unit = unit || ''; // parse value

    if (typeof value === 'number') {
      // ensure a valid numeric value
      this.value = isNaN(value) ? 0 : !isFinite(value) ? value < 0 ? -3.4e+38 : +3.4e+38 : value;
    } else if (typeof value === 'string') {
      unit = value.match(numberAndUnit);

      if (unit) {
        // make value numeric
        this.value = parseFloat(unit[1]); // normalize

        if (unit[5] === '%') {
          this.value /= 100;
        } else if (unit[5] === 's') {
          this.value *= 1000;
        } // store unit


        this.unit = unit[5];
      }
    } else {
      if (value instanceof SVGNumber) {
        this.value = value.valueOf();
        this.unit = value.unit;
      }
    }

    return this;
  } // Subtract number


  minus(number) {
    number = new SVGNumber(number);
    return new SVGNumber(this - number, this.unit || number.unit);
  } // Add number


  plus(number) {
    number = new SVGNumber(number);
    return new SVGNumber(this + number, this.unit || number.unit);
  } // Multiply number


  times(number) {
    number = new SVGNumber(number);
    return new SVGNumber(this * number, this.unit || number.unit);
  }

  toArray() {
    return [this.value, this.unit];
  }

  toJSON() {
    return this.toString();
  }

  toString() {
    return (this.unit === '%' ? ~~(this.value * 1e8) / 1e6 : this.unit === 's' ? this.value / 1e3 : this.value) + this.unit;
  }

  valueOf() {
    return this.value;
  }

}

const hooks = [];
function registerAttrHook(fn) {
  hooks.push(fn);
} // Set svg element attribute

function attr(attr, val, ns) {
  // act as full getter
  if (attr == null) {
    // get an object of attributes
    attr = {};
    val = this.node.attributes;

    for (const node of val) {
      attr[node.nodeName] = isNumber.test(node.nodeValue) ? parseFloat(node.nodeValue) : node.nodeValue;
    }

    return attr;
  } else if (attr instanceof Array) {
    // loop through array and get all values
    return attr.reduce((last, curr) => {
      last[curr] = this.attr(curr);
      return last;
    }, {});
  } else if (typeof attr === 'object' && attr.constructor === Object) {
    // apply every attribute individually if an object is passed
    for (val in attr) this.attr(val, attr[val]);
  } else if (val === null) {
    // remove value
    this.node.removeAttribute(attr);
  } else if (val == null) {
    // act as a getter if the first and only argument is not an object
    val = this.node.getAttribute(attr);
    return val == null ? attrs[attr] : isNumber.test(val) ? parseFloat(val) : val;
  } else {
    // Loop through hooks and execute them to convert value
    val = hooks.reduce((_val, hook) => {
      return hook(attr, _val, this);
    }, val); // ensure correct numeric values (also accepts NaN and Infinity)

    if (typeof val === 'number') {
      val = new SVGNumber(val);
    } else if (Color.isColor(val)) {
      // ensure full hex color
      val = new Color(val);
    } else if (val.constructor === Array) {
      // Check for plain arrays and parse array values
      val = new SVGArray(val);
    } // if the passed attribute is leading...


    if (attr === 'leading') {
      // ... call the leading method instead
      if (this.leading) {
        this.leading(val);
      }
    } else {
      // set given attribute on node
      typeof ns === 'string' ? this.node.setAttributeNS(ns, attr, val.toString()) : this.node.setAttribute(attr, val.toString());
    } // rebuild if required


    if (this.rebuild && (attr === 'font-size' || attr === 'x')) {
      this.rebuild();
    }
  }

  return this;
}

class Dom extends EventTarget {
  constructor(node, attrs) {
    super();
    this.node = node;
    this.type = node.nodeName;

    if (attrs && node !== attrs) {
      this.attr(attrs);
    }
  } // Add given element at a position


  add(element, i) {
    element = makeInstance(element); // If non-root svg nodes are added we have to remove their namespaces

    if (element.removeNamespace && this.node instanceof globals.window.SVGElement) {
      element.removeNamespace();
    }

    if (i == null) {
      this.node.appendChild(element.node);
    } else if (element.node !== this.node.childNodes[i]) {
      this.node.insertBefore(element.node, this.node.childNodes[i]);
    }

    return this;
  } // Add element to given container and return self


  addTo(parent, i) {
    return makeInstance(parent).put(this, i);
  } // Returns all child elements


  children() {
    return new List(map(this.node.children, function (node) {
      return adopt(node);
    }));
  } // Remove all elements in this container


  clear() {
    // remove children
    while (this.node.hasChildNodes()) {
      this.node.removeChild(this.node.lastChild);
    }

    return this;
  } // Clone element


  clone(deep = true, assignNewIds = true) {
    // write dom data to the dom so the clone can pickup the data
    this.writeDataToDom(); // clone element

    let nodeClone = this.node.cloneNode(deep);

    if (assignNewIds) {
      // assign new id
      nodeClone = assignNewId(nodeClone);
    }

    return new this.constructor(nodeClone);
  } // Iterates over all children and invokes a given block


  each(block, deep) {
    const children = this.children();
    let i, il;

    for (i = 0, il = children.length; i < il; i++) {
      block.apply(children[i], [i, children]);

      if (deep) {
        children[i].each(block, deep);
      }
    }

    return this;
  }

  element(nodeName, attrs) {
    return this.put(new Dom(create(nodeName), attrs));
  } // Get first child


  first() {
    return adopt(this.node.firstChild);
  } // Get a element at the given index


  get(i) {
    return adopt(this.node.childNodes[i]);
  }

  getEventHolder() {
    return this.node;
  }

  getEventTarget() {
    return this.node;
  } // Checks if the given element is a child


  has(element) {
    return this.index(element) >= 0;
  }

  html(htmlOrFn, outerHTML) {
    return this.xml(htmlOrFn, outerHTML, html);
  } // Get / set id


  id(id) {
    // generate new id if no id set
    if (typeof id === 'undefined' && !this.node.id) {
      this.node.id = eid(this.type);
    } // don't set directly with this.node.id to make `null` work correctly


    return this.attr('id', id);
  } // Gets index of given element


  index(element) {
    return [].slice.call(this.node.childNodes).indexOf(element.node);
  } // Get the last child


  last() {
    return adopt(this.node.lastChild);
  } // matches the element vs a css selector


  matches(selector) {
    const el = this.node;
    const matcher = el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector || null;
    return matcher && matcher.call(el, selector);
  } // Returns the parent element instance


  parent(type) {
    let parent = this; // check for parent

    if (!parent.node.parentNode) return null; // get parent element

    parent = adopt(parent.node.parentNode);
    if (!type) return parent; // loop through ancestors if type is given

    do {
      if (typeof type === 'string' ? parent.matches(type) : parent instanceof type) return parent;
    } while (parent = adopt(parent.node.parentNode));

    return parent;
  } // Basically does the same as `add()` but returns the added element instead


  put(element, i) {
    element = makeInstance(element);
    this.add(element, i);
    return element;
  } // Add element to given container and return container


  putIn(parent, i) {
    return makeInstance(parent).add(this, i);
  } // Remove element


  remove() {
    if (this.parent()) {
      this.parent().removeElement(this);
    }

    return this;
  } // Remove a given child


  removeElement(element) {
    this.node.removeChild(element.node);
    return this;
  } // Replace this with element


  replace(element) {
    element = makeInstance(element);

    if (this.node.parentNode) {
      this.node.parentNode.replaceChild(element.node, this.node);
    }

    return element;
  }

  round(precision = 2, map = null) {
    const factor = 10 ** precision;
    const attrs = this.attr(map);

    for (const i in attrs) {
      if (typeof attrs[i] === 'number') {
        attrs[i] = Math.round(attrs[i] * factor) / factor;
      }
    }

    this.attr(attrs);
    return this;
  } // Import / Export raw svg


  svg(svgOrFn, outerSVG) {
    return this.xml(svgOrFn, outerSVG, svg);
  } // Return id on string conversion


  toString() {
    return this.id();
  }

  words(text) {
    // This is faster than removing all children and adding a new one
    this.node.textContent = text;
    return this;
  }

  wrap(node) {
    const parent = this.parent();

    if (!parent) {
      return this.addTo(node);
    }

    const position = parent.index(this);
    return parent.put(node, position).put(this);
  } // write svgjs data to the dom


  writeDataToDom() {
    // dump variables recursively
    this.each(function () {
      this.writeDataToDom();
    });
    return this;
  } // Import / Export raw svg


  xml(xmlOrFn, outerXML, ns) {
    if (typeof xmlOrFn === 'boolean') {
      ns = outerXML;
      outerXML = xmlOrFn;
      xmlOrFn = null;
    } // act as getter if no svg string is given


    if (xmlOrFn == null || typeof xmlOrFn === 'function') {
      // The default for exports is, that the outerNode is included
      outerXML = outerXML == null ? true : outerXML; // write svgjs data to the dom

      this.writeDataToDom();
      let current = this; // An export modifier was passed

      if (xmlOrFn != null) {
        current = adopt(current.node.cloneNode(true)); // If the user wants outerHTML we need to process this node, too

        if (outerXML) {
          const result = xmlOrFn(current);
          current = result || current; // The user does not want this node? Well, then he gets nothing

          if (result === false) return '';
        } // Deep loop through all children and apply modifier


        current.each(function () {
          const result = xmlOrFn(this);

          const _this = result || this; // If modifier returns false, discard node


          if (result === false) {
            this.remove(); // If modifier returns new node, use it
          } else if (result && this !== _this) {
            this.replace(_this);
          }
        }, true);
      } // Return outer or inner content


      return outerXML ? current.node.outerHTML : current.node.innerHTML;
    } // Act as setter if we got a string
    // The default for import is, that the current node is not replaced


    outerXML = outerXML == null ? false : outerXML; // Create temporary holder

    const well = create('wrapper', ns);
    const fragment = globals.document.createDocumentFragment(); // Dump raw svg

    well.innerHTML = xmlOrFn; // Transplant nodes into the fragment

    for (let len = well.children.length; len--;) {
      fragment.appendChild(well.firstElementChild);
    }

    const parent = this.parent(); // Add the whole fragment at once

    return outerXML ? this.replace(fragment) && parent : this.add(fragment);
  }

}
extend(Dom, {
  attr,
  find,
  findOne
});
register(Dom, 'Dom');

class Element extends Dom {
  constructor(node, attrs) {
    super(node, attrs); // initialize data object

    this.dom = {}; // create circular reference

    this.node.instance = this;

    if (node.hasAttribute('svgjs:data')) {
      // pull svgjs data from the dom (getAttributeNS doesn't work in html5)
      this.setData(JSON.parse(node.getAttribute('svgjs:data')) || {});
    }
  } // Move element by its center


  center(x, y) {
    return this.cx(x).cy(y);
  } // Move by center over x-axis


  cx(x) {
    return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2);
  } // Move by center over y-axis


  cy(y) {
    return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2);
  } // Get defs


  defs() {
    const root = this.root();
    return root && root.defs();
  } // Relative move over x and y axes


  dmove(x, y) {
    return this.dx(x).dy(y);
  } // Relative move over x axis


  dx(x = 0) {
    return this.x(new SVGNumber(x).plus(this.x()));
  } // Relative move over y axis


  dy(y = 0) {
    return this.y(new SVGNumber(y).plus(this.y()));
  }

  getEventHolder() {
    return this;
  } // Set height of element


  height(height) {
    return this.attr('height', height);
  } // Move element to given x and y values


  move(x, y) {
    return this.x(x).y(y);
  } // return array of all ancestors of given type up to the root svg


  parents(until = this.root()) {
    const isSelector = typeof until === 'string';

    if (!isSelector) {
      until = makeInstance(until);
    }

    const parents = new List();
    let parent = this;

    while ((parent = parent.parent()) && parent.node !== globals.document && parent.nodeName !== '#document-fragment') {
      parents.push(parent);

      if (!isSelector && parent.node === until.node) {
        break;
      }

      if (isSelector && parent.matches(until)) {
        break;
      }

      if (parent.node === this.root().node) {
        // We worked our way to the root and didn't match `until`
        return null;
      }
    }

    return parents;
  } // Get referenced element form attribute value


  reference(attr) {
    attr = this.attr(attr);
    if (!attr) return null;
    const m = (attr + '').match(reference);
    return m ? makeInstance(m[1]) : null;
  } // Get parent document


  root() {
    const p = this.parent(getClass(root));
    return p && p.root();
  } // set given data to the elements data property


  setData(o) {
    this.dom = o;
    return this;
  } // Set element size to given width and height


  size(width, height) {
    const p = proportionalSize(this, width, height);
    return this.width(new SVGNumber(p.width)).height(new SVGNumber(p.height));
  } // Set width of element


  width(width) {
    return this.attr('width', width);
  } // write svgjs data to the dom


  writeDataToDom() {
    // remove previously set data
    this.node.removeAttribute('svgjs:data');

    if (Object.keys(this.dom).length) {
      this.node.setAttribute('svgjs:data', JSON.stringify(this.dom)); // see #428
    }

    return super.writeDataToDom();
  } // Move over x-axis


  x(x) {
    return this.attr('x', x);
  } // Move over y-axis


  y(y) {
    return this.attr('y', y);
  }

}
extend(Element, {
  bbox,
  rbox,
  inside,
  point,
  ctm,
  screenCTM
});
register(Element, 'Element');

const sugar = {
  stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset'],
  fill: ['color', 'opacity', 'rule'],
  prefix: function (t, a) {
    return a === 'color' ? t : t + '-' + a;
  }
} // Add sugar for fill and stroke
;
['fill', 'stroke'].forEach(function (m) {
  const extension = {};
  let i;

  extension[m] = function (o) {
    if (typeof o === 'undefined') {
      return this.attr(m);
    }

    if (typeof o === 'string' || o instanceof Color || Color.isRgb(o) || o instanceof Element) {
      this.attr(m, o);
    } else {
      // set all attributes from sugar.fill and sugar.stroke list
      for (i = sugar[m].length - 1; i >= 0; i--) {
        if (o[sugar[m][i]] != null) {
          this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]]);
        }
      }
    }

    return this;
  };

  registerMethods(['Element', 'Runner'], extension);
});
registerMethods(['Element', 'Runner'], {
  // Let the user set the matrix directly
  matrix: function (mat, b, c, d, e, f) {
    // Act as a getter
    if (mat == null) {
      return new Matrix(this);
    } // Act as a setter, the user can pass a matrix or a set of numbers


    return this.attr('transform', new Matrix(mat, b, c, d, e, f));
  },
  // Map rotation to transform
  rotate: function (angle, cx, cy) {
    return this.transform({
      rotate: angle,
      ox: cx,
      oy: cy
    }, true);
  },
  // Map skew to transform
  skew: function (x, y, cx, cy) {
    return arguments.length === 1 || arguments.length === 3 ? this.transform({
      skew: x,
      ox: y,
      oy: cx
    }, true) : this.transform({
      skew: [x, y],
      ox: cx,
      oy: cy
    }, true);
  },
  shear: function (lam, cx, cy) {
    return this.transform({
      shear: lam,
      ox: cx,
      oy: cy
    }, true);
  },
  // Map scale to transform
  scale: function (x, y, cx, cy) {
    return arguments.length === 1 || arguments.length === 3 ? this.transform({
      scale: x,
      ox: y,
      oy: cx
    }, true) : this.transform({
      scale: [x, y],
      ox: cx,
      oy: cy
    }, true);
  },
  // Map translate to transform
  translate: function (x, y) {
    return this.transform({
      translate: [x, y]
    }, true);
  },
  // Map relative translations to transform
  relative: function (x, y) {
    return this.transform({
      relative: [x, y]
    }, true);
  },
  // Map flip to transform
  flip: function (direction = 'both', origin = 'center') {
    if ('xybothtrue'.indexOf(direction) === -1) {
      origin = direction;
      direction = 'both';
    }

    return this.transform({
      flip: direction,
      origin: origin
    }, true);
  },
  // Opacity
  opacity: function (value) {
    return this.attr('opacity', value);
  }
});
registerMethods('radius', {
  // Add x and y radius
  radius: function (x, y = x) {
    const type = (this._element || this).type;
    return type === 'radialGradient' ? this.attr('r', new SVGNumber(x)) : this.rx(x).ry(y);
  }
});
registerMethods('Path', {
  // Get path length
  length: function () {
    return this.node.getTotalLength();
  },
  // Get point at length
  pointAt: function (length) {
    return new Point(this.node.getPointAtLength(length));
  }
});
registerMethods(['Element', 'Runner'], {
  // Set font
  font: function (a, v) {
    if (typeof a === 'object') {
      for (v in a) this.font(v, a[v]);

      return this;
    }

    return a === 'leading' ? this.leading(v) : a === 'anchor' ? this.attr('text-anchor', v) : a === 'size' || a === 'family' || a === 'weight' || a === 'stretch' || a === 'variant' || a === 'style' ? this.attr('font-' + a, v) : this.attr(a, v);
  }
}); // Add events to elements

const methods = ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mousemove', 'mouseenter', 'mouseleave', 'touchstart', 'touchmove', 'touchleave', 'touchend', 'touchcancel'].reduce(function (last, event) {
  // add event to Element
  const fn = function (f) {
    if (f === null) {
      this.off(event);
    } else {
      this.on(event, f);
    }

    return this;
  };

  last[event] = fn;
  return last;
}, {});
registerMethods('Element', methods);

function untransform() {
  return this.attr('transform', null);
} // merge the whole transformation chain into one matrix and returns it

function matrixify() {
  const matrix = (this.attr('transform') || '' // split transformations
  ).split(transforms).slice(0, -1).map(function (str) {
    // generate key => value pairs
    const kv = str.trim().split('(');
    return [kv[0], kv[1].split(delimiter).map(function (str) {
      return parseFloat(str);
    })];
  }).reverse() // merge every transformation into one matrix
  .reduce(function (matrix, transform) {
    if (transform[0] === 'matrix') {
      return matrix.lmultiply(Matrix.fromArray(transform[1]));
    }

    return matrix[transform[0]].apply(matrix, transform[1]);
  }, new Matrix());
  return matrix;
} // add an element to another parent without changing the visual representation on the screen

function toParent(parent, i) {
  if (this === parent) return this;
  const ctm = this.screenCTM();
  const pCtm = parent.screenCTM().inverse();
  this.addTo(parent, i).untransform().transform(pCtm.multiply(ctm));
  return this;
} // same as above with parent equals root-svg

function toRoot(i) {
  return this.toParent(this.root(), i);
} // Add transformations

function transform(o, relative) {
  // Act as a getter if no object was passed
  if (o == null || typeof o === 'string') {
    const decomposed = new Matrix(this).decompose();
    return o == null ? decomposed : decomposed[o];
  }

  if (!Matrix.isMatrixLike(o)) {
    // Set the origin according to the defined transform
    o = { ...o,
      origin: getOrigin(o, this)
    };
  } // The user can pass a boolean, an Element or an Matrix or nothing


  const cleanRelative = relative === true ? this : relative || false;
  const result = new Matrix(cleanRelative).transform(o);
  return this.attr('transform', result);
}
registerMethods('Element', {
  untransform,
  matrixify,
  toParent,
  toRoot,
  transform
});

class Container extends Element {
  flatten(parent = this, index) {
    this.each(function () {
      if (this instanceof Container) {
        return this.flatten().ungroup();
      }
    });
    return this;
  }

  ungroup(parent = this.parent(), index = parent.index(this)) {
    // when parent != this, we want append all elements to the end
    index = index === -1 ? parent.children().length : index;
    this.each(function (i, children) {
      // reverse each
      return children[children.length - i - 1].toParent(parent, index);
    });
    return this.remove();
  }

}
register(Container, 'Container');

class Defs extends Container {
  constructor(node, attrs = node) {
    super(nodeOrNew('defs', node), attrs);
  }

  flatten() {
    return this;
  }

  ungroup() {
    return this;
  }

}
register(Defs, 'Defs');

class Shape extends Element {}
register(Shape, 'Shape');

function rx(rx) {
  return this.attr('rx', rx);
} // Radius y value

function ry(ry) {
  return this.attr('ry', ry);
} // Move over x-axis

function x$3(x) {
  return x == null ? this.cx() - this.rx() : this.cx(x + this.rx());
} // Move over y-axis

function y$3(y) {
  return y == null ? this.cy() - this.ry() : this.cy(y + this.ry());
} // Move by center over x-axis

function cx$1(x) {
  return this.attr('cx', x);
} // Move by center over y-axis

function cy$1(y) {
  return this.attr('cy', y);
} // Set width of element

function width$2(width) {
  return width == null ? this.rx() * 2 : this.rx(new SVGNumber(width).divide(2));
} // Set height of element

function height$2(height) {
  return height == null ? this.ry() * 2 : this.ry(new SVGNumber(height).divide(2));
}

var circled = {
  __proto__: null,
  rx: rx,
  ry: ry,
  x: x$3,
  y: y$3,
  cx: cx$1,
  cy: cy$1,
  width: width$2,
  height: height$2
};

class Ellipse extends Shape {
  constructor(node, attrs = node) {
    super(nodeOrNew('ellipse', node), attrs);
  }

  size(width, height) {
    const p = proportionalSize(this, width, height);
    return this.rx(new SVGNumber(p.width).divide(2)).ry(new SVGNumber(p.height).divide(2));
  }

}
extend(Ellipse, circled);
registerMethods('Container', {
  // Create an ellipse
  ellipse: wrapWithAttrCheck(function (width = 0, height = width) {
    return this.put(new Ellipse()).size(width, height).move(0, 0);
  })
});
register(Ellipse, 'Ellipse');

class Fragment extends Dom {
  constructor(node = globals.document.createDocumentFragment()) {
    super(node);
  } // Import / Export raw xml


  xml(xmlOrFn, outerXML, ns) {
    if (typeof xmlOrFn === 'boolean') {
      ns = outerXML;
      outerXML = xmlOrFn;
      xmlOrFn = null;
    } // because this is a fragment we have to put all elements into a wrapper first
    // before we can get the innerXML from it


    if (xmlOrFn == null || typeof xmlOrFn === 'function') {
      const wrapper = new Dom(create('wrapper', ns));
      wrapper.add(this.node.cloneNode(true));
      return wrapper.xml(false, ns);
    } // Act as setter if we got a string


    return super.xml(xmlOrFn, false, ns);
  }

}

register(Fragment, 'Fragment');

function from(x, y) {
  return (this._element || this).type === 'radialGradient' ? this.attr({
    fx: new SVGNumber(x),
    fy: new SVGNumber(y)
  }) : this.attr({
    x1: new SVGNumber(x),
    y1: new SVGNumber(y)
  });
}
function to(x, y) {
  return (this._element || this).type === 'radialGradient' ? this.attr({
    cx: new SVGNumber(x),
    cy: new SVGNumber(y)
  }) : this.attr({
    x2: new SVGNumber(x),
    y2: new SVGNumber(y)
  });
}

var gradiented = {
  __proto__: null,
  from: from,
  to: to
};

class Gradient extends Container {
  constructor(type, attrs) {
    super(nodeOrNew(type + 'Gradient', typeof type === 'string' ? null : type), attrs);
  } // custom attr to handle transform


  attr(a, b, c) {
    if (a === 'transform') a = 'gradientTransform';
    return super.attr(a, b, c);
  }

  bbox() {
    return new Box();
  }

  targets() {
    return baseFind('svg [fill*=' + this.id() + ']');
  } // Alias string conversion to fill


  toString() {
    return this.url();
  } // Update gradient


  update(block) {
    // remove all stops
    this.clear(); // invoke passed block

    if (typeof block === 'function') {
      block.call(this, this);
    }

    return this;
  } // Return the fill id


  url() {
    return 'url(#' + this.id() + ')';
  }

}
extend(Gradient, gradiented);
registerMethods({
  Container: {
    // Create gradient element in defs
    gradient(...args) {
      return this.defs().gradient(...args);
    }

  },
  // define gradient
  Defs: {
    gradient: wrapWithAttrCheck(function (type, block) {
      return this.put(new Gradient(type)).update(block);
    })
  }
});
register(Gradient, 'Gradient');

class Pattern extends Container {
  // Initialize node
  constructor(node, attrs = node) {
    super(nodeOrNew('pattern', node), attrs);
  } // custom attr to handle transform


  attr(a, b, c) {
    if (a === 'transform') a = 'patternTransform';
    return super.attr(a, b, c);
  }

  bbox() {
    return new Box();
  }

  targets() {
    return baseFind('svg [fill*=' + this.id() + ']');
  } // Alias string conversion to fill


  toString() {
    return this.url();
  } // Update pattern by rebuilding


  update(block) {
    // remove content
    this.clear(); // invoke passed block

    if (typeof block === 'function') {
      block.call(this, this);
    }

    return this;
  } // Return the fill id


  url() {
    return 'url(#' + this.id() + ')';
  }

}
registerMethods({
  Container: {
    // Create pattern element in defs
    pattern(...args) {
      return this.defs().pattern(...args);
    }

  },
  Defs: {
    pattern: wrapWithAttrCheck(function (width, height, block) {
      return this.put(new Pattern()).update(block).attr({
        x: 0,
        y: 0,
        width: width,
        height: height,
        patternUnits: 'userSpaceOnUse'
      });
    })
  }
});
register(Pattern, 'Pattern');

class Image extends Shape {
  constructor(node, attrs = node) {
    super(nodeOrNew('image', node), attrs);
  } // (re)load image


  load(url, callback) {
    if (!url) return this;
    const img = new globals.window.Image();
    on(img, 'load', function (e) {
      const p = this.parent(Pattern); // ensure image size

      if (this.width() === 0 && this.height() === 0) {
        this.size(img.width, img.height);
      }

      if (p instanceof Pattern) {
        // ensure pattern size if not set
        if (p.width() === 0 && p.height() === 0) {
          p.size(this.width(), this.height());
        }
      }

      if (typeof callback === 'function') {
        callback.call(this, e);
      }
    }, this);
    on(img, 'load error', function () {
      // dont forget to unbind memory leaking events
      off(img);
    });
    return this.attr('href', img.src = url, xlink);
  }

}
registerAttrHook(function (attr, val, _this) {
  // convert image fill and stroke to patterns
  if (attr === 'fill' || attr === 'stroke') {
    if (isImage.test(val)) {
      val = _this.root().defs().image(val);
    }
  }

  if (val instanceof Image) {
    val = _this.root().defs().pattern(0, 0, pattern => {
      pattern.add(val);
    });
  }

  return val;
});
registerMethods({
  Container: {
    // create image element, load image and set its size
    image: wrapWithAttrCheck(function (source, callback) {
      return this.put(new Image()).size(0, 0).load(source, callback);
    })
  }
});
register(Image, 'Image');

class PointArray extends SVGArray {
  // Get bounding box of points
  bbox() {
    let maxX = -Infinity;
    let maxY = -Infinity;
    let minX = Infinity;
    let minY = Infinity;
    this.forEach(function (el) {
      maxX = Math.max(el[0], maxX);
      maxY = Math.max(el[1], maxY);
      minX = Math.min(el[0], minX);
      minY = Math.min(el[1], minY);
    });
    return new Box(minX, minY, maxX - minX, maxY - minY);
  } // Move point string


  move(x, y) {
    const box = this.bbox(); // get relative offset

    x -= box.x;
    y -= box.y; // move every point

    if (!isNaN(x) && !isNaN(y)) {
      for (let i = this.length - 1; i >= 0; i--) {
        this[i] = [this[i][0] + x, this[i][1] + y];
      }
    }

    return this;
  } // Parse point string and flat array


  parse(array = [0, 0]) {
    const points = []; // if it is an array, we flatten it and therefore clone it to 1 depths

    if (array instanceof Array) {
      array = Array.prototype.concat.apply([], array);
    } else {
      // Else, it is considered as a string
      // parse points
      array = array.trim().split(delimiter).map(parseFloat);
    } // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints
    // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.


    if (array.length % 2 !== 0) array.pop(); // wrap points in two-tuples

    for (let i = 0, len = array.length; i < len; i = i + 2) {
      points.push([array[i], array[i + 1]]);
    }

    return points;
  } // Resize poly string


  size(width, height) {
    let i;
    const box = this.bbox(); // recalculate position of all points according to new size

    for (i = this.length - 1; i >= 0; i--) {
      if (box.width) this[i][0] = (this[i][0] - box.x) * width / box.width + box.x;
      if (box.height) this[i][1] = (this[i][1] - box.y) * height / box.height + box.y;
    }

    return this;
  } // Convert array to line object


  toLine() {
    return {
      x1: this[0][0],
      y1: this[0][1],
      x2: this[1][0],
      y2: this[1][1]
    };
  } // Convert array to string


  toString() {
    const array = []; // convert to a poly point string

    for (let i = 0, il = this.length; i < il; i++) {
      array.push(this[i].join(','));
    }

    return array.join(' ');
  }

  transform(m) {
    return this.clone().transformO(m);
  } // transform points with matrix (similar to Point.transform)


  transformO(m) {
    if (!Matrix.isMatrixLike(m)) {
      m = new Matrix(m);
    }

    for (let i = this.length; i--;) {
      // Perform the matrix multiplication
      const [x, y] = this[i];
      this[i][0] = m.a * x + m.c * y + m.e;
      this[i][1] = m.b * x + m.d * y + m.f;
    }

    return this;
  }

}

const MorphArray = PointArray; // Move by left top corner over x-axis

function x$2(x) {
  return x == null ? this.bbox().x : this.move(x, this.bbox().y);
} // Move by left top corner over y-axis

function y$2(y) {
  return y == null ? this.bbox().y : this.move(this.bbox().x, y);
} // Set width of element

function width$1(width) {
  const b = this.bbox();
  return width == null ? b.width : this.size(width, b.height);
} // Set height of element

function height$1(height) {
  const b = this.bbox();
  return height == null ? b.height : this.size(b.width, height);
}

var pointed = {
  __proto__: null,
  MorphArray: MorphArray,
  x: x$2,
  y: y$2,
  width: width$1,
  height: height$1
};

class Line extends Shape {
  // Initialize node
  constructor(node, attrs = node) {
    super(nodeOrNew('line', node), attrs);
  } // Get array


  array() {
    return new PointArray([[this.attr('x1'), this.attr('y1')], [this.attr('x2'), this.attr('y2')]]);
  } // Move by left top corner


  move(x, y) {
    return this.attr(this.array().move(x, y).toLine());
  } // Overwrite native plot() method


  plot(x1, y1, x2, y2) {
    if (x1 == null) {
      return this.array();
    } else if (typeof y1 !== 'undefined') {
      x1 = {
        x1,
        y1,
        x2,
        y2
      };
    } else {
      x1 = new PointArray(x1).toLine();
    }

    return this.attr(x1);
  } // Set element size to given width and height


  size(width, height) {
    const p = proportionalSize(this, width, height);
    return this.attr(this.array().size(p.width, p.height).toLine());
  }

}
extend(Line, pointed);
registerMethods({
  Container: {
    // Create a line element
    line: wrapWithAttrCheck(function (...args) {
      // make sure plot is called as a setter
      // x1 is not necessarily a number, it can also be an array, a string and a PointArray
      return Line.prototype.plot.apply(this.put(new Line()), args[0] != null ? args : [0, 0, 0, 0]);
    })
  }
});
register(Line, 'Line');

class Marker extends Container {
  // Initialize node
  constructor(node, attrs = node) {
    super(nodeOrNew('marker', node), attrs);
  } // Set height of element


  height(height) {
    return this.attr('markerHeight', height);
  }

  orient(orient) {
    return this.attr('orient', orient);
  } // Set marker refX and refY


  ref(x, y) {
    return this.attr('refX', x).attr('refY', y);
  } // Return the fill id


  toString() {
    return 'url(#' + this.id() + ')';
  } // Update marker


  update(block) {
    // remove all content
    this.clear(); // invoke passed block

    if (typeof block === 'function') {
      block.call(this, this);
    }

    return this;
  } // Set width of element


  width(width) {
    return this.attr('markerWidth', width);
  }

}
registerMethods({
  Container: {
    marker(...args) {
      // Create marker element in defs
      return this.defs().marker(...args);
    }

  },
  Defs: {
    // Create marker
    marker: wrapWithAttrCheck(function (width, height, block) {
      // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto
      return this.put(new Marker()).size(width, height).ref(width / 2, height / 2).viewbox(0, 0, width, height).attr('orient', 'auto').update(block);
    })
  },
  marker: {
    // Create and attach markers
    marker(marker, width, height, block) {
      let attr = ['marker']; // Build attribute name

      if (marker !== 'all') attr.push(marker);
      attr = attr.join('-'); // Set marker attribute

      marker = arguments[1] instanceof Marker ? arguments[1] : this.defs().marker(width, height, block);
      return this.attr(attr, marker);
    }

  }
});
register(Marker, 'Marker');

/***
Base Class
==========
The base stepper class that will be
***/

function makeSetterGetter(k, f) {
  return function (v) {
    if (v == null) return this[k];
    this[k] = v;
    if (f) f.call(this);
    return this;
  };
}

const easing = {
  '-': function (pos) {
    return pos;
  },
  '<>': function (pos) {
    return -Math.cos(pos * Math.PI) / 2 + 0.5;
  },
  '>': function (pos) {
    return Math.sin(pos * Math.PI / 2);
  },
  '<': function (pos) {
    return -Math.cos(pos * Math.PI / 2) + 1;
  },
  bezier: function (x1, y1, x2, y2) {
    // see https://www.w3.org/TR/css-easing-1/#cubic-bezier-algo
    return function (t) {
      if (t < 0) {
        if (x1 > 0) {
          return y1 / x1 * t;
        } else if (x2 > 0) {
          return y2 / x2 * t;
        } else {
          return 0;
        }
      } else if (t > 1) {
        if (x2 < 1) {
          return (1 - y2) / (1 - x2) * t + (y2 - x2) / (1 - x2);
        } else if (x1 < 1) {
          return (1 - y1) / (1 - x1) * t + (y1 - x1) / (1 - x1);
        } else {
          return 1;
        }
      } else {
        return 3 * t * (1 - t) ** 2 * y1 + 3 * t ** 2 * (1 - t) * y2 + t ** 3;
      }
    };
  },
  // see https://www.w3.org/TR/css-easing-1/#step-timing-function-algo
  steps: function (steps, stepPosition = 'end') {
    // deal with "jump-" prefix
    stepPosition = stepPosition.split('-').reverse()[0];
    let jumps = steps;

    if (stepPosition === 'none') {
      --jumps;
    } else if (stepPosition === 'both') {
      ++jumps;
    } // The beforeFlag is essentially useless


    return (t, beforeFlag = false) => {
      // Step is called currentStep in referenced url
      let step = Math.floor(t * steps);
      const jumping = t * step % 1 === 0;

      if (stepPosition === 'start' || stepPosition === 'both') {
        ++step;
      }

      if (beforeFlag && jumping) {
        --step;
      }

      if (t >= 0 && step < 0) {
        step = 0;
      }

      if (t <= 1 && step > jumps) {
        step = jumps;
      }

      return step / jumps;
    };
  }
};
class Stepper {
  done() {
    return false;
  }

}
/***
Easing Functions
================
***/

class Ease extends Stepper {
  constructor(fn = timeline.ease) {
    super();
    this.ease = easing[fn] || fn;
  }

  step(from, to, pos) {
    if (typeof from !== 'number') {
      return pos < 1 ? from : to;
    }

    return from + (to - from) * this.ease(pos);
  }

}
/***
Controller Types
================
***/

class Controller extends Stepper {
  constructor(fn) {
    super();
    this.stepper = fn;
  }

  done(c) {
    return c.done;
  }

  step(current, target, dt, c) {
    return this.stepper(current, target, dt, c);
  }

}

function recalculate() {
  // Apply the default parameters
  const duration = (this._duration || 500) / 1000;
  const overshoot = this._overshoot || 0; // Calculate the PID natural response

  const eps = 1e-10;
  const pi = Math.PI;
  const os = Math.log(overshoot / 100 + eps);
  const zeta = -os / Math.sqrt(pi * pi + os * os);
  const wn = 3.9 / (zeta * duration); // Calculate the Spring values

  this.d = 2 * zeta * wn;
  this.k = wn * wn;
}

class Spring extends Controller {
  constructor(duration = 500, overshoot = 0) {
    super();
    this.duration(duration).overshoot(overshoot);
  }

  step(current, target, dt, c) {
    if (typeof current === 'string') return current;
    c.done = dt === Infinity;
    if (dt === Infinity) return target;
    if (dt === 0) return current;
    if (dt > 100) dt = 16;
    dt /= 1000; // Get the previous velocity

    const velocity = c.velocity || 0; // Apply the control to get the new position and store it

    const acceleration = -this.d * velocity - this.k * (current - target);
    const newPosition = current + velocity * dt + acceleration * dt * dt / 2; // Store the velocity

    c.velocity = velocity + acceleration * dt; // Figure out if we have converged, and if so, pass the value

    c.done = Math.abs(target - newPosition) + Math.abs(velocity) < 0.002;
    return c.done ? target : newPosition;
  }

}
extend(Spring, {
  duration: makeSetterGetter('_duration', recalculate),
  overshoot: makeSetterGetter('_overshoot', recalculate)
});
class PID extends Controller {
  constructor(p = 0.1, i = 0.01, d = 0, windup = 1000) {
    super();
    this.p(p).i(i).d(d).windup(windup);
  }

  step(current, target, dt, c) {
    if (typeof current === 'string') return current;
    c.done = dt === Infinity;
    if (dt === Infinity) return target;
    if (dt === 0) return current;
    const p = target - current;
    let i = (c.integral || 0) + p * dt;
    const d = (p - (c.error || 0)) / dt;
    const windup = this._windup; // antiwindup

    if (windup !== false) {
      i = Math.max(-windup, Math.min(i, windup));
    }

    c.error = p;
    c.integral = i;
    c.done = Math.abs(p) < 0.001;
    return c.done ? target : current + (this.P * p + this.I * i + this.D * d);
  }

}
extend(PID, {
  windup: makeSetterGetter('_windup'),
  p: makeSetterGetter('P'),
  i: makeSetterGetter('I'),
  d: makeSetterGetter('D')
});

const segmentParameters = {
  M: 2,
  L: 2,
  H: 1,
  V: 1,
  C: 6,
  S: 4,
  Q: 4,
  T: 2,
  A: 7,
  Z: 0
};
const pathHandlers = {
  M: function (c, p, p0) {
    p.x = p0.x = c[0];
    p.y = p0.y = c[1];
    return ['M', p.x, p.y];
  },
  L: function (c, p) {
    p.x = c[0];
    p.y = c[1];
    return ['L', c[0], c[1]];
  },
  H: function (c, p) {
    p.x = c[0];
    return ['H', c[0]];
  },
  V: function (c, p) {
    p.y = c[0];
    return ['V', c[0]];
  },
  C: function (c, p) {
    p.x = c[4];
    p.y = c[5];
    return ['C', c[0], c[1], c[2], c[3], c[4], c[5]];
  },
  S: function (c, p) {
    p.x = c[2];
    p.y = c[3];
    return ['S', c[0], c[1], c[2], c[3]];
  },
  Q: function (c, p) {
    p.x = c[2];
    p.y = c[3];
    return ['Q', c[0], c[1], c[2], c[3]];
  },
  T: function (c, p) {
    p.x = c[0];
    p.y = c[1];
    return ['T', c[0], c[1]];
  },
  Z: function (c, p, p0) {
    p.x = p0.x;
    p.y = p0.y;
    return ['Z'];
  },
  A: function (c, p) {
    p.x = c[5];
    p.y = c[6];
    return ['A', c[0], c[1], c[2], c[3], c[4], c[5], c[6]];
  }
};
const mlhvqtcsaz = 'mlhvqtcsaz'.split('');

for (let i = 0, il = mlhvqtcsaz.length; i < il; ++i) {
  pathHandlers[mlhvqtcsaz[i]] = function (i) {
    return function (c, p, p0) {
      if (i === 'H') c[0] = c[0] + p.x;else if (i === 'V') c[0] = c[0] + p.y;else if (i === 'A') {
        c[5] = c[5] + p.x;
        c[6] = c[6] + p.y;
      } else {
        for (let j = 0, jl = c.length; j < jl; ++j) {
          c[j] = c[j] + (j % 2 ? p.y : p.x);
        }
      }
      return pathHandlers[i](c, p, p0);
    };
  }(mlhvqtcsaz[i].toUpperCase());
}

function makeAbsolut(parser) {
  const command = parser.segment[0];
  return pathHandlers[command](parser.segment.slice(1), parser.p, parser.p0);
}

function segmentComplete(parser) {
  return parser.segment.length && parser.segment.length - 1 === segmentParameters[parser.segment[0].toUpperCase()];
}

function startNewSegment(parser, token) {
  parser.inNumber && finalizeNumber(parser, false);
  const pathLetter = isPathLetter.test(token);

  if (pathLetter) {
    parser.segment = [token];
  } else {
    const lastCommand = parser.lastCommand;
    const small = lastCommand.toLowerCase();
    const isSmall = lastCommand === small;
    parser.segment = [small === 'm' ? isSmall ? 'l' : 'L' : lastCommand];
  }

  parser.inSegment = true;
  parser.lastCommand = parser.segment[0];
  return pathLetter;
}

function finalizeNumber(parser, inNumber) {
  if (!parser.inNumber) throw new Error('Parser Error');
  parser.number && parser.segment.push(parseFloat(parser.number));
  parser.inNumber = inNumber;
  parser.number = '';
  parser.pointSeen = false;
  parser.hasExponent = false;

  if (segmentComplete(parser)) {
    finalizeSegment(parser);
  }
}

function finalizeSegment(parser) {
  parser.inSegment = false;

  if (parser.absolute) {
    parser.segment = makeAbsolut(parser);
  }

  parser.segments.push(parser.segment);
}

function isArcFlag(parser) {
  if (!parser.segment.length) return false;
  const isArc = parser.segment[0].toUpperCase() === 'A';
  const length = parser.segment.length;
  return isArc && (length === 4 || length === 5);
}

function isExponential(parser) {
  return parser.lastToken.toUpperCase() === 'E';
}

function pathParser(d, toAbsolute = true) {
  let index = 0;
  let token = '';
  const parser = {
    segment: [],
    inNumber: false,
    number: '',
    lastToken: '',
    inSegment: false,
    segments: [],
    pointSeen: false,
    hasExponent: false,
    absolute: toAbsolute,
    p0: new Point(),
    p: new Point()
  };

  while (parser.lastToken = token, token = d.charAt(index++)) {
    if (!parser.inSegment) {
      if (startNewSegment(parser, token)) {
        continue;
      }
    }

    if (token === '.') {
      if (parser.pointSeen || parser.hasExponent) {
        finalizeNumber(parser, false);
        --index;
        continue;
      }

      parser.inNumber = true;
      parser.pointSeen = true;
      parser.number += token;
      continue;
    }

    if (!isNaN(parseInt(token))) {
      if (parser.number === '0' || isArcFlag(parser)) {
        parser.inNumber = true;
        parser.number = token;
        finalizeNumber(parser, true);
        continue;
      }

      parser.inNumber = true;
      parser.number += token;
      continue;
    }

    if (token === ' ' || token === ',') {
      if (parser.inNumber) {
        finalizeNumber(parser, false);
      }

      continue;
    }

    if (token === '-') {
      if (parser.inNumber && !isExponential(parser)) {
        finalizeNumber(parser, false);
        --index;
        continue;
      }

      parser.number += token;
      parser.inNumber = true;
      continue;
    }

    if (token.toUpperCase() === 'E') {
      parser.number += token;
      parser.hasExponent = true;
      continue;
    }

    if (isPathLetter.test(token)) {
      if (parser.inNumber) {
        finalizeNumber(parser, false);
      } else if (!segmentComplete(parser)) {
        throw new Error('parser Error');
      } else {
        finalizeSegment(parser);
      }

      --index;
    }
  }

  if (parser.inNumber) {
    finalizeNumber(parser, false);
  }

  if (parser.inSegment && segmentComplete(parser)) {
    finalizeSegment(parser);
  }

  return parser.segments;
}

function arrayToString(a) {
  let s = '';

  for (let i = 0, il = a.length; i < il; i++) {
    s += a[i][0];

    if (a[i][1] != null) {
      s += a[i][1];

      if (a[i][2] != null) {
        s += ' ';
        s += a[i][2];

        if (a[i][3] != null) {
          s += ' ';
          s += a[i][3];
          s += ' ';
          s += a[i][4];

          if (a[i][5] != null) {
            s += ' ';
            s += a[i][5];
            s += ' ';
            s += a[i][6];

            if (a[i][7] != null) {
              s += ' ';
              s += a[i][7];
            }
          }
        }
      }
    }
  }

  return s + ' ';
}

class PathArray extends SVGArray {
  // Get bounding box of path
  bbox() {
    parser().path.setAttribute('d', this.toString());
    return new Box(parser.nodes.path.getBBox());
  } // Move path string


  move(x, y) {
    // get bounding box of current situation
    const box = this.bbox(); // get relative offset

    x -= box.x;
    y -= box.y;

    if (!isNaN(x) && !isNaN(y)) {
      // move every point
      for (let l, i = this.length - 1; i >= 0; i--) {
        l = this[i][0];

        if (l === 'M' || l === 'L' || l === 'T') {
          this[i][1] += x;
          this[i][2] += y;
        } else if (l === 'H') {
          this[i][1] += x;
        } else if (l === 'V') {
          this[i][1] += y;
        } else if (l === 'C' || l === 'S' || l === 'Q') {
          this[i][1] += x;
          this[i][2] += y;
          this[i][3] += x;
          this[i][4] += y;

          if (l === 'C') {
            this[i][5] += x;
            this[i][6] += y;
          }
        } else if (l === 'A') {
          this[i][6] += x;
          this[i][7] += y;
        }
      }
    }

    return this;
  } // Absolutize and parse path to array


  parse(d = 'M0 0') {
    if (Array.isArray(d)) {
      d = Array.prototype.concat.apply([], d).toString();
    }

    return pathParser(d);
  } // Resize path string


  size(width, height) {
    // get bounding box of current situation
    const box = this.bbox();
    let i, l; // If the box width or height is 0 then we ignore
    // transformations on the respective axis

    box.width = box.width === 0 ? 1 : box.width;
    box.height = box.height === 0 ? 1 : box.height; // recalculate position of all points according to new size

    for (i = this.length - 1; i >= 0; i--) {
      l = this[i][0];

      if (l === 'M' || l === 'L' || l === 'T') {
        this[i][1] = (this[i][1] - box.x) * width / box.width + box.x;
        this[i][2] = (this[i][2] - box.y) * height / box.height + box.y;
      } else if (l === 'H') {
        this[i][1] = (this[i][1] - box.x) * width / box.width + box.x;
      } else if (l === 'V') {
        this[i][1] = (this[i][1] - box.y) * height / box.height + box.y;
      } else if (l === 'C' || l === 'S' || l === 'Q') {
        this[i][1] = (this[i][1] - box.x) * width / box.width + box.x;
        this[i][2] = (this[i][2] - box.y) * height / box.height + box.y;
        this[i][3] = (this[i][3] - box.x) * width / box.width + box.x;
        this[i][4] = (this[i][4] - box.y) * height / box.height + box.y;

        if (l === 'C') {
          this[i][5] = (this[i][5] - box.x) * width / box.width + box.x;
          this[i][6] = (this[i][6] - box.y) * height / box.height + box.y;
        }
      } else if (l === 'A') {
        // resize radii
        this[i][1] = this[i][1] * width / box.width;
        this[i][2] = this[i][2] * height / box.height; // move position values

        this[i][6] = (this[i][6] - box.x) * width / box.width + box.x;
        this[i][7] = (this[i][7] - box.y) * height / box.height + box.y;
      }
    }

    return this;
  } // Convert array to string


  toString() {
    return arrayToString(this);
  }

}

const getClassForType = value => {
  const type = typeof value;

  if (type === 'number') {
    return SVGNumber;
  } else if (type === 'string') {
    if (Color.isColor(value)) {
      return Color;
    } else if (delimiter.test(value)) {
      return isPathLetter.test(value) ? PathArray : SVGArray;
    } else if (numberAndUnit.test(value)) {
      return SVGNumber;
    } else {
      return NonMorphable;
    }
  } else if (morphableTypes.indexOf(value.constructor) > -1) {
    return value.constructor;
  } else if (Array.isArray(value)) {
    return SVGArray;
  } else if (type === 'object') {
    return ObjectBag;
  } else {
    return NonMorphable;
  }
};

class Morphable {
  constructor(stepper) {
    this._stepper = stepper || new Ease('-');
    this._from = null;
    this._to = null;
    this._type = null;
    this._context = null;
    this._morphObj = null;
  }

  at(pos) {
    return this._morphObj.morph(this._from, this._to, pos, this._stepper, this._context);
  }

  done() {
    const complete = this._context.map(this._stepper.done).reduce(function (last, curr) {
      return last && curr;
    }, true);

    return complete;
  }

  from(val) {
    if (val == null) {
      return this._from;
    }

    this._from = this._set(val);
    return this;
  }

  stepper(stepper) {
    if (stepper == null) return this._stepper;
    this._stepper = stepper;
    return this;
  }

  to(val) {
    if (val == null) {
      return this._to;
    }

    this._to = this._set(val);
    return this;
  }

  type(type) {
    // getter
    if (type == null) {
      return this._type;
    } // setter


    this._type = type;
    return this;
  }

  _set(value) {
    if (!this._type) {
      this.type(getClassForType(value));
    }

    let result = new this._type(value);

    if (this._type === Color) {
      result = this._to ? result[this._to[4]]() : this._from ? result[this._from[4]]() : result;
    }

    if (this._type === ObjectBag) {
      result = this._to ? result.align(this._to) : this._from ? result.align(this._from) : result;
    }

    result = result.toConsumable();
    this._morphObj = this._morphObj || new this._type();
    this._context = this._context || Array.apply(null, Array(result.length)).map(Object).map(function (o) {
      o.done = true;
      return o;
    });
    return result;
  }

}
class NonMorphable {
  constructor(...args) {
    this.init(...args);
  }

  init(val) {
    val = Array.isArray(val) ? val[0] : val;
    this.value = val;
    return this;
  }

  toArray() {
    return [this.value];
  }

  valueOf() {
    return this.value;
  }

}
class TransformBag {
  constructor(...args) {
    this.init(...args);
  }

  init(obj) {
    if (Array.isArray(obj)) {
      obj = {
        scaleX: obj[0],
        scaleY: obj[1],
        shear: obj[2],
        rotate: obj[3],
        translateX: obj[4],
        translateY: obj[5],
        originX: obj[6],
        originY: obj[7]
      };
    }

    Object.assign(this, TransformBag.defaults, obj);
    return this;
  }

  toArray() {
    const v = this;
    return [v.scaleX, v.scaleY, v.shear, v.rotate, v.translateX, v.translateY, v.originX, v.originY];
  }

}
TransformBag.defaults = {
  scaleX: 1,
  scaleY: 1,
  shear: 0,
  rotate: 0,
  translateX: 0,
  translateY: 0,
  originX: 0,
  originY: 0
};

const sortByKey = (a, b) => {
  return a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0;
};

class ObjectBag {
  constructor(...args) {
    this.init(...args);
  }

  align(other) {
    const values = this.values;

    for (let i = 0, il = values.length; i < il; ++i) {
      // If the type is the same we only need to check if the color is in the correct format
      if (values[i + 1] === other[i + 1]) {
        if (values[i + 1] === Color && other[i + 7] !== values[i + 7]) {
          const space = other[i + 7];
          const color = new Color(this.values.splice(i + 3, 5))[space]().toArray();
          this.values.splice(i + 3, 0, ...color);
        }

        i += values[i + 2] + 2;
        continue;
      }

      if (!other[i + 1]) {
        return this;
      } // The types differ, so we overwrite the new type with the old one
      // And initialize it with the types default (e.g. black for color or 0 for number)


      const defaultObject = new other[i + 1]().toArray(); // Than we fix the values array

      const toDelete = values[i + 2] + 3;
      values.splice(i, toDelete, other[i], other[i + 1], other[i + 2], ...defaultObject);
      i += values[i + 2] + 2;
    }

    return this;
  }

  init(objOrArr) {
    this.values = [];

    if (Array.isArray(objOrArr)) {
      this.values = objOrArr.slice();
      return;
    }

    objOrArr = objOrArr || {};
    const entries = [];

    for (const i in objOrArr) {
      const Type = getClassForType(objOrArr[i]);
      const val = new Type(objOrArr[i]).toArray();
      entries.push([i, Type, val.length, ...val]);
    }

    entries.sort(sortByKey);
    this.values = entries.reduce((last, curr) => last.concat(curr), []);
    return this;
  }

  toArray() {
    return this.values;
  }

  valueOf() {
    const obj = {};
    const arr = this.values; // for (var i = 0, len = arr.length; i < len; i += 2) {

    while (arr.length) {
      const key = arr.shift();
      const Type = arr.shift();
      const num = arr.shift();
      const values = arr.splice(0, num);
      obj[key] = new Type(values); // .valueOf()
    }

    return obj;
  }

}
const morphableTypes = [NonMorphable, TransformBag, ObjectBag];
function registerMorphableType(type = []) {
  morphableTypes.push(...[].concat(type));
}
function makeMorphable() {
  extend(morphableTypes, {
    to(val) {
      return new Morphable().type(this.constructor).from(this.toArray()) // this.valueOf())
      .to(val);
    },

    fromArray(arr) {
      this.init(arr);
      return this;
    },

    toConsumable() {
      return this.toArray();
    },

    morph(from, to, pos, stepper, context) {
      const mapper = function (i, index) {
        return stepper.step(i, to[index], pos, context[index], context);
      };

      return this.fromArray(from.map(mapper));
    }

  });
}

class Path extends Shape {
  // Initialize node
  constructor(node, attrs = node) {
    super(nodeOrNew('path', node), attrs);
  } // Get array


  array() {
    return this._array || (this._array = new PathArray(this.attr('d')));
  } // Clear array cache


  clear() {
    delete this._array;
    return this;
  } // Set height of element


  height(height) {
    return height == null ? this.bbox().height : this.size(this.bbox().width, height);
  } // Move by left top corner


  move(x, y) {
    return this.attr('d', this.array().move(x, y));
  } // Plot new path


  plot(d) {
    return d == null ? this.array() : this.clear().attr('d', typeof d === 'string' ? d : this._array = new PathArray(d));
  } // Set element size to given width and height


  size(width, height) {
    const p = proportionalSize(this, width, height);
    return this.attr('d', this.array().size(p.width, p.height));
  } // Set width of element


  width(width) {
    return width == null ? this.bbox().width : this.size(width, this.bbox().height);
  } // Move by left top corner over x-axis


  x(x) {
    return x == null ? this.bbox().x : this.move(x, this.bbox().y);
  } // Move by left top corner over y-axis


  y(y) {
    return y == null ? this.bbox().y : this.move(this.bbox().x, y);
  }

} // Define morphable array

Path.prototype.MorphArray = PathArray; // Add parent method

registerMethods({
  Container: {
    // Create a wrapped path element
    path: wrapWithAttrCheck(function (d) {
      // make sure plot is called as a setter
      return this.put(new Path()).plot(d || new PathArray());
    })
  }
});
register(Path, 'Path');

function array() {
  return this._array || (this._array = new PointArray(this.attr('points')));
} // Clear array cache

function clear() {
  delete this._array;
  return this;
} // Move by left top corner

function move$2(x, y) {
  return this.attr('points', this.array().move(x, y));
} // Plot new path

function plot(p) {
  return p == null ? this.array() : this.clear().attr('points', typeof p === 'string' ? p : this._array = new PointArray(p));
} // Set element size to given width and height

function size$1(width, height) {
  const p = proportionalSize(this, width, height);
  return this.attr('points', this.array().size(p.width, p.height));
}

var poly = {
  __proto__: null,
  array: array,
  clear: clear,
  move: move$2,
  plot: plot,
  size: size$1
};

class Polygon extends Shape {
  // Initialize node
  constructor(node, attrs = node) {
    super(nodeOrNew('polygon', node), attrs);
  }

}
registerMethods({
  Container: {
    // Create a wrapped polygon element
    polygon: wrapWithAttrCheck(function (p) {
      // make sure plot is called as a setter
      return this.put(new Polygon()).plot(p || new PointArray());
    })
  }
});
extend(Polygon, pointed);
extend(Polygon, poly);
register(Polygon, 'Polygon');

class Polyline extends Shape {
  // Initialize node
  constructor(node, attrs = node) {
    super(nodeOrNew('polyline', node), attrs);
  }

}
registerMethods({
  Container: {
    // Create a wrapped polygon element
    polyline: wrapWithAttrCheck(function (p) {
      // make sure plot is called as a setter
      return this.put(new Polyline()).plot(p || new PointArray());
    })
  }
});
extend(Polyline, pointed);
extend(Polyline, poly);
register(Polyline, 'Polyline');

class Rect extends Shape {
  // Initialize node
  constructor(node, attrs = node) {
    super(nodeOrNew('rect', node), attrs);
  }

}
extend(Rect, {
  rx,
  ry
});
registerMethods({
  Container: {
    // Create a rect element
    rect: wrapWithAttrCheck(function (width, height) {
      return this.put(new Rect()).size(width, height);
    })
  }
});
register(Rect, 'Rect');

class Queue {
  constructor() {
    this._first = null;
    this._last = null;
  } // Shows us the first item in the list


  first() {
    return this._first && this._first.value;
  } // Shows us the last item in the list


  last() {
    return this._last && this._last.value;
  }

  push(value) {
    // An item stores an id and the provided value
    const item = typeof value.next !== 'undefined' ? value : {
      value: value,
      next: null,
      prev: null
    }; // Deal with the queue being empty or populated

    if (this._last) {
      item.prev = this._last;
      this._last.next = item;
      this._last = item;
    } else {
      this._last = item;
      this._first = item;
    } // Return the current item


    return item;
  } // Removes the item that was returned from the push


  remove(item) {
    // Relink the previous item
    if (item.prev) item.prev.next = item.next;
    if (item.next) item.next.prev = item.prev;
    if (item === this._last) this._last = item.prev;
    if (item === this._first) this._first = item.next; // Invalidate item

    item.prev = null;
    item.next = null;
  }

  shift() {
    // Check if we have a value
    const remove = this._first;
    if (!remove) return null; // If we do, remove it and relink things

    this._first = remove.next;
    if (this._first) this._first.prev = null;
    this._last = this._first ? this._last : null;
    return remove.value;
  }

}

const Animator = {
  nextDraw: null,
  frames: new Queue(),
  timeouts: new Queue(),
  immediates: new Queue(),
  timer: () => globals.window.performance || globals.window.Date,
  transforms: [],

  frame(fn) {
    // Store the node
    const node = Animator.frames.push({
      run: fn
    }); // Request an animation frame if we don't have one

    if (Animator.nextDraw === null) {
      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);
    } // Return the node so we can remove it easily


    return node;
  },

  timeout(fn, delay) {
    delay = delay || 0; // Work out when the event should fire

    const time = Animator.timer().now() + delay; // Add the timeout to the end of the queue

    const node = Animator.timeouts.push({
      run: fn,
      time: time
    }); // Request another animation frame if we need one

    if (Animator.nextDraw === null) {
      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);
    }

    return node;
  },

  immediate(fn) {
    // Add the immediate fn to the end of the queue
    const node = Animator.immediates.push(fn); // Request another animation frame if we need one

    if (Animator.nextDraw === null) {
      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);
    }

    return node;
  },

  cancelFrame(node) {
    node != null && Animator.frames.remove(node);
  },

  clearTimeout(node) {
    node != null && Animator.timeouts.remove(node);
  },

  cancelImmediate(node) {
    node != null && Animator.immediates.remove(node);
  },

  _draw(now) {
    // Run all the timeouts we can run, if they are not ready yet, add them
    // to the end of the queue immediately! (bad timeouts!!! [sarcasm])
    let nextTimeout = null;
    const lastTimeout = Animator.timeouts.last();

    while (nextTimeout = Animator.timeouts.shift()) {
      // Run the timeout if its time, or push it to the end
      if (now >= nextTimeout.time) {
        nextTimeout.run();
      } else {
        Animator.timeouts.push(nextTimeout);
      } // If we hit the last item, we should stop shifting out more items


      if (nextTimeout === lastTimeout) break;
    } // Run all of the animation frames


    let nextFrame = null;
    const lastFrame = Animator.frames.last();

    while (nextFrame !== lastFrame && (nextFrame = Animator.frames.shift())) {
      nextFrame.run(now);
    }

    let nextImmediate = null;

    while (nextImmediate = Animator.immediates.shift()) {
      nextImmediate();
    } // If we have remaining timeouts or frames, draw until we don't anymore


    Animator.nextDraw = Animator.timeouts.first() || Animator.frames.first() ? globals.window.requestAnimationFrame(Animator._draw) : null;
  }

};

const makeSchedule = function (runnerInfo) {
  const start = runnerInfo.start;
  const duration = runnerInfo.runner.duration();
  const end = start + duration;
  return {
    start: start,
    duration: duration,
    end: end,
    runner: runnerInfo.runner
  };
};

const defaultSource = function () {
  const w = globals.window;
  return (w.performance || w.Date).now();
};

class Timeline extends EventTarget {
  // Construct a new timeline on the given element
  constructor(timeSource = defaultSource) {
    super();
    this._timeSource = timeSource; // Store the timing variables

    this._startTime = 0;
    this._speed = 1.0; // Determines how long a runner is hold in memory. Can be a dt or true/false

    this._persist = 0; // Keep track of the running animations and their starting parameters

    this._nextFrame = null;
    this._paused = true;
    this._runners = [];
    this._runnerIds = [];
    this._lastRunnerId = -1;
    this._time = 0;
    this._lastSourceTime = 0;
    this._lastStepTime = 0; // Make sure that step is always called in class context

    this._step = this._stepFn.bind(this, false);
    this._stepImmediate = this._stepFn.bind(this, true);
  }

  active() {
    return !!this._nextFrame;
  }

  finish() {
    // Go to end and pause
    this.time(this.getEndTimeOfTimeline() + 1);
    return this.pause();
  } // Calculates the end of the timeline


  getEndTime() {
    const lastRunnerInfo = this.getLastRunnerInfo();
    const lastDuration = lastRunnerInfo ? lastRunnerInfo.runner.duration() : 0;
    const lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : this._time;
    return lastStartTime + lastDuration;
  }

  getEndTimeOfTimeline() {
    const endTimes = this._runners.map(i => i.start + i.runner.duration());

    return Math.max(0, ...endTimes);
  }

  getLastRunnerInfo() {
    return this.getRunnerInfoById(this._lastRunnerId);
  }

  getRunnerInfoById(id) {
    return this._runners[this._runnerIds.indexOf(id)] || null;
  }

  pause() {
    this._paused = true;
    return this._continue();
  }

  persist(dtOrForever) {
    if (dtOrForever == null) return this._persist;
    this._persist = dtOrForever;
    return this;
  }

  play() {
    // Now make sure we are not paused and continue the animation
    this._paused = false;
    return this.updateTime()._continue();
  }

  reverse(yes) {
    const currentSpeed = this.speed();
    if (yes == null) return this.speed(-currentSpeed);
    const positive = Math.abs(currentSpeed);
    return this.speed(yes ? -positive : positive);
  } // schedules a runner on the timeline


  schedule(runner, delay, when) {
    if (runner == null) {
      return this._runners.map(makeSchedule);
    } // The start time for the next animation can either be given explicitly,
    // derived from the current timeline time or it can be relative to the
    // last start time to chain animations directly


    let absoluteStartTime = 0;
    const endTime = this.getEndTime();
    delay = delay || 0; // Work out when to start the animation

    if (when == null || when === 'last' || when === 'after') {
      // Take the last time and increment
      absoluteStartTime = endTime;
    } else if (when === 'absolute' || when === 'start') {
      absoluteStartTime = delay;
      delay = 0;
    } else if (when === 'now') {
      absoluteStartTime = this._time;
    } else if (when === 'relative') {
      const runnerInfo = this.getRunnerInfoById(runner.id);

      if (runnerInfo) {
        absoluteStartTime = runnerInfo.start + delay;
        delay = 0;
      }
    } else if (when === 'with-last') {
      const lastRunnerInfo = this.getLastRunnerInfo();
      const lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : this._time;
      absoluteStartTime = lastStartTime;
    } else {
      throw new Error('Invalid value for the "when" parameter');
    } // Manage runner


    runner.unschedule();
    runner.timeline(this);
    const persist = runner.persist();
    const runnerInfo = {
      persist: persist === null ? this._persist : persist,
      start: absoluteStartTime + delay,
      runner
    };
    this._lastRunnerId = runner.id;

    this._runners.push(runnerInfo);

    this._runners.sort((a, b) => a.start - b.start);

    this._runnerIds = this._runners.map(info => info.runner.id);

    this.updateTime()._continue();

    return this;
  }

  seek(dt) {
    return this.time(this._time + dt);
  }

  source(fn) {
    if (fn == null) return this._timeSource;
    this._timeSource = fn;
    return this;
  }

  speed(speed) {
    if (speed == null) return this._speed;
    this._speed = speed;
    return this;
  }

  stop() {
    // Go to start and pause
    this.time(0);
    return this.pause();
  }

  time(time) {
    if (time == null) return this._time;
    this._time = time;
    return this._continue(true);
  } // Remove the runner from this timeline


  unschedule(runner) {
    const index = this._runnerIds.indexOf(runner.id);

    if (index < 0) return this;

    this._runners.splice(index, 1);

    this._runnerIds.splice(index, 1);

    runner.timeline(null);
    return this;
  } // Makes sure, that after pausing the time doesn't jump


  updateTime() {
    if (!this.active()) {
      this._lastSourceTime = this._timeSource();
    }

    return this;
  } // Checks if we are running and continues the animation


  _continue(immediateStep = false) {
    Animator.cancelFrame(this._nextFrame);
    this._nextFrame = null;
    if (immediateStep) return this._stepImmediate();
    if (this._paused) return this;
    this._nextFrame = Animator.frame(this._step);
    return this;
  }

  _stepFn(immediateStep = false) {
    // Get the time delta from the last time and update the time
    const time = this._timeSource();

    let dtSource = time - this._lastSourceTime;
    if (immediateStep) dtSource = 0;
    const dtTime = this._speed * dtSource + (this._time - this._lastStepTime);
    this._lastSourceTime = time; // Only update the time if we use the timeSource.
    // Otherwise use the current time

    if (!immediateStep) {
      // Update the time
      this._time += dtTime;
      this._time = this._time < 0 ? 0 : this._time;
    }

    this._lastStepTime = this._time;
    this.fire('time', this._time); // This is for the case that the timeline was seeked so that the time
    // is now before the startTime of the runner. That is why we need to set
    // the runner to position 0
    // FIXME:
    // However, resetting in insertion order leads to bugs. Considering the case,
    // where 2 runners change the same attribute but in different times,
    // resetting both of them will lead to the case where the later defined
    // runner always wins the reset even if the other runner started earlier
    // and therefore should win the attribute battle
    // this can be solved by resetting them backwards

    for (let k = this._runners.length; k--;) {
      // Get and run the current runner and ignore it if its inactive
      const runnerInfo = this._runners[k];
      const runner = runnerInfo.runner; // Make sure that we give the actual difference
      // between runner start time and now

      const dtToStart = this._time - runnerInfo.start; // Dont run runner if not started yet
      // and try to reset it

      if (dtToStart <= 0) {
        runner.reset();
      }
    } // Run all of the runners directly


    let runnersLeft = false;

    for (let i = 0, len = this._runners.length; i < len; i++) {
      // Get and run the current runner and ignore it if its inactive
      const runnerInfo = this._runners[i];
      const runner = runnerInfo.runner;
      let dt = dtTime; // Make sure that we give the actual difference
      // between runner start time and now

      const dtToStart = this._time - runnerInfo.start; // Dont run runner if not started yet

      if (dtToStart <= 0) {
        runnersLeft = true;
        continue;
      } else if (dtToStart < dt) {
        // Adjust dt to make sure that animation is on point
        dt = dtToStart;
      }

      if (!runner.active()) continue; // If this runner is still going, signal that we need another animation
      // frame, otherwise, remove the completed runner

      const finished = runner.step(dt).done;

      if (!finished) {
        runnersLeft = true; // continue
      } else if (runnerInfo.persist !== true) {
        // runner is finished. And runner might get removed
        const endTime = runner.duration() - runner.time() + this._time;

        if (endTime + runnerInfo.persist < this._time) {
          // Delete runner and correct index
          runner.unschedule();
          --i;
          --len;
        }
      }
    } // Basically: we continue when there are runners right from us in time
    // when -->, and when runners are left from us when <--


    if (runnersLeft && !(this._speed < 0 && this._time === 0) || this._runnerIds.length && this._speed < 0 && this._time > 0) {
      this._continue();
    } else {
      this.pause();
      this.fire('finished');
    }

    return this;
  }

}
registerMethods({
  Element: {
    timeline: function (timeline) {
      if (timeline == null) {
        this._timeline = this._timeline || new Timeline();
        return this._timeline;
      } else {
        this._timeline = timeline;
        return this;
      }
    }
  }
});

class Runner extends EventTarget {
  constructor(options) {
    super(); // Store a unique id on the runner, so that we can identify it later

    this.id = Runner.id++; // Ensure a default value

    options = options == null ? timeline.duration : options; // Ensure that we get a controller

    options = typeof options === 'function' ? new Controller(options) : options; // Declare all of the variables

    this._element = null;
    this._timeline = null;
    this.done = false;
    this._queue = []; // Work out the stepper and the duration

    this._duration = typeof options === 'number' && options;
    this._isDeclarative = options instanceof Controller;
    this._stepper = this._isDeclarative ? options : new Ease(); // We copy the current values from the timeline because they can change

    this._history = {}; // Store the state of the runner

    this.enabled = true;
    this._time = 0;
    this._lastTime = 0; // At creation, the runner is in reset state

    this._reseted = true; // Save transforms applied to this runner

    this.transforms = new Matrix();
    this.transformId = 1; // Looping variables

    this._haveReversed = false;
    this._reverse = false;
    this._loopsDone = 0;
    this._swing = false;
    this._wait = 0;
    this._times = 1;
    this._frameId = null; // Stores how long a runner is stored after being done

    this._persist = this._isDeclarative ? true : null;
  }

  static sanitise(duration, delay, when) {
    // Initialise the default parameters
    let times = 1;
    let swing = false;
    let wait = 0;
    duration = duration || timeline.duration;
    delay = delay || timeline.delay;
    when = when || 'last'; // If we have an object, unpack the values

    if (typeof duration === 'object' && !(duration instanceof Stepper)) {
      delay = duration.delay || delay;
      when = duration.when || when;
      swing = duration.swing || swing;
      times = duration.times || times;
      wait = duration.wait || wait;
      duration = duration.duration || timeline.duration;
    }

    return {
      duration: duration,
      delay: delay,
      swing: swing,
      times: times,
      wait: wait,
      when: when
    };
  }

  active(enabled) {
    if (enabled == null) return this.enabled;
    this.enabled = enabled;
    return this;
  }
  /*
  Private Methods
  ===============
  Methods that shouldn't be used externally
  */


  addTransform(transform, index) {
    this.transforms.lmultiplyO(transform);
    return this;
  }

  after(fn) {
    return this.on('finished', fn);
  }

  animate(duration, delay, when) {
    const o = Runner.sanitise(duration, delay, when);
    const runner = new Runner(o.duration);
    if (this._timeline) runner.timeline(this._timeline);
    if (this._element) runner.element(this._element);
    return runner.loop(o).schedule(o.delay, o.when);
  }

  clearTransform() {
    this.transforms = new Matrix();
    return this;
  } // TODO: Keep track of all transformations so that deletion is faster


  clearTransformsFromQueue() {
    if (!this.done || !this._timeline || !this._timeline._runnerIds.includes(this.id)) {
      this._queue = this._queue.filter(item => {
        return !item.isTransform;
      });
    }
  }

  delay(delay) {
    return this.animate(0, delay);
  }

  duration() {
    return this._times * (this._wait + this._duration) - this._wait;
  }

  during(fn) {
    return this.queue(null, fn);
  }

  ease(fn) {
    this._stepper = new Ease(fn);
    return this;
  }
  /*
  Runner Definitions
  ==================
  These methods help us define the runtime behaviour of the Runner or they
  help us make new runners from the current runner
  */


  element(element) {
    if (element == null) return this._element;
    this._element = element;

    element._prepareRunner();

    return this;
  }

  finish() {
    return this.step(Infinity);
  }

  loop(times, swing, wait) {
    // Deal with the user passing in an object
    if (typeof times === 'object') {
      swing = times.swing;
      wait = times.wait;
      times = times.times;
    } // Sanitise the values and store them


    this._times = times || Infinity;
    this._swing = swing || false;
    this._wait = wait || 0; // Allow true to be passed

    if (this._times === true) {
      this._times = Infinity;
    }

    return this;
  }

  loops(p) {
    const loopDuration = this._duration + this._wait;

    if (p == null) {
      const loopsDone = Math.floor(this._time / loopDuration);
      const relativeTime = this._time - loopsDone * loopDuration;
      const position = relativeTime / this._duration;
      return Math.min(loopsDone + position, this._times);
    }

    const whole = Math.floor(p);
    const partial = p % 1;
    const time = loopDuration * whole + this._duration * partial;
    return this.time(time);
  }

  persist(dtOrForever) {
    if (dtOrForever == null) return this._persist;
    this._persist = dtOrForever;
    return this;
  }

  position(p) {
    // Get all of the variables we need
    const x = this._time;
    const d = this._duration;
    const w = this._wait;
    const t = this._times;
    const s = this._swing;
    const r = this._reverse;
    let position;

    if (p == null) {
      /*
      This function converts a time to a position in the range [0, 1]
      The full explanation can be found in this desmos demonstration
        https://www.desmos.com/calculator/u4fbavgche
      The logic is slightly simplified here because we can use booleans
      */
      // Figure out the value without thinking about the start or end time
      const f = function (x) {
        const swinging = s * Math.floor(x % (2 * (w + d)) / (w + d));
        const backwards = swinging && !r || !swinging && r;
        const uncliped = Math.pow(-1, backwards) * (x % (w + d)) / d + backwards;
        const clipped = Math.max(Math.min(uncliped, 1), 0);
        return clipped;
      }; // Figure out the value by incorporating the start time


      const endTime = t * (w + d) - w;
      position = x <= 0 ? Math.round(f(1e-5)) : x < endTime ? f(x) : Math.round(f(endTime - 1e-5));
      return position;
    } // Work out the loops done and add the position to the loops done


    const loopsDone = Math.floor(this.loops());
    const swingForward = s && loopsDone % 2 === 0;
    const forwards = swingForward && !r || r && swingForward;
    position = loopsDone + (forwards ? p : 1 - p);
    return this.loops(position);
  }

  progress(p) {
    if (p == null) {
      return Math.min(1, this._time / this.duration());
    }

    return this.time(p * this.duration());
  }
  /*
  Basic Functionality
  ===================
  These methods allow us to attach basic functions to the runner directly
  */


  queue(initFn, runFn, retargetFn, isTransform) {
    this._queue.push({
      initialiser: initFn || noop,
      runner: runFn || noop,
      retarget: retargetFn,
      isTransform: isTransform,
      initialised: false,
      finished: false
    });

    const timeline = this.timeline();
    timeline && this.timeline()._continue();
    return this;
  }

  reset() {
    if (this._reseted) return this;
    this.time(0);
    this._reseted = true;
    return this;
  }

  reverse(reverse) {
    this._reverse = reverse == null ? !this._reverse : reverse;
    return this;
  }

  schedule(timeline, delay, when) {
    // The user doesn't need to pass a timeline if we already have one
    if (!(timeline instanceof Timeline)) {
      when = delay;
      delay = timeline;
      timeline = this.timeline();
    } // If there is no timeline, yell at the user...


    if (!timeline) {
      throw Error('Runner cannot be scheduled without timeline');
    } // Schedule the runner on the timeline provided


    timeline.schedule(this, delay, when);
    return this;
  }

  step(dt) {
    // If we are inactive, this stepper just gets skipped
    if (!this.enabled) return this; // Update the time and get the new position

    dt = dt == null ? 16 : dt;
    this._time += dt;
    const position = this.position(); // Figure out if we need to run the stepper in this frame

    const running = this._lastPosition !== position && this._time >= 0;
    this._lastPosition = position; // Figure out if we just started

    const duration = this.duration();
    const justStarted = this._lastTime <= 0 && this._time > 0;
    const justFinished = this._lastTime < duration && this._time >= duration;
    this._lastTime = this._time;

    if (justStarted) {
      this.fire('start', this);
    } // Work out if the runner is finished set the done flag here so animations
    // know, that they are running in the last step (this is good for
    // transformations which can be merged)


    const declarative = this._isDeclarative;
    this.done = !declarative && !justFinished && this._time >= duration; // Runner is running. So its not in reset state anymore

    this._reseted = false;
    let converged = false; // Call initialise and the run function

    if (running || declarative) {
      this._initialise(running); // clear the transforms on this runner so they dont get added again and again


      this.transforms = new Matrix();
      converged = this._run(declarative ? dt : position);
      this.fire('step', this);
    } // correct the done flag here
    // declarative animations itself know when they converged


    this.done = this.done || converged && declarative;

    if (justFinished) {
      this.fire('finished', this);
    }

    return this;
  }
  /*
  Runner animation methods
  ========================
  Control how the animation plays
  */


  time(time) {
    if (time == null) {
      return this._time;
    }

    const dt = time - this._time;
    this.step(dt);
    return this;
  }

  timeline(timeline) {
    // check explicitly for undefined so we can set the timeline to null
    if (typeof timeline === 'undefined') return this._timeline;
    this._timeline = timeline;
    return this;
  }

  unschedule() {
    const timeline = this.timeline();
    timeline && timeline.unschedule(this);
    return this;
  } // Run each initialise function in the runner if required


  _initialise(running) {
    // If we aren't running, we shouldn't initialise when not declarative
    if (!running && !this._isDeclarative) return; // Loop through all of the initialisers

    for (let i = 0, len = this._queue.length; i < len; ++i) {
      // Get the current initialiser
      const current = this._queue[i]; // Determine whether we need to initialise

      const needsIt = this._isDeclarative || !current.initialised && running;
      running = !current.finished; // Call the initialiser if we need to

      if (needsIt && running) {
        current.initialiser.call(this);
        current.initialised = true;
      }
    }
  } // Save a morpher to the morpher list so that we can retarget it later


  _rememberMorpher(method, morpher) {
    this._history[method] = {
      morpher: morpher,
      caller: this._queue[this._queue.length - 1]
    }; // We have to resume the timeline in case a controller
    // is already done without being ever run
    // This can happen when e.g. this is done:
    //    anim = el.animate(new SVG.Spring)
    // and later
    //    anim.move(...)

    if (this._isDeclarative) {
      const timeline = this.timeline();
      timeline && timeline.play();
    }
  } // Try to set the target for a morpher if the morpher exists, otherwise
  // Run each run function for the position or dt given


  _run(positionOrDt) {
    // Run all of the _queue directly
    let allfinished = true;

    for (let i = 0, len = this._queue.length; i < len; ++i) {
      // Get the current function to run
      const current = this._queue[i]; // Run the function if its not finished, we keep track of the finished
      // flag for the sake of declarative _queue

      const converged = current.runner.call(this, positionOrDt);
      current.finished = current.finished || converged === true;
      allfinished = allfinished && current.finished;
    } // We report when all of the constructors are finished


    return allfinished;
  } // do nothing and return false


  _tryRetarget(method, target, extra) {
    if (this._history[method]) {
      // if the last method wasn't even initialised, throw it away
      if (!this._history[method].caller.initialised) {
        const index = this._queue.indexOf(this._history[method].caller);

        this._queue.splice(index, 1);

        return false;
      } // for the case of transformations, we use the special retarget function
      // which has access to the outer scope


      if (this._history[method].caller.retarget) {
        this._history[method].caller.retarget.call(this, target, extra); // for everything else a simple morpher change is sufficient

      } else {
        this._history[method].morpher.to(target);
      }

      this._history[method].caller.finished = false;
      const timeline = this.timeline();
      timeline && timeline.play();
      return true;
    }

    return false;
  }

}
Runner.id = 0;
class FakeRunner {
  constructor(transforms = new Matrix(), id = -1, done = true) {
    this.transforms = transforms;
    this.id = id;
    this.done = done;
  }

  clearTransformsFromQueue() {}

}
extend([Runner, FakeRunner], {
  mergeWith(runner) {
    return new FakeRunner(runner.transforms.lmultiply(this.transforms), runner.id);
  }

}); // FakeRunner.emptyRunner = new FakeRunner()

const lmultiply = (last, curr) => last.lmultiplyO(curr);

const getRunnerTransform = runner => runner.transforms;

function mergeTransforms() {
  // Find the matrix to apply to the element and apply it
  const runners = this._transformationRunners.runners;
  const netTransform = runners.map(getRunnerTransform).reduce(lmultiply, new Matrix());
  this.transform(netTransform);

  this._transformationRunners.merge();

  if (this._transformationRunners.length() === 1) {
    this._frameId = null;
  }
}

class RunnerArray {
  constructor() {
    this.runners = [];
    this.ids = [];
  }

  add(runner) {
    if (this.runners.includes(runner)) return;
    const id = runner.id + 1;
    this.runners.push(runner);
    this.ids.push(id);
    return this;
  }

  clearBefore(id) {
    const deleteCnt = this.ids.indexOf(id + 1) || 1;
    this.ids.splice(0, deleteCnt, 0);
    this.runners.splice(0, deleteCnt, new FakeRunner()).forEach(r => r.clearTransformsFromQueue());
    return this;
  }

  edit(id, newRunner) {
    const index = this.ids.indexOf(id + 1);
    this.ids.splice(index, 1, id + 1);
    this.runners.splice(index, 1, newRunner);
    return this;
  }

  getByID(id) {
    return this.runners[this.ids.indexOf(id + 1)];
  }

  length() {
    return this.ids.length;
  }

  merge() {
    let lastRunner = null;

    for (let i = 0; i < this.runners.length; ++i) {
      const runner = this.runners[i];
      const condition = lastRunner && runner.done && lastRunner.done // don't merge runner when persisted on timeline
      && (!runner._timeline || !runner._timeline._runnerIds.includes(runner.id)) && (!lastRunner._timeline || !lastRunner._timeline._runnerIds.includes(lastRunner.id));

      if (condition) {
        // the +1 happens in the function
        this.remove(runner.id);
        const newRunner = runner.mergeWith(lastRunner);
        this.edit(lastRunner.id, newRunner);
        lastRunner = newRunner;
        --i;
      } else {
        lastRunner = runner;
      }
    }

    return this;
  }

  remove(id) {
    const index = this.ids.indexOf(id + 1);
    this.ids.splice(index, 1);
    this.runners.splice(index, 1);
    return this;
  }

}
registerMethods({
  Element: {
    animate(duration, delay, when) {
      const o = Runner.sanitise(duration, delay, when);
      const timeline = this.timeline();
      return new Runner(o.duration).loop(o).element(this).timeline(timeline.play()).schedule(o.delay, o.when);
    },

    delay(by, when) {
      return this.animate(0, by, when);
    },

    // this function searches for all runners on the element and deletes the ones
    // which run before the current one. This is because absolute transformations
    // overwrite anything anyway so there is no need to waste time computing
    // other runners
    _clearTransformRunnersBefore(currentRunner) {
      this._transformationRunners.clearBefore(currentRunner.id);
    },

    _currentTransform(current) {
      return this._transformationRunners.runners // we need the equal sign here to make sure, that also transformations
      // on the same runner which execute before the current transformation are
      // taken into account
      .filter(runner => runner.id <= current.id).map(getRunnerTransform).reduce(lmultiply, new Matrix());
    },

    _addRunner(runner) {
      this._transformationRunners.add(runner); // Make sure that the runner merge is executed at the very end of
      // all Animator functions. That is why we use immediate here to execute
      // the merge right after all frames are run


      Animator.cancelImmediate(this._frameId);
      this._frameId = Animator.immediate(mergeTransforms.bind(this));
    },

    _prepareRunner() {
      if (this._frameId == null) {
        this._transformationRunners = new RunnerArray().add(new FakeRunner(new Matrix(this)));
      }
    }

  }
}); // Will output the elements from array A that are not in the array B

const difference = (a, b) => a.filter(x => !b.includes(x));

extend(Runner, {
  attr(a, v) {
    return this.styleAttr('attr', a, v);
  },

  // Add animatable styles
  css(s, v) {
    return this.styleAttr('css', s, v);
  },

  styleAttr(type, nameOrAttrs, val) {
    if (typeof nameOrAttrs === 'string') {
      return this.styleAttr(type, {
        [nameOrAttrs]: val
      });
    }

    let attrs = nameOrAttrs;
    if (this._tryRetarget(type, attrs)) return this;
    let morpher = new Morphable(this._stepper).to(attrs);
    let keys = Object.keys(attrs);
    this.queue(function () {
      morpher = morpher.from(this.element()[type](keys));
    }, function (pos) {
      this.element()[type](morpher.at(pos).valueOf());
      return morpher.done();
    }, function (newToAttrs) {
      // Check if any new keys were added
      const newKeys = Object.keys(newToAttrs);
      const differences = difference(newKeys, keys); // If their are new keys, initialize them and add them to morpher

      if (differences.length) {
        // Get the values
        const addedFromAttrs = this.element()[type](differences); // Get the already initialized values

        const oldFromAttrs = new ObjectBag(morpher.from()).valueOf(); // Merge old and new

        Object.assign(oldFromAttrs, addedFromAttrs);
        morpher.from(oldFromAttrs);
      } // Get the object from the morpher


      const oldToAttrs = new ObjectBag(morpher.to()).valueOf(); // Merge in new attributes

      Object.assign(oldToAttrs, newToAttrs); // Change morpher target

      morpher.to(oldToAttrs); // Make sure that we save the work we did so we don't need it to do again

      keys = newKeys;
      attrs = newToAttrs;
    });

    this._rememberMorpher(type, morpher);

    return this;
  },

  zoom(level, point) {
    if (this._tryRetarget('zoom', level, point)) return this;
    let morpher = new Morphable(this._stepper).to(new SVGNumber(level));
    this.queue(function () {
      morpher = morpher.from(this.element().zoom());
    }, function (pos) {
      this.element().zoom(morpher.at(pos), point);
      return morpher.done();
    }, function (newLevel, newPoint) {
      point = newPoint;
      morpher.to(newLevel);
    });

    this._rememberMorpher('zoom', morpher);

    return this;
  },

  /**
   ** absolute transformations
   **/
  //
  // M v -----|-----(D M v = F v)------|----->  T v
  //
  // 1. define the final state (T) and decompose it (once)
  //    t = [tx, ty, the, lam, sy, sx]
  // 2. on every frame: pull the current state of all previous transforms
  //    (M - m can change)
  //   and then write this as m = [tx0, ty0, the0, lam0, sy0, sx0]
  // 3. Find the interpolated matrix F(pos) = m + pos * (t - m)
  //   - Note F(0) = M
  //   - Note F(1) = T
  // 4. Now you get the delta matrix as a result: D = F * inv(M)
  transform(transforms, relative, affine) {
    // If we have a declarative function, we should retarget it if possible
    relative = transforms.relative || relative;

    if (this._isDeclarative && !relative && this._tryRetarget('transform', transforms)) {
      return this;
    } // Parse the parameters


    const isMatrix = Matrix.isMatrixLike(transforms);
    affine = transforms.affine != null ? transforms.affine : affine != null ? affine : !isMatrix; // Create a morpher and set its type

    const morpher = new Morphable(this._stepper).type(affine ? TransformBag : Matrix);
    let origin;
    let element;
    let current;
    let currentAngle;
    let startTransform;

    function setup() {
      // make sure element and origin is defined
      element = element || this.element();
      origin = origin || getOrigin(transforms, element);
      startTransform = new Matrix(relative ? undefined : element); // add the runner to the element so it can merge transformations

      element._addRunner(this); // Deactivate all transforms that have run so far if we are absolute


      if (!relative) {
        element._clearTransformRunnersBefore(this);
      }
    }

    function run(pos) {
      // clear all other transforms before this in case something is saved
      // on this runner. We are absolute. We dont need these!
      if (!relative) this.clearTransform();
      const {
        x,
        y
      } = new Point(origin).transform(element._currentTransform(this));
      let target = new Matrix({ ...transforms,
        origin: [x, y]
      });
      let start = this._isDeclarative && current ? current : startTransform;

      if (affine) {
        target = target.decompose(x, y);
        start = start.decompose(x, y); // Get the current and target angle as it was set

        const rTarget = target.rotate;
        const rCurrent = start.rotate; // Figure out the shortest path to rotate directly

        const possibilities = [rTarget - 360, rTarget, rTarget + 360];
        const distances = possibilities.map(a => Math.abs(a - rCurrent));
        const shortest = Math.min(...distances);
        const index = distances.indexOf(shortest);
        target.rotate = possibilities[index];
      }

      if (relative) {
        // we have to be careful here not to overwrite the rotation
        // with the rotate method of Matrix
        if (!isMatrix) {
          target.rotate = transforms.rotate || 0;
        }

        if (this._isDeclarative && currentAngle) {
          start.rotate = currentAngle;
        }
      }

      morpher.from(start);
      morpher.to(target);
      const affineParameters = morpher.at(pos);
      currentAngle = affineParameters.rotate;
      current = new Matrix(affineParameters);
      this.addTransform(current);

      element._addRunner(this);

      return morpher.done();
    }

    function retarget(newTransforms) {
      // only get a new origin if it changed since the last call
      if ((newTransforms.origin || 'center').toString() !== (transforms.origin || 'center').toString()) {
        origin = getOrigin(newTransforms, element);
      } // overwrite the old transformations with the new ones


      transforms = { ...newTransforms,
        origin
      };
    }

    this.queue(setup, run, retarget, true);
    this._isDeclarative && this._rememberMorpher('transform', morpher);
    return this;
  },

  // Animatable x-axis
  x(x, relative) {
    return this._queueNumber('x', x);
  },

  // Animatable y-axis
  y(y) {
    return this._queueNumber('y', y);
  },

  dx(x = 0) {
    return this._queueNumberDelta('x', x);
  },

  dy(y = 0) {
    return this._queueNumberDelta('y', y);
  },

  dmove(x, y) {
    return this.dx(x).dy(y);
  },

  _queueNumberDelta(method, to) {
    to = new SVGNumber(to); // Try to change the target if we have this method already registered

    if (this._tryRetarget(method, to)) return this; // Make a morpher and queue the animation

    const morpher = new Morphable(this._stepper).to(to);
    let from = null;
    this.queue(function () {
      from = this.element()[method]();
      morpher.from(from);
      morpher.to(from + to);
    }, function (pos) {
      this.element()[method](morpher.at(pos));
      return morpher.done();
    }, function (newTo) {
      morpher.to(from + new SVGNumber(newTo));
    }); // Register the morpher so that if it is changed again, we can retarget it

    this._rememberMorpher(method, morpher);

    return this;
  },

  _queueObject(method, to) {
    // Try to change the target if we have this method already registered
    if (this._tryRetarget(method, to)) return this; // Make a morpher and queue the animation

    const morpher = new Morphable(this._stepper).to(to);
    this.queue(function () {
      morpher.from(this.element()[method]());
    }, function (pos) {
      this.element()[method](morpher.at(pos));
      return morpher.done();
    }); // Register the morpher so that if it is changed again, we can retarget it

    this._rememberMorpher(method, morpher);

    return this;
  },

  _queueNumber(method, value) {
    return this._queueObject(method, new SVGNumber(value));
  },

  // Animatable center x-axis
  cx(x) {
    return this._queueNumber('cx', x);
  },

  // Animatable center y-axis
  cy(y) {
    return this._queueNumber('cy', y);
  },

  // Add animatable move
  move(x, y) {
    return this.x(x).y(y);
  },

  // Add animatable center
  center(x, y) {
    return this.cx(x).cy(y);
  },

  // Add animatable size
  size(width, height) {
    // animate bbox based size for all other elements
    let box;

    if (!width || !height) {
      box = this._element.bbox();
    }

    if (!width) {
      width = box.width / box.height * height;
    }

    if (!height) {
      height = box.height / box.width * width;
    }

    return this.width(width).height(height);
  },

  // Add animatable width
  width(width) {
    return this._queueNumber('width', width);
  },

  // Add animatable height
  height(height) {
    return this._queueNumber('height', height);
  },

  // Add animatable plot
  plot(a, b, c, d) {
    // Lines can be plotted with 4 arguments
    if (arguments.length === 4) {
      return this.plot([a, b, c, d]);
    }

    if (this._tryRetarget('plot', a)) return this;
    const morpher = new Morphable(this._stepper).type(this._element.MorphArray).to(a);
    this.queue(function () {
      morpher.from(this._element.array());
    }, function (pos) {
      this._element.plot(morpher.at(pos));

      return morpher.done();
    });

    this._rememberMorpher('plot', morpher);

    return this;
  },

  // Add leading method
  leading(value) {
    return this._queueNumber('leading', value);
  },

  // Add animatable viewbox
  viewbox(x, y, width, height) {
    return this._queueObject('viewbox', new Box(x, y, width, height));
  },

  update(o) {
    if (typeof o !== 'object') {
      return this.update({
        offset: arguments[0],
        color: arguments[1],
        opacity: arguments[2]
      });
    }

    if (o.opacity != null) this.attr('stop-opacity', o.opacity);
    if (o.color != null) this.attr('stop-color', o.color);
    if (o.offset != null) this.attr('offset', o.offset);
    return this;
  }

});
extend(Runner, {
  rx,
  ry,
  from,
  to
});
register(Runner, 'Runner');

class Svg extends Container {
  constructor(node, attrs = node) {
    super(nodeOrNew('svg', node), attrs);
    this.namespace();
  } // Creates and returns defs element


  defs() {
    if (!this.isRoot()) return this.root().defs();
    return adopt(this.node.querySelector('defs')) || this.put(new Defs());
  }

  isRoot() {
    return !this.node.parentNode || !(this.node.parentNode instanceof globals.window.SVGElement) && this.node.parentNode.nodeName !== '#document-fragment';
  } // Add namespaces


  namespace() {
    if (!this.isRoot()) return this.root().namespace();
    return this.attr({
      xmlns: svg,
      version: '1.1'
    }).attr('xmlns:xlink', xlink, xmlns).attr('xmlns:svgjs', svgjs, xmlns);
  }

  removeNamespace() {
    return this.attr({
      xmlns: null,
      version: null
    }).attr('xmlns:xlink', null, xmlns).attr('xmlns:svgjs', null, xmlns);
  } // Check if this is a root svg
  // If not, call root() from this element


  root() {
    if (this.isRoot()) return this;
    return super.root();
  }

}
registerMethods({
  Container: {
    // Create nested svg document
    nested: wrapWithAttrCheck(function () {
      return this.put(new Svg());
    })
  }
});
register(Svg, 'Svg', true);

class Symbol extends Container {
  // Initialize node
  constructor(node, attrs = node) {
    super(nodeOrNew('symbol', node), attrs);
  }

}
registerMethods({
  Container: {
    symbol: wrapWithAttrCheck(function () {
      return this.put(new Symbol());
    })
  }
});
register(Symbol, 'Symbol');

function plain(text) {
  // clear if build mode is disabled
  if (this._build === false) {
    this.clear();
  } // create text node


  this.node.appendChild(globals.document.createTextNode(text));
  return this;
} // Get length of text element

function length() {
  return this.node.getComputedTextLength();
} // Move over x-axis
// Text is moved by its bounding box
// text-anchor does NOT matter

function x$1(x, box = this.bbox()) {
  if (x == null) {
    return box.x;
  }

  return this.attr('x', this.attr('x') + x - box.x);
} // Move over y-axis

function y$1(y, box = this.bbox()) {
  if (y == null) {
    return box.y;
  }

  return this.attr('y', this.attr('y') + y - box.y);
}
function move$1(x, y, box = this.bbox()) {
  return this.x(x, box).y(y, box);
} // Move center over x-axis

function cx(x, box = this.bbox()) {
  if (x == null) {
    return box.cx;
  }

  return this.attr('x', this.attr('x') + x - box.cx);
} // Move center over y-axis

function cy(y, box = this.bbox()) {
  if (y == null) {
    return box.cy;
  }

  return this.attr('y', this.attr('y') + y - box.cy);
}
function center(x, y, box = this.bbox()) {
  return this.cx(x, box).cy(y, box);
}
function ax(x) {
  return this.attr('x', x);
}
function ay(y) {
  return this.attr('y', y);
}
function amove(x, y) {
  return this.ax(x).ay(y);
} // Enable / disable build mode

function build(build) {
  this._build = !!build;
  return this;
}

var textable = {
  __proto__: null,
  plain: plain,
  length: length,
  x: x$1,
  y: y$1,
  move: move$1,
  cx: cx,
  cy: cy,
  center: center,
  ax: ax,
  ay: ay,
  amove: amove,
  build: build
};

class Text extends Shape {
  // Initialize node
  constructor(node, attrs = node) {
    super(nodeOrNew('text', node), attrs);
    this.dom.leading = new SVGNumber(1.3); // store leading value for rebuilding

    this._rebuild = true; // enable automatic updating of dy values

    this._build = false; // disable build mode for adding multiple lines
  } // Set / get leading


  leading(value) {
    // act as getter
    if (value == null) {
      return this.dom.leading;
    } // act as setter


    this.dom.leading = new SVGNumber(value);
    return this.rebuild();
  } // Rebuild appearance type


  rebuild(rebuild) {
    // store new rebuild flag if given
    if (typeof rebuild === 'boolean') {
      this._rebuild = rebuild;
    } // define position of all lines


    if (this._rebuild) {
      const self = this;
      let blankLineOffset = 0;
      const leading = this.dom.leading;
      this.each(function (i) {
        const fontSize = globals.window.getComputedStyle(this.node).getPropertyValue('font-size');
        const dy = leading * new SVGNumber(fontSize);

        if (this.dom.newLined) {
          this.attr('x', self.attr('x'));

          if (this.text() === '\n') {
            blankLineOffset += dy;
          } else {
            this.attr('dy', i ? dy + blankLineOffset : 0);
            blankLineOffset = 0;
          }
        }
      });
      this.fire('rebuild');
    }

    return this;
  } // overwrite method from parent to set data properly


  setData(o) {
    this.dom = o;
    this.dom.leading = new SVGNumber(o.leading || 1.3);
    return this;
  } // Set the text content


  text(text) {
    // act as getter
    if (text === undefined) {
      const children = this.node.childNodes;
      let firstLine = 0;
      text = '';

      for (let i = 0, len = children.length; i < len; ++i) {
        // skip textPaths - they are no lines
        if (children[i].nodeName === 'textPath') {
          if (i === 0) firstLine = 1;
          continue;
        } // add newline if its not the first child and newLined is set to true


        if (i !== firstLine && children[i].nodeType !== 3 && adopt(children[i]).dom.newLined === true) {
          text += '\n';
        } // add content of this node


        text += children[i].textContent;
      }

      return text;
    } // remove existing content


    this.clear().build(true);

    if (typeof text === 'function') {
      // call block
      text.call(this, this);
    } else {
      // store text and make sure text is not blank
      text = (text + '').split('\n'); // build new lines

      for (let j = 0, jl = text.length; j < jl; j++) {
        this.newLine(text[j]);
      }
    } // disable build mode and rebuild lines


    return this.build(false).rebuild();
  }

}
extend(Text, textable);
registerMethods({
  Container: {
    // Create text element
    text: wrapWithAttrCheck(function (text = '') {
      return this.put(new Text()).text(text);
    }),
    // Create plain text element
    plain: wrapWithAttrCheck(function (text = '') {
      return this.put(new Text()).plain(text);
    })
  }
});
register(Text, 'Text');

class Tspan extends Shape {
  // Initialize node
  constructor(node, attrs = node) {
    super(nodeOrNew('tspan', node), attrs);
    this._build = false; // disable build mode for adding multiple lines
  } // Shortcut dx


  dx(dx) {
    return this.attr('dx', dx);
  } // Shortcut dy


  dy(dy) {
    return this.attr('dy', dy);
  } // Create new line


  newLine() {
    // mark new line
    this.dom.newLined = true; // fetch parent

    const text = this.parent(); // early return in case we are not in a text element

    if (!(text instanceof Text)) {
      return this;
    }

    const i = text.index(this);
    const fontSize = globals.window.getComputedStyle(this.node).getPropertyValue('font-size');
    const dy = text.dom.leading * new SVGNumber(fontSize); // apply new position

    return this.dy(i ? dy : 0).attr('x', text.x());
  } // Set text content


  text(text) {
    if (text == null) return this.node.textContent + (this.dom.newLined ? '\n' : '');

    if (typeof text === 'function') {
      this.clear().build(true);
      text.call(this, this);
      this.build(false);
    } else {
      this.plain(text);
    }

    return this;
  }

}
extend(Tspan, textable);
registerMethods({
  Tspan: {
    tspan: wrapWithAttrCheck(function (text = '') {
      const tspan = new Tspan(); // clear if build mode is disabled

      if (!this._build) {
        this.clear();
      } // add new tspan


      return this.put(tspan).text(text);
    })
  },
  Text: {
    newLine: function (text = '') {
      return this.tspan(text).newLine();
    }
  }
});
register(Tspan, 'Tspan');

class Circle extends Shape {
  constructor(node, attrs = node) {
    super(nodeOrNew('circle', node), attrs);
  }

  radius(r) {
    return this.attr('r', r);
  } // Radius x value


  rx(rx) {
    return this.attr('r', rx);
  } // Alias radius x value


  ry(ry) {
    return this.rx(ry);
  }

  size(size) {
    return this.radius(new SVGNumber(size).divide(2));
  }

}
extend(Circle, {
  x: x$3,
  y: y$3,
  cx: cx$1,
  cy: cy$1,
  width: width$2,
  height: height$2
});
registerMethods({
  Container: {
    // Create circle element
    circle: wrapWithAttrCheck(function (size = 0) {
      return this.put(new Circle()).size(size).move(0, 0);
    })
  }
});
register(Circle, 'Circle');

class ClipPath extends Container {
  constructor(node, attrs = node) {
    super(nodeOrNew('clipPath', node), attrs);
  } // Unclip all clipped elements and remove itself


  remove() {
    // unclip all targets
    this.targets().forEach(function (el) {
      el.unclip();
    }); // remove clipPath from parent

    return super.remove();
  }

  targets() {
    return baseFind('svg [clip-path*=' + this.id() + ']');
  }

}
registerMethods({
  Container: {
    // Create clipping element
    clip: wrapWithAttrCheck(function () {
      return this.defs().put(new ClipPath());
    })
  },
  Element: {
    // Distribute clipPath to svg element
    clipper() {
      return this.reference('clip-path');
    },

    clipWith(element) {
      // use given clip or create a new one
      const clipper = element instanceof ClipPath ? element : this.parent().clip().add(element); // apply mask

      return this.attr('clip-path', 'url(#' + clipper.id() + ')');
    },

    // Unclip element
    unclip() {
      return this.attr('clip-path', null);
    }

  }
});
register(ClipPath, 'ClipPath');

class ForeignObject extends Element {
  constructor(node, attrs = node) {
    super(nodeOrNew('foreignObject', node), attrs);
  }

}
registerMethods({
  Container: {
    foreignObject: wrapWithAttrCheck(function (width, height) {
      return this.put(new ForeignObject()).size(width, height);
    })
  }
});
register(ForeignObject, 'ForeignObject');

function dmove(dx, dy) {
  this.children().forEach((child, i) => {
    let bbox; // We have to wrap this for elements that dont have a bbox
    // e.g. title and other descriptive elements

    try {
      // Get the childs bbox
      bbox = child.bbox();
    } catch (e) {
      return;
    } // Get childs matrix


    const m = new Matrix(child); // Translate childs matrix by amount and
    // transform it back into parents space

    const matrix = m.translate(dx, dy).transform(m.inverse()); // Calculate new x and y from old box

    const p = new Point(bbox.x, bbox.y).transform(matrix); // Move element

    child.move(p.x, p.y);
  });
  return this;
}
function dx(dx) {
  return this.dmove(dx, 0);
}
function dy(dy) {
  return this.dmove(0, dy);
}
function height(height, box = this.bbox()) {
  if (height == null) return box.height;
  return this.size(box.width, height, box);
}
function move(x = 0, y = 0, box = this.bbox()) {
  const dx = x - box.x;
  const dy = y - box.y;
  return this.dmove(dx, dy);
}
function size(width, height, box = this.bbox()) {
  const p = proportionalSize(this, width, height, box);
  const scaleX = p.width / box.width;
  const scaleY = p.height / box.height;
  this.children().forEach((child, i) => {
    const o = new Point(box).transform(new Matrix(child).inverse());
    child.scale(scaleX, scaleY, o.x, o.y);
  });
  return this;
}
function width(width, box = this.bbox()) {
  if (width == null) return box.width;
  return this.size(width, box.height, box);
}
function x(x, box = this.bbox()) {
  if (x == null) return box.x;
  return this.move(x, box.y, box);
}
function y(y, box = this.bbox()) {
  if (y == null) return box.y;
  return this.move(box.x, y, box);
}

var containerGeometry = {
  __proto__: null,
  dmove: dmove,
  dx: dx,
  dy: dy,
  height: height,
  move: move,
  size: size,
  width: width,
  x: x,
  y: y
};

class G extends Container {
  constructor(node, attrs = node) {
    super(nodeOrNew('g', node), attrs);
  }

}
extend(G, containerGeometry);
registerMethods({
  Container: {
    // Create a group element
    group: wrapWithAttrCheck(function () {
      return this.put(new G());
    })
  }
});
register(G, 'G');

class A extends Container {
  constructor(node, attrs = node) {
    super(nodeOrNew('a', node), attrs);
  } // Link target attribute


  target(target) {
    return this.attr('target', target);
  } // Link url


  to(url) {
    return this.attr('href', url, xlink);
  }

}
extend(A, containerGeometry);
registerMethods({
  Container: {
    // Create a hyperlink element
    link: wrapWithAttrCheck(function (url) {
      return this.put(new A()).to(url);
    })
  },
  Element: {
    unlink() {
      const link = this.linker();
      if (!link) return this;
      const parent = link.parent();

      if (!parent) {
        return this.remove();
      }

      const index = parent.index(link);
      parent.add(this, index);
      link.remove();
      return this;
    },

    linkTo(url) {
      // reuse old link if possible
      let link = this.linker();

      if (!link) {
        link = new A();
        this.wrap(link);
      }

      if (typeof url === 'function') {
        url.call(link, link);
      } else {
        link.to(url);
      }

      return this;
    },

    linker() {
      const link = this.parent();

      if (link && link.node.nodeName.toLowerCase() === 'a') {
        return link;
      }

      return null;
    }

  }
});
register(A, 'A');

class Mask extends Container {
  // Initialize node
  constructor(node, attrs = node) {
    super(nodeOrNew('mask', node), attrs);
  } // Unmask all masked elements and remove itself


  remove() {
    // unmask all targets
    this.targets().forEach(function (el) {
      el.unmask();
    }); // remove mask from parent

    return super.remove();
  }

  targets() {
    return baseFind('svg [mask*=' + this.id() + ']');
  }

}
registerMethods({
  Container: {
    mask: wrapWithAttrCheck(function () {
      return this.defs().put(new Mask());
    })
  },
  Element: {
    // Distribute mask to svg element
    masker() {
      return this.reference('mask');
    },

    maskWith(element) {
      // use given mask or create a new one
      const masker = element instanceof Mask ? element : this.parent().mask().add(element); // apply mask

      return this.attr('mask', 'url(#' + masker.id() + ')');
    },

    // Unmask element
    unmask() {
      return this.attr('mask', null);
    }

  }
});
register(Mask, 'Mask');

class Stop extends Element {
  constructor(node, attrs = node) {
    super(nodeOrNew('stop', node), attrs);
  } // add color stops


  update(o) {
    if (typeof o === 'number' || o instanceof SVGNumber) {
      o = {
        offset: arguments[0],
        color: arguments[1],
        opacity: arguments[2]
      };
    } // set attributes


    if (o.opacity != null) this.attr('stop-opacity', o.opacity);
    if (o.color != null) this.attr('stop-color', o.color);
    if (o.offset != null) this.attr('offset', new SVGNumber(o.offset));
    return this;
  }

}
registerMethods({
  Gradient: {
    // Add a color stop
    stop: function (offset, color, opacity) {
      return this.put(new Stop()).update(offset, color, opacity);
    }
  }
});
register(Stop, 'Stop');

function cssRule(selector, rule) {
  if (!selector) return '';
  if (!rule) return selector;
  let ret = selector + '{';

  for (const i in rule) {
    ret += unCamelCase(i) + ':' + rule[i] + ';';
  }

  ret += '}';
  return ret;
}

class Style extends Element {
  constructor(node, attrs = node) {
    super(nodeOrNew('style', node), attrs);
  }

  addText(w = '') {
    this.node.textContent += w;
    return this;
  }

  font(name, src, params = {}) {
    return this.rule('@font-face', {
      fontFamily: name,
      src: src,
      ...params
    });
  }

  rule(selector, obj) {
    return this.addText(cssRule(selector, obj));
  }

}
registerMethods('Dom', {
  style(selector, obj) {
    return this.put(new Style()).rule(selector, obj);
  },

  fontface(name, src, params) {
    return this.put(new Style()).font(name, src, params);
  }

});
register(Style, 'Style');

class TextPath extends Text {
  // Initialize node
  constructor(node, attrs = node) {
    super(nodeOrNew('textPath', node), attrs);
  } // return the array of the path track element


  array() {
    const track = this.track();
    return track ? track.array() : null;
  } // Plot path if any


  plot(d) {
    const track = this.track();
    let pathArray = null;

    if (track) {
      pathArray = track.plot(d);
    }

    return d == null ? pathArray : this;
  } // Get the path element


  track() {
    return this.reference('href');
  }

}
registerMethods({
  Container: {
    textPath: wrapWithAttrCheck(function (text, path) {
      // Convert text to instance if needed
      if (!(text instanceof Text)) {
        text = this.text(text);
      }

      return text.path(path);
    })
  },
  Text: {
    // Create path for text to run on
    path: wrapWithAttrCheck(function (track, importNodes = true) {
      const textPath = new TextPath(); // if track is a path, reuse it

      if (!(track instanceof Path)) {
        // create path element
        track = this.defs().path(track);
      } // link textPath to path and add content


      textPath.attr('href', '#' + track, xlink); // Transplant all nodes from text to textPath

      let node;

      if (importNodes) {
        while (node = this.node.firstChild) {
          textPath.node.appendChild(node);
        }
      } // add textPath element as child node and return textPath


      return this.put(textPath);
    }),

    // Get the textPath children
    textPath() {
      return this.findOne('textPath');
    }

  },
  Path: {
    // creates a textPath from this path
    text: wrapWithAttrCheck(function (text) {
      // Convert text to instance if needed
      if (!(text instanceof Text)) {
        text = new Text().addTo(this.parent()).text(text);
      } // Create textPath from text and path and return


      return text.path(this);
    }),

    targets() {
      return baseFind('svg textPath').filter(node => {
        return (node.attr('href') || '').includes(this.id());
      }); // Does not work in IE11. Use when IE support is dropped
      // return baseFind('svg textPath[*|href*=' + this.id() + ']')
    }

  }
});
TextPath.prototype.MorphArray = PathArray;
register(TextPath, 'TextPath');

class Use extends Shape {
  constructor(node, attrs = node) {
    super(nodeOrNew('use', node), attrs);
  } // Use element as a reference


  use(element, file) {
    // Set lined element
    return this.attr('href', (file || '') + '#' + element, xlink);
  }

}
registerMethods({
  Container: {
    // Create a use element
    use: wrapWithAttrCheck(function (element, file) {
      return this.put(new Use()).use(element, file);
    })
  }
});
register(Use, 'Use');

/* Optional Modules */
const SVG = makeInstance;
extend([Svg, Symbol, Image, Pattern, Marker], getMethodsFor('viewbox'));
extend([Line, Polyline, Polygon, Path], getMethodsFor('marker'));
extend(Text, getMethodsFor('Text'));
extend(Path, getMethodsFor('Path'));
extend(Defs, getMethodsFor('Defs'));
extend([Text, Tspan], getMethodsFor('Tspan'));
extend([Rect, Ellipse, Gradient, Runner], getMethodsFor('radius'));
extend(EventTarget, getMethodsFor('EventTarget'));
extend(Dom, getMethodsFor('Dom'));
extend(Element, getMethodsFor('Element'));
extend(Shape, getMethodsFor('Shape'));
extend([Container, Fragment], getMethodsFor('Container'));
extend(Gradient, getMethodsFor('Gradient'));
extend(Runner, getMethodsFor('Runner'));
List.extend(getMethodNames());
registerMorphableType([SVGNumber, Color, Box, Matrix, SVGArray, PointArray, PathArray, Point]);
makeMorphable();


//# sourceMappingURL=svg.esm.js.map


/***/ }),

/***/ "./node_modules/dat.gui/build/dat.gui.module.js":
/*!******************************************************!*\
  !*** ./node_modules/dat.gui/build/dat.gui.module.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GUI: () => (/* binding */ GUI$1),
/* harmony export */   color: () => (/* binding */ color),
/* harmony export */   controllers: () => (/* binding */ controllers),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   dom: () => (/* binding */ dom$1),
/* harmony export */   gui: () => (/* binding */ gui)
/* harmony export */ });
/**
 * dat-gui JavaScript Controller Library
 * https://github.com/dataarts/dat.gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

function ___$insertStyle(css) {
  if (!css) {
    return;
  }
  if (typeof window === 'undefined') {
    return;
  }

  var style = document.createElement('style');

  style.setAttribute('type', 'text/css');
  style.innerHTML = css;
  document.head.appendChild(style);

  return css;
}

function colorToString (color, forceCSSHex) {
  var colorFormat = color.__state.conversionName.toString();
  var r = Math.round(color.r);
  var g = Math.round(color.g);
  var b = Math.round(color.b);
  var a = color.a;
  var h = Math.round(color.h);
  var s = color.s.toFixed(1);
  var v = color.v.toFixed(1);
  if (forceCSSHex || colorFormat === 'THREE_CHAR_HEX' || colorFormat === 'SIX_CHAR_HEX') {
    var str = color.hex.toString(16);
    while (str.length < 6) {
      str = '0' + str;
    }
    return '#' + str;
  } else if (colorFormat === 'CSS_RGB') {
    return 'rgb(' + r + ',' + g + ',' + b + ')';
  } else if (colorFormat === 'CSS_RGBA') {
    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
  } else if (colorFormat === 'HEX') {
    return '0x' + color.hex.toString(16);
  } else if (colorFormat === 'RGB_ARRAY') {
    return '[' + r + ',' + g + ',' + b + ']';
  } else if (colorFormat === 'RGBA_ARRAY') {
    return '[' + r + ',' + g + ',' + b + ',' + a + ']';
  } else if (colorFormat === 'RGB_OBJ') {
    return '{r:' + r + ',g:' + g + ',b:' + b + '}';
  } else if (colorFormat === 'RGBA_OBJ') {
    return '{r:' + r + ',g:' + g + ',b:' + b + ',a:' + a + '}';
  } else if (colorFormat === 'HSV_OBJ') {
    return '{h:' + h + ',s:' + s + ',v:' + v + '}';
  } else if (colorFormat === 'HSVA_OBJ') {
    return '{h:' + h + ',s:' + s + ',v:' + v + ',a:' + a + '}';
  }
  return 'unknown format';
}

var ARR_EACH = Array.prototype.forEach;
var ARR_SLICE = Array.prototype.slice;
var Common = {
  BREAK: {},
  extend: function extend(target) {
    this.each(ARR_SLICE.call(arguments, 1), function (obj) {
      var keys = this.isObject(obj) ? Object.keys(obj) : [];
      keys.forEach(function (key) {
        if (!this.isUndefined(obj[key])) {
          target[key] = obj[key];
        }
      }.bind(this));
    }, this);
    return target;
  },
  defaults: function defaults(target) {
    this.each(ARR_SLICE.call(arguments, 1), function (obj) {
      var keys = this.isObject(obj) ? Object.keys(obj) : [];
      keys.forEach(function (key) {
        if (this.isUndefined(target[key])) {
          target[key] = obj[key];
        }
      }.bind(this));
    }, this);
    return target;
  },
  compose: function compose() {
    var toCall = ARR_SLICE.call(arguments);
    return function () {
      var args = ARR_SLICE.call(arguments);
      for (var i = toCall.length - 1; i >= 0; i--) {
        args = [toCall[i].apply(this, args)];
      }
      return args[0];
    };
  },
  each: function each(obj, itr, scope) {
    if (!obj) {
      return;
    }
    if (ARR_EACH && obj.forEach && obj.forEach === ARR_EACH) {
      obj.forEach(itr, scope);
    } else if (obj.length === obj.length + 0) {
      var key = void 0;
      var l = void 0;
      for (key = 0, l = obj.length; key < l; key++) {
        if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) {
          return;
        }
      }
    } else {
      for (var _key in obj) {
        if (itr.call(scope, obj[_key], _key) === this.BREAK) {
          return;
        }
      }
    }
  },
  defer: function defer(fnc) {
    setTimeout(fnc, 0);
  },
  debounce: function debounce(func, threshold, callImmediately) {
    var timeout = void 0;
    return function () {
      var obj = this;
      var args = arguments;
      function delayed() {
        timeout = null;
        if (!callImmediately) func.apply(obj, args);
      }
      var callNow = callImmediately || !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(delayed, threshold);
      if (callNow) {
        func.apply(obj, args);
      }
    };
  },
  toArray: function toArray(obj) {
    if (obj.toArray) return obj.toArray();
    return ARR_SLICE.call(obj);
  },
  isUndefined: function isUndefined(obj) {
    return obj === undefined;
  },
  isNull: function isNull(obj) {
    return obj === null;
  },
  isNaN: function (_isNaN) {
    function isNaN(_x) {
      return _isNaN.apply(this, arguments);
    }
    isNaN.toString = function () {
      return _isNaN.toString();
    };
    return isNaN;
  }(function (obj) {
    return isNaN(obj);
  }),
  isArray: Array.isArray || function (obj) {
    return obj.constructor === Array;
  },
  isObject: function isObject(obj) {
    return obj === Object(obj);
  },
  isNumber: function isNumber(obj) {
    return obj === obj + 0;
  },
  isString: function isString(obj) {
    return obj === obj + '';
  },
  isBoolean: function isBoolean(obj) {
    return obj === false || obj === true;
  },
  isFunction: function isFunction(obj) {
    return obj instanceof Function;
  }
};

var INTERPRETATIONS = [
{
  litmus: Common.isString,
  conversions: {
    THREE_CHAR_HEX: {
      read: function read(original) {
        var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
        if (test === null) {
          return false;
        }
        return {
          space: 'HEX',
          hex: parseInt('0x' + test[1].toString() + test[1].toString() + test[2].toString() + test[2].toString() + test[3].toString() + test[3].toString(), 0)
        };
      },
      write: colorToString
    },
    SIX_CHAR_HEX: {
      read: function read(original) {
        var test = original.match(/^#([A-F0-9]{6})$/i);
        if (test === null) {
          return false;
        }
        return {
          space: 'HEX',
          hex: parseInt('0x' + test[1].toString(), 0)
        };
      },
      write: colorToString
    },
    CSS_RGB: {
      read: function read(original) {
        var test = original.match(/^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
        if (test === null) {
          return false;
        }
        return {
          space: 'RGB',
          r: parseFloat(test[1]),
          g: parseFloat(test[2]),
          b: parseFloat(test[3])
        };
      },
      write: colorToString
    },
    CSS_RGBA: {
      read: function read(original) {
        var test = original.match(/^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
        if (test === null) {
          return false;
        }
        return {
          space: 'RGB',
          r: parseFloat(test[1]),
          g: parseFloat(test[2]),
          b: parseFloat(test[3]),
          a: parseFloat(test[4])
        };
      },
      write: colorToString
    }
  }
},
{
  litmus: Common.isNumber,
  conversions: {
    HEX: {
      read: function read(original) {
        return {
          space: 'HEX',
          hex: original,
          conversionName: 'HEX'
        };
      },
      write: function write(color) {
        return color.hex;
      }
    }
  }
},
{
  litmus: Common.isArray,
  conversions: {
    RGB_ARRAY: {
      read: function read(original) {
        if (original.length !== 3) {
          return false;
        }
        return {
          space: 'RGB',
          r: original[0],
          g: original[1],
          b: original[2]
        };
      },
      write: function write(color) {
        return [color.r, color.g, color.b];
      }
    },
    RGBA_ARRAY: {
      read: function read(original) {
        if (original.length !== 4) return false;
        return {
          space: 'RGB',
          r: original[0],
          g: original[1],
          b: original[2],
          a: original[3]
        };
      },
      write: function write(color) {
        return [color.r, color.g, color.b, color.a];
      }
    }
  }
},
{
  litmus: Common.isObject,
  conversions: {
    RGBA_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b) && Common.isNumber(original.a)) {
          return {
            space: 'RGB',
            r: original.r,
            g: original.g,
            b: original.b,
            a: original.a
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          r: color.r,
          g: color.g,
          b: color.b,
          a: color.a
        };
      }
    },
    RGB_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b)) {
          return {
            space: 'RGB',
            r: original.r,
            g: original.g,
            b: original.b
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          r: color.r,
          g: color.g,
          b: color.b
        };
      }
    },
    HSVA_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v) && Common.isNumber(original.a)) {
          return {
            space: 'HSV',
            h: original.h,
            s: original.s,
            v: original.v,
            a: original.a
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          h: color.h,
          s: color.s,
          v: color.v,
          a: color.a
        };
      }
    },
    HSV_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v)) {
          return {
            space: 'HSV',
            h: original.h,
            s: original.s,
            v: original.v
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          h: color.h,
          s: color.s,
          v: color.v
        };
      }
    }
  }
}];
var result = void 0;
var toReturn = void 0;
var interpret = function interpret() {
  toReturn = false;
  var original = arguments.length > 1 ? Common.toArray(arguments) : arguments[0];
  Common.each(INTERPRETATIONS, function (family) {
    if (family.litmus(original)) {
      Common.each(family.conversions, function (conversion, conversionName) {
        result = conversion.read(original);
        if (toReturn === false && result !== false) {
          toReturn = result;
          result.conversionName = conversionName;
          result.conversion = conversion;
          return Common.BREAK;
        }
      });
      return Common.BREAK;
    }
  });
  return toReturn;
};

var tmpComponent = void 0;
var ColorMath = {
  hsv_to_rgb: function hsv_to_rgb(h, s, v) {
    var hi = Math.floor(h / 60) % 6;
    var f = h / 60 - Math.floor(h / 60);
    var p = v * (1.0 - s);
    var q = v * (1.0 - f * s);
    var t = v * (1.0 - (1.0 - f) * s);
    var c = [[v, t, p], [q, v, p], [p, v, t], [p, q, v], [t, p, v], [v, p, q]][hi];
    return {
      r: c[0] * 255,
      g: c[1] * 255,
      b: c[2] * 255
    };
  },
  rgb_to_hsv: function rgb_to_hsv(r, g, b) {
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var delta = max - min;
    var h = void 0;
    var s = void 0;
    if (max !== 0) {
      s = delta / max;
    } else {
      return {
        h: NaN,
        s: 0,
        v: 0
      };
    }
    if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else {
      h = 4 + (r - g) / delta;
    }
    h /= 6;
    if (h < 0) {
      h += 1;
    }
    return {
      h: h * 360,
      s: s,
      v: max / 255
    };
  },
  rgb_to_hex: function rgb_to_hex(r, g, b) {
    var hex = this.hex_with_component(0, 2, r);
    hex = this.hex_with_component(hex, 1, g);
    hex = this.hex_with_component(hex, 0, b);
    return hex;
  },
  component_from_hex: function component_from_hex(hex, componentIndex) {
    return hex >> componentIndex * 8 & 0xFF;
  },
  hex_with_component: function hex_with_component(hex, componentIndex, value) {
    return value << (tmpComponent = componentIndex * 8) | hex & ~(0xFF << tmpComponent);
  }
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var Color = function () {
  function Color() {
    classCallCheck(this, Color);
    this.__state = interpret.apply(this, arguments);
    if (this.__state === false) {
      throw new Error('Failed to interpret color arguments');
    }
    this.__state.a = this.__state.a || 1;
  }
  createClass(Color, [{
    key: 'toString',
    value: function toString() {
      return colorToString(this);
    }
  }, {
    key: 'toHexString',
    value: function toHexString() {
      return colorToString(this, true);
    }
  }, {
    key: 'toOriginal',
    value: function toOriginal() {
      return this.__state.conversion.write(this);
    }
  }]);
  return Color;
}();
function defineRGBComponent(target, component, componentHexIndex) {
  Object.defineProperty(target, component, {
    get: function get$$1() {
      if (this.__state.space === 'RGB') {
        return this.__state[component];
      }
      Color.recalculateRGB(this, component, componentHexIndex);
      return this.__state[component];
    },
    set: function set$$1(v) {
      if (this.__state.space !== 'RGB') {
        Color.recalculateRGB(this, component, componentHexIndex);
        this.__state.space = 'RGB';
      }
      this.__state[component] = v;
    }
  });
}
function defineHSVComponent(target, component) {
  Object.defineProperty(target, component, {
    get: function get$$1() {
      if (this.__state.space === 'HSV') {
        return this.__state[component];
      }
      Color.recalculateHSV(this);
      return this.__state[component];
    },
    set: function set$$1(v) {
      if (this.__state.space !== 'HSV') {
        Color.recalculateHSV(this);
        this.__state.space = 'HSV';
      }
      this.__state[component] = v;
    }
  });
}
Color.recalculateRGB = function (color, component, componentHexIndex) {
  if (color.__state.space === 'HEX') {
    color.__state[component] = ColorMath.component_from_hex(color.__state.hex, componentHexIndex);
  } else if (color.__state.space === 'HSV') {
    Common.extend(color.__state, ColorMath.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));
  } else {
    throw new Error('Corrupted color state');
  }
};
Color.recalculateHSV = function (color) {
  var result = ColorMath.rgb_to_hsv(color.r, color.g, color.b);
  Common.extend(color.__state, {
    s: result.s,
    v: result.v
  });
  if (!Common.isNaN(result.h)) {
    color.__state.h = result.h;
  } else if (Common.isUndefined(color.__state.h)) {
    color.__state.h = 0;
  }
};
Color.COMPONENTS = ['r', 'g', 'b', 'h', 's', 'v', 'hex', 'a'];
defineRGBComponent(Color.prototype, 'r', 2);
defineRGBComponent(Color.prototype, 'g', 1);
defineRGBComponent(Color.prototype, 'b', 0);
defineHSVComponent(Color.prototype, 'h');
defineHSVComponent(Color.prototype, 's');
defineHSVComponent(Color.prototype, 'v');
Object.defineProperty(Color.prototype, 'a', {
  get: function get$$1() {
    return this.__state.a;
  },
  set: function set$$1(v) {
    this.__state.a = v;
  }
});
Object.defineProperty(Color.prototype, 'hex', {
  get: function get$$1() {
    if (this.__state.space !== 'HEX') {
      this.__state.hex = ColorMath.rgb_to_hex(this.r, this.g, this.b);
      this.__state.space = 'HEX';
    }
    return this.__state.hex;
  },
  set: function set$$1(v) {
    this.__state.space = 'HEX';
    this.__state.hex = v;
  }
});

var Controller = function () {
  function Controller(object, property) {
    classCallCheck(this, Controller);
    this.initialValue = object[property];
    this.domElement = document.createElement('div');
    this.object = object;
    this.property = property;
    this.__onChange = undefined;
    this.__onFinishChange = undefined;
  }
  createClass(Controller, [{
    key: 'onChange',
    value: function onChange(fnc) {
      this.__onChange = fnc;
      return this;
    }
  }, {
    key: 'onFinishChange',
    value: function onFinishChange(fnc) {
      this.__onFinishChange = fnc;
      return this;
    }
  }, {
    key: 'setValue',
    value: function setValue(newValue) {
      this.object[this.property] = newValue;
      if (this.__onChange) {
        this.__onChange.call(this, newValue);
      }
      this.updateDisplay();
      return this;
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      return this.object[this.property];
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      return this;
    }
  }, {
    key: 'isModified',
    value: function isModified() {
      return this.initialValue !== this.getValue();
    }
  }]);
  return Controller;
}();

var EVENT_MAP = {
  HTMLEvents: ['change'],
  MouseEvents: ['click', 'mousemove', 'mousedown', 'mouseup', 'mouseover'],
  KeyboardEvents: ['keydown']
};
var EVENT_MAP_INV = {};
Common.each(EVENT_MAP, function (v, k) {
  Common.each(v, function (e) {
    EVENT_MAP_INV[e] = k;
  });
});
var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;
function cssValueToPixels(val) {
  if (val === '0' || Common.isUndefined(val)) {
    return 0;
  }
  var match = val.match(CSS_VALUE_PIXELS);
  if (!Common.isNull(match)) {
    return parseFloat(match[1]);
  }
  return 0;
}
var dom = {
  makeSelectable: function makeSelectable(elem, selectable) {
    if (elem === undefined || elem.style === undefined) return;
    elem.onselectstart = selectable ? function () {
      return false;
    } : function () {};
    elem.style.MozUserSelect = selectable ? 'auto' : 'none';
    elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
    elem.unselectable = selectable ? 'on' : 'off';
  },
  makeFullscreen: function makeFullscreen(elem, hor, vert) {
    var vertical = vert;
    var horizontal = hor;
    if (Common.isUndefined(horizontal)) {
      horizontal = true;
    }
    if (Common.isUndefined(vertical)) {
      vertical = true;
    }
    elem.style.position = 'absolute';
    if (horizontal) {
      elem.style.left = 0;
      elem.style.right = 0;
    }
    if (vertical) {
      elem.style.top = 0;
      elem.style.bottom = 0;
    }
  },
  fakeEvent: function fakeEvent(elem, eventType, pars, aux) {
    var params = pars || {};
    var className = EVENT_MAP_INV[eventType];
    if (!className) {
      throw new Error('Event type ' + eventType + ' not supported.');
    }
    var evt = document.createEvent(className);
    switch (className) {
      case 'MouseEvents':
        {
          var clientX = params.x || params.clientX || 0;
          var clientY = params.y || params.clientY || 0;
          evt.initMouseEvent(eventType, params.bubbles || false, params.cancelable || true, window, params.clickCount || 1, 0,
          0,
          clientX,
          clientY,
          false, false, false, false, 0, null);
          break;
        }
      case 'KeyboardEvents':
        {
          var init = evt.initKeyboardEvent || evt.initKeyEvent;
          Common.defaults(params, {
            cancelable: true,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            keyCode: undefined,
            charCode: undefined
          });
          init(eventType, params.bubbles || false, params.cancelable, window, params.ctrlKey, params.altKey, params.shiftKey, params.metaKey, params.keyCode, params.charCode);
          break;
        }
      default:
        {
          evt.initEvent(eventType, params.bubbles || false, params.cancelable || true);
          break;
        }
    }
    Common.defaults(evt, aux);
    elem.dispatchEvent(evt);
  },
  bind: function bind(elem, event, func, newBool) {
    var bool = newBool || false;
    if (elem.addEventListener) {
      elem.addEventListener(event, func, bool);
    } else if (elem.attachEvent) {
      elem.attachEvent('on' + event, func);
    }
    return dom;
  },
  unbind: function unbind(elem, event, func, newBool) {
    var bool = newBool || false;
    if (elem.removeEventListener) {
      elem.removeEventListener(event, func, bool);
    } else if (elem.detachEvent) {
      elem.detachEvent('on' + event, func);
    }
    return dom;
  },
  addClass: function addClass(elem, className) {
    if (elem.className === undefined) {
      elem.className = className;
    } else if (elem.className !== className) {
      var classes = elem.className.split(/ +/);
      if (classes.indexOf(className) === -1) {
        classes.push(className);
        elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
      }
    }
    return dom;
  },
  removeClass: function removeClass(elem, className) {
    if (className) {
      if (elem.className === className) {
        elem.removeAttribute('class');
      } else {
        var classes = elem.className.split(/ +/);
        var index = classes.indexOf(className);
        if (index !== -1) {
          classes.splice(index, 1);
          elem.className = classes.join(' ');
        }
      }
    } else {
      elem.className = undefined;
    }
    return dom;
  },
  hasClass: function hasClass(elem, className) {
    return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
  },
  getWidth: function getWidth(elem) {
    var style = getComputedStyle(elem);
    return cssValueToPixels(style['border-left-width']) + cssValueToPixels(style['border-right-width']) + cssValueToPixels(style['padding-left']) + cssValueToPixels(style['padding-right']) + cssValueToPixels(style.width);
  },
  getHeight: function getHeight(elem) {
    var style = getComputedStyle(elem);
    return cssValueToPixels(style['border-top-width']) + cssValueToPixels(style['border-bottom-width']) + cssValueToPixels(style['padding-top']) + cssValueToPixels(style['padding-bottom']) + cssValueToPixels(style.height);
  },
  getOffset: function getOffset(el) {
    var elem = el;
    var offset = { left: 0, top: 0 };
    if (elem.offsetParent) {
      do {
        offset.left += elem.offsetLeft;
        offset.top += elem.offsetTop;
        elem = elem.offsetParent;
      } while (elem);
    }
    return offset;
  },
  isActive: function isActive(elem) {
    return elem === document.activeElement && (elem.type || elem.href);
  }
};

var BooleanController = function (_Controller) {
  inherits(BooleanController, _Controller);
  function BooleanController(object, property) {
    classCallCheck(this, BooleanController);
    var _this2 = possibleConstructorReturn(this, (BooleanController.__proto__ || Object.getPrototypeOf(BooleanController)).call(this, object, property));
    var _this = _this2;
    _this2.__prev = _this2.getValue();
    _this2.__checkbox = document.createElement('input');
    _this2.__checkbox.setAttribute('type', 'checkbox');
    function onChange() {
      _this.setValue(!_this.__prev);
    }
    dom.bind(_this2.__checkbox, 'change', onChange, false);
    _this2.domElement.appendChild(_this2.__checkbox);
    _this2.updateDisplay();
    return _this2;
  }
  createClass(BooleanController, [{
    key: 'setValue',
    value: function setValue(v) {
      var toReturn = get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'setValue', this).call(this, v);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
      this.__prev = this.getValue();
      return toReturn;
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (this.getValue() === true) {
        this.__checkbox.setAttribute('checked', 'checked');
        this.__checkbox.checked = true;
        this.__prev = true;
      } else {
        this.__checkbox.checked = false;
        this.__prev = false;
      }
      return get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return BooleanController;
}(Controller);

var OptionController = function (_Controller) {
  inherits(OptionController, _Controller);
  function OptionController(object, property, opts) {
    classCallCheck(this, OptionController);
    var _this2 = possibleConstructorReturn(this, (OptionController.__proto__ || Object.getPrototypeOf(OptionController)).call(this, object, property));
    var options = opts;
    var _this = _this2;
    _this2.__select = document.createElement('select');
    if (Common.isArray(options)) {
      var map = {};
      Common.each(options, function (element) {
        map[element] = element;
      });
      options = map;
    }
    Common.each(options, function (value, key) {
      var opt = document.createElement('option');
      opt.innerHTML = key;
      opt.setAttribute('value', value);
      _this.__select.appendChild(opt);
    });
    _this2.updateDisplay();
    dom.bind(_this2.__select, 'change', function () {
      var desiredValue = this.options[this.selectedIndex].value;
      _this.setValue(desiredValue);
    });
    _this2.domElement.appendChild(_this2.__select);
    return _this2;
  }
  createClass(OptionController, [{
    key: 'setValue',
    value: function setValue(v) {
      var toReturn = get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'setValue', this).call(this, v);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
      return toReturn;
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (dom.isActive(this.__select)) return this;
      this.__select.value = this.getValue();
      return get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return OptionController;
}(Controller);

var StringController = function (_Controller) {
  inherits(StringController, _Controller);
  function StringController(object, property) {
    classCallCheck(this, StringController);
    var _this2 = possibleConstructorReturn(this, (StringController.__proto__ || Object.getPrototypeOf(StringController)).call(this, object, property));
    var _this = _this2;
    function onChange() {
      _this.setValue(_this.__input.value);
    }
    function onBlur() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    _this2.__input = document.createElement('input');
    _this2.__input.setAttribute('type', 'text');
    dom.bind(_this2.__input, 'keyup', onChange);
    dom.bind(_this2.__input, 'change', onChange);
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        this.blur();
      }
    });
    _this2.updateDisplay();
    _this2.domElement.appendChild(_this2.__input);
    return _this2;
  }
  createClass(StringController, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (!dom.isActive(this.__input)) {
        this.__input.value = this.getValue();
      }
      return get(StringController.prototype.__proto__ || Object.getPrototypeOf(StringController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return StringController;
}(Controller);

function numDecimals(x) {
  var _x = x.toString();
  if (_x.indexOf('.') > -1) {
    return _x.length - _x.indexOf('.') - 1;
  }
  return 0;
}
var NumberController = function (_Controller) {
  inherits(NumberController, _Controller);
  function NumberController(object, property, params) {
    classCallCheck(this, NumberController);
    var _this = possibleConstructorReturn(this, (NumberController.__proto__ || Object.getPrototypeOf(NumberController)).call(this, object, property));
    var _params = params || {};
    _this.__min = _params.min;
    _this.__max = _params.max;
    _this.__step = _params.step;
    if (Common.isUndefined(_this.__step)) {
      if (_this.initialValue === 0) {
        _this.__impliedStep = 1;
      } else {
        _this.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(_this.initialValue)) / Math.LN10)) / 10;
      }
    } else {
      _this.__impliedStep = _this.__step;
    }
    _this.__precision = numDecimals(_this.__impliedStep);
    return _this;
  }
  createClass(NumberController, [{
    key: 'setValue',
    value: function setValue(v) {
      var _v = v;
      if (this.__min !== undefined && _v < this.__min) {
        _v = this.__min;
      } else if (this.__max !== undefined && _v > this.__max) {
        _v = this.__max;
      }
      if (this.__step !== undefined && _v % this.__step !== 0) {
        _v = Math.round(_v / this.__step) * this.__step;
      }
      return get(NumberController.prototype.__proto__ || Object.getPrototypeOf(NumberController.prototype), 'setValue', this).call(this, _v);
    }
  }, {
    key: 'min',
    value: function min(minValue) {
      this.__min = minValue;
      return this;
    }
  }, {
    key: 'max',
    value: function max(maxValue) {
      this.__max = maxValue;
      return this;
    }
  }, {
    key: 'step',
    value: function step(stepValue) {
      this.__step = stepValue;
      this.__impliedStep = stepValue;
      this.__precision = numDecimals(stepValue);
      return this;
    }
  }]);
  return NumberController;
}(Controller);

function roundToDecimal(value, decimals) {
  var tenTo = Math.pow(10, decimals);
  return Math.round(value * tenTo) / tenTo;
}
var NumberControllerBox = function (_NumberController) {
  inherits(NumberControllerBox, _NumberController);
  function NumberControllerBox(object, property, params) {
    classCallCheck(this, NumberControllerBox);
    var _this2 = possibleConstructorReturn(this, (NumberControllerBox.__proto__ || Object.getPrototypeOf(NumberControllerBox)).call(this, object, property, params));
    _this2.__truncationSuspended = false;
    var _this = _this2;
    var prevY = void 0;
    function onChange() {
      var attempted = parseFloat(_this.__input.value);
      if (!Common.isNaN(attempted)) {
        _this.setValue(attempted);
      }
    }
    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    function onBlur() {
      onFinish();
    }
    function onMouseDrag(e) {
      var diff = prevY - e.clientY;
      _this.setValue(_this.getValue() + diff * _this.__impliedStep);
      prevY = e.clientY;
    }
    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      onFinish();
    }
    function onMouseDown(e) {
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      prevY = e.clientY;
    }
    _this2.__input = document.createElement('input');
    _this2.__input.setAttribute('type', 'text');
    dom.bind(_this2.__input, 'change', onChange);
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__input, 'mousedown', onMouseDown);
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        _this.__truncationSuspended = true;
        this.blur();
        _this.__truncationSuspended = false;
        onFinish();
      }
    });
    _this2.updateDisplay();
    _this2.domElement.appendChild(_this2.__input);
    return _this2;
  }
  createClass(NumberControllerBox, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
      return get(NumberControllerBox.prototype.__proto__ || Object.getPrototypeOf(NumberControllerBox.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return NumberControllerBox;
}(NumberController);

function map(v, i1, i2, o1, o2) {
  return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
}
var NumberControllerSlider = function (_NumberController) {
  inherits(NumberControllerSlider, _NumberController);
  function NumberControllerSlider(object, property, min, max, step) {
    classCallCheck(this, NumberControllerSlider);
    var _this2 = possibleConstructorReturn(this, (NumberControllerSlider.__proto__ || Object.getPrototypeOf(NumberControllerSlider)).call(this, object, property, { min: min, max: max, step: step }));
    var _this = _this2;
    _this2.__background = document.createElement('div');
    _this2.__foreground = document.createElement('div');
    dom.bind(_this2.__background, 'mousedown', onMouseDown);
    dom.bind(_this2.__background, 'touchstart', onTouchStart);
    dom.addClass(_this2.__background, 'slider');
    dom.addClass(_this2.__foreground, 'slider-fg');
    function onMouseDown(e) {
      document.activeElement.blur();
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      onMouseDrag(e);
    }
    function onMouseDrag(e) {
      e.preventDefault();
      var bgRect = _this.__background.getBoundingClientRect();
      _this.setValue(map(e.clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
      return false;
    }
    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    function onTouchStart(e) {
      if (e.touches.length !== 1) {
        return;
      }
      dom.bind(window, 'touchmove', onTouchMove);
      dom.bind(window, 'touchend', onTouchEnd);
      onTouchMove(e);
    }
    function onTouchMove(e) {
      var clientX = e.touches[0].clientX;
      var bgRect = _this.__background.getBoundingClientRect();
      _this.setValue(map(clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
    }
    function onTouchEnd() {
      dom.unbind(window, 'touchmove', onTouchMove);
      dom.unbind(window, 'touchend', onTouchEnd);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    _this2.updateDisplay();
    _this2.__background.appendChild(_this2.__foreground);
    _this2.domElement.appendChild(_this2.__background);
    return _this2;
  }
  createClass(NumberControllerSlider, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      var pct = (this.getValue() - this.__min) / (this.__max - this.__min);
      this.__foreground.style.width = pct * 100 + '%';
      return get(NumberControllerSlider.prototype.__proto__ || Object.getPrototypeOf(NumberControllerSlider.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return NumberControllerSlider;
}(NumberController);

var FunctionController = function (_Controller) {
  inherits(FunctionController, _Controller);
  function FunctionController(object, property, text) {
    classCallCheck(this, FunctionController);
    var _this2 = possibleConstructorReturn(this, (FunctionController.__proto__ || Object.getPrototypeOf(FunctionController)).call(this, object, property));
    var _this = _this2;
    _this2.__button = document.createElement('div');
    _this2.__button.innerHTML = text === undefined ? 'Fire' : text;
    dom.bind(_this2.__button, 'click', function (e) {
      e.preventDefault();
      _this.fire();
      return false;
    });
    dom.addClass(_this2.__button, 'button');
    _this2.domElement.appendChild(_this2.__button);
    return _this2;
  }
  createClass(FunctionController, [{
    key: 'fire',
    value: function fire() {
      if (this.__onChange) {
        this.__onChange.call(this);
      }
      this.getValue().call(this.object);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
    }
  }]);
  return FunctionController;
}(Controller);

var ColorController = function (_Controller) {
  inherits(ColorController, _Controller);
  function ColorController(object, property) {
    classCallCheck(this, ColorController);
    var _this2 = possibleConstructorReturn(this, (ColorController.__proto__ || Object.getPrototypeOf(ColorController)).call(this, object, property));
    _this2.__color = new Color(_this2.getValue());
    _this2.__temp = new Color(0);
    var _this = _this2;
    _this2.domElement = document.createElement('div');
    dom.makeSelectable(_this2.domElement, false);
    _this2.__selector = document.createElement('div');
    _this2.__selector.className = 'selector';
    _this2.__saturation_field = document.createElement('div');
    _this2.__saturation_field.className = 'saturation-field';
    _this2.__field_knob = document.createElement('div');
    _this2.__field_knob.className = 'field-knob';
    _this2.__field_knob_border = '2px solid ';
    _this2.__hue_knob = document.createElement('div');
    _this2.__hue_knob.className = 'hue-knob';
    _this2.__hue_field = document.createElement('div');
    _this2.__hue_field.className = 'hue-field';
    _this2.__input = document.createElement('input');
    _this2.__input.type = 'text';
    _this2.__input_textShadow = '0 1px 1px ';
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        onBlur.call(this);
      }
    });
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__selector, 'mousedown', function () {
      dom.addClass(this, 'drag').bind(window, 'mouseup', function () {
        dom.removeClass(_this.__selector, 'drag');
      });
    });
    dom.bind(_this2.__selector, 'touchstart', function () {
      dom.addClass(this, 'drag').bind(window, 'touchend', function () {
        dom.removeClass(_this.__selector, 'drag');
      });
    });
    var valueField = document.createElement('div');
    Common.extend(_this2.__selector.style, {
      width: '122px',
      height: '102px',
      padding: '3px',
      backgroundColor: '#222',
      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
    });
    Common.extend(_this2.__field_knob.style, {
      position: 'absolute',
      width: '12px',
      height: '12px',
      border: _this2.__field_knob_border + (_this2.__color.v < 0.5 ? '#fff' : '#000'),
      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
      borderRadius: '12px',
      zIndex: 1
    });
    Common.extend(_this2.__hue_knob.style, {
      position: 'absolute',
      width: '15px',
      height: '2px',
      borderRight: '4px solid #fff',
      zIndex: 1
    });
    Common.extend(_this2.__saturation_field.style, {
      width: '100px',
      height: '100px',
      border: '1px solid #555',
      marginRight: '3px',
      display: 'inline-block',
      cursor: 'pointer'
    });
    Common.extend(valueField.style, {
      width: '100%',
      height: '100%',
      background: 'none'
    });
    linearGradient(valueField, 'top', 'rgba(0,0,0,0)', '#000');
    Common.extend(_this2.__hue_field.style, {
      width: '15px',
      height: '100px',
      border: '1px solid #555',
      cursor: 'ns-resize',
      position: 'absolute',
      top: '3px',
      right: '3px'
    });
    hueGradient(_this2.__hue_field);
    Common.extend(_this2.__input.style, {
      outline: 'none',
      textAlign: 'center',
      color: '#fff',
      border: 0,
      fontWeight: 'bold',
      textShadow: _this2.__input_textShadow + 'rgba(0,0,0,0.7)'
    });
    dom.bind(_this2.__saturation_field, 'mousedown', fieldDown);
    dom.bind(_this2.__saturation_field, 'touchstart', fieldDown);
    dom.bind(_this2.__field_knob, 'mousedown', fieldDown);
    dom.bind(_this2.__field_knob, 'touchstart', fieldDown);
    dom.bind(_this2.__hue_field, 'mousedown', fieldDownH);
    dom.bind(_this2.__hue_field, 'touchstart', fieldDownH);
    function fieldDown(e) {
      setSV(e);
      dom.bind(window, 'mousemove', setSV);
      dom.bind(window, 'touchmove', setSV);
      dom.bind(window, 'mouseup', fieldUpSV);
      dom.bind(window, 'touchend', fieldUpSV);
    }
    function fieldDownH(e) {
      setH(e);
      dom.bind(window, 'mousemove', setH);
      dom.bind(window, 'touchmove', setH);
      dom.bind(window, 'mouseup', fieldUpH);
      dom.bind(window, 'touchend', fieldUpH);
    }
    function fieldUpSV() {
      dom.unbind(window, 'mousemove', setSV);
      dom.unbind(window, 'touchmove', setSV);
      dom.unbind(window, 'mouseup', fieldUpSV);
      dom.unbind(window, 'touchend', fieldUpSV);
      onFinish();
    }
    function fieldUpH() {
      dom.unbind(window, 'mousemove', setH);
      dom.unbind(window, 'touchmove', setH);
      dom.unbind(window, 'mouseup', fieldUpH);
      dom.unbind(window, 'touchend', fieldUpH);
      onFinish();
    }
    function onBlur() {
      var i = interpret(this.value);
      if (i !== false) {
        _this.__color.__state = i;
        _this.setValue(_this.__color.toOriginal());
      } else {
        this.value = _this.__color.toString();
      }
    }
    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.__color.toOriginal());
      }
    }
    _this2.__saturation_field.appendChild(valueField);
    _this2.__selector.appendChild(_this2.__field_knob);
    _this2.__selector.appendChild(_this2.__saturation_field);
    _this2.__selector.appendChild(_this2.__hue_field);
    _this2.__hue_field.appendChild(_this2.__hue_knob);
    _this2.domElement.appendChild(_this2.__input);
    _this2.domElement.appendChild(_this2.__selector);
    _this2.updateDisplay();
    function setSV(e) {
      if (e.type.indexOf('touch') === -1) {
        e.preventDefault();
      }
      var fieldRect = _this.__saturation_field.getBoundingClientRect();
      var _ref = e.touches && e.touches[0] || e,
          clientX = _ref.clientX,
          clientY = _ref.clientY;
      var s = (clientX - fieldRect.left) / (fieldRect.right - fieldRect.left);
      var v = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
      if (v > 1) {
        v = 1;
      } else if (v < 0) {
        v = 0;
      }
      if (s > 1) {
        s = 1;
      } else if (s < 0) {
        s = 0;
      }
      _this.__color.v = v;
      _this.__color.s = s;
      _this.setValue(_this.__color.toOriginal());
      return false;
    }
    function setH(e) {
      if (e.type.indexOf('touch') === -1) {
        e.preventDefault();
      }
      var fieldRect = _this.__hue_field.getBoundingClientRect();
      var _ref2 = e.touches && e.touches[0] || e,
          clientY = _ref2.clientY;
      var h = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
      if (h > 1) {
        h = 1;
      } else if (h < 0) {
        h = 0;
      }
      _this.__color.h = h * 360;
      _this.setValue(_this.__color.toOriginal());
      return false;
    }
    return _this2;
  }
  createClass(ColorController, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      var i = interpret(this.getValue());
      if (i !== false) {
        var mismatch = false;
        Common.each(Color.COMPONENTS, function (component) {
          if (!Common.isUndefined(i[component]) && !Common.isUndefined(this.__color.__state[component]) && i[component] !== this.__color.__state[component]) {
            mismatch = true;
            return {};
          }
        }, this);
        if (mismatch) {
          Common.extend(this.__color.__state, i);
        }
      }
      Common.extend(this.__temp.__state, this.__color.__state);
      this.__temp.a = 1;
      var flip = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0;
      var _flip = 255 - flip;
      Common.extend(this.__field_knob.style, {
        marginLeft: 100 * this.__color.s - 7 + 'px',
        marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
        backgroundColor: this.__temp.toHexString(),
        border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip + ')'
      });
      this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px';
      this.__temp.s = 1;
      this.__temp.v = 1;
      linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toHexString());
      this.__input.value = this.__color.toString();
      Common.extend(this.__input.style, {
        backgroundColor: this.__color.toHexString(),
        color: 'rgb(' + flip + ',' + flip + ',' + flip + ')',
        textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip + ',.7)'
      });
    }
  }]);
  return ColorController;
}(Controller);
var vendors = ['-moz-', '-o-', '-webkit-', '-ms-', ''];
function linearGradient(elem, x, a, b) {
  elem.style.background = '';
  Common.each(vendors, function (vendor) {
    elem.style.cssText += 'background: ' + vendor + 'linear-gradient(' + x + ', ' + a + ' 0%, ' + b + ' 100%); ';
  });
}
function hueGradient(elem) {
  elem.style.background = '';
  elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);';
  elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
}

var css = {
  load: function load(url, indoc) {
    var doc = indoc || document;
    var link = doc.createElement('link');
    link.type = 'text/css';
    link.rel = 'stylesheet';
    link.href = url;
    doc.getElementsByTagName('head')[0].appendChild(link);
  },
  inject: function inject(cssContent, indoc) {
    var doc = indoc || document;
    var injected = document.createElement('style');
    injected.type = 'text/css';
    injected.innerHTML = cssContent;
    var head = doc.getElementsByTagName('head')[0];
    try {
      head.appendChild(injected);
    } catch (e) {
    }
  }
};

var saveDialogContents = "<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>";

var ControllerFactory = function ControllerFactory(object, property) {
  var initialValue = object[property];
  if (Common.isArray(arguments[2]) || Common.isObject(arguments[2])) {
    return new OptionController(object, property, arguments[2]);
  }
  if (Common.isNumber(initialValue)) {
    if (Common.isNumber(arguments[2]) && Common.isNumber(arguments[3])) {
      if (Common.isNumber(arguments[4])) {
        return new NumberControllerSlider(object, property, arguments[2], arguments[3], arguments[4]);
      }
      return new NumberControllerSlider(object, property, arguments[2], arguments[3]);
    }
    if (Common.isNumber(arguments[4])) {
      return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3], step: arguments[4] });
    }
    return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });
  }
  if (Common.isString(initialValue)) {
    return new StringController(object, property);
  }
  if (Common.isFunction(initialValue)) {
    return new FunctionController(object, property, '');
  }
  if (Common.isBoolean(initialValue)) {
    return new BooleanController(object, property);
  }
  return null;
};

function requestAnimationFrame(callback) {
  setTimeout(callback, 1000 / 60);
}
var requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || requestAnimationFrame;

var CenteredDiv = function () {
  function CenteredDiv() {
    classCallCheck(this, CenteredDiv);
    this.backgroundElement = document.createElement('div');
    Common.extend(this.backgroundElement.style, {
      backgroundColor: 'rgba(0,0,0,0.8)',
      top: 0,
      left: 0,
      display: 'none',
      zIndex: '1000',
      opacity: 0,
      WebkitTransition: 'opacity 0.2s linear',
      transition: 'opacity 0.2s linear'
    });
    dom.makeFullscreen(this.backgroundElement);
    this.backgroundElement.style.position = 'fixed';
    this.domElement = document.createElement('div');
    Common.extend(this.domElement.style, {
      position: 'fixed',
      display: 'none',
      zIndex: '1001',
      opacity: 0,
      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear',
      transition: 'transform 0.2s ease-out, opacity 0.2s linear'
    });
    document.body.appendChild(this.backgroundElement);
    document.body.appendChild(this.domElement);
    var _this = this;
    dom.bind(this.backgroundElement, 'click', function () {
      _this.hide();
    });
  }
  createClass(CenteredDiv, [{
    key: 'show',
    value: function show() {
      var _this = this;
      this.backgroundElement.style.display = 'block';
      this.domElement.style.display = 'block';
      this.domElement.style.opacity = 0;
      this.domElement.style.webkitTransform = 'scale(1.1)';
      this.layout();
      Common.defer(function () {
        _this.backgroundElement.style.opacity = 1;
        _this.domElement.style.opacity = 1;
        _this.domElement.style.webkitTransform = 'scale(1)';
      });
    }
  }, {
    key: 'hide',
    value: function hide() {
      var _this = this;
      var hide = function hide() {
        _this.domElement.style.display = 'none';
        _this.backgroundElement.style.display = 'none';
        dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
        dom.unbind(_this.domElement, 'transitionend', hide);
        dom.unbind(_this.domElement, 'oTransitionEnd', hide);
      };
      dom.bind(this.domElement, 'webkitTransitionEnd', hide);
      dom.bind(this.domElement, 'transitionend', hide);
      dom.bind(this.domElement, 'oTransitionEnd', hide);
      this.backgroundElement.style.opacity = 0;
      this.domElement.style.opacity = 0;
      this.domElement.style.webkitTransform = 'scale(1.1)';
    }
  }, {
    key: 'layout',
    value: function layout() {
      this.domElement.style.left = window.innerWidth / 2 - dom.getWidth(this.domElement) / 2 + 'px';
      this.domElement.style.top = window.innerHeight / 2 - dom.getHeight(this.domElement) / 2 + 'px';
    }
  }]);
  return CenteredDiv;
}();

var styleSheet = ___$insertStyle(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n");

css.inject(styleSheet);
var CSS_NAMESPACE = 'dg';
var HIDE_KEY_CODE = 72;
var CLOSE_BUTTON_HEIGHT = 20;
var DEFAULT_DEFAULT_PRESET_NAME = 'Default';
var SUPPORTS_LOCAL_STORAGE = function () {
  try {
    return !!window.localStorage;
  } catch (e) {
    return false;
  }
}();
var SAVE_DIALOGUE = void 0;
var autoPlaceVirgin = true;
var autoPlaceContainer = void 0;
var hide = false;
var hideableGuis = [];
var GUI = function GUI(pars) {
  var _this = this;
  var params = pars || {};
  this.domElement = document.createElement('div');
  this.__ul = document.createElement('ul');
  this.domElement.appendChild(this.__ul);
  dom.addClass(this.domElement, CSS_NAMESPACE);
  this.__folders = {};
  this.__controllers = [];
  this.__rememberedObjects = [];
  this.__rememberedObjectIndecesToControllers = [];
  this.__listening = [];
  params = Common.defaults(params, {
    closeOnTop: false,
    autoPlace: true,
    width: GUI.DEFAULT_WIDTH
  });
  params = Common.defaults(params, {
    resizable: params.autoPlace,
    hideable: params.autoPlace
  });
  if (!Common.isUndefined(params.load)) {
    if (params.preset) {
      params.load.preset = params.preset;
    }
  } else {
    params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };
  }
  if (Common.isUndefined(params.parent) && params.hideable) {
    hideableGuis.push(this);
  }
  params.resizable = Common.isUndefined(params.parent) && params.resizable;
  if (params.autoPlace && Common.isUndefined(params.scrollable)) {
    params.scrollable = true;
  }
  var useLocalStorage = SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';
  var saveToLocalStorage = void 0;
  var titleRow = void 0;
  Object.defineProperties(this,
  {
    parent: {
      get: function get$$1() {
        return params.parent;
      }
    },
    scrollable: {
      get: function get$$1() {
        return params.scrollable;
      }
    },
    autoPlace: {
      get: function get$$1() {
        return params.autoPlace;
      }
    },
    closeOnTop: {
      get: function get$$1() {
        return params.closeOnTop;
      }
    },
    preset: {
      get: function get$$1() {
        if (_this.parent) {
          return _this.getRoot().preset;
        }
        return params.load.preset;
      },
      set: function set$$1(v) {
        if (_this.parent) {
          _this.getRoot().preset = v;
        } else {
          params.load.preset = v;
        }
        setPresetSelectIndex(this);
        _this.revert();
      }
    },
    width: {
      get: function get$$1() {
        return params.width;
      },
      set: function set$$1(v) {
        params.width = v;
        setWidth(_this, v);
      }
    },
    name: {
      get: function get$$1() {
        return params.name;
      },
      set: function set$$1(v) {
        params.name = v;
        if (titleRow) {
          titleRow.innerHTML = params.name;
        }
      }
    },
    closed: {
      get: function get$$1() {
        return params.closed;
      },
      set: function set$$1(v) {
        params.closed = v;
        if (params.closed) {
          dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
        } else {
          dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
        }
        this.onResize();
        if (_this.__closeButton) {
          _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
        }
      }
    },
    load: {
      get: function get$$1() {
        return params.load;
      }
    },
    useLocalStorage: {
      get: function get$$1() {
        return useLocalStorage;
      },
      set: function set$$1(bool) {
        if (SUPPORTS_LOCAL_STORAGE) {
          useLocalStorage = bool;
          if (bool) {
            dom.bind(window, 'unload', saveToLocalStorage);
          } else {
            dom.unbind(window, 'unload', saveToLocalStorage);
          }
          localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
        }
      }
    }
  });
  if (Common.isUndefined(params.parent)) {
    this.closed = params.closed || false;
    dom.addClass(this.domElement, GUI.CLASS_MAIN);
    dom.makeSelectable(this.domElement, false);
    if (SUPPORTS_LOCAL_STORAGE) {
      if (useLocalStorage) {
        _this.useLocalStorage = true;
        var savedGui = localStorage.getItem(getLocalStorageHash(this, 'gui'));
        if (savedGui) {
          params.load = JSON.parse(savedGui);
        }
      }
    }
    this.__closeButton = document.createElement('div');
    this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
    dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);
    if (params.closeOnTop) {
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_TOP);
      this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0]);
    } else {
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BOTTOM);
      this.domElement.appendChild(this.__closeButton);
    }
    dom.bind(this.__closeButton, 'click', function () {
      _this.closed = !_this.closed;
    });
  } else {
    if (params.closed === undefined) {
      params.closed = true;
    }
    var titleRowName = document.createTextNode(params.name);
    dom.addClass(titleRowName, 'controller-name');
    titleRow = addRow(_this, titleRowName);
    var onClickTitle = function onClickTitle(e) {
      e.preventDefault();
      _this.closed = !_this.closed;
      return false;
    };
    dom.addClass(this.__ul, GUI.CLASS_CLOSED);
    dom.addClass(titleRow, 'title');
    dom.bind(titleRow, 'click', onClickTitle);
    if (!params.closed) {
      this.closed = false;
    }
  }
  if (params.autoPlace) {
    if (Common.isUndefined(params.parent)) {
      if (autoPlaceVirgin) {
        autoPlaceContainer = document.createElement('div');
        dom.addClass(autoPlaceContainer, CSS_NAMESPACE);
        dom.addClass(autoPlaceContainer, GUI.CLASS_AUTO_PLACE_CONTAINER);
        document.body.appendChild(autoPlaceContainer);
        autoPlaceVirgin = false;
      }
      autoPlaceContainer.appendChild(this.domElement);
      dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);
    }
    if (!this.parent) {
      setWidth(_this, params.width);
    }
  }
  this.__resizeHandler = function () {
    _this.onResizeDebounced();
  };
  dom.bind(window, 'resize', this.__resizeHandler);
  dom.bind(this.__ul, 'webkitTransitionEnd', this.__resizeHandler);
  dom.bind(this.__ul, 'transitionend', this.__resizeHandler);
  dom.bind(this.__ul, 'oTransitionEnd', this.__resizeHandler);
  this.onResize();
  if (params.resizable) {
    addResizeHandle(this);
  }
  saveToLocalStorage = function saveToLocalStorage() {
    if (SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(_this, 'isLocal')) === 'true') {
      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
    }
  };
  this.saveToLocalStorageIfPossible = saveToLocalStorage;
  function resetWidth() {
    var root = _this.getRoot();
    root.width += 1;
    Common.defer(function () {
      root.width -= 1;
    });
  }
  if (!params.parent) {
    resetWidth();
  }
};
GUI.toggleHide = function () {
  hide = !hide;
  Common.each(hideableGuis, function (gui) {
    gui.domElement.style.display = hide ? 'none' : '';
  });
};
GUI.CLASS_AUTO_PLACE = 'a';
GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
GUI.CLASS_MAIN = 'main';
GUI.CLASS_CONTROLLER_ROW = 'cr';
GUI.CLASS_TOO_TALL = 'taller-than-window';
GUI.CLASS_CLOSED = 'closed';
GUI.CLASS_CLOSE_BUTTON = 'close-button';
GUI.CLASS_CLOSE_TOP = 'close-top';
GUI.CLASS_CLOSE_BOTTOM = 'close-bottom';
GUI.CLASS_DRAG = 'drag';
GUI.DEFAULT_WIDTH = 245;
GUI.TEXT_CLOSED = 'Close Controls';
GUI.TEXT_OPEN = 'Open Controls';
GUI._keydownHandler = function (e) {
  if (document.activeElement.type !== 'text' && (e.which === HIDE_KEY_CODE || e.keyCode === HIDE_KEY_CODE)) {
    GUI.toggleHide();
  }
};
dom.bind(window, 'keydown', GUI._keydownHandler, false);
Common.extend(GUI.prototype,
{
  add: function add(object, property) {
    return _add(this, object, property, {
      factoryArgs: Array.prototype.slice.call(arguments, 2)
    });
  },
  addColor: function addColor(object, property) {
    return _add(this, object, property, {
      color: true
    });
  },
  remove: function remove(controller) {
    this.__ul.removeChild(controller.__li);
    this.__controllers.splice(this.__controllers.indexOf(controller), 1);
    var _this = this;
    Common.defer(function () {
      _this.onResize();
    });
  },
  destroy: function destroy() {
    if (this.parent) {
      throw new Error('Only the root GUI should be removed with .destroy(). ' + 'For subfolders, use gui.removeFolder(folder) instead.');
    }
    if (this.autoPlace) {
      autoPlaceContainer.removeChild(this.domElement);
    }
    var _this = this;
    Common.each(this.__folders, function (subfolder) {
      _this.removeFolder(subfolder);
    });
    dom.unbind(window, 'keydown', GUI._keydownHandler, false);
    removeListeners(this);
  },
  addFolder: function addFolder(name) {
    if (this.__folders[name] !== undefined) {
      throw new Error('You already have a folder in this GUI by the' + ' name "' + name + '"');
    }
    var newGuiParams = { name: name, parent: this };
    newGuiParams.autoPlace = this.autoPlace;
    if (this.load &&
    this.load.folders &&
    this.load.folders[name]) {
      newGuiParams.closed = this.load.folders[name].closed;
      newGuiParams.load = this.load.folders[name];
    }
    var gui = new GUI(newGuiParams);
    this.__folders[name] = gui;
    var li = addRow(this, gui.domElement);
    dom.addClass(li, 'folder');
    return gui;
  },
  removeFolder: function removeFolder(folder) {
    this.__ul.removeChild(folder.domElement.parentElement);
    delete this.__folders[folder.name];
    if (this.load &&
    this.load.folders &&
    this.load.folders[folder.name]) {
      delete this.load.folders[folder.name];
    }
    removeListeners(folder);
    var _this = this;
    Common.each(folder.__folders, function (subfolder) {
      folder.removeFolder(subfolder);
    });
    Common.defer(function () {
      _this.onResize();
    });
  },
  open: function open() {
    this.closed = false;
  },
  close: function close() {
    this.closed = true;
  },
  hide: function hide() {
    this.domElement.style.display = 'none';
  },
  show: function show() {
    this.domElement.style.display = '';
  },
  onResize: function onResize() {
    var root = this.getRoot();
    if (root.scrollable) {
      var top = dom.getOffset(root.__ul).top;
      var h = 0;
      Common.each(root.__ul.childNodes, function (node) {
        if (!(root.autoPlace && node === root.__save_row)) {
          h += dom.getHeight(node);
        }
      });
      if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
        dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
        root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
      } else {
        dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
        root.__ul.style.height = 'auto';
      }
    }
    if (root.__resize_handle) {
      Common.defer(function () {
        root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
      });
    }
    if (root.__closeButton) {
      root.__closeButton.style.width = root.width + 'px';
    }
  },
  onResizeDebounced: Common.debounce(function () {
    this.onResize();
  }, 50),
  remember: function remember() {
    if (Common.isUndefined(SAVE_DIALOGUE)) {
      SAVE_DIALOGUE = new CenteredDiv();
      SAVE_DIALOGUE.domElement.innerHTML = saveDialogContents;
    }
    if (this.parent) {
      throw new Error('You can only call remember on a top level GUI.');
    }
    var _this = this;
    Common.each(Array.prototype.slice.call(arguments), function (object) {
      if (_this.__rememberedObjects.length === 0) {
        addSaveMenu(_this);
      }
      if (_this.__rememberedObjects.indexOf(object) === -1) {
        _this.__rememberedObjects.push(object);
      }
    });
    if (this.autoPlace) {
      setWidth(this, this.width);
    }
  },
  getRoot: function getRoot() {
    var gui = this;
    while (gui.parent) {
      gui = gui.parent;
    }
    return gui;
  },
  getSaveObject: function getSaveObject() {
    var toReturn = this.load;
    toReturn.closed = this.closed;
    if (this.__rememberedObjects.length > 0) {
      toReturn.preset = this.preset;
      if (!toReturn.remembered) {
        toReturn.remembered = {};
      }
      toReturn.remembered[this.preset] = getCurrentPreset(this);
    }
    toReturn.folders = {};
    Common.each(this.__folders, function (element, key) {
      toReturn.folders[key] = element.getSaveObject();
    });
    return toReturn;
  },
  save: function save() {
    if (!this.load.remembered) {
      this.load.remembered = {};
    }
    this.load.remembered[this.preset] = getCurrentPreset(this);
    markPresetModified(this, false);
    this.saveToLocalStorageIfPossible();
  },
  saveAs: function saveAs(presetName) {
    if (!this.load.remembered) {
      this.load.remembered = {};
      this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);
    }
    this.load.remembered[presetName] = getCurrentPreset(this);
    this.preset = presetName;
    addPresetOption(this, presetName, true);
    this.saveToLocalStorageIfPossible();
  },
  revert: function revert(gui) {
    Common.each(this.__controllers, function (controller) {
      if (!this.getRoot().load.remembered) {
        controller.setValue(controller.initialValue);
      } else {
        recallSavedValue(gui || this.getRoot(), controller);
      }
      if (controller.__onFinishChange) {
        controller.__onFinishChange.call(controller, controller.getValue());
      }
    }, this);
    Common.each(this.__folders, function (folder) {
      folder.revert(folder);
    });
    if (!gui) {
      markPresetModified(this.getRoot(), false);
    }
  },
  listen: function listen(controller) {
    var init = this.__listening.length === 0;
    this.__listening.push(controller);
    if (init) {
      updateDisplays(this.__listening);
    }
  },
  updateDisplay: function updateDisplay() {
    Common.each(this.__controllers, function (controller) {
      controller.updateDisplay();
    });
    Common.each(this.__folders, function (folder) {
      folder.updateDisplay();
    });
  }
});
function addRow(gui, newDom, liBefore) {
  var li = document.createElement('li');
  if (newDom) {
    li.appendChild(newDom);
  }
  if (liBefore) {
    gui.__ul.insertBefore(li, liBefore);
  } else {
    gui.__ul.appendChild(li);
  }
  gui.onResize();
  return li;
}
function removeListeners(gui) {
  dom.unbind(window, 'resize', gui.__resizeHandler);
  if (gui.saveToLocalStorageIfPossible) {
    dom.unbind(window, 'unload', gui.saveToLocalStorageIfPossible);
  }
}
function markPresetModified(gui, modified) {
  var opt = gui.__preset_select[gui.__preset_select.selectedIndex];
  if (modified) {
    opt.innerHTML = opt.value + '*';
  } else {
    opt.innerHTML = opt.value;
  }
}
function augmentController(gui, li, controller) {
  controller.__li = li;
  controller.__gui = gui;
  Common.extend(controller, {
    options: function options(_options) {
      if (arguments.length > 1) {
        var nextSibling = controller.__li.nextElementSibling;
        controller.remove();
        return _add(gui, controller.object, controller.property, {
          before: nextSibling,
          factoryArgs: [Common.toArray(arguments)]
        });
      }
      if (Common.isArray(_options) || Common.isObject(_options)) {
        var _nextSibling = controller.__li.nextElementSibling;
        controller.remove();
        return _add(gui, controller.object, controller.property, {
          before: _nextSibling,
          factoryArgs: [_options]
        });
      }
    },
    name: function name(_name) {
      controller.__li.firstElementChild.firstElementChild.innerHTML = _name;
      return controller;
    },
    listen: function listen() {
      controller.__gui.listen(controller);
      return controller;
    },
    remove: function remove() {
      controller.__gui.remove(controller);
      return controller;
    }
  });
  if (controller instanceof NumberControllerSlider) {
    var box = new NumberControllerBox(controller.object, controller.property, { min: controller.__min, max: controller.__max, step: controller.__step });
    Common.each(['updateDisplay', 'onChange', 'onFinishChange', 'step', 'min', 'max'], function (method) {
      var pc = controller[method];
      var pb = box[method];
      controller[method] = box[method] = function () {
        var args = Array.prototype.slice.call(arguments);
        pb.apply(box, args);
        return pc.apply(controller, args);
      };
    });
    dom.addClass(li, 'has-slider');
    controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);
  } else if (controller instanceof NumberControllerBox) {
    var r = function r(returned) {
      if (Common.isNumber(controller.__min) && Common.isNumber(controller.__max)) {
        var oldName = controller.__li.firstElementChild.firstElementChild.innerHTML;
        var wasListening = controller.__gui.__listening.indexOf(controller) > -1;
        controller.remove();
        var newController = _add(gui, controller.object, controller.property, {
          before: controller.__li.nextElementSibling,
          factoryArgs: [controller.__min, controller.__max, controller.__step]
        });
        newController.name(oldName);
        if (wasListening) newController.listen();
        return newController;
      }
      return returned;
    };
    controller.min = Common.compose(r, controller.min);
    controller.max = Common.compose(r, controller.max);
  } else if (controller instanceof BooleanController) {
    dom.bind(li, 'click', function () {
      dom.fakeEvent(controller.__checkbox, 'click');
    });
    dom.bind(controller.__checkbox, 'click', function (e) {
      e.stopPropagation();
    });
  } else if (controller instanceof FunctionController) {
    dom.bind(li, 'click', function () {
      dom.fakeEvent(controller.__button, 'click');
    });
    dom.bind(li, 'mouseover', function () {
      dom.addClass(controller.__button, 'hover');
    });
    dom.bind(li, 'mouseout', function () {
      dom.removeClass(controller.__button, 'hover');
    });
  } else if (controller instanceof ColorController) {
    dom.addClass(li, 'color');
    controller.updateDisplay = Common.compose(function (val) {
      li.style.borderLeftColor = controller.__color.toString();
      return val;
    }, controller.updateDisplay);
    controller.updateDisplay();
  }
  controller.setValue = Common.compose(function (val) {
    if (gui.getRoot().__preset_select && controller.isModified()) {
      markPresetModified(gui.getRoot(), true);
    }
    return val;
  }, controller.setValue);
}
function recallSavedValue(gui, controller) {
  var root = gui.getRoot();
  var matchedIndex = root.__rememberedObjects.indexOf(controller.object);
  if (matchedIndex !== -1) {
    var controllerMap = root.__rememberedObjectIndecesToControllers[matchedIndex];
    if (controllerMap === undefined) {
      controllerMap = {};
      root.__rememberedObjectIndecesToControllers[matchedIndex] = controllerMap;
    }
    controllerMap[controller.property] = controller;
    if (root.load && root.load.remembered) {
      var presetMap = root.load.remembered;
      var preset = void 0;
      if (presetMap[gui.preset]) {
        preset = presetMap[gui.preset];
      } else if (presetMap[DEFAULT_DEFAULT_PRESET_NAME]) {
        preset = presetMap[DEFAULT_DEFAULT_PRESET_NAME];
      } else {
        return;
      }
      if (preset[matchedIndex] && preset[matchedIndex][controller.property] !== undefined) {
        var value = preset[matchedIndex][controller.property];
        controller.initialValue = value;
        controller.setValue(value);
      }
    }
  }
}
function _add(gui, object, property, params) {
  if (object[property] === undefined) {
    throw new Error('Object "' + object + '" has no property "' + property + '"');
  }
  var controller = void 0;
  if (params.color) {
    controller = new ColorController(object, property);
  } else {
    var factoryArgs = [object, property].concat(params.factoryArgs);
    controller = ControllerFactory.apply(gui, factoryArgs);
  }
  if (params.before instanceof Controller) {
    params.before = params.before.__li;
  }
  recallSavedValue(gui, controller);
  dom.addClass(controller.domElement, 'c');
  var name = document.createElement('span');
  dom.addClass(name, 'property-name');
  name.innerHTML = controller.property;
  var container = document.createElement('div');
  container.appendChild(name);
  container.appendChild(controller.domElement);
  var li = addRow(gui, container, params.before);
  dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);
  if (controller instanceof ColorController) {
    dom.addClass(li, 'color');
  } else {
    dom.addClass(li, _typeof(controller.getValue()));
  }
  augmentController(gui, li, controller);
  gui.__controllers.push(controller);
  return controller;
}
function getLocalStorageHash(gui, key) {
  return document.location.href + '.' + key;
}
function addPresetOption(gui, name, setSelected) {
  var opt = document.createElement('option');
  opt.innerHTML = name;
  opt.value = name;
  gui.__preset_select.appendChild(opt);
  if (setSelected) {
    gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
  }
}
function showHideExplain(gui, explain) {
  explain.style.display = gui.useLocalStorage ? 'block' : 'none';
}
function addSaveMenu(gui) {
  var div = gui.__save_row = document.createElement('li');
  dom.addClass(gui.domElement, 'has-save');
  gui.__ul.insertBefore(div, gui.__ul.firstChild);
  dom.addClass(div, 'save-row');
  var gears = document.createElement('span');
  gears.innerHTML = '&nbsp;';
  dom.addClass(gears, 'button gears');
  var button = document.createElement('span');
  button.innerHTML = 'Save';
  dom.addClass(button, 'button');
  dom.addClass(button, 'save');
  var button2 = document.createElement('span');
  button2.innerHTML = 'New';
  dom.addClass(button2, 'button');
  dom.addClass(button2, 'save-as');
  var button3 = document.createElement('span');
  button3.innerHTML = 'Revert';
  dom.addClass(button3, 'button');
  dom.addClass(button3, 'revert');
  var select = gui.__preset_select = document.createElement('select');
  if (gui.load && gui.load.remembered) {
    Common.each(gui.load.remembered, function (value, key) {
      addPresetOption(gui, key, key === gui.preset);
    });
  } else {
    addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
  }
  dom.bind(select, 'change', function () {
    for (var index = 0; index < gui.__preset_select.length; index++) {
      gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
    }
    gui.preset = this.value;
  });
  div.appendChild(select);
  div.appendChild(gears);
  div.appendChild(button);
  div.appendChild(button2);
  div.appendChild(button3);
  if (SUPPORTS_LOCAL_STORAGE) {
    var explain = document.getElementById('dg-local-explain');
    var localStorageCheckBox = document.getElementById('dg-local-storage');
    var saveLocally = document.getElementById('dg-save-locally');
    saveLocally.style.display = 'block';
    if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
      localStorageCheckBox.setAttribute('checked', 'checked');
    }
    showHideExplain(gui, explain);
    dom.bind(localStorageCheckBox, 'change', function () {
      gui.useLocalStorage = !gui.useLocalStorage;
      showHideExplain(gui, explain);
    });
  }
  var newConstructorTextArea = document.getElementById('dg-new-constructor');
  dom.bind(newConstructorTextArea, 'keydown', function (e) {
    if (e.metaKey && (e.which === 67 || e.keyCode === 67)) {
      SAVE_DIALOGUE.hide();
    }
  });
  dom.bind(gears, 'click', function () {
    newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
    SAVE_DIALOGUE.show();
    newConstructorTextArea.focus();
    newConstructorTextArea.select();
  });
  dom.bind(button, 'click', function () {
    gui.save();
  });
  dom.bind(button2, 'click', function () {
    var presetName = prompt('Enter a new preset name.');
    if (presetName) {
      gui.saveAs(presetName);
    }
  });
  dom.bind(button3, 'click', function () {
    gui.revert();
  });
}
function addResizeHandle(gui) {
  var pmouseX = void 0;
  gui.__resize_handle = document.createElement('div');
  Common.extend(gui.__resize_handle.style, {
    width: '6px',
    marginLeft: '-3px',
    height: '200px',
    cursor: 'ew-resize',
    position: 'absolute'
  });
  function drag(e) {
    e.preventDefault();
    gui.width += pmouseX - e.clientX;
    gui.onResize();
    pmouseX = e.clientX;
    return false;
  }
  function dragStop() {
    dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
    dom.unbind(window, 'mousemove', drag);
    dom.unbind(window, 'mouseup', dragStop);
  }
  function dragStart(e) {
    e.preventDefault();
    pmouseX = e.clientX;
    dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
    dom.bind(window, 'mousemove', drag);
    dom.bind(window, 'mouseup', dragStop);
    return false;
  }
  dom.bind(gui.__resize_handle, 'mousedown', dragStart);
  dom.bind(gui.__closeButton, 'mousedown', dragStart);
  gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);
}
function setWidth(gui, w) {
  gui.domElement.style.width = w + 'px';
  if (gui.__save_row && gui.autoPlace) {
    gui.__save_row.style.width = w + 'px';
  }
  if (gui.__closeButton) {
    gui.__closeButton.style.width = w + 'px';
  }
}
function getCurrentPreset(gui, useInitialValues) {
  var toReturn = {};
  Common.each(gui.__rememberedObjects, function (val, index) {
    var savedValues = {};
    var controllerMap = gui.__rememberedObjectIndecesToControllers[index];
    Common.each(controllerMap, function (controller, property) {
      savedValues[property] = useInitialValues ? controller.initialValue : controller.getValue();
    });
    toReturn[index] = savedValues;
  });
  return toReturn;
}
function setPresetSelectIndex(gui) {
  for (var index = 0; index < gui.__preset_select.length; index++) {
    if (gui.__preset_select[index].value === gui.preset) {
      gui.__preset_select.selectedIndex = index;
    }
  }
}
function updateDisplays(controllerArray) {
  if (controllerArray.length !== 0) {
    requestAnimationFrame$1.call(window, function () {
      updateDisplays(controllerArray);
    });
  }
  Common.each(controllerArray, function (c) {
    c.updateDisplay();
  });
}

var color = {
  Color: Color,
  math: ColorMath,
  interpret: interpret
};
var controllers = {
  Controller: Controller,
  BooleanController: BooleanController,
  OptionController: OptionController,
  StringController: StringController,
  NumberController: NumberController,
  NumberControllerBox: NumberControllerBox,
  NumberControllerSlider: NumberControllerSlider,
  FunctionController: FunctionController,
  ColorController: ColorController
};
var dom$1 = { dom: dom };
var gui = { GUI: GUI };
var GUI$1 = GUI;
var index = {
  color: color,
  controllers: controllers,
  dom: dom$1,
  gui: gui,
  GUI: GUI$1
};


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (index);
//# sourceMappingURL=dat.gui.module.js.map


/***/ }),

/***/ "./node_modules/file-saver/dist/FileSaver.min.js":
/*!*******************************************************!*\
  !*** ./node_modules/file-saver/dist/FileSaver.min.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(a,b){if(true)!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (b),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}})(this,function(){"use strict";function b(a,b){return"undefined"==typeof b?b={autoBom:!1}:"object"!=typeof b&&(console.warn("Deprecated: Expected third argument to be a object"),b={autoBom:!b}),b.autoBom&&/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type)?new Blob(["\uFEFF",a],{type:a.type}):a}function c(a,b,c){var d=new XMLHttpRequest;d.open("GET",a),d.responseType="blob",d.onload=function(){g(d.response,b,c)},d.onerror=function(){console.error("could not download file")},d.send()}function d(a){var b=new XMLHttpRequest;b.open("HEAD",a,!1);try{b.send()}catch(a){}return 200<=b.status&&299>=b.status}function e(a){try{a.dispatchEvent(new MouseEvent("click"))}catch(c){var b=document.createEvent("MouseEvents");b.initMouseEvent("click",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b)}}var f="object"==typeof window&&window.window===window?window:"object"==typeof self&&self.self===self?self:"object"==typeof __webpack_require__.g&&__webpack_require__.g.global===__webpack_require__.g?__webpack_require__.g:void 0,a=f.navigator&&/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),g=f.saveAs||("object"!=typeof window||window!==f?function(){}:"download"in HTMLAnchorElement.prototype&&!a?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement("a");g=g||b.name||"download",j.download=g,j.rel="noopener","string"==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target="_blank")):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href)},4E4),setTimeout(function(){e(j)},0))}:"msSaveOrOpenBlob"in navigator?function(f,g,h){if(g=g||f.name||"download","string"!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else{var i=document.createElement("a");i.href=f,i.target="_blank",setTimeout(function(){e(i)})}}:function(b,d,e,g){if(g=g||open("","_blank"),g&&(g.document.title=g.document.body.innerText="downloading..."),"string"==typeof b)return c(b,d,e);var h="application/octet-stream"===b.type,i=/constructor/i.test(f.HTMLElement)||f.safari,j=/CriOS\/[\d]+/.test(navigator.userAgent);if((j||h&&i||a)&&"undefined"!=typeof FileReader){var k=new FileReader;k.onloadend=function(){var a=k.result;a=j?a:a.replace(/^data:[^;]*;/,"data:attachment/file;"),g?g.location.href=a:location=a,g=null},k.readAsDataURL(b)}else{var l=f.URL||f.webkitURL,m=l.createObjectURL(b);g?g.location=m:location.href=m,g=null,setTimeout(function(){l.revokeObjectURL(m)},4E4)}});f.saveAs=g.saveAs=g, true&&(module.exports=g)});

//# sourceMappingURL=FileSaver.min.js.map

/***/ }),

/***/ "./node_modules/interactjs/dist/interact.min.js":
/*!******************************************************!*\
  !*** ./node_modules/interactjs/dist/interact.min.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
/* interact.js 1.10.26 | https://raw.github.com/taye/interact.js/main/LICENSE */

!function(t,e){ true?module.exports=e():0}(this,(function(){"use strict";function t(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)}return n}function e(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?t(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):t(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function n(t){return n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},n(t)}function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,d(r.key),r)}}function o(t,e,n){return e&&i(t.prototype,e),n&&i(t,n),Object.defineProperty(t,"prototype",{writable:!1}),t}function a(t,e,n){return(e=d(e))in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&l(t,e)}function c(t){return c=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},c(t)}function l(t,e){return l=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},l(t,e)}function u(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function p(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,r=c(t);if(e){var i=c(this).constructor;n=Reflect.construct(r,arguments,i)}else n=r.apply(this,arguments);return function(t,e){if(e&&("object"==typeof e||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return u(t)}(this,n)}}function f(){return f="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,n){var r=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=c(t)););return t}(t,e);if(r){var i=Object.getOwnPropertyDescriptor(r,e);return i.get?i.get.call(arguments.length<3?t:n):i.value}},f.apply(this,arguments)}function d(t){var e=function(t,e){if("object"!=typeof t||null===t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var r=n.call(t,e||"default");if("object"!=typeof r)return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(t,"string");return"symbol"==typeof e?e:e+""}var h=function(t){return!(!t||!t.Window)&&t instanceof t.Window},v=void 0,g=void 0;function m(t){v=t;var e=t.document.createTextNode("");e.ownerDocument!==t.document&&"function"==typeof t.wrap&&t.wrap(e)===e&&(t=t.wrap(t)),g=t}function y(t){return h(t)?t:(t.ownerDocument||t).defaultView||g.window}"undefined"!=typeof window&&window&&m(window);var b=function(t){return!!t&&"object"===n(t)},x=function(t){return"function"==typeof t},w={window:function(t){return t===g||h(t)},docFrag:function(t){return b(t)&&11===t.nodeType},object:b,func:x,number:function(t){return"number"==typeof t},bool:function(t){return"boolean"==typeof t},string:function(t){return"string"==typeof t},element:function(t){if(!t||"object"!==n(t))return!1;var e=y(t)||g;return/object|function/.test("undefined"==typeof Element?"undefined":n(Element))?t instanceof Element||t instanceof e.Element:1===t.nodeType&&"string"==typeof t.nodeName},plainObject:function(t){return b(t)&&!!t.constructor&&/function Object\b/.test(t.constructor.toString())},array:function(t){return b(t)&&void 0!==t.length&&x(t.splice)}};function E(t){var e=t.interaction;if("drag"===e.prepared.name){var n=e.prepared.axis;"x"===n?(e.coords.cur.page.y=e.coords.start.page.y,e.coords.cur.client.y=e.coords.start.client.y,e.coords.velocity.client.y=0,e.coords.velocity.page.y=0):"y"===n&&(e.coords.cur.page.x=e.coords.start.page.x,e.coords.cur.client.x=e.coords.start.client.x,e.coords.velocity.client.x=0,e.coords.velocity.page.x=0)}}function T(t){var e=t.iEvent,n=t.interaction;if("drag"===n.prepared.name){var r=n.prepared.axis;if("x"===r||"y"===r){var i="x"===r?"y":"x";e.page[i]=n.coords.start.page[i],e.client[i]=n.coords.start.client[i],e.delta[i]=0}}}var S={id:"actions/drag",install:function(t){var e=t.actions,n=t.Interactable,r=t.defaults;n.prototype.draggable=S.draggable,e.map.drag=S,e.methodDict.drag="draggable",r.actions.drag=S.defaults},listeners:{"interactions:before-action-move":E,"interactions:action-resume":E,"interactions:action-move":T,"auto-start:check":function(t){var e=t.interaction,n=t.interactable,r=t.buttons,i=n.options.drag;if(i&&i.enabled&&(!e.pointerIsDown||!/mouse|pointer/.test(e.pointerType)||0!=(r&n.options.drag.mouseButtons)))return t.action={name:"drag",axis:"start"===i.lockAxis?i.startAxis:i.lockAxis},!1}},draggable:function(t){return w.object(t)?(this.options.drag.enabled=!1!==t.enabled,this.setPerAction("drag",t),this.setOnEvents("drag",t),/^(xy|x|y|start)$/.test(t.lockAxis)&&(this.options.drag.lockAxis=t.lockAxis),/^(xy|x|y)$/.test(t.startAxis)&&(this.options.drag.startAxis=t.startAxis),this):w.bool(t)?(this.options.drag.enabled=t,this):this.options.drag},beforeMove:E,move:T,defaults:{startAxis:"xy",lockAxis:"xy"},getCursor:function(){return"move"},filterEventType:function(t){return 0===t.search("drag")}},_=S,P={init:function(t){var e=t;P.document=e.document,P.DocumentFragment=e.DocumentFragment||O,P.SVGElement=e.SVGElement||O,P.SVGSVGElement=e.SVGSVGElement||O,P.SVGElementInstance=e.SVGElementInstance||O,P.Element=e.Element||O,P.HTMLElement=e.HTMLElement||P.Element,P.Event=e.Event,P.Touch=e.Touch||O,P.PointerEvent=e.PointerEvent||e.MSPointerEvent},document:null,DocumentFragment:null,SVGElement:null,SVGSVGElement:null,SVGElementInstance:null,Element:null,HTMLElement:null,Event:null,Touch:null,PointerEvent:null};function O(){}var k=P;var D={init:function(t){var e=k.Element,n=t.navigator||{};D.supportsTouch="ontouchstart"in t||w.func(t.DocumentTouch)&&k.document instanceof t.DocumentTouch,D.supportsPointerEvent=!1!==n.pointerEnabled&&!!k.PointerEvent,D.isIOS=/iP(hone|od|ad)/.test(n.platform),D.isIOS7=/iP(hone|od|ad)/.test(n.platform)&&/OS 7[^\d]/.test(n.appVersion),D.isIe9=/MSIE 9/.test(n.userAgent),D.isOperaMobile="Opera"===n.appName&&D.supportsTouch&&/Presto/.test(n.userAgent),D.prefixedMatchesSelector="matches"in e.prototype?"matches":"webkitMatchesSelector"in e.prototype?"webkitMatchesSelector":"mozMatchesSelector"in e.prototype?"mozMatchesSelector":"oMatchesSelector"in e.prototype?"oMatchesSelector":"msMatchesSelector",D.pEventTypes=D.supportsPointerEvent?k.PointerEvent===t.MSPointerEvent?{up:"MSPointerUp",down:"MSPointerDown",over:"mouseover",out:"mouseout",move:"MSPointerMove",cancel:"MSPointerCancel"}:{up:"pointerup",down:"pointerdown",over:"pointerover",out:"pointerout",move:"pointermove",cancel:"pointercancel"}:null,D.wheelEvent=k.document&&"onmousewheel"in k.document?"mousewheel":"wheel"},supportsTouch:null,supportsPointerEvent:null,isIOS7:null,isIOS:null,isIe9:null,isOperaMobile:null,prefixedMatchesSelector:null,pEventTypes:null,wheelEvent:null};var I=D;function M(t,e){if(t.contains)return t.contains(e);for(;e;){if(e===t)return!0;e=e.parentNode}return!1}function z(t,e){for(;w.element(t);){if(R(t,e))return t;t=A(t)}return null}function A(t){var e=t.parentNode;if(w.docFrag(e)){for(;(e=e.host)&&w.docFrag(e););return e}return e}function R(t,e){return g!==v&&(e=e.replace(/\/deep\//g," ")),t[I.prefixedMatchesSelector](e)}var C=function(t){return t.parentNode||t.host};function j(t,e){for(var n,r=[],i=t;(n=C(i))&&i!==e&&n!==i.ownerDocument;)r.unshift(i),i=n;return r}function F(t,e,n){for(;w.element(t);){if(R(t,e))return!0;if((t=A(t))===n)return R(t,e)}return!1}function X(t){return t.correspondingUseElement||t}function Y(t){var e=t instanceof k.SVGElement?t.getBoundingClientRect():t.getClientRects()[0];return e&&{left:e.left,right:e.right,top:e.top,bottom:e.bottom,width:e.width||e.right-e.left,height:e.height||e.bottom-e.top}}function L(t){var e,n=Y(t);if(!I.isIOS7&&n){var r={x:(e=(e=y(t))||g).scrollX||e.document.documentElement.scrollLeft,y:e.scrollY||e.document.documentElement.scrollTop};n.left+=r.x,n.right+=r.x,n.top+=r.y,n.bottom+=r.y}return n}function q(t){for(var e=[];t;)e.push(t),t=A(t);return e}function B(t){return!!w.string(t)&&(k.document.querySelector(t),!0)}function V(t,e){for(var n in e)t[n]=e[n];return t}function W(t,e,n){return"parent"===t?A(n):"self"===t?e.getRect(n):z(n,t)}function G(t,e,n,r){var i=t;return w.string(i)?i=W(i,e,n):w.func(i)&&(i=i.apply(void 0,r)),w.element(i)&&(i=L(i)),i}function N(t){return t&&{x:"x"in t?t.x:t.left,y:"y"in t?t.y:t.top}}function U(t){return!t||"x"in t&&"y"in t||((t=V({},t)).x=t.left||0,t.y=t.top||0,t.width=t.width||(t.right||0)-t.x,t.height=t.height||(t.bottom||0)-t.y),t}function H(t,e,n){t.left&&(e.left+=n.x),t.right&&(e.right+=n.x),t.top&&(e.top+=n.y),t.bottom&&(e.bottom+=n.y),e.width=e.right-e.left,e.height=e.bottom-e.top}function K(t,e,n){var r=n&&t.options[n];return N(G(r&&r.origin||t.options.origin,t,e,[t&&e]))||{x:0,y:0}}function $(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:function(t){return!0},r=arguments.length>3?arguments[3]:void 0;if(r=r||{},w.string(t)&&-1!==t.search(" ")&&(t=J(t)),w.array(t))return t.forEach((function(t){return $(t,e,n,r)})),r;if(w.object(t)&&(e=t,t=""),w.func(e)&&n(t))r[t]=r[t]||[],r[t].push(e);else if(w.array(e))for(var i=0,o=e;i<o.length;i++){var a=o[i];$(t,a,n,r)}else if(w.object(e))for(var s in e){$(J(s).map((function(e){return"".concat(t).concat(e)})),e[s],n,r)}return r}function J(t){return t.trim().split(/ +/)}var Q=function(t,e){return Math.sqrt(t*t+e*e)},Z=["webkit","moz"];function tt(t,e){t.__set||(t.__set={});var n=function(n){if(Z.some((function(t){return 0===n.indexOf(t)})))return 1;"function"!=typeof t[n]&&"__set"!==n&&Object.defineProperty(t,n,{get:function(){return n in t.__set?t.__set[n]:t.__set[n]=e[n]},set:function(e){t.__set[n]=e},configurable:!0})};for(var r in e)n(r);return t}function et(t,e){t.page=t.page||{},t.page.x=e.page.x,t.page.y=e.page.y,t.client=t.client||{},t.client.x=e.client.x,t.client.y=e.client.y,t.timeStamp=e.timeStamp}function nt(t){t.page.x=0,t.page.y=0,t.client.x=0,t.client.y=0}function rt(t){return t instanceof k.Event||t instanceof k.Touch}function it(t,e,n){return t=t||"page",(n=n||{}).x=e[t+"X"],n.y=e[t+"Y"],n}function ot(t,e){return e=e||{x:0,y:0},I.isOperaMobile&&rt(t)?(it("screen",t,e),e.x+=window.scrollX,e.y+=window.scrollY):it("page",t,e),e}function at(t){return w.number(t.pointerId)?t.pointerId:t.identifier}function st(t,e,n){var r=e.length>1?lt(e):e[0];ot(r,t.page),function(t,e){e=e||{},I.isOperaMobile&&rt(t)?it("screen",t,e):it("client",t,e)}(r,t.client),t.timeStamp=n}function ct(t){var e=[];return w.array(t)?(e[0]=t[0],e[1]=t[1]):"touchend"===t.type?1===t.touches.length?(e[0]=t.touches[0],e[1]=t.changedTouches[0]):0===t.touches.length&&(e[0]=t.changedTouches[0],e[1]=t.changedTouches[1]):(e[0]=t.touches[0],e[1]=t.touches[1]),e}function lt(t){for(var e={pageX:0,pageY:0,clientX:0,clientY:0,screenX:0,screenY:0},n=0;n<t.length;n++){var r=t[n];for(var i in e)e[i]+=r[i]}for(var o in e)e[o]/=t.length;return e}function ut(t){if(!t.length)return null;var e=ct(t),n=Math.min(e[0].pageX,e[1].pageX),r=Math.min(e[0].pageY,e[1].pageY),i=Math.max(e[0].pageX,e[1].pageX),o=Math.max(e[0].pageY,e[1].pageY);return{x:n,y:r,left:n,top:r,right:i,bottom:o,width:i-n,height:o-r}}function pt(t,e){var n=e+"X",r=e+"Y",i=ct(t),o=i[0][n]-i[1][n],a=i[0][r]-i[1][r];return Q(o,a)}function ft(t,e){var n=e+"X",r=e+"Y",i=ct(t),o=i[1][n]-i[0][n],a=i[1][r]-i[0][r];return 180*Math.atan2(a,o)/Math.PI}function dt(t){return w.string(t.pointerType)?t.pointerType:w.number(t.pointerType)?[void 0,void 0,"touch","pen","mouse"][t.pointerType]:/touch/.test(t.type||"")||t instanceof k.Touch?"touch":"mouse"}function ht(t){var e=w.func(t.composedPath)?t.composedPath():t.path;return[X(e?e[0]:t.target),X(t.currentTarget)]}var vt=function(){function t(e){r(this,t),this.immediatePropagationStopped=!1,this.propagationStopped=!1,this._interaction=e}return o(t,[{key:"preventDefault",value:function(){}},{key:"stopPropagation",value:function(){this.propagationStopped=!0}},{key:"stopImmediatePropagation",value:function(){this.immediatePropagationStopped=this.propagationStopped=!0}}]),t}();Object.defineProperty(vt.prototype,"interaction",{get:function(){return this._interaction._proxy},set:function(){}});var gt=function(t,e){for(var n=0;n<e.length;n++){var r=e[n];t.push(r)}return t},mt=function(t){return gt([],t)},yt=function(t,e){for(var n=0;n<t.length;n++)if(e(t[n],n,t))return n;return-1},bt=function(t,e){return t[yt(t,e)]},xt=function(t){s(n,t);var e=p(n);function n(t,i,o){var a;r(this,n),(a=e.call(this,i._interaction)).dropzone=void 0,a.dragEvent=void 0,a.relatedTarget=void 0,a.draggable=void 0,a.propagationStopped=!1,a.immediatePropagationStopped=!1;var s="dragleave"===o?t.prev:t.cur,c=s.element,l=s.dropzone;return a.type=o,a.target=c,a.currentTarget=c,a.dropzone=l,a.dragEvent=i,a.relatedTarget=i.target,a.draggable=i.interactable,a.timeStamp=i.timeStamp,a}return o(n,[{key:"reject",value:function(){var t=this,e=this._interaction.dropState;if("dropactivate"===this.type||this.dropzone&&e.cur.dropzone===this.dropzone&&e.cur.element===this.target)if(e.prev.dropzone=this.dropzone,e.prev.element=this.target,e.rejected=!0,e.events.enter=null,this.stopImmediatePropagation(),"dropactivate"===this.type){var r=e.activeDrops,i=yt(r,(function(e){var n=e.dropzone,r=e.element;return n===t.dropzone&&r===t.target}));e.activeDrops.splice(i,1);var o=new n(e,this.dragEvent,"dropdeactivate");o.dropzone=this.dropzone,o.target=this.target,this.dropzone.fire(o)}else this.dropzone.fire(new n(e,this.dragEvent,"dragleave"))}},{key:"preventDefault",value:function(){}},{key:"stopPropagation",value:function(){this.propagationStopped=!0}},{key:"stopImmediatePropagation",value:function(){this.immediatePropagationStopped=this.propagationStopped=!0}}]),n}(vt);function wt(t,e){for(var n=0,r=t.slice();n<r.length;n++){var i=r[n],o=i.dropzone,a=i.element;e.dropzone=o,e.target=a,o.fire(e),e.propagationStopped=e.immediatePropagationStopped=!1}}function Et(t,e){for(var n=function(t,e){for(var n=[],r=0,i=t.interactables.list;r<i.length;r++){var o=i[r];if(o.options.drop.enabled){var a=o.options.drop.accept;if(!(w.element(a)&&a!==e||w.string(a)&&!R(e,a)||w.func(a)&&!a({dropzone:o,draggableElement:e})))for(var s=0,c=o.getAllElements();s<c.length;s++){var l=c[s];l!==e&&n.push({dropzone:o,element:l,rect:o.getRect(l)})}}}return n}(t,e),r=0;r<n.length;r++){var i=n[r];i.rect=i.dropzone.getRect(i.element)}return n}function Tt(t,e,n){for(var r=t.dropState,i=t.interactable,o=t.element,a=[],s=0,c=r.activeDrops;s<c.length;s++){var l=c[s],u=l.dropzone,p=l.element,f=l.rect,d=u.dropCheck(e,n,i,o,p,f);a.push(d?p:null)}var h=function(t){for(var e,n,r,i=[],o=0;o<t.length;o++){var a=t[o],s=t[e];if(a&&o!==e)if(s){var c=C(a),l=C(s);if(c!==a.ownerDocument)if(l!==a.ownerDocument)if(c!==l){i=i.length?i:j(s);var u=void 0;if(s instanceof k.HTMLElement&&a instanceof k.SVGElement&&!(a instanceof k.SVGSVGElement)){if(a===l)continue;u=a.ownerSVGElement}else u=a;for(var p=j(u,s.ownerDocument),f=0;p[f]&&p[f]===i[f];)f++;var d=[p[f-1],p[f],i[f]];if(d[0])for(var h=d[0].lastChild;h;){if(h===d[1]){e=o,i=p;break}if(h===d[2])break;h=h.previousSibling}}else r=s,void 0,void 0,(parseInt(y(n=a).getComputedStyle(n).zIndex,10)||0)>=(parseInt(y(r).getComputedStyle(r).zIndex,10)||0)&&(e=o);else e=o}else e=o}return e}(a);return r.activeDrops[h]||null}function St(t,e,n){var r=t.dropState,i={enter:null,leave:null,activate:null,deactivate:null,move:null,drop:null};return"dragstart"===n.type&&(i.activate=new xt(r,n,"dropactivate"),i.activate.target=null,i.activate.dropzone=null),"dragend"===n.type&&(i.deactivate=new xt(r,n,"dropdeactivate"),i.deactivate.target=null,i.deactivate.dropzone=null),r.rejected||(r.cur.element!==r.prev.element&&(r.prev.dropzone&&(i.leave=new xt(r,n,"dragleave"),n.dragLeave=i.leave.target=r.prev.element,n.prevDropzone=i.leave.dropzone=r.prev.dropzone),r.cur.dropzone&&(i.enter=new xt(r,n,"dragenter"),n.dragEnter=r.cur.element,n.dropzone=r.cur.dropzone)),"dragend"===n.type&&r.cur.dropzone&&(i.drop=new xt(r,n,"drop"),n.dropzone=r.cur.dropzone,n.relatedTarget=r.cur.element),"dragmove"===n.type&&r.cur.dropzone&&(i.move=new xt(r,n,"dropmove"),n.dropzone=r.cur.dropzone)),i}function _t(t,e){var n=t.dropState,r=n.activeDrops,i=n.cur,o=n.prev;e.leave&&o.dropzone.fire(e.leave),e.enter&&i.dropzone.fire(e.enter),e.move&&i.dropzone.fire(e.move),e.drop&&i.dropzone.fire(e.drop),e.deactivate&&wt(r,e.deactivate),n.prev.dropzone=i.dropzone,n.prev.element=i.element}function Pt(t,e){var n=t.interaction,r=t.iEvent,i=t.event;if("dragmove"===r.type||"dragend"===r.type){var o=n.dropState;e.dynamicDrop&&(o.activeDrops=Et(e,n.element));var a=r,s=Tt(n,a,i);o.rejected=o.rejected&&!!s&&s.dropzone===o.cur.dropzone&&s.element===o.cur.element,o.cur.dropzone=s&&s.dropzone,o.cur.element=s&&s.element,o.events=St(n,0,a)}}var Ot={id:"actions/drop",install:function(t){var e=t.actions,n=t.interactStatic,r=t.Interactable,i=t.defaults;t.usePlugin(_),r.prototype.dropzone=function(t){return function(t,e){if(w.object(e)){if(t.options.drop.enabled=!1!==e.enabled,e.listeners){var n=$(e.listeners),r=Object.keys(n).reduce((function(t,e){return t[/^(enter|leave)/.test(e)?"drag".concat(e):/^(activate|deactivate|move)/.test(e)?"drop".concat(e):e]=n[e],t}),{}),i=t.options.drop.listeners;i&&t.off(i),t.on(r),t.options.drop.listeners=r}return w.func(e.ondrop)&&t.on("drop",e.ondrop),w.func(e.ondropactivate)&&t.on("dropactivate",e.ondropactivate),w.func(e.ondropdeactivate)&&t.on("dropdeactivate",e.ondropdeactivate),w.func(e.ondragenter)&&t.on("dragenter",e.ondragenter),w.func(e.ondragleave)&&t.on("dragleave",e.ondragleave),w.func(e.ondropmove)&&t.on("dropmove",e.ondropmove),/^(pointer|center)$/.test(e.overlap)?t.options.drop.overlap=e.overlap:w.number(e.overlap)&&(t.options.drop.overlap=Math.max(Math.min(1,e.overlap),0)),"accept"in e&&(t.options.drop.accept=e.accept),"checker"in e&&(t.options.drop.checker=e.checker),t}if(w.bool(e))return t.options.drop.enabled=e,t;return t.options.drop}(this,t)},r.prototype.dropCheck=function(t,e,n,r,i,o){return function(t,e,n,r,i,o,a){var s=!1;if(!(a=a||t.getRect(o)))return!!t.options.drop.checker&&t.options.drop.checker(e,n,s,t,o,r,i);var c=t.options.drop.overlap;if("pointer"===c){var l=K(r,i,"drag"),u=ot(e);u.x+=l.x,u.y+=l.y;var p=u.x>a.left&&u.x<a.right,f=u.y>a.top&&u.y<a.bottom;s=p&&f}var d=r.getRect(i);if(d&&"center"===c){var h=d.left+d.width/2,v=d.top+d.height/2;s=h>=a.left&&h<=a.right&&v>=a.top&&v<=a.bottom}if(d&&w.number(c)){s=Math.max(0,Math.min(a.right,d.right)-Math.max(a.left,d.left))*Math.max(0,Math.min(a.bottom,d.bottom)-Math.max(a.top,d.top))/(d.width*d.height)>=c}t.options.drop.checker&&(s=t.options.drop.checker(e,n,s,t,o,r,i));return s}(this,t,e,n,r,i,o)},n.dynamicDrop=function(e){return w.bool(e)?(t.dynamicDrop=e,n):t.dynamicDrop},V(e.phaselessTypes,{dragenter:!0,dragleave:!0,dropactivate:!0,dropdeactivate:!0,dropmove:!0,drop:!0}),e.methodDict.drop="dropzone",t.dynamicDrop=!1,i.actions.drop=Ot.defaults},listeners:{"interactions:before-action-start":function(t){var e=t.interaction;"drag"===e.prepared.name&&(e.dropState={cur:{dropzone:null,element:null},prev:{dropzone:null,element:null},rejected:null,events:null,activeDrops:[]})},"interactions:after-action-start":function(t,e){var n=t.interaction,r=(t.event,t.iEvent);if("drag"===n.prepared.name){var i=n.dropState;i.activeDrops=[],i.events={},i.activeDrops=Et(e,n.element),i.events=St(n,0,r),i.events.activate&&(wt(i.activeDrops,i.events.activate),e.fire("actions/drop:start",{interaction:n,dragEvent:r}))}},"interactions:action-move":Pt,"interactions:after-action-move":function(t,e){var n=t.interaction,r=t.iEvent;if("drag"===n.prepared.name){var i=n.dropState;_t(n,i.events),e.fire("actions/drop:move",{interaction:n,dragEvent:r}),i.events={}}},"interactions:action-end":function(t,e){if("drag"===t.interaction.prepared.name){var n=t.interaction,r=t.iEvent;Pt(t,e),_t(n,n.dropState.events),e.fire("actions/drop:end",{interaction:n,dragEvent:r})}},"interactions:stop":function(t){var e=t.interaction;if("drag"===e.prepared.name){var n=e.dropState;n&&(n.activeDrops=null,n.events=null,n.cur.dropzone=null,n.cur.element=null,n.prev.dropzone=null,n.prev.element=null,n.rejected=!1)}}},getActiveDrops:Et,getDrop:Tt,getDropEvents:St,fireDropEvents:_t,filterEventType:function(t){return 0===t.search("drag")||0===t.search("drop")},defaults:{enabled:!1,accept:null,overlap:"pointer"}},kt=Ot;function Dt(t){var e=t.interaction,n=t.iEvent,r=t.phase;if("gesture"===e.prepared.name){var i=e.pointers.map((function(t){return t.pointer})),o="start"===r,a="end"===r,s=e.interactable.options.deltaSource;if(n.touches=[i[0],i[1]],o)n.distance=pt(i,s),n.box=ut(i),n.scale=1,n.ds=0,n.angle=ft(i,s),n.da=0,e.gesture.startDistance=n.distance,e.gesture.startAngle=n.angle;else if(a||e.pointers.length<2){var c=e.prevEvent;n.distance=c.distance,n.box=c.box,n.scale=c.scale,n.ds=0,n.angle=c.angle,n.da=0}else n.distance=pt(i,s),n.box=ut(i),n.scale=n.distance/e.gesture.startDistance,n.angle=ft(i,s),n.ds=n.scale-e.gesture.scale,n.da=n.angle-e.gesture.angle;e.gesture.distance=n.distance,e.gesture.angle=n.angle,w.number(n.scale)&&n.scale!==1/0&&!isNaN(n.scale)&&(e.gesture.scale=n.scale)}}var It={id:"actions/gesture",before:["actions/drag","actions/resize"],install:function(t){var e=t.actions,n=t.Interactable,r=t.defaults;n.prototype.gesturable=function(t){return w.object(t)?(this.options.gesture.enabled=!1!==t.enabled,this.setPerAction("gesture",t),this.setOnEvents("gesture",t),this):w.bool(t)?(this.options.gesture.enabled=t,this):this.options.gesture},e.map.gesture=It,e.methodDict.gesture="gesturable",r.actions.gesture=It.defaults},listeners:{"interactions:action-start":Dt,"interactions:action-move":Dt,"interactions:action-end":Dt,"interactions:new":function(t){t.interaction.gesture={angle:0,distance:0,scale:1,startAngle:0,startDistance:0}},"auto-start:check":function(t){if(!(t.interaction.pointers.length<2)){var e=t.interactable.options.gesture;if(e&&e.enabled)return t.action={name:"gesture"},!1}}},defaults:{},getCursor:function(){return""},filterEventType:function(t){return 0===t.search("gesture")}},Mt=It;function zt(t,e,n,r,i,o,a){if(!e)return!1;if(!0===e){var s=w.number(o.width)?o.width:o.right-o.left,c=w.number(o.height)?o.height:o.bottom-o.top;if(a=Math.min(a,Math.abs(("left"===t||"right"===t?s:c)/2)),s<0&&("left"===t?t="right":"right"===t&&(t="left")),c<0&&("top"===t?t="bottom":"bottom"===t&&(t="top")),"left"===t){var l=s>=0?o.left:o.right;return n.x<l+a}if("top"===t){var u=c>=0?o.top:o.bottom;return n.y<u+a}if("right"===t)return n.x>(s>=0?o.right:o.left)-a;if("bottom"===t)return n.y>(c>=0?o.bottom:o.top)-a}return!!w.element(r)&&(w.element(e)?e===r:F(r,e,i))}function At(t){var e=t.iEvent,n=t.interaction;if("resize"===n.prepared.name&&n.resizeAxes){var r=e;n.interactable.options.resize.square?("y"===n.resizeAxes?r.delta.x=r.delta.y:r.delta.y=r.delta.x,r.axes="xy"):(r.axes=n.resizeAxes,"x"===n.resizeAxes?r.delta.y=0:"y"===n.resizeAxes&&(r.delta.x=0))}}var Rt,Ct,jt={id:"actions/resize",before:["actions/drag"],install:function(t){var e=t.actions,n=t.browser,r=t.Interactable,i=t.defaults;jt.cursors=function(t){return t.isIe9?{x:"e-resize",y:"s-resize",xy:"se-resize",top:"n-resize",left:"w-resize",bottom:"s-resize",right:"e-resize",topleft:"se-resize",bottomright:"se-resize",topright:"ne-resize",bottomleft:"ne-resize"}:{x:"ew-resize",y:"ns-resize",xy:"nwse-resize",top:"ns-resize",left:"ew-resize",bottom:"ns-resize",right:"ew-resize",topleft:"nwse-resize",bottomright:"nwse-resize",topright:"nesw-resize",bottomleft:"nesw-resize"}}(n),jt.defaultMargin=n.supportsTouch||n.supportsPointerEvent?20:10,r.prototype.resizable=function(e){return function(t,e,n){if(w.object(e))return t.options.resize.enabled=!1!==e.enabled,t.setPerAction("resize",e),t.setOnEvents("resize",e),w.string(e.axis)&&/^x$|^y$|^xy$/.test(e.axis)?t.options.resize.axis=e.axis:null===e.axis&&(t.options.resize.axis=n.defaults.actions.resize.axis),w.bool(e.preserveAspectRatio)?t.options.resize.preserveAspectRatio=e.preserveAspectRatio:w.bool(e.square)&&(t.options.resize.square=e.square),t;if(w.bool(e))return t.options.resize.enabled=e,t;return t.options.resize}(this,e,t)},e.map.resize=jt,e.methodDict.resize="resizable",i.actions.resize=jt.defaults},listeners:{"interactions:new":function(t){t.interaction.resizeAxes="xy"},"interactions:action-start":function(t){!function(t){var e=t.iEvent,n=t.interaction;if("resize"===n.prepared.name&&n.prepared.edges){var r=e,i=n.rect;n._rects={start:V({},i),corrected:V({},i),previous:V({},i),delta:{left:0,right:0,width:0,top:0,bottom:0,height:0}},r.edges=n.prepared.edges,r.rect=n._rects.corrected,r.deltaRect=n._rects.delta}}(t),At(t)},"interactions:action-move":function(t){!function(t){var e=t.iEvent,n=t.interaction;if("resize"===n.prepared.name&&n.prepared.edges){var r=e,i=n.interactable.options.resize.invert,o="reposition"===i||"negate"===i,a=n.rect,s=n._rects,c=s.start,l=s.corrected,u=s.delta,p=s.previous;if(V(p,l),o){if(V(l,a),"reposition"===i){if(l.top>l.bottom){var f=l.top;l.top=l.bottom,l.bottom=f}if(l.left>l.right){var d=l.left;l.left=l.right,l.right=d}}}else l.top=Math.min(a.top,c.bottom),l.bottom=Math.max(a.bottom,c.top),l.left=Math.min(a.left,c.right),l.right=Math.max(a.right,c.left);for(var h in l.width=l.right-l.left,l.height=l.bottom-l.top,l)u[h]=l[h]-p[h];r.edges=n.prepared.edges,r.rect=l,r.deltaRect=u}}(t),At(t)},"interactions:action-end":function(t){var e=t.iEvent,n=t.interaction;if("resize"===n.prepared.name&&n.prepared.edges){var r=e;r.edges=n.prepared.edges,r.rect=n._rects.corrected,r.deltaRect=n._rects.delta}},"auto-start:check":function(t){var e=t.interaction,n=t.interactable,r=t.element,i=t.rect,o=t.buttons;if(i){var a=V({},e.coords.cur.page),s=n.options.resize;if(s&&s.enabled&&(!e.pointerIsDown||!/mouse|pointer/.test(e.pointerType)||0!=(o&s.mouseButtons))){if(w.object(s.edges)){var c={left:!1,right:!1,top:!1,bottom:!1};for(var l in c)c[l]=zt(l,s.edges[l],a,e._latestPointer.eventTarget,r,i,s.margin||jt.defaultMargin);c.left=c.left&&!c.right,c.top=c.top&&!c.bottom,(c.left||c.right||c.top||c.bottom)&&(t.action={name:"resize",edges:c})}else{var u="y"!==s.axis&&a.x>i.right-jt.defaultMargin,p="x"!==s.axis&&a.y>i.bottom-jt.defaultMargin;(u||p)&&(t.action={name:"resize",axes:(u?"x":"")+(p?"y":"")})}return!t.action&&void 0}}}},defaults:{square:!1,preserveAspectRatio:!1,axis:"xy",margin:NaN,edges:null,invert:"none"},cursors:null,getCursor:function(t){var e=t.edges,n=t.axis,r=t.name,i=jt.cursors,o=null;if(n)o=i[r+n];else if(e){for(var a="",s=0,c=["top","bottom","left","right"];s<c.length;s++){var l=c[s];e[l]&&(a+=l)}o=i[a]}return o},filterEventType:function(t){return 0===t.search("resize")},defaultMargin:null},Ft=jt,Xt={id:"actions",install:function(t){t.usePlugin(Mt),t.usePlugin(Ft),t.usePlugin(_),t.usePlugin(kt)}},Yt=0;var Lt={request:function(t){return Rt(t)},cancel:function(t){return Ct(t)},init:function(t){if(Rt=t.requestAnimationFrame,Ct=t.cancelAnimationFrame,!Rt)for(var e=["ms","moz","webkit","o"],n=0;n<e.length;n++){var r=e[n];Rt=t["".concat(r,"RequestAnimationFrame")],Ct=t["".concat(r,"CancelAnimationFrame")]||t["".concat(r,"CancelRequestAnimationFrame")]}Rt=Rt&&Rt.bind(t),Ct=Ct&&Ct.bind(t),Rt||(Rt=function(e){var n=Date.now(),r=Math.max(0,16-(n-Yt)),i=t.setTimeout((function(){e(n+r)}),r);return Yt=n+r,i},Ct=function(t){return clearTimeout(t)})}};var qt={defaults:{enabled:!1,margin:60,container:null,speed:300},now:Date.now,interaction:null,i:0,x:0,y:0,isScrolling:!1,prevTime:0,margin:0,speed:0,start:function(t){qt.isScrolling=!0,Lt.cancel(qt.i),t.autoScroll=qt,qt.interaction=t,qt.prevTime=qt.now(),qt.i=Lt.request(qt.scroll)},stop:function(){qt.isScrolling=!1,qt.interaction&&(qt.interaction.autoScroll=null),Lt.cancel(qt.i)},scroll:function(){var t=qt.interaction,e=t.interactable,n=t.element,r=t.prepared.name,i=e.options[r].autoScroll,o=Bt(i.container,e,n),a=qt.now(),s=(a-qt.prevTime)/1e3,c=i.speed*s;if(c>=1){var l={x:qt.x*c,y:qt.y*c};if(l.x||l.y){var u=Vt(o);w.window(o)?o.scrollBy(l.x,l.y):o&&(o.scrollLeft+=l.x,o.scrollTop+=l.y);var p=Vt(o),f={x:p.x-u.x,y:p.y-u.y};(f.x||f.y)&&e.fire({type:"autoscroll",target:n,interactable:e,delta:f,interaction:t,container:o})}qt.prevTime=a}qt.isScrolling&&(Lt.cancel(qt.i),qt.i=Lt.request(qt.scroll))},check:function(t,e){var n;return null==(n=t.options[e].autoScroll)?void 0:n.enabled},onInteractionMove:function(t){var e=t.interaction,n=t.pointer;if(e.interacting()&&qt.check(e.interactable,e.prepared.name))if(e.simulation)qt.x=qt.y=0;else{var r,i,o,a,s=e.interactable,c=e.element,l=e.prepared.name,u=s.options[l].autoScroll,p=Bt(u.container,s,c);if(w.window(p))a=n.clientX<qt.margin,r=n.clientY<qt.margin,i=n.clientX>p.innerWidth-qt.margin,o=n.clientY>p.innerHeight-qt.margin;else{var f=Y(p);a=n.clientX<f.left+qt.margin,r=n.clientY<f.top+qt.margin,i=n.clientX>f.right-qt.margin,o=n.clientY>f.bottom-qt.margin}qt.x=i?1:a?-1:0,qt.y=o?1:r?-1:0,qt.isScrolling||(qt.margin=u.margin,qt.speed=u.speed,qt.start(e))}}};function Bt(t,e,n){return(w.string(t)?W(t,e,n):t)||y(n)}function Vt(t){return w.window(t)&&(t=window.document.body),{x:t.scrollLeft,y:t.scrollTop}}var Wt={id:"auto-scroll",install:function(t){var e=t.defaults,n=t.actions;t.autoScroll=qt,qt.now=function(){return t.now()},n.phaselessTypes.autoscroll=!0,e.perAction.autoScroll=qt.defaults},listeners:{"interactions:new":function(t){t.interaction.autoScroll=null},"interactions:destroy":function(t){t.interaction.autoScroll=null,qt.stop(),qt.interaction&&(qt.interaction=null)},"interactions:stop":qt.stop,"interactions:action-move":function(t){return qt.onInteractionMove(t)}}},Gt=Wt;function Nt(t,e){var n=!1;return function(){return n||(g.console.warn(e),n=!0),t.apply(this,arguments)}}function Ut(t,e){return t.name=e.name,t.axis=e.axis,t.edges=e.edges,t}function Ht(t){return w.bool(t)?(this.options.styleCursor=t,this):null===t?(delete this.options.styleCursor,this):this.options.styleCursor}function Kt(t){return w.func(t)?(this.options.actionChecker=t,this):null===t?(delete this.options.actionChecker,this):this.options.actionChecker}var $t={id:"auto-start/interactableMethods",install:function(t){var e=t.Interactable;e.prototype.getAction=function(e,n,r,i){var o=function(t,e,n,r,i){var o=t.getRect(r),a=e.buttons||{0:1,1:4,3:8,4:16}[e.button],s={action:null,interactable:t,interaction:n,element:r,rect:o,buttons:a};return i.fire("auto-start:check",s),s.action}(this,n,r,i,t);return this.options.actionChecker?this.options.actionChecker(e,n,o,this,i,r):o},e.prototype.ignoreFrom=Nt((function(t){return this._backCompatOption("ignoreFrom",t)}),"Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue})."),e.prototype.allowFrom=Nt((function(t){return this._backCompatOption("allowFrom",t)}),"Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue})."),e.prototype.actionChecker=Kt,e.prototype.styleCursor=Ht}};function Jt(t,e,n,r,i){return e.testIgnoreAllow(e.options[t.name],n,r)&&e.options[t.name].enabled&&ee(e,n,t,i)?t:null}function Qt(t,e,n,r,i,o,a){for(var s=0,c=r.length;s<c;s++){var l=r[s],u=i[s],p=l.getAction(e,n,t,u);if(p){var f=Jt(p,l,u,o,a);if(f)return{action:f,interactable:l,element:u}}}return{action:null,interactable:null,element:null}}function Zt(t,e,n,r,i){var o=[],a=[],s=r;function c(t){o.push(t),a.push(s)}for(;w.element(s);){o=[],a=[],i.interactables.forEachMatch(s,c);var l=Qt(t,e,n,o,a,r,i);if(l.action&&!l.interactable.options[l.action.name].manualStart)return l;s=A(s)}return{action:null,interactable:null,element:null}}function te(t,e,n){var r=e.action,i=e.interactable,o=e.element;r=r||{name:null},t.interactable=i,t.element=o,Ut(t.prepared,r),t.rect=i&&r.name?i.getRect(o):null,ie(t,n),n.fire("autoStart:prepared",{interaction:t})}function ee(t,e,n,r){var i=t.options,o=i[n.name].max,a=i[n.name].maxPerElement,s=r.autoStart.maxInteractions,c=0,l=0,u=0;if(!(o&&a&&s))return!1;for(var p=0,f=r.interactions.list;p<f.length;p++){var d=f[p],h=d.prepared.name;if(d.interacting()){if(++c>=s)return!1;if(d.interactable===t){if((l+=h===n.name?1:0)>=o)return!1;if(d.element===e&&(u++,h===n.name&&u>=a))return!1}}}return s>0}function ne(t,e){return w.number(t)?(e.autoStart.maxInteractions=t,this):e.autoStart.maxInteractions}function re(t,e,n){var r=n.autoStart.cursorElement;r&&r!==t&&(r.style.cursor=""),t.ownerDocument.documentElement.style.cursor=e,t.style.cursor=e,n.autoStart.cursorElement=e?t:null}function ie(t,e){var n=t.interactable,r=t.element,i=t.prepared;if("mouse"===t.pointerType&&n&&n.options.styleCursor){var o="";if(i.name){var a=n.options[i.name].cursorChecker;o=w.func(a)?a(i,n,r,t._interacting):e.actions.map[i.name].getCursor(i)}re(t.element,o||"",e)}else e.autoStart.cursorElement&&re(e.autoStart.cursorElement,"",e)}var oe={id:"auto-start/base",before:["actions"],install:function(t){var e=t.interactStatic,n=t.defaults;t.usePlugin($t),n.base.actionChecker=null,n.base.styleCursor=!0,V(n.perAction,{manualStart:!1,max:1/0,maxPerElement:1,allowFrom:null,ignoreFrom:null,mouseButtons:1}),e.maxInteractions=function(e){return ne(e,t)},t.autoStart={maxInteractions:1/0,withinInteractionLimit:ee,cursorElement:null}},listeners:{"interactions:down":function(t,e){var n=t.interaction,r=t.pointer,i=t.event,o=t.eventTarget;n.interacting()||te(n,Zt(n,r,i,o,e),e)},"interactions:move":function(t,e){!function(t,e){var n=t.interaction,r=t.pointer,i=t.event,o=t.eventTarget;"mouse"!==n.pointerType||n.pointerIsDown||n.interacting()||te(n,Zt(n,r,i,o,e),e)}(t,e),function(t,e){var n=t.interaction;if(n.pointerIsDown&&!n.interacting()&&n.pointerWasMoved&&n.prepared.name){e.fire("autoStart:before-start",t);var r=n.interactable,i=n.prepared.name;i&&r&&(r.options[i].manualStart||!ee(r,n.element,n.prepared,e)?n.stop():(n.start(n.prepared,r,n.element),ie(n,e)))}}(t,e)},"interactions:stop":function(t,e){var n=t.interaction,r=n.interactable;r&&r.options.styleCursor&&re(n.element,"",e)}},maxInteractions:ne,withinInteractionLimit:ee,validateAction:Jt},ae=oe;var se={id:"auto-start/dragAxis",listeners:{"autoStart:before-start":function(t,e){var n=t.interaction,r=t.eventTarget,i=t.dx,o=t.dy;if("drag"===n.prepared.name){var a=Math.abs(i),s=Math.abs(o),c=n.interactable.options.drag,l=c.startAxis,u=a>s?"x":a<s?"y":"xy";if(n.prepared.axis="start"===c.lockAxis?u[0]:c.lockAxis,"xy"!==u&&"xy"!==l&&l!==u){n.prepared.name=null;for(var p=r,f=function(t){if(t!==n.interactable){var i=n.interactable.options.drag;if(!i.manualStart&&t.testIgnoreAllow(i,p,r)){var o=t.getAction(n.downPointer,n.downEvent,n,p);if(o&&"drag"===o.name&&function(t,e){if(!e)return!1;var n=e.options.drag.startAxis;return"xy"===t||"xy"===n||n===t}(u,t)&&ae.validateAction(o,t,p,r,e))return t}}};w.element(p);){var d=e.interactables.forEachMatch(p,f);if(d){n.prepared.name="drag",n.interactable=d,n.element=p;break}p=A(p)}}}}}};function ce(t){var e=t.prepared&&t.prepared.name;if(!e)return null;var n=t.interactable.options;return n[e].hold||n[e].delay}var le={id:"auto-start/hold",install:function(t){var e=t.defaults;t.usePlugin(ae),e.perAction.hold=0,e.perAction.delay=0},listeners:{"interactions:new":function(t){t.interaction.autoStartHoldTimer=null},"autoStart:prepared":function(t){var e=t.interaction,n=ce(e);n>0&&(e.autoStartHoldTimer=setTimeout((function(){e.start(e.prepared,e.interactable,e.element)}),n))},"interactions:move":function(t){var e=t.interaction,n=t.duplicate;e.autoStartHoldTimer&&e.pointerWasMoved&&!n&&(clearTimeout(e.autoStartHoldTimer),e.autoStartHoldTimer=null)},"autoStart:before-start":function(t){var e=t.interaction;ce(e)>0&&(e.prepared.name=null)}},getHoldDuration:ce},ue=le,pe={id:"auto-start",install:function(t){t.usePlugin(ae),t.usePlugin(ue),t.usePlugin(se)}},fe=function(t){return/^(always|never|auto)$/.test(t)?(this.options.preventDefault=t,this):w.bool(t)?(this.options.preventDefault=t?"always":"never",this):this.options.preventDefault};function de(t){var e=t.interaction,n=t.event;e.interactable&&e.interactable.checkAndPreventDefault(n)}var he={id:"core/interactablePreventDefault",install:function(t){var e=t.Interactable;e.prototype.preventDefault=fe,e.prototype.checkAndPreventDefault=function(e){return function(t,e,n){var r=t.options.preventDefault;if("never"!==r)if("always"!==r){if(e.events.supportsPassive&&/^touch(start|move)$/.test(n.type)){var i=y(n.target).document,o=e.getDocOptions(i);if(!o||!o.events||!1!==o.events.passive)return}/^(mouse|pointer|touch)*(down|start)/i.test(n.type)||w.element(n.target)&&R(n.target,"input,select,textarea,[contenteditable=true],[contenteditable=true] *")||n.preventDefault()}else n.preventDefault()}(this,t,e)},t.interactions.docEvents.push({type:"dragstart",listener:function(e){for(var n=0,r=t.interactions.list;n<r.length;n++){var i=r[n];if(i.element&&(i.element===e.target||M(i.element,e.target)))return void i.interactable.checkAndPreventDefault(e)}}})},listeners:["down","move","up","cancel"].reduce((function(t,e){return t["interactions:".concat(e)]=de,t}),{})};function ve(t,e){if(e.phaselessTypes[t])return!0;for(var n in e.map)if(0===t.indexOf(n)&&t.substr(n.length)in e.phases)return!0;return!1}function ge(t){var e={};for(var n in t){var r=t[n];w.plainObject(r)?e[n]=ge(r):w.array(r)?e[n]=mt(r):e[n]=r}return e}var me=function(){function t(e){r(this,t),this.states=[],this.startOffset={left:0,right:0,top:0,bottom:0},this.startDelta=void 0,this.result=void 0,this.endResult=void 0,this.startEdges=void 0,this.edges=void 0,this.interaction=void 0,this.interaction=e,this.result=ye(),this.edges={left:!1,right:!1,top:!1,bottom:!1}}return o(t,[{key:"start",value:function(t,e){var n,r,i=t.phase,o=this.interaction,a=function(t){var e=t.interactable.options[t.prepared.name],n=e.modifiers;if(n&&n.length)return n;return["snap","snapSize","snapEdges","restrict","restrictEdges","restrictSize"].map((function(t){var n=e[t];return n&&n.enabled&&{options:n,methods:n._methods}})).filter((function(t){return!!t}))}(o);this.prepareStates(a),this.startEdges=V({},o.edges),this.edges=V({},this.startEdges),this.startOffset=(n=o.rect,r=e,n?{left:r.x-n.left,top:r.y-n.top,right:n.right-r.x,bottom:n.bottom-r.y}:{left:0,top:0,right:0,bottom:0}),this.startDelta={x:0,y:0};var s=this.fillArg({phase:i,pageCoords:e,preEnd:!1});return this.result=ye(),this.startAll(s),this.result=this.setAll(s)}},{key:"fillArg",value:function(t){var e=this.interaction;return t.interaction=e,t.interactable=e.interactable,t.element=e.element,t.rect||(t.rect=e.rect),t.edges||(t.edges=this.startEdges),t.startOffset=this.startOffset,t}},{key:"startAll",value:function(t){for(var e=0,n=this.states;e<n.length;e++){var r=n[e];r.methods.start&&(t.state=r,r.methods.start(t))}}},{key:"setAll",value:function(t){var e=t.phase,n=t.preEnd,r=t.skipModifiers,i=t.rect,o=t.edges;t.coords=V({},t.pageCoords),t.rect=V({},i),t.edges=V({},o);for(var a=r?this.states.slice(r):this.states,s=ye(t.coords,t.rect),c=0;c<a.length;c++){var l,u=a[c],p=u.options,f=V({},t.coords),d=null;null!=(l=u.methods)&&l.set&&this.shouldDo(p,n,e)&&(t.state=u,d=u.methods.set(t),H(t.edges,t.rect,{x:t.coords.x-f.x,y:t.coords.y-f.y})),s.eventProps.push(d)}V(this.edges,t.edges),s.delta.x=t.coords.x-t.pageCoords.x,s.delta.y=t.coords.y-t.pageCoords.y,s.rectDelta.left=t.rect.left-i.left,s.rectDelta.right=t.rect.right-i.right,s.rectDelta.top=t.rect.top-i.top,s.rectDelta.bottom=t.rect.bottom-i.bottom;var h=this.result.coords,v=this.result.rect;if(h&&v){var g=s.rect.left!==v.left||s.rect.right!==v.right||s.rect.top!==v.top||s.rect.bottom!==v.bottom;s.changed=g||h.x!==s.coords.x||h.y!==s.coords.y}return s}},{key:"applyToInteraction",value:function(t){var e=this.interaction,n=t.phase,r=e.coords.cur,i=e.coords.start,o=this.result,a=this.startDelta,s=o.delta;"start"===n&&V(this.startDelta,o.delta);for(var c=0,l=[[i,a],[r,s]];c<l.length;c++){var u=l[c],p=u[0],f=u[1];p.page.x+=f.x,p.page.y+=f.y,p.client.x+=f.x,p.client.y+=f.y}var d=this.result.rectDelta,h=t.rect||e.rect;h.left+=d.left,h.right+=d.right,h.top+=d.top,h.bottom+=d.bottom,h.width=h.right-h.left,h.height=h.bottom-h.top}},{key:"setAndApply",value:function(t){var e=this.interaction,n=t.phase,r=t.preEnd,i=t.skipModifiers,o=this.setAll(this.fillArg({preEnd:r,phase:n,pageCoords:t.modifiedCoords||e.coords.cur.page}));if(this.result=o,!o.changed&&(!i||i<this.states.length)&&e.interacting())return!1;if(t.modifiedCoords){var a=e.coords.cur.page,s={x:t.modifiedCoords.x-a.x,y:t.modifiedCoords.y-a.y};o.coords.x+=s.x,o.coords.y+=s.y,o.delta.x+=s.x,o.delta.y+=s.y}this.applyToInteraction(t)}},{key:"beforeEnd",value:function(t){var e=t.interaction,n=t.event,r=this.states;if(r&&r.length){for(var i=!1,o=0;o<r.length;o++){var a=r[o];t.state=a;var s=a.options,c=a.methods,l=c.beforeEnd&&c.beforeEnd(t);if(l)return this.endResult=l,!1;i=i||!i&&this.shouldDo(s,!0,t.phase,!0)}i&&e.move({event:n,preEnd:!0})}}},{key:"stop",value:function(t){var e=t.interaction;if(this.states&&this.states.length){var n=V({states:this.states,interactable:e.interactable,element:e.element,rect:null},t);this.fillArg(n);for(var r=0,i=this.states;r<i.length;r++){var o=i[r];n.state=o,o.methods.stop&&o.methods.stop(n)}this.states=null,this.endResult=null}}},{key:"prepareStates",value:function(t){this.states=[];for(var e=0;e<t.length;e++){var n=t[e],r=n.options,i=n.methods,o=n.name;this.states.push({options:r,methods:i,index:e,name:o})}return this.states}},{key:"restoreInteractionCoords",value:function(t){var e=t.interaction,n=e.coords,r=e.rect,i=e.modification;if(i.result){for(var o=i.startDelta,a=i.result,s=a.delta,c=a.rectDelta,l=0,u=[[n.start,o],[n.cur,s]];l<u.length;l++){var p=u[l],f=p[0],d=p[1];f.page.x-=d.x,f.page.y-=d.y,f.client.x-=d.x,f.client.y-=d.y}r.left-=c.left,r.right-=c.right,r.top-=c.top,r.bottom-=c.bottom}}},{key:"shouldDo",value:function(t,e,n,r){return!(!t||!1===t.enabled||r&&!t.endOnly||t.endOnly&&!e||"start"===n&&!t.setStart)}},{key:"copyFrom",value:function(t){this.startOffset=t.startOffset,this.startDelta=t.startDelta,this.startEdges=t.startEdges,this.edges=t.edges,this.states=t.states.map((function(t){return ge(t)})),this.result=ye(V({},t.result.coords),V({},t.result.rect))}},{key:"destroy",value:function(){for(var t in this)this[t]=null}}]),t}();function ye(t,e){return{rect:e,coords:t,delta:{x:0,y:0},rectDelta:{left:0,right:0,top:0,bottom:0},eventProps:[],changed:!0}}function be(t,e){var n=t.defaults,r={start:t.start,set:t.set,beforeEnd:t.beforeEnd,stop:t.stop},i=function(t){var i=t||{};for(var o in i.enabled=!1!==i.enabled,n)o in i||(i[o]=n[o]);var a={options:i,methods:r,name:e,enable:function(){return i.enabled=!0,a},disable:function(){return i.enabled=!1,a}};return a};return e&&"string"==typeof e&&(i._defaults=n,i._methods=r),i}function xe(t){var e=t.iEvent,n=t.interaction.modification.result;n&&(e.modifiers=n.eventProps)}var we={id:"modifiers/base",before:["actions"],install:function(t){t.defaults.perAction.modifiers=[]},listeners:{"interactions:new":function(t){var e=t.interaction;e.modification=new me(e)},"interactions:before-action-start":function(t){var e=t.interaction,n=t.interaction.modification;n.start(t,e.coords.start.page),e.edges=n.edges,n.applyToInteraction(t)},"interactions:before-action-move":function(t){var e=t.interaction,n=e.modification,r=n.setAndApply(t);return e.edges=n.edges,r},"interactions:before-action-end":function(t){var e=t.interaction,n=e.modification,r=n.beforeEnd(t);return e.edges=n.startEdges,r},"interactions:action-start":xe,"interactions:action-move":xe,"interactions:action-end":xe,"interactions:after-action-start":function(t){return t.interaction.modification.restoreInteractionCoords(t)},"interactions:after-action-move":function(t){return t.interaction.modification.restoreInteractionCoords(t)},"interactions:stop":function(t){return t.interaction.modification.stop(t)}}},Ee=we,Te={base:{preventDefault:"auto",deltaSource:"page"},perAction:{enabled:!1,origin:{x:0,y:0}},actions:{}},Se=function(t){s(n,t);var e=p(n);function n(t,i,o,a,s,c,l){var p;r(this,n),(p=e.call(this,t)).relatedTarget=null,p.screenX=void 0,p.screenY=void 0,p.button=void 0,p.buttons=void 0,p.ctrlKey=void 0,p.shiftKey=void 0,p.altKey=void 0,p.metaKey=void 0,p.page=void 0,p.client=void 0,p.delta=void 0,p.rect=void 0,p.x0=void 0,p.y0=void 0,p.t0=void 0,p.dt=void 0,p.duration=void 0,p.clientX0=void 0,p.clientY0=void 0,p.velocity=void 0,p.speed=void 0,p.swipe=void 0,p.axes=void 0,p.preEnd=void 0,s=s||t.element;var f=t.interactable,d=(f&&f.options||Te).deltaSource,h=K(f,s,o),v="start"===a,g="end"===a,m=v?u(p):t.prevEvent,y=v?t.coords.start:g?{page:m.page,client:m.client,timeStamp:t.coords.cur.timeStamp}:t.coords.cur;return p.page=V({},y.page),p.client=V({},y.client),p.rect=V({},t.rect),p.timeStamp=y.timeStamp,g||(p.page.x-=h.x,p.page.y-=h.y,p.client.x-=h.x,p.client.y-=h.y),p.ctrlKey=i.ctrlKey,p.altKey=i.altKey,p.shiftKey=i.shiftKey,p.metaKey=i.metaKey,p.button=i.button,p.buttons=i.buttons,p.target=s,p.currentTarget=s,p.preEnd=c,p.type=l||o+(a||""),p.interactable=f,p.t0=v?t.pointers[t.pointers.length-1].downTime:m.t0,p.x0=t.coords.start.page.x-h.x,p.y0=t.coords.start.page.y-h.y,p.clientX0=t.coords.start.client.x-h.x,p.clientY0=t.coords.start.client.y-h.y,p.delta=v||g?{x:0,y:0}:{x:p[d].x-m[d].x,y:p[d].y-m[d].y},p.dt=t.coords.delta.timeStamp,p.duration=p.timeStamp-p.t0,p.velocity=V({},t.coords.velocity[d]),p.speed=Q(p.velocity.x,p.velocity.y),p.swipe=g||"inertiastart"===a?p.getSwipe():null,p}return o(n,[{key:"getSwipe",value:function(){var t=this._interaction;if(t.prevEvent.speed<600||this.timeStamp-t.prevEvent.timeStamp>150)return null;var e=180*Math.atan2(t.prevEvent.velocityY,t.prevEvent.velocityX)/Math.PI;e<0&&(e+=360);var n=112.5<=e&&e<247.5,r=202.5<=e&&e<337.5;return{up:r,down:!r&&22.5<=e&&e<157.5,left:n,right:!n&&(292.5<=e||e<67.5),angle:e,speed:t.prevEvent.speed,velocity:{x:t.prevEvent.velocityX,y:t.prevEvent.velocityY}}}},{key:"preventDefault",value:function(){}},{key:"stopImmediatePropagation",value:function(){this.immediatePropagationStopped=this.propagationStopped=!0}},{key:"stopPropagation",value:function(){this.propagationStopped=!0}}]),n}(vt);Object.defineProperties(Se.prototype,{pageX:{get:function(){return this.page.x},set:function(t){this.page.x=t}},pageY:{get:function(){return this.page.y},set:function(t){this.page.y=t}},clientX:{get:function(){return this.client.x},set:function(t){this.client.x=t}},clientY:{get:function(){return this.client.y},set:function(t){this.client.y=t}},dx:{get:function(){return this.delta.x},set:function(t){this.delta.x=t}},dy:{get:function(){return this.delta.y},set:function(t){this.delta.y=t}},velocityX:{get:function(){return this.velocity.x},set:function(t){this.velocity.x=t}},velocityY:{get:function(){return this.velocity.y},set:function(t){this.velocity.y=t}}});var _e=o((function t(e,n,i,o,a){r(this,t),this.id=void 0,this.pointer=void 0,this.event=void 0,this.downTime=void 0,this.downTarget=void 0,this.id=e,this.pointer=n,this.event=i,this.downTime=o,this.downTarget=a})),Pe=function(t){return t.interactable="",t.element="",t.prepared="",t.pointerIsDown="",t.pointerWasMoved="",t._proxy="",t}({}),Oe=function(t){return t.start="",t.move="",t.end="",t.stop="",t.interacting="",t}({}),ke=0,De=function(){function t(e){var n=this,i=e.pointerType,o=e.scopeFire;r(this,t),this.interactable=null,this.element=null,this.rect=null,this._rects=void 0,this.edges=null,this._scopeFire=void 0,this.prepared={name:null,axis:null,edges:null},this.pointerType=void 0,this.pointers=[],this.downEvent=null,this.downPointer={},this._latestPointer={pointer:null,event:null,eventTarget:null},this.prevEvent=null,this.pointerIsDown=!1,this.pointerWasMoved=!1,this._interacting=!1,this._ending=!1,this._stopped=!0,this._proxy=void 0,this.simulation=null,this.doMove=Nt((function(t){this.move(t)}),"The interaction.doMove() method has been renamed to interaction.move()"),this.coords={start:{page:{x:0,y:0},client:{x:0,y:0},timeStamp:0},prev:{page:{x:0,y:0},client:{x:0,y:0},timeStamp:0},cur:{page:{x:0,y:0},client:{x:0,y:0},timeStamp:0},delta:{page:{x:0,y:0},client:{x:0,y:0},timeStamp:0},velocity:{page:{x:0,y:0},client:{x:0,y:0},timeStamp:0}},this._id=ke++,this._scopeFire=o,this.pointerType=i;var a=this;this._proxy={};var s=function(t){Object.defineProperty(n._proxy,t,{get:function(){return a[t]}})};for(var c in Pe)s(c);var l=function(t){Object.defineProperty(n._proxy,t,{value:function(){return a[t].apply(a,arguments)}})};for(var u in Oe)l(u);this._scopeFire("interactions:new",{interaction:this})}return o(t,[{key:"pointerMoveTolerance",get:function(){return 1}},{key:"pointerDown",value:function(t,e,n){var r=this.updatePointer(t,e,n,!0),i=this.pointers[r];this._scopeFire("interactions:down",{pointer:t,event:e,eventTarget:n,pointerIndex:r,pointerInfo:i,type:"down",interaction:this})}},{key:"start",value:function(t,e,n){return!(this.interacting()||!this.pointerIsDown||this.pointers.length<("gesture"===t.name?2:1)||!e.options[t.name].enabled)&&(Ut(this.prepared,t),this.interactable=e,this.element=n,this.rect=e.getRect(n),this.edges=this.prepared.edges?V({},this.prepared.edges):{left:!0,right:!0,top:!0,bottom:!0},this._stopped=!1,this._interacting=this._doPhase({interaction:this,event:this.downEvent,phase:"start"})&&!this._stopped,this._interacting)}},{key:"pointerMove",value:function(t,e,n){this.simulation||this.modification&&this.modification.endResult||this.updatePointer(t,e,n,!1);var r,i,o=this.coords.cur.page.x===this.coords.prev.page.x&&this.coords.cur.page.y===this.coords.prev.page.y&&this.coords.cur.client.x===this.coords.prev.client.x&&this.coords.cur.client.y===this.coords.prev.client.y;this.pointerIsDown&&!this.pointerWasMoved&&(r=this.coords.cur.client.x-this.coords.start.client.x,i=this.coords.cur.client.y-this.coords.start.client.y,this.pointerWasMoved=Q(r,i)>this.pointerMoveTolerance);var a,s,c,l=this.getPointerIndex(t),u={pointer:t,pointerIndex:l,pointerInfo:this.pointers[l],event:e,type:"move",eventTarget:n,dx:r,dy:i,duplicate:o,interaction:this};o||(a=this.coords.velocity,s=this.coords.delta,c=Math.max(s.timeStamp/1e3,.001),a.page.x=s.page.x/c,a.page.y=s.page.y/c,a.client.x=s.client.x/c,a.client.y=s.client.y/c,a.timeStamp=c),this._scopeFire("interactions:move",u),o||this.simulation||(this.interacting()&&(u.type=null,this.move(u)),this.pointerWasMoved&&et(this.coords.prev,this.coords.cur))}},{key:"move",value:function(t){t&&t.event||nt(this.coords.delta),(t=V({pointer:this._latestPointer.pointer,event:this._latestPointer.event,eventTarget:this._latestPointer.eventTarget,interaction:this},t||{})).phase="move",this._doPhase(t)}},{key:"pointerUp",value:function(t,e,n,r){var i=this.getPointerIndex(t);-1===i&&(i=this.updatePointer(t,e,n,!1));var o=/cancel$/i.test(e.type)?"cancel":"up";this._scopeFire("interactions:".concat(o),{pointer:t,pointerIndex:i,pointerInfo:this.pointers[i],event:e,eventTarget:n,type:o,curEventTarget:r,interaction:this}),this.simulation||this.end(e),this.removePointer(t,e)}},{key:"documentBlur",value:function(t){this.end(t),this._scopeFire("interactions:blur",{event:t,type:"blur",interaction:this})}},{key:"end",value:function(t){var e;this._ending=!0,t=t||this._latestPointer.event,this.interacting()&&(e=this._doPhase({event:t,interaction:this,phase:"end"})),this._ending=!1,!0===e&&this.stop()}},{key:"currentAction",value:function(){return this._interacting?this.prepared.name:null}},{key:"interacting",value:function(){return this._interacting}},{key:"stop",value:function(){this._scopeFire("interactions:stop",{interaction:this}),this.interactable=this.element=null,this._interacting=!1,this._stopped=!0,this.prepared.name=this.prevEvent=null}},{key:"getPointerIndex",value:function(t){var e=at(t);return"mouse"===this.pointerType||"pen"===this.pointerType?this.pointers.length-1:yt(this.pointers,(function(t){return t.id===e}))}},{key:"getPointerInfo",value:function(t){return this.pointers[this.getPointerIndex(t)]}},{key:"updatePointer",value:function(t,e,n,r){var i,o,a,s=at(t),c=this.getPointerIndex(t),l=this.pointers[c];return r=!1!==r&&(r||/(down|start)$/i.test(e.type)),l?l.pointer=t:(l=new _e(s,t,e,null,null),c=this.pointers.length,this.pointers.push(l)),st(this.coords.cur,this.pointers.map((function(t){return t.pointer})),this._now()),i=this.coords.delta,o=this.coords.prev,a=this.coords.cur,i.page.x=a.page.x-o.page.x,i.page.y=a.page.y-o.page.y,i.client.x=a.client.x-o.client.x,i.client.y=a.client.y-o.client.y,i.timeStamp=a.timeStamp-o.timeStamp,r&&(this.pointerIsDown=!0,l.downTime=this.coords.cur.timeStamp,l.downTarget=n,tt(this.downPointer,t),this.interacting()||(et(this.coords.start,this.coords.cur),et(this.coords.prev,this.coords.cur),this.downEvent=e,this.pointerWasMoved=!1)),this._updateLatestPointer(t,e,n),this._scopeFire("interactions:update-pointer",{pointer:t,event:e,eventTarget:n,down:r,pointerInfo:l,pointerIndex:c,interaction:this}),c}},{key:"removePointer",value:function(t,e){var n=this.getPointerIndex(t);if(-1!==n){var r=this.pointers[n];this._scopeFire("interactions:remove-pointer",{pointer:t,event:e,eventTarget:null,pointerIndex:n,pointerInfo:r,interaction:this}),this.pointers.splice(n,1),this.pointerIsDown=!1}}},{key:"_updateLatestPointer",value:function(t,e,n){this._latestPointer.pointer=t,this._latestPointer.event=e,this._latestPointer.eventTarget=n}},{key:"destroy",value:function(){this._latestPointer.pointer=null,this._latestPointer.event=null,this._latestPointer.eventTarget=null}},{key:"_createPreparedEvent",value:function(t,e,n,r){return new Se(this,t,this.prepared.name,e,this.element,n,r)}},{key:"_fireEvent",value:function(t){var e;null==(e=this.interactable)||e.fire(t),(!this.prevEvent||t.timeStamp>=this.prevEvent.timeStamp)&&(this.prevEvent=t)}},{key:"_doPhase",value:function(t){var e=t.event,n=t.phase,r=t.preEnd,i=t.type,o=this.rect;if(o&&"move"===n&&(H(this.edges,o,this.coords.delta[this.interactable.options.deltaSource]),o.width=o.right-o.left,o.height=o.bottom-o.top),!1===this._scopeFire("interactions:before-action-".concat(n),t))return!1;var a=t.iEvent=this._createPreparedEvent(e,n,r,i);return this._scopeFire("interactions:action-".concat(n),t),"start"===n&&(this.prevEvent=a),this._fireEvent(a),this._scopeFire("interactions:after-action-".concat(n),t),!0}},{key:"_now",value:function(){return Date.now()}}]),t}();function Ie(t){Me(t.interaction)}function Me(t){if(!function(t){return!(!t.offset.pending.x&&!t.offset.pending.y)}(t))return!1;var e=t.offset.pending;return Ae(t.coords.cur,e),Ae(t.coords.delta,e),H(t.edges,t.rect,e),e.x=0,e.y=0,!0}function ze(t){var e=t.x,n=t.y;this.offset.pending.x+=e,this.offset.pending.y+=n,this.offset.total.x+=e,this.offset.total.y+=n}function Ae(t,e){var n=t.page,r=t.client,i=e.x,o=e.y;n.x+=i,n.y+=o,r.x+=i,r.y+=o}Oe.offsetBy="";var Re={id:"offset",before:["modifiers","pointer-events","actions","inertia"],install:function(t){t.Interaction.prototype.offsetBy=ze},listeners:{"interactions:new":function(t){t.interaction.offset={total:{x:0,y:0},pending:{x:0,y:0}}},"interactions:update-pointer":function(t){return function(t){t.pointerIsDown&&(Ae(t.coords.cur,t.offset.total),t.offset.pending.x=0,t.offset.pending.y=0)}(t.interaction)},"interactions:before-action-start":Ie,"interactions:before-action-move":Ie,"interactions:before-action-end":function(t){var e=t.interaction;if(Me(e))return e.move({offset:!0}),e.end(),!1},"interactions:stop":function(t){var e=t.interaction;e.offset.total.x=0,e.offset.total.y=0,e.offset.pending.x=0,e.offset.pending.y=0}}},Ce=Re;var je=function(){function t(e){r(this,t),this.active=!1,this.isModified=!1,this.smoothEnd=!1,this.allowResume=!1,this.modification=void 0,this.modifierCount=0,this.modifierArg=void 0,this.startCoords=void 0,this.t0=0,this.v0=0,this.te=0,this.targetOffset=void 0,this.modifiedOffset=void 0,this.currentOffset=void 0,this.lambda_v0=0,this.one_ve_v0=0,this.timeout=void 0,this.interaction=void 0,this.interaction=e}return o(t,[{key:"start",value:function(t){var e=this.interaction,n=Fe(e);if(!n||!n.enabled)return!1;var r=e.coords.velocity.client,i=Q(r.x,r.y),o=this.modification||(this.modification=new me(e));if(o.copyFrom(e.modification),this.t0=e._now(),this.allowResume=n.allowResume,this.v0=i,this.currentOffset={x:0,y:0},this.startCoords=e.coords.cur.page,this.modifierArg=o.fillArg({pageCoords:this.startCoords,preEnd:!0,phase:"inertiastart"}),this.t0-e.coords.cur.timeStamp<50&&i>n.minSpeed&&i>n.endSpeed)this.startInertia();else{if(o.result=o.setAll(this.modifierArg),!o.result.changed)return!1;this.startSmoothEnd()}return e.modification.result.rect=null,e.offsetBy(this.targetOffset),e._doPhase({interaction:e,event:t,phase:"inertiastart"}),e.offsetBy({x:-this.targetOffset.x,y:-this.targetOffset.y}),e.modification.result.rect=null,this.active=!0,e.simulation=this,!0}},{key:"startInertia",value:function(){var t=this,e=this.interaction.coords.velocity.client,n=Fe(this.interaction),r=n.resistance,i=-Math.log(n.endSpeed/this.v0)/r;this.targetOffset={x:(e.x-i)/r,y:(e.y-i)/r},this.te=i,this.lambda_v0=r/this.v0,this.one_ve_v0=1-n.endSpeed/this.v0;var o=this.modification,a=this.modifierArg;a.pageCoords={x:this.startCoords.x+this.targetOffset.x,y:this.startCoords.y+this.targetOffset.y},o.result=o.setAll(a),o.result.changed&&(this.isModified=!0,this.modifiedOffset={x:this.targetOffset.x+o.result.delta.x,y:this.targetOffset.y+o.result.delta.y}),this.onNextFrame((function(){return t.inertiaTick()}))}},{key:"startSmoothEnd",value:function(){var t=this;this.smoothEnd=!0,this.isModified=!0,this.targetOffset={x:this.modification.result.delta.x,y:this.modification.result.delta.y},this.onNextFrame((function(){return t.smoothEndTick()}))}},{key:"onNextFrame",value:function(t){var e=this;this.timeout=Lt.request((function(){e.active&&t()}))}},{key:"inertiaTick",value:function(){var t,e,n,r,i,o,a,s=this,c=this.interaction,l=Fe(c).resistance,u=(c._now()-this.t0)/1e3;if(u<this.te){var p,f=1-(Math.exp(-l*u)-this.lambda_v0)/this.one_ve_v0;this.isModified?(t=0,e=0,n=this.targetOffset.x,r=this.targetOffset.y,i=this.modifiedOffset.x,o=this.modifiedOffset.y,p={x:Ye(a=f,t,n,i),y:Ye(a,e,r,o)}):p={x:this.targetOffset.x*f,y:this.targetOffset.y*f};var d={x:p.x-this.currentOffset.x,y:p.y-this.currentOffset.y};this.currentOffset.x+=d.x,this.currentOffset.y+=d.y,c.offsetBy(d),c.move(),this.onNextFrame((function(){return s.inertiaTick()}))}else c.offsetBy({x:this.modifiedOffset.x-this.currentOffset.x,y:this.modifiedOffset.y-this.currentOffset.y}),this.end()}},{key:"smoothEndTick",value:function(){var t=this,e=this.interaction,n=e._now()-this.t0,r=Fe(e).smoothEndDuration;if(n<r){var i={x:Le(n,0,this.targetOffset.x,r),y:Le(n,0,this.targetOffset.y,r)},o={x:i.x-this.currentOffset.x,y:i.y-this.currentOffset.y};this.currentOffset.x+=o.x,this.currentOffset.y+=o.y,e.offsetBy(o),e.move({skipModifiers:this.modifierCount}),this.onNextFrame((function(){return t.smoothEndTick()}))}else e.offsetBy({x:this.targetOffset.x-this.currentOffset.x,y:this.targetOffset.y-this.currentOffset.y}),this.end()}},{key:"resume",value:function(t){var e=t.pointer,n=t.event,r=t.eventTarget,i=this.interaction;i.offsetBy({x:-this.currentOffset.x,y:-this.currentOffset.y}),i.updatePointer(e,n,r,!0),i._doPhase({interaction:i,event:n,phase:"resume"}),et(i.coords.prev,i.coords.cur),this.stop()}},{key:"end",value:function(){this.interaction.move(),this.interaction.end(),this.stop()}},{key:"stop",value:function(){this.active=this.smoothEnd=!1,this.interaction.simulation=null,Lt.cancel(this.timeout)}}]),t}();function Fe(t){var e=t.interactable,n=t.prepared;return e&&e.options&&n.name&&e.options[n.name].inertia}var Xe={id:"inertia",before:["modifiers","actions"],install:function(t){var e=t.defaults;t.usePlugin(Ce),t.usePlugin(Ee),t.actions.phases.inertiastart=!0,t.actions.phases.resume=!0,e.perAction.inertia={enabled:!1,resistance:10,minSpeed:100,endSpeed:10,allowResume:!0,smoothEndDuration:300}},listeners:{"interactions:new":function(t){var e=t.interaction;e.inertia=new je(e)},"interactions:before-action-end":function(t){var e=t.interaction,n=t.event;return(!e._interacting||e.simulation||!e.inertia.start(n))&&null},"interactions:down":function(t){var e=t.interaction,n=t.eventTarget,r=e.inertia;if(r.active)for(var i=n;w.element(i);){if(i===e.element){r.resume(t);break}i=A(i)}},"interactions:stop":function(t){var e=t.interaction.inertia;e.active&&e.stop()},"interactions:before-action-resume":function(t){var e=t.interaction.modification;e.stop(t),e.start(t,t.interaction.coords.cur.page),e.applyToInteraction(t)},"interactions:before-action-inertiastart":function(t){return t.interaction.modification.setAndApply(t)},"interactions:action-resume":xe,"interactions:action-inertiastart":xe,"interactions:after-action-inertiastart":function(t){return t.interaction.modification.restoreInteractionCoords(t)},"interactions:after-action-resume":function(t){return t.interaction.modification.restoreInteractionCoords(t)}}};function Ye(t,e,n,r){var i=1-t;return i*i*e+2*i*t*n+t*t*r}function Le(t,e,n,r){return-n*(t/=r)*(t-2)+e}var qe=Xe;function Be(t,e){for(var n=0;n<e.length;n++){var r=e[n];if(t.immediatePropagationStopped)break;r(t)}}var Ve=function(){function t(e){r(this,t),this.options=void 0,this.types={},this.propagationStopped=!1,this.immediatePropagationStopped=!1,this.global=void 0,this.options=V({},e||{})}return o(t,[{key:"fire",value:function(t){var e,n=this.global;(e=this.types[t.type])&&Be(t,e),!t.propagationStopped&&n&&(e=n[t.type])&&Be(t,e)}},{key:"on",value:function(t,e){var n=$(t,e);for(t in n)this.types[t]=gt(this.types[t]||[],n[t])}},{key:"off",value:function(t,e){var n=$(t,e);for(t in n){var r=this.types[t];if(r&&r.length)for(var i=0,o=n[t];i<o.length;i++){var a=o[i],s=r.indexOf(a);-1!==s&&r.splice(s,1)}}}},{key:"getRect",value:function(t){return null}}]),t}();var We=function(){function t(e){r(this,t),this.currentTarget=void 0,this.originalEvent=void 0,this.type=void 0,this.originalEvent=e,tt(this,e)}return o(t,[{key:"preventOriginalDefault",value:function(){this.originalEvent.preventDefault()}},{key:"stopPropagation",value:function(){this.originalEvent.stopPropagation()}},{key:"stopImmediatePropagation",value:function(){this.originalEvent.stopImmediatePropagation()}}]),t}();function Ge(t){return w.object(t)?{capture:!!t.capture,passive:!!t.passive}:{capture:!!t,passive:!1}}function Ne(t,e){return t===e||("boolean"==typeof t?!!e.capture===t&&!1==!!e.passive:!!t.capture==!!e.capture&&!!t.passive==!!e.passive)}var Ue={id:"events",install:function(t){var e,n=[],r={},i=[],o={add:a,remove:s,addDelegate:function(t,e,n,o,s){var u=Ge(s);if(!r[n]){r[n]=[];for(var p=0;p<i.length;p++){var f=i[p];a(f,n,c),a(f,n,l,!0)}}var d=r[n],h=bt(d,(function(n){return n.selector===t&&n.context===e}));h||(h={selector:t,context:e,listeners:[]},d.push(h));h.listeners.push({func:o,options:u})},removeDelegate:function(t,e,n,i,o){var a,u=Ge(o),p=r[n],f=!1;if(!p)return;for(a=p.length-1;a>=0;a--){var d=p[a];if(d.selector===t&&d.context===e){for(var h=d.listeners,v=h.length-1;v>=0;v--){var g=h[v];if(g.func===i&&Ne(g.options,u)){h.splice(v,1),h.length||(p.splice(a,1),s(e,n,c),s(e,n,l,!0)),f=!0;break}}if(f)break}}},delegateListener:c,delegateUseCapture:l,delegatedEvents:r,documents:i,targets:n,supportsOptions:!1,supportsPassive:!1};function a(t,e,r,i){if(t.addEventListener){var a=Ge(i),s=bt(n,(function(e){return e.eventTarget===t}));s||(s={eventTarget:t,events:{}},n.push(s)),s.events[e]||(s.events[e]=[]),bt(s.events[e],(function(t){return t.func===r&&Ne(t.options,a)}))||(t.addEventListener(e,r,o.supportsOptions?a:a.capture),s.events[e].push({func:r,options:a}))}}function s(t,e,r,i){if(t.addEventListener&&t.removeEventListener){var a=yt(n,(function(e){return e.eventTarget===t})),c=n[a];if(c&&c.events)if("all"!==e){var l=!1,u=c.events[e];if(u){if("all"===r){for(var p=u.length-1;p>=0;p--){var f=u[p];s(t,e,f.func,f.options)}return}for(var d=Ge(i),h=0;h<u.length;h++){var v=u[h];if(v.func===r&&Ne(v.options,d)){t.removeEventListener(e,r,o.supportsOptions?d:d.capture),u.splice(h,1),0===u.length&&(delete c.events[e],l=!0);break}}}l&&!Object.keys(c.events).length&&n.splice(a,1)}else for(e in c.events)c.events.hasOwnProperty(e)&&s(t,e,"all")}}function c(t,e){for(var n=Ge(e),i=new We(t),o=r[t.type],a=ht(t)[0],s=a;w.element(s);){for(var c=0;c<o.length;c++){var l=o[c],u=l.selector,p=l.context;if(R(s,u)&&M(p,a)&&M(p,s)){var f=l.listeners;i.currentTarget=s;for(var d=0;d<f.length;d++){var h=f[d];Ne(h.options,n)&&h.func(i)}}}s=A(s)}}function l(t){return c(t,!0)}return null==(e=t.document)||e.createElement("div").addEventListener("test",null,{get capture(){return o.supportsOptions=!0},get passive(){return o.supportsPassive=!0}}),t.events=o,o}},He={methodOrder:["simulationResume","mouseOrPen","hasPointer","idle"],search:function(t){for(var e=0,n=He.methodOrder;e<n.length;e++){var r=n[e],i=He[r](t);if(i)return i}return null},simulationResume:function(t){var e=t.pointerType,n=t.eventType,r=t.eventTarget,i=t.scope;if(!/down|start/i.test(n))return null;for(var o=0,a=i.interactions.list;o<a.length;o++){var s=a[o],c=r;if(s.simulation&&s.simulation.allowResume&&s.pointerType===e)for(;c;){if(c===s.element)return s;c=A(c)}}return null},mouseOrPen:function(t){var e,n=t.pointerId,r=t.pointerType,i=t.eventType,o=t.scope;if("mouse"!==r&&"pen"!==r)return null;for(var a=0,s=o.interactions.list;a<s.length;a++){var c=s[a];if(c.pointerType===r){if(c.simulation&&!Ke(c,n))continue;if(c.interacting())return c;e||(e=c)}}if(e)return e;for(var l=0,u=o.interactions.list;l<u.length;l++){var p=u[l];if(!(p.pointerType!==r||/down/i.test(i)&&p.simulation))return p}return null},hasPointer:function(t){for(var e=t.pointerId,n=0,r=t.scope.interactions.list;n<r.length;n++){var i=r[n];if(Ke(i,e))return i}return null},idle:function(t){for(var e=t.pointerType,n=0,r=t.scope.interactions.list;n<r.length;n++){var i=r[n];if(1===i.pointers.length){var o=i.interactable;if(o&&(!o.options.gesture||!o.options.gesture.enabled))continue}else if(i.pointers.length>=2)continue;if(!i.interacting()&&e===i.pointerType)return i}return null}};function Ke(t,e){return t.pointers.some((function(t){return t.id===e}))}var $e=He,Je=["pointerDown","pointerMove","pointerUp","updatePointer","removePointer","windowBlur"];function Qe(t,e){return function(n){var r=e.interactions.list,i=dt(n),o=ht(n),a=o[0],s=o[1],c=[];if(/^touch/.test(n.type)){e.prevTouchTime=e.now();for(var l=0,u=n.changedTouches;l<u.length;l++){var p=u[l],f={pointer:p,pointerId:at(p),pointerType:i,eventType:n.type,eventTarget:a,curEventTarget:s,scope:e},d=Ze(f);c.push([f.pointer,f.eventTarget,f.curEventTarget,d])}}else{var h=!1;if(!I.supportsPointerEvent&&/mouse/.test(n.type)){for(var v=0;v<r.length&&!h;v++)h="mouse"!==r[v].pointerType&&r[v].pointerIsDown;h=h||e.now()-e.prevTouchTime<500||0===n.timeStamp}if(!h){var g={pointer:n,pointerId:at(n),pointerType:i,eventType:n.type,curEventTarget:s,eventTarget:a,scope:e},m=Ze(g);c.push([g.pointer,g.eventTarget,g.curEventTarget,m])}}for(var y=0;y<c.length;y++){var b=c[y],x=b[0],w=b[1],E=b[2];b[3][t](x,n,w,E)}}}function Ze(t){var e=t.pointerType,n=t.scope,r={interaction:$e.search(t),searchDetails:t};return n.fire("interactions:find",r),r.interaction||n.interactions.new({pointerType:e})}function tn(t,e){var n=t.doc,r=t.scope,i=t.options,o=r.interactions.docEvents,a=r.events,s=a[e];for(var c in r.browser.isIOS&&!i.events&&(i.events={passive:!1}),a.delegatedEvents)s(n,c,a.delegateListener),s(n,c,a.delegateUseCapture,!0);for(var l=i&&i.events,u=0;u<o.length;u++){var p=o[u];s(n,p.type,p.listener,l)}}var en={id:"core/interactions",install:function(t){for(var e={},n=0;n<Je.length;n++){var i=Je[n];e[i]=Qe(i,t)}var a,c=I.pEventTypes;function l(){for(var e=0,n=t.interactions.list;e<n.length;e++){var r=n[e];if(r.pointerIsDown&&"touch"===r.pointerType&&!r._interacting)for(var i=function(){var e=a[o];t.documents.some((function(t){return M(t.doc,e.downTarget)}))||r.removePointer(e.pointer,e.event)},o=0,a=r.pointers;o<a.length;o++)i()}}(a=k.PointerEvent?[{type:c.down,listener:l},{type:c.down,listener:e.pointerDown},{type:c.move,listener:e.pointerMove},{type:c.up,listener:e.pointerUp},{type:c.cancel,listener:e.pointerUp}]:[{type:"mousedown",listener:e.pointerDown},{type:"mousemove",listener:e.pointerMove},{type:"mouseup",listener:e.pointerUp},{type:"touchstart",listener:l},{type:"touchstart",listener:e.pointerDown},{type:"touchmove",listener:e.pointerMove},{type:"touchend",listener:e.pointerUp},{type:"touchcancel",listener:e.pointerUp}]).push({type:"blur",listener:function(e){for(var n=0,r=t.interactions.list;n<r.length;n++){r[n].documentBlur(e)}}}),t.prevTouchTime=0,t.Interaction=function(e){s(i,e);var n=p(i);function i(){return r(this,i),n.apply(this,arguments)}return o(i,[{key:"pointerMoveTolerance",get:function(){return t.interactions.pointerMoveTolerance},set:function(e){t.interactions.pointerMoveTolerance=e}},{key:"_now",value:function(){return t.now()}}]),i}(De),t.interactions={list:[],new:function(e){e.scopeFire=function(e,n){return t.fire(e,n)};var n=new t.Interaction(e);return t.interactions.list.push(n),n},listeners:e,docEvents:a,pointerMoveTolerance:1},t.usePlugin(he)},listeners:{"scope:add-document":function(t){return tn(t,"add")},"scope:remove-document":function(t){return tn(t,"remove")},"interactable:unset":function(t,e){for(var n=t.interactable,r=e.interactions.list.length-1;r>=0;r--){var i=e.interactions.list[r];i.interactable===n&&(i.stop(),e.fire("interactions:destroy",{interaction:i}),i.destroy(),e.interactions.list.length>2&&e.interactions.list.splice(r,1))}}},onDocSignal:tn,doOnInteractions:Qe,methodNames:Je},nn=en,rn=function(t){return t[t.On=0]="On",t[t.Off=1]="Off",t}(rn||{}),on=function(){function t(e,n,i,o){r(this,t),this.target=void 0,this.options=void 0,this._actions=void 0,this.events=new Ve,this._context=void 0,this._win=void 0,this._doc=void 0,this._scopeEvents=void 0,this._actions=n.actions,this.target=e,this._context=n.context||i,this._win=y(B(e)?this._context:e),this._doc=this._win.document,this._scopeEvents=o,this.set(n)}return o(t,[{key:"_defaults",get:function(){return{base:{},perAction:{},actions:{}}}},{key:"setOnEvents",value:function(t,e){return w.func(e.onstart)&&this.on("".concat(t,"start"),e.onstart),w.func(e.onmove)&&this.on("".concat(t,"move"),e.onmove),w.func(e.onend)&&this.on("".concat(t,"end"),e.onend),w.func(e.oninertiastart)&&this.on("".concat(t,"inertiastart"),e.oninertiastart),this}},{key:"updatePerActionListeners",value:function(t,e,n){var r,i=this,o=null==(r=this._actions.map[t])?void 0:r.filterEventType,a=function(t){return(null==o||o(t))&&ve(t,i._actions)};(w.array(e)||w.object(e))&&this._onOff(rn.Off,t,e,void 0,a),(w.array(n)||w.object(n))&&this._onOff(rn.On,t,n,void 0,a)}},{key:"setPerAction",value:function(t,e){var n=this._defaults;for(var r in e){var i=r,o=this.options[t],a=e[i];"listeners"===i&&this.updatePerActionListeners(t,o.listeners,a),w.array(a)?o[i]=mt(a):w.plainObject(a)?(o[i]=V(o[i]||{},ge(a)),w.object(n.perAction[i])&&"enabled"in n.perAction[i]&&(o[i].enabled=!1!==a.enabled)):w.bool(a)&&w.object(n.perAction[i])?o[i].enabled=a:o[i]=a}}},{key:"getRect",value:function(t){return t=t||(w.element(this.target)?this.target:null),w.string(this.target)&&(t=t||this._context.querySelector(this.target)),L(t)}},{key:"rectChecker",value:function(t){var e=this;return w.func(t)?(this.getRect=function(n){var r=V({},t.apply(e,n));return"width"in r||(r.width=r.right-r.left,r.height=r.bottom-r.top),r},this):null===t?(delete this.getRect,this):this.getRect}},{key:"_backCompatOption",value:function(t,e){if(B(e)||w.object(e)){for(var n in this.options[t]=e,this._actions.map)this.options[n][t]=e;return this}return this.options[t]}},{key:"origin",value:function(t){return this._backCompatOption("origin",t)}},{key:"deltaSource",value:function(t){return"page"===t||"client"===t?(this.options.deltaSource=t,this):this.options.deltaSource}},{key:"getAllElements",value:function(){var t=this.target;return w.string(t)?Array.from(this._context.querySelectorAll(t)):w.func(t)&&t.getAllElements?t.getAllElements():w.element(t)?[t]:[]}},{key:"context",value:function(){return this._context}},{key:"inContext",value:function(t){return this._context===t.ownerDocument||M(this._context,t)}},{key:"testIgnoreAllow",value:function(t,e,n){return!this.testIgnore(t.ignoreFrom,e,n)&&this.testAllow(t.allowFrom,e,n)}},{key:"testAllow",value:function(t,e,n){return!t||!!w.element(n)&&(w.string(t)?F(n,t,e):!!w.element(t)&&M(t,n))}},{key:"testIgnore",value:function(t,e,n){return!(!t||!w.element(n))&&(w.string(t)?F(n,t,e):!!w.element(t)&&M(t,n))}},{key:"fire",value:function(t){return this.events.fire(t),this}},{key:"_onOff",value:function(t,e,n,r,i){w.object(e)&&!w.array(e)&&(r=n,n=null);var o=$(e,n,i);for(var a in o){"wheel"===a&&(a=I.wheelEvent);for(var s=0,c=o[a];s<c.length;s++){var l=c[s];ve(a,this._actions)?this.events[t===rn.On?"on":"off"](a,l):w.string(this.target)?this._scopeEvents[t===rn.On?"addDelegate":"removeDelegate"](this.target,this._context,a,l,r):this._scopeEvents[t===rn.On?"add":"remove"](this.target,a,l,r)}}return this}},{key:"on",value:function(t,e,n){return this._onOff(rn.On,t,e,n)}},{key:"off",value:function(t,e,n){return this._onOff(rn.Off,t,e,n)}},{key:"set",value:function(t){var e=this._defaults;for(var n in w.object(t)||(t={}),this.options=ge(e.base),this._actions.methodDict){var r=n,i=this._actions.methodDict[r];this.options[r]={},this.setPerAction(r,V(V({},e.perAction),e.actions[r])),this[i](t[r])}for(var o in t)"getRect"!==o?w.func(this[o])&&this[o](t[o]):this.rectChecker(t.getRect);return this}},{key:"unset",value:function(){if(w.string(this.target))for(var t in this._scopeEvents.delegatedEvents)for(var e=this._scopeEvents.delegatedEvents[t],n=e.length-1;n>=0;n--){var r=e[n],i=r.selector,o=r.context,a=r.listeners;i===this.target&&o===this._context&&e.splice(n,1);for(var s=a.length-1;s>=0;s--)this._scopeEvents.removeDelegate(this.target,this._context,t,a[s][0],a[s][1])}else this._scopeEvents.remove(this.target,"all")}}]),t}(),an=function(){function t(e){var n=this;r(this,t),this.list=[],this.selectorMap={},this.scope=void 0,this.scope=e,e.addListeners({"interactable:unset":function(t){var e=t.interactable,r=e.target,i=w.string(r)?n.selectorMap[r]:r[n.scope.id],o=yt(i,(function(t){return t===e}));i.splice(o,1)}})}return o(t,[{key:"new",value:function(t,e){e=V(e||{},{actions:this.scope.actions});var n=new this.scope.Interactable(t,e,this.scope.document,this.scope.events);return this.scope.addDocument(n._doc),this.list.push(n),w.string(t)?(this.selectorMap[t]||(this.selectorMap[t]=[]),this.selectorMap[t].push(n)):(n.target[this.scope.id]||Object.defineProperty(t,this.scope.id,{value:[],configurable:!0}),t[this.scope.id].push(n)),this.scope.fire("interactable:new",{target:t,options:e,interactable:n,win:this.scope._win}),n}},{key:"getExisting",value:function(t,e){var n=e&&e.context||this.scope.document,r=w.string(t),i=r?this.selectorMap[t]:t[this.scope.id];if(i)return bt(i,(function(e){return e._context===n&&(r||e.inContext(t))}))}},{key:"forEachMatch",value:function(t,e){for(var n=0,r=this.list;n<r.length;n++){var i=r[n],o=void 0;if((w.string(i.target)?w.element(t)&&R(t,i.target):t===i.target)&&i.inContext(t)&&(o=e(i)),void 0!==o)return o}}}]),t}();var sn=function(){function t(){var e=this;r(this,t),this.id="__interact_scope_".concat(Math.floor(100*Math.random())),this.isInitialized=!1,this.listenerMaps=[],this.browser=I,this.defaults=ge(Te),this.Eventable=Ve,this.actions={map:{},phases:{start:!0,move:!0,end:!0},methodDict:{},phaselessTypes:{}},this.interactStatic=function(t){var e=function e(n,r){var i=t.interactables.getExisting(n,r);return i||((i=t.interactables.new(n,r)).events.global=e.globalEvents),i};return e.getPointerAverage=lt,e.getTouchBBox=ut,e.getTouchDistance=pt,e.getTouchAngle=ft,e.getElementRect=L,e.getElementClientRect=Y,e.matchesSelector=R,e.closest=z,e.globalEvents={},e.version="1.10.26",e.scope=t,e.use=function(t,e){return this.scope.usePlugin(t,e),this},e.isSet=function(t,e){return!!this.scope.interactables.get(t,e&&e.context)},e.on=Nt((function(t,e,n){if(w.string(t)&&-1!==t.search(" ")&&(t=t.trim().split(/ +/)),w.array(t)){for(var r=0,i=t;r<i.length;r++){var o=i[r];this.on(o,e,n)}return this}if(w.object(t)){for(var a in t)this.on(a,t[a],e);return this}return ve(t,this.scope.actions)?this.globalEvents[t]?this.globalEvents[t].push(e):this.globalEvents[t]=[e]:this.scope.events.add(this.scope.document,t,e,{options:n}),this}),"The interact.on() method is being deprecated"),e.off=Nt((function(t,e,n){if(w.string(t)&&-1!==t.search(" ")&&(t=t.trim().split(/ +/)),w.array(t)){for(var r=0,i=t;r<i.length;r++){var o=i[r];this.off(o,e,n)}return this}if(w.object(t)){for(var a in t)this.off(a,t[a],e);return this}var s;return ve(t,this.scope.actions)?t in this.globalEvents&&-1!==(s=this.globalEvents[t].indexOf(e))&&this.globalEvents[t].splice(s,1):this.scope.events.remove(this.scope.document,t,e,n),this}),"The interact.off() method is being deprecated"),e.debug=function(){return this.scope},e.supportsTouch=function(){return I.supportsTouch},e.supportsPointerEvent=function(){return I.supportsPointerEvent},e.stop=function(){for(var t=0,e=this.scope.interactions.list;t<e.length;t++)e[t].stop();return this},e.pointerMoveTolerance=function(t){return w.number(t)?(this.scope.interactions.pointerMoveTolerance=t,this):this.scope.interactions.pointerMoveTolerance},e.addDocument=function(t,e){this.scope.addDocument(t,e)},e.removeDocument=function(t){this.scope.removeDocument(t)},e}(this),this.InteractEvent=Se,this.Interactable=void 0,this.interactables=new an(this),this._win=void 0,this.document=void 0,this.window=void 0,this.documents=[],this._plugins={list:[],map:{}},this.onWindowUnload=function(t){return e.removeDocument(t.target)};var n=this;this.Interactable=function(t){s(i,t);var e=p(i);function i(){return r(this,i),e.apply(this,arguments)}return o(i,[{key:"_defaults",get:function(){return n.defaults}},{key:"set",value:function(t){return f(c(i.prototype),"set",this).call(this,t),n.fire("interactable:set",{options:t,interactable:this}),this}},{key:"unset",value:function(){f(c(i.prototype),"unset",this).call(this);var t=n.interactables.list.indexOf(this);t<0||(n.interactables.list.splice(t,1),n.fire("interactable:unset",{interactable:this}))}}]),i}(on)}return o(t,[{key:"addListeners",value:function(t,e){this.listenerMaps.push({id:e,map:t})}},{key:"fire",value:function(t,e){for(var n=0,r=this.listenerMaps;n<r.length;n++){var i=r[n].map[t];if(i&&!1===i(e,this,t))return!1}}},{key:"init",value:function(t){return this.isInitialized?this:function(t,e){t.isInitialized=!0,w.window(e)&&m(e);return k.init(e),I.init(e),Lt.init(e),t.window=e,t.document=e.document,t.usePlugin(nn),t.usePlugin(Ue),t}(this,t)}},{key:"pluginIsInstalled",value:function(t){var e=t.id;return e?!!this._plugins.map[e]:-1!==this._plugins.list.indexOf(t)}},{key:"usePlugin",value:function(t,e){if(!this.isInitialized)return this;if(this.pluginIsInstalled(t))return this;if(t.id&&(this._plugins.map[t.id]=t),this._plugins.list.push(t),t.install&&t.install(this,e),t.listeners&&t.before){for(var n=0,r=this.listenerMaps.length,i=t.before.reduce((function(t,e){return t[e]=!0,t[cn(e)]=!0,t}),{});n<r;n++){var o=this.listenerMaps[n].id;if(o&&(i[o]||i[cn(o)]))break}this.listenerMaps.splice(n,0,{id:t.id,map:t.listeners})}else t.listeners&&this.listenerMaps.push({id:t.id,map:t.listeners});return this}},{key:"addDocument",value:function(t,e){if(-1!==this.getDocIndex(t))return!1;var n=y(t);e=e?V({},e):{},this.documents.push({doc:t,options:e}),this.events.documents.push(t),t!==this.document&&this.events.add(n,"unload",this.onWindowUnload),this.fire("scope:add-document",{doc:t,window:n,scope:this,options:e})}},{key:"removeDocument",value:function(t){var e=this.getDocIndex(t),n=y(t),r=this.documents[e].options;this.events.remove(n,"unload",this.onWindowUnload),this.documents.splice(e,1),this.events.documents.splice(e,1),this.fire("scope:remove-document",{doc:t,window:n,scope:this,options:r})}},{key:"getDocIndex",value:function(t){for(var e=0;e<this.documents.length;e++)if(this.documents[e].doc===t)return e;return-1}},{key:"getDocOptions",value:function(t){var e=this.getDocIndex(t);return-1===e?null:this.documents[e].options}},{key:"now",value:function(){return(this.window.Date||Date).now()}}]),t}();function cn(t){return t&&t.replace(/\/.*$/,"")}var ln=new sn,un=ln.interactStatic,pn="undefined"!=typeof globalThis?globalThis:window;ln.init(pn);var fn=Object.freeze({__proto__:null,edgeTarget:function(){},elements:function(){},grid:function(t){var e=[["x","y"],["left","top"],["right","bottom"],["width","height"]].filter((function(e){var n=e[0],r=e[1];return n in t||r in t})),n=function(n,r){for(var i=t.range,o=t.limits,a=void 0===o?{left:-1/0,right:1/0,top:-1/0,bottom:1/0}:o,s=t.offset,c=void 0===s?{x:0,y:0}:s,l={range:i,grid:t,x:null,y:null},u=0;u<e.length;u++){var p=e[u],f=p[0],d=p[1],h=Math.round((n-c.x)/t[f]),v=Math.round((r-c.y)/t[d]);l[f]=Math.max(a.left,Math.min(a.right,h*t[f]+c.x)),l[d]=Math.max(a.top,Math.min(a.bottom,v*t[d]+c.y))}return l};return n.grid=t,n.coordFields=e,n}}),dn={id:"snappers",install:function(t){var e=t.interactStatic;e.snappers=V(e.snappers||{},fn),e.createSnapGrid=e.snappers.grid}},hn=dn,vn={start:function(t){var n=t.state,r=t.rect,i=t.edges,o=t.pageCoords,a=n.options,s=a.ratio,c=a.enabled,l=n.options,u=l.equalDelta,p=l.modifiers;"preserve"===s&&(s=r.width/r.height),n.startCoords=V({},o),n.startRect=V({},r),n.ratio=s,n.equalDelta=u;var f=n.linkedEdges={top:i.top||i.left&&!i.bottom,left:i.left||i.top&&!i.right,bottom:i.bottom||i.right&&!i.top,right:i.right||i.bottom&&!i.left};if(n.xIsPrimaryAxis=!(!i.left&&!i.right),n.equalDelta){var d=(f.left?1:-1)*(f.top?1:-1);n.edgeSign={x:d,y:d}}else n.edgeSign={x:f.left?-1:1,y:f.top?-1:1};if(!1!==c&&V(i,f),null!=p&&p.length){var h=new me(t.interaction);h.copyFrom(t.interaction.modification),h.prepareStates(p),n.subModification=h,h.startAll(e({},t))}},set:function(t){var n=t.state,r=t.rect,i=t.coords,o=n.linkedEdges,a=V({},i),s=n.equalDelta?gn:mn;if(V(t.edges,o),s(n,n.xIsPrimaryAxis,i,r),!n.subModification)return null;var c=V({},r);H(o,c,{x:i.x-a.x,y:i.y-a.y});var l=n.subModification.setAll(e(e({},t),{},{rect:c,edges:o,pageCoords:i,prevCoords:i,prevRect:c})),u=l.delta;l.changed&&(s(n,Math.abs(u.x)>Math.abs(u.y),l.coords,l.rect),V(i,l.coords));return l.eventProps},defaults:{ratio:"preserve",equalDelta:!1,modifiers:[],enabled:!1}};function gn(t,e,n){var r=t.startCoords,i=t.edgeSign;e?n.y=r.y+(n.x-r.x)*i.y:n.x=r.x+(n.y-r.y)*i.x}function mn(t,e,n,r){var i=t.startRect,o=t.startCoords,a=t.ratio,s=t.edgeSign;if(e){var c=r.width/a;n.y=o.y+(c-i.height)*s.y}else{var l=r.height*a;n.x=o.x+(l-i.width)*s.x}}var yn=be(vn,"aspectRatio"),bn=function(){};bn._defaults={};var xn=bn;function wn(t,e,n){return w.func(t)?G(t,e.interactable,e.element,[n.x,n.y,e]):G(t,e.interactable,e.element)}var En={start:function(t){var e=t.rect,n=t.startOffset,r=t.state,i=t.interaction,o=t.pageCoords,a=r.options,s=a.elementRect,c=V({left:0,top:0,right:0,bottom:0},a.offset||{});if(e&&s){var l=wn(a.restriction,i,o);if(l){var u=l.right-l.left-e.width,p=l.bottom-l.top-e.height;u<0&&(c.left+=u,c.right+=u),p<0&&(c.top+=p,c.bottom+=p)}c.left+=n.left-e.width*s.left,c.top+=n.top-e.height*s.top,c.right+=n.right-e.width*(1-s.right),c.bottom+=n.bottom-e.height*(1-s.bottom)}r.offset=c},set:function(t){var e=t.coords,n=t.interaction,r=t.state,i=r.options,o=r.offset,a=wn(i.restriction,n,e);if(a){var s=function(t){return!t||"left"in t&&"top"in t||((t=V({},t)).left=t.x||0,t.top=t.y||0,t.right=t.right||t.left+t.width,t.bottom=t.bottom||t.top+t.height),t}(a);e.x=Math.max(Math.min(s.right-o.right,e.x),s.left+o.left),e.y=Math.max(Math.min(s.bottom-o.bottom,e.y),s.top+o.top)}},defaults:{restriction:null,elementRect:null,offset:null,endOnly:!1,enabled:!1}},Tn=be(En,"restrict"),Sn={top:1/0,left:1/0,bottom:-1/0,right:-1/0},_n={top:-1/0,left:-1/0,bottom:1/0,right:1/0};function Pn(t,e){for(var n=0,r=["top","left","bottom","right"];n<r.length;n++){var i=r[n];i in t||(t[i]=e[i])}return t}var On={noInner:Sn,noOuter:_n,start:function(t){var e,n=t.interaction,r=t.startOffset,i=t.state,o=i.options;o&&(e=N(wn(o.offset,n,n.coords.start.page))),e=e||{x:0,y:0},i.offset={top:e.y+r.top,left:e.x+r.left,bottom:e.y-r.bottom,right:e.x-r.right}},set:function(t){var e=t.coords,n=t.edges,r=t.interaction,i=t.state,o=i.offset,a=i.options;if(n){var s=V({},e),c=wn(a.inner,r,s)||{},l=wn(a.outer,r,s)||{};Pn(c,Sn),Pn(l,_n),n.top?e.y=Math.min(Math.max(l.top+o.top,s.y),c.top+o.top):n.bottom&&(e.y=Math.max(Math.min(l.bottom+o.bottom,s.y),c.bottom+o.bottom)),n.left?e.x=Math.min(Math.max(l.left+o.left,s.x),c.left+o.left):n.right&&(e.x=Math.max(Math.min(l.right+o.right,s.x),c.right+o.right))}},defaults:{inner:null,outer:null,offset:null,endOnly:!1,enabled:!1}},kn=be(On,"restrictEdges"),Dn=V({get elementRect(){return{top:0,left:0,bottom:1,right:1}},set elementRect(t){}},En.defaults),In=be({start:En.start,set:En.set,defaults:Dn},"restrictRect"),Mn={width:-1/0,height:-1/0},zn={width:1/0,height:1/0};var An=be({start:function(t){return On.start(t)},set:function(t){var e=t.interaction,n=t.state,r=t.rect,i=t.edges,o=n.options;if(i){var a=U(wn(o.min,e,t.coords))||Mn,s=U(wn(o.max,e,t.coords))||zn;n.options={endOnly:o.endOnly,inner:V({},On.noInner),outer:V({},On.noOuter)},i.top?(n.options.inner.top=r.bottom-a.height,n.options.outer.top=r.bottom-s.height):i.bottom&&(n.options.inner.bottom=r.top+a.height,n.options.outer.bottom=r.top+s.height),i.left?(n.options.inner.left=r.right-a.width,n.options.outer.left=r.right-s.width):i.right&&(n.options.inner.right=r.left+a.width,n.options.outer.right=r.left+s.width),On.set(t),n.options=o}},defaults:{min:null,max:null,endOnly:!1,enabled:!1}},"restrictSize");var Rn={start:function(t){var e,n=t.interaction,r=t.interactable,i=t.element,o=t.rect,a=t.state,s=t.startOffset,c=a.options,l=c.offsetWithOrigin?function(t){var e=t.interaction.element,n=N(G(t.state.options.origin,null,null,[e])),r=n||K(t.interactable,e,t.interaction.prepared.name);return r}(t):{x:0,y:0};if("startCoords"===c.offset)e={x:n.coords.start.page.x,y:n.coords.start.page.y};else{var u=G(c.offset,r,i,[n]);(e=N(u)||{x:0,y:0}).x+=l.x,e.y+=l.y}var p=c.relativePoints;a.offsets=o&&p&&p.length?p.map((function(t,n){return{index:n,relativePoint:t,x:s.left-o.width*t.x+e.x,y:s.top-o.height*t.y+e.y}})):[{index:0,relativePoint:null,x:e.x,y:e.y}]},set:function(t){var e=t.interaction,n=t.coords,r=t.state,i=r.options,o=r.offsets,a=K(e.interactable,e.element,e.prepared.name),s=V({},n),c=[];i.offsetWithOrigin||(s.x-=a.x,s.y-=a.y);for(var l=0,u=o;l<u.length;l++)for(var p=u[l],f=s.x-p.x,d=s.y-p.y,h=0,v=i.targets.length;h<v;h++){var g=i.targets[h],m=void 0;(m=w.func(g)?g(f,d,e._proxy,p,h):g)&&c.push({x:(w.number(m.x)?m.x:f)+p.x,y:(w.number(m.y)?m.y:d)+p.y,range:w.number(m.range)?m.range:i.range,source:g,index:h,offset:p})}for(var y={target:null,inRange:!1,distance:0,range:0,delta:{x:0,y:0}},b=0;b<c.length;b++){var x=c[b],E=x.range,T=x.x-s.x,S=x.y-s.y,_=Q(T,S),P=_<=E;E===1/0&&y.inRange&&y.range!==1/0&&(P=!1),y.target&&!(P?y.inRange&&E!==1/0?_/E<y.distance/y.range:E===1/0&&y.range!==1/0||_<y.distance:!y.inRange&&_<y.distance)||(y.target=x,y.distance=_,y.range=E,y.inRange=P,y.delta.x=T,y.delta.y=S)}return y.inRange&&(n.x=y.target.x,n.y=y.target.y),r.closest=y,y},defaults:{range:1/0,targets:null,offset:null,offsetWithOrigin:!0,origin:null,relativePoints:null,endOnly:!1,enabled:!1}},Cn=be(Rn,"snap");var jn={start:function(t){var e=t.state,n=t.edges,r=e.options;if(!n)return null;t.state={options:{targets:null,relativePoints:[{x:n.left?0:1,y:n.top?0:1}],offset:r.offset||"self",origin:{x:0,y:0},range:r.range}},e.targetFields=e.targetFields||[["width","height"],["x","y"]],Rn.start(t),e.offsets=t.state.offsets,t.state=e},set:function(t){var e=t.interaction,n=t.state,r=t.coords,i=n.options,o=n.offsets,a={x:r.x-o[0].x,y:r.y-o[0].y};n.options=V({},i),n.options.targets=[];for(var s=0,c=i.targets||[];s<c.length;s++){var l=c[s],u=void 0;if(u=w.func(l)?l(a.x,a.y,e):l){for(var p=0,f=n.targetFields;p<f.length;p++){var d=f[p],h=d[0],v=d[1];if(h in u||v in u){u.x=u[h],u.y=u[v];break}}n.options.targets.push(u)}}var g=Rn.set(t);return n.options=i,g},defaults:{range:1/0,targets:null,offset:null,endOnly:!1,enabled:!1}},Fn=be(jn,"snapSize");var Xn={aspectRatio:yn,restrictEdges:kn,restrict:Tn,restrictRect:In,restrictSize:An,snapEdges:be({start:function(t){var e=t.edges;return e?(t.state.targetFields=t.state.targetFields||[[e.left?"left":"right",e.top?"top":"bottom"]],jn.start(t)):null},set:jn.set,defaults:V(ge(jn.defaults),{targets:void 0,range:void 0,offset:{x:0,y:0}})},"snapEdges"),snap:Cn,snapSize:Fn,spring:xn,avoid:xn,transform:xn,rubberband:xn},Yn={id:"modifiers",install:function(t){var e=t.interactStatic;for(var n in t.usePlugin(Ee),t.usePlugin(hn),e.modifiers=Xn,Xn){var r=Xn[n],i=r._defaults,o=r._methods;i._methods=o,t.defaults.perAction[n]=i}}},Ln=Yn,qn=function(t){s(n,t);var e=p(n);function n(t,i,o,a,s,c){var l;if(r(this,n),tt(u(l=e.call(this,s)),o),o!==i&&tt(u(l),i),l.timeStamp=c,l.originalEvent=o,l.type=t,l.pointerId=at(i),l.pointerType=dt(i),l.target=a,l.currentTarget=null,"tap"===t){var p=s.getPointerIndex(i);l.dt=l.timeStamp-s.pointers[p].downTime;var f=l.timeStamp-s.tapTime;l.double=!!s.prevTap&&"doubletap"!==s.prevTap.type&&s.prevTap.target===l.target&&f<500}else"doubletap"===t&&(l.dt=i.timeStamp-s.tapTime,l.double=!0);return l}return o(n,[{key:"_subtractOrigin",value:function(t){var e=t.x,n=t.y;return this.pageX-=e,this.pageY-=n,this.clientX-=e,this.clientY-=n,this}},{key:"_addOrigin",value:function(t){var e=t.x,n=t.y;return this.pageX+=e,this.pageY+=n,this.clientX+=e,this.clientY+=n,this}},{key:"preventDefault",value:function(){this.originalEvent.preventDefault()}}]),n}(vt),Bn={id:"pointer-events/base",before:["inertia","modifiers","auto-start","actions"],install:function(t){t.pointerEvents=Bn,t.defaults.actions.pointerEvents=Bn.defaults,V(t.actions.phaselessTypes,Bn.types)},listeners:{"interactions:new":function(t){var e=t.interaction;e.prevTap=null,e.tapTime=0},"interactions:update-pointer":function(t){var e=t.down,n=t.pointerInfo;if(!e&&n.hold)return;n.hold={duration:1/0,timeout:null}},"interactions:move":function(t,e){var n=t.interaction,r=t.pointer,i=t.event,o=t.eventTarget;t.duplicate||n.pointerIsDown&&!n.pointerWasMoved||(n.pointerIsDown&&Gn(t),Vn({interaction:n,pointer:r,event:i,eventTarget:o,type:"move"},e))},"interactions:down":function(t,e){!function(t,e){for(var n=t.interaction,r=t.pointer,i=t.event,o=t.eventTarget,a=t.pointerIndex,s=n.pointers[a].hold,c=q(o),l={interaction:n,pointer:r,event:i,eventTarget:o,type:"hold",targets:[],path:c,node:null},u=0;u<c.length;u++){var p=c[u];l.node=p,e.fire("pointerEvents:collect-targets",l)}if(!l.targets.length)return;for(var f=1/0,d=0,h=l.targets;d<h.length;d++){var v=h[d].eventable.options.holdDuration;v<f&&(f=v)}s.duration=f,s.timeout=setTimeout((function(){Vn({interaction:n,eventTarget:o,pointer:r,event:i,type:"hold"},e)}),f)}(t,e),Vn(t,e)},"interactions:up":function(t,e){Gn(t),Vn(t,e),function(t,e){var n=t.interaction,r=t.pointer,i=t.event,o=t.eventTarget;n.pointerWasMoved||Vn({interaction:n,eventTarget:o,pointer:r,event:i,type:"tap"},e)}(t,e)},"interactions:cancel":function(t,e){Gn(t),Vn(t,e)}},PointerEvent:qn,fire:Vn,collectEventTargets:Wn,defaults:{holdDuration:600,ignoreFrom:null,allowFrom:null,origin:{x:0,y:0}},types:{down:!0,move:!0,up:!0,cancel:!0,tap:!0,doubletap:!0,hold:!0}};function Vn(t,e){var n=t.interaction,r=t.pointer,i=t.event,o=t.eventTarget,a=t.type,s=t.targets,c=void 0===s?Wn(t,e):s,l=new qn(a,r,i,o,n,e.now());e.fire("pointerEvents:new",{pointerEvent:l});for(var u={interaction:n,pointer:r,event:i,eventTarget:o,targets:c,type:a,pointerEvent:l},p=0;p<c.length;p++){var f=c[p];for(var d in f.props||{})l[d]=f.props[d];var h=K(f.eventable,f.node);if(l._subtractOrigin(h),l.eventable=f.eventable,l.currentTarget=f.node,f.eventable.fire(l),l._addOrigin(h),l.immediatePropagationStopped||l.propagationStopped&&p+1<c.length&&c[p+1].node!==l.currentTarget)break}if(e.fire("pointerEvents:fired",u),"tap"===a){var v=l.double?Vn({interaction:n,pointer:r,event:i,eventTarget:o,type:"doubletap"},e):l;n.prevTap=v,n.tapTime=v.timeStamp}return l}function Wn(t,e){var n=t.interaction,r=t.pointer,i=t.event,o=t.eventTarget,a=t.type,s=n.getPointerIndex(r),c=n.pointers[s];if("tap"===a&&(n.pointerWasMoved||!c||c.downTarget!==o))return[];for(var l=q(o),u={interaction:n,pointer:r,event:i,eventTarget:o,type:a,path:l,targets:[],node:null},p=0;p<l.length;p++){var f=l[p];u.node=f,e.fire("pointerEvents:collect-targets",u)}return"hold"===a&&(u.targets=u.targets.filter((function(t){var e,r;return t.eventable.options.holdDuration===(null==(e=n.pointers[s])||null==(r=e.hold)?void 0:r.duration)}))),u.targets}function Gn(t){var e=t.interaction,n=t.pointerIndex,r=e.pointers[n].hold;r&&r.timeout&&(clearTimeout(r.timeout),r.timeout=null)}var Nn=Object.freeze({__proto__:null,default:Bn});function Un(t){var e=t.interaction;e.holdIntervalHandle&&(clearInterval(e.holdIntervalHandle),e.holdIntervalHandle=null)}var Hn={id:"pointer-events/holdRepeat",install:function(t){t.usePlugin(Bn);var e=t.pointerEvents;e.defaults.holdRepeatInterval=0,e.types.holdrepeat=t.actions.phaselessTypes.holdrepeat=!0},listeners:["move","up","cancel","endall"].reduce((function(t,e){return t["pointerEvents:".concat(e)]=Un,t}),{"pointerEvents:new":function(t){var e=t.pointerEvent;"hold"===e.type&&(e.count=(e.count||0)+1)},"pointerEvents:fired":function(t,e){var n=t.interaction,r=t.pointerEvent,i=t.eventTarget,o=t.targets;if("hold"===r.type&&o.length){var a=o[0].eventable.options.holdRepeatInterval;a<=0||(n.holdIntervalHandle=setTimeout((function(){e.pointerEvents.fire({interaction:n,eventTarget:i,type:"hold",pointer:r,event:r},e)}),a))}}})},Kn=Hn;var $n={id:"pointer-events/interactableTargets",install:function(t){var e=t.Interactable;e.prototype.pointerEvents=function(t){return V(this.events.options,t),this};var n=e.prototype._backCompatOption;e.prototype._backCompatOption=function(t,e){var r=n.call(this,t,e);return r===this&&(this.events.options[t]=e),r}},listeners:{"pointerEvents:collect-targets":function(t,e){var n=t.targets,r=t.node,i=t.type,o=t.eventTarget;e.interactables.forEachMatch(r,(function(t){var e=t.events,a=e.options;e.types[i]&&e.types[i].length&&t.testIgnoreAllow(a,r,o)&&n.push({node:r,eventable:e,props:{interactable:t}})}))},"interactable:new":function(t){var e=t.interactable;e.events.getRect=function(t){return e.getRect(t)}},"interactable:set":function(t,e){var n=t.interactable,r=t.options;V(n.events.options,e.pointerEvents.defaults),V(n.events.options,r.pointerEvents||{})}}},Jn=$n,Qn={id:"pointer-events",install:function(t){t.usePlugin(Nn),t.usePlugin(Kn),t.usePlugin(Jn)}},Zn=Qn;var tr={id:"reflow",install:function(t){var e=t.Interactable;t.actions.phases.reflow=!0,e.prototype.reflow=function(e){return function(t,e,n){for(var r=t.getAllElements(),i=n.window.Promise,o=i?[]:null,a=function(){var a=r[s],c=t.getRect(a);if(!c)return 1;var l,u=bt(n.interactions.list,(function(n){return n.interacting()&&n.interactable===t&&n.element===a&&n.prepared.name===e.name}));if(u)u.move(),o&&(l=u._reflowPromise||new i((function(t){u._reflowResolve=t})));else{var p=U(c),f=function(t){return{coords:t,get page(){return this.coords.page},get client(){return this.coords.client},get timeStamp(){return this.coords.timeStamp},get pageX(){return this.coords.page.x},get pageY(){return this.coords.page.y},get clientX(){return this.coords.client.x},get clientY(){return this.coords.client.y},get pointerId(){return this.coords.pointerId},get target(){return this.coords.target},get type(){return this.coords.type},get pointerType(){return this.coords.pointerType},get buttons(){return this.coords.buttons},preventDefault:function(){}}}({page:{x:p.x,y:p.y},client:{x:p.x,y:p.y},timeStamp:n.now()});l=function(t,e,n,r,i){var o=t.interactions.new({pointerType:"reflow"}),a={interaction:o,event:i,pointer:i,eventTarget:n,phase:"reflow"};o.interactable=e,o.element=n,o.prevEvent=i,o.updatePointer(i,i,n,!0),nt(o.coords.delta),Ut(o.prepared,r),o._doPhase(a);var s=t.window,c=s.Promise,l=c?new c((function(t){o._reflowResolve=t})):void 0;o._reflowPromise=l,o.start(r,e,n),o._interacting?(o.move(a),o.end(i)):(o.stop(),o._reflowResolve());return o.removePointer(i,i),l}(n,t,a,e,f)}o&&o.push(l)},s=0;s<r.length&&!a();s++);return o&&i.all(o).then((function(){return t}))}(this,e,t)}},listeners:{"interactions:stop":function(t,e){var n=t.interaction;"reflow"===n.pointerType&&(n._reflowResolve&&n._reflowResolve(),function(t,e){t.splice(t.indexOf(e),1)}(e.interactions.list,n))}}},er=tr;if(un.use(he),un.use(Ce),un.use(Zn),un.use(qe),un.use(Ln),un.use(pe),un.use(Xt),un.use(Gt),un.use(er),un.default=un,"object"===( false?0:n(module))&&module)try{module.exports=un}catch(t){}return un.default=un,un}));
//# sourceMappingURL=interact.min.js.map


/***/ }),

/***/ "./node_modules/isect/build/isect.module.js":
/*!**************************************************!*\
  !*** ./node_modules/isect/build/isect.module.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   brute: () => (/* binding */ brute),
/* harmony export */   bush: () => (/* binding */ bush),
/* harmony export */   sweep: () => (/* binding */ isect)
/* harmony export */ });
/* follows "An implementation of top-down splaying"
 * by D. Sleator <sleator@cs.cmu.edu> March 1992
 */

/**
 * @typedef {*} Key
 */


/**
 * @typedef {*} Value
 */


/**
 * @typedef {function(node:Node):void} Visitor
 */


/**
 * @typedef {function(a:Key, b:Key):number} Comparator
 */


/**
 * @param {function(node:Node):string} NodePrinter
 */


/**
 * @typedef {Object}  Node
 * @property {Key}    Key
 * @property {Value=} data
 * @property {Node}   left
 * @property {Node}   right
 */

var Node = function Node (key, data) {
  this.key  = key;
  this.data = data;
  this.left = null;
  this.right= null;
};

function DEFAULT_COMPARE (a, b) { return a > b ? 1 : a < b ? -1 : 0; }


/**
 * Simple top down splay, not requiring i to be in the tree t.
 * @param {Key} i
 * @param {Node?} t
 * @param {Comparator} comparator
 */
function splay (i, t, comparator) {
  if (t === null) { return t; }
  var l, r, y;
  var N = new Node();
  l = r = N;

  while (true) {
    var cmp = comparator(i, t.key);
    //if (i < t.key) {
    if (cmp < 0) {
      if (t.left === null) { break; }
      //if (i < t.left.key) {
      if (comparator(i, t.left.key) < 0) {
        y = t.left;                           /* rotate right */
        t.left = y.right;
        y.right = t;
        t = y;
        if (t.left === null) { break; }
      }
      r.left = t;                               /* link right */
      r = t;
      t = t.left;
    //} else if (i > t.key) {
    } else if (cmp > 0) {
      if (t.right === null) { break; }
      //if (i > t.right.key) {
      if (comparator(i, t.right.key) > 0) {
        y = t.right;                          /* rotate left */
        t.right = y.left;
        y.left = t;
        t = y;
        if (t.right === null) { break; }
      }
      l.right = t;                              /* link left */
      l = t;
      t = t.right;
    } else {
      break;
    }
  }
  /* assemble */
  l.right = t.left;
  r.left = t.right;
  t.left = N.right;
  t.right = N.left;
  return t;
}


/**
 * @param  {Key}        i
 * @param  {Value}      data
 * @param  {Comparator} comparator
 * @param  {Tree}       tree
 * @return {Node}      root
 */
function insert (i, data, t, comparator, tree) {
  var node = new Node(i, data);

  tree._size++;

  if (t === null) {
    node.left = node.right = null;
    return node;
  }

  t = splay(i, t, comparator);
  var cmp = comparator(i, t.key);
  if (cmp < 0) {
    node.left = t.left;
    node.right = t;
    t.left = null;
  } else if (cmp >= 0) {
    node.right = t.right;
    node.left = t;
    t.right = null;
  }
  return node;
}


/**
 * Insert i into the tree t, unless it's already there.
 * @param  {Key}        i
 * @param  {Value}      data
 * @param  {Comparator} comparator
 * @param  {Tree}       tree
 * @return {Node}       root
 */
function add (i, data, t, comparator, tree) {
  var node = new Node(i, data);

  if (t === null) {
    node.left = node.right = null;
    tree._size++;
    return node;
  }

  t = splay(i, t, comparator);
  var cmp = comparator(i, t.key);
  if (cmp === 0) { return t; }
  else {
    if (cmp < 0) {
      node.left = t.left;
      node.right = t;
      t.left = null;
    } else if (cmp > 0) {
      node.right = t.right;
      node.left = t;
      t.right = null;
    }
    tree._size++;
    return node;
  }
}


/**
 * Deletes i from the tree if it's there
 * @param {Key}        i
 * @param {Tree}       tree
 * @param {Comparator} comparator
 * @param {Tree}       tree
 * @return {Node}      new root
 */
function remove (i, t, comparator, tree) {
  var x;
  if (t === null) { return null; }
  t = splay(i, t, comparator);
  var cmp = comparator(i, t.key);
  if (cmp === 0) {               /* found it */
    if (t.left === null) {
      x = t.right;
    } else {
      x = splay(i, t.left, comparator);
      x.right = t.right;
    }
    tree._size--;
    return x;
  }
  return t;                         /* It wasn't there */
}


function split (key, v, comparator) {
  var left, right;
  if (v === null) {
    left = right = null;
  } else {
    v = splay(key, v, comparator);

    var cmp = comparator(v.key, key);
    if (cmp === 0) {
      left  = v.left;
      right = v.right;
    } else if (cmp < 0) {
      right   = v.right;
      v.right = null;
      left    = v;
    } else {
      left   = v.left;
      v.left = null;
      right  = v;
    }
  }
  return { left: left, right: right };
}


function merge (left, right, comparator) {
  if (right === null) { return left; }
  if (left  === null) { return right; }

  right = splay(left.key, right, comparator);
  right.left = left;
  return right;
}


/**
 * Prints level of the tree
 * @param  {Node}                        root
 * @param  {String}                      prefix
 * @param  {Boolean}                     isTail
 * @param  {Array<string>}               out
 * @param  {Function(node:Node):String}  printNode
 */
function printRow (root, prefix, isTail, out, printNode) {
  if (root) {
    out(("" + prefix + (isTail ? ' ' : ' ') + (printNode(root)) + "\n"));
    var indent = prefix + (isTail ? '    ' : '   ');
    if (root.left)  { printRow(root.left,  indent, false, out, printNode); }
    if (root.right) { printRow(root.right, indent, true,  out, printNode); }
  }
}


var Tree = function Tree (comparator) {
  if ( comparator === void 0 ) comparator = DEFAULT_COMPARE;

  this._comparator = comparator;
  this._root = null;
  this._size = 0;
};

var prototypeAccessors = { size: { configurable: true } };


/**
 * Inserts a key, allows duplicates
 * @param{Key}  key
 * @param{Value=} data
 * @return {Node|null}
 */
Tree.prototype.insert = function insert$1 (key, data) {
  return this._root = insert(key, data, this._root, this._comparator, this);
};


/**
 * Adds a key, if it is not present in the tree
 * @param{Key}  key
 * @param{Value=} data
 * @return {Node|null}
 */
Tree.prototype.add = function add$1 (key, data) {
  return this._root = add(key, data, this._root, this._comparator, this);
};


/**
 * @param{Key} key
 * @return {Node|null}
 */
Tree.prototype.remove = function remove$1 (key) {
  this._root = remove(key, this._root, this._comparator, this);
};


/**
 * Removes and returns the node with smallest key
 * @return {?Node}
 */
Tree.prototype.pop = function pop () {
  var node = this._root;
  if (node) {
    while (node.left) { node = node.left; }
    this._root = splay(node.key,this._root, this._comparator);
    this._root = remove(node.key, this._root, this._comparator, this);
    return { key: node.key, data: node.data };
  }
  return null;
};


/**
 * @param{Key} key
 * @return {Node|null}
 */
Tree.prototype.findStatic = function findStatic (key) {
  var current = this._root;
  var compare = this._comparator;
  while (current) {
    var cmp = compare(key, current.key);
    if (cmp === 0)  { return current; }
    else if (cmp < 0) { current = current.left; }
    else            { current = current.right; }
  }
  return null;
};


/**
 * @param{Key} key
 * @return {Node|null}
 */
Tree.prototype.find = function find (key) {
  if (this._root) {
    this._root = splay(key, this._root, this._comparator);
    if (this._comparator(key, this._root.key) !== 0) { return null; }
  }
  return this._root;
};


/**
 * @param{Key} key
 * @return {Boolean}
 */
Tree.prototype.contains = function contains (key) {
  var current = this._root;
  var compare = this._comparator;
  while (current) {
    var cmp = compare(key, current.key);
    if (cmp === 0)  { return true; }
    else if (cmp < 0) { current = current.left; }
    else            { current = current.right; }
  }
  return false;
};


/**
 * @param{Visitor} visitor
 * @param{*=}    ctx
 * @return {SplayTree}
 */
Tree.prototype.forEach = function forEach (visitor, ctx) {
  var current = this._root;
  var Q = [];/* Initialize stack s */
  var done = false;

  while (!done) {
    if (current !==null) {
      Q.push(current);
      current = current.left;
    } else {
      if (Q.length !== 0) {
        current = Q.pop();
        visitor.call(ctx, current);

        current = current.right;
      } else { done = true; }
    }
  }
  return this;
};


/**
 * Walk key range from `low` to `high`. Stops if `fn` returns a value.
 * @param{Key}    low
 * @param{Key}    high
 * @param{Function} fn
 * @param{*?}     ctx
 * @return {SplayTree}
 */
Tree.prototype.range = function range (low, high, fn, ctx) {
    var this$1 = this;

  var Q = [];
  var compare = this._comparator;
  var node = this._root, cmp;

  while (Q.length !== 0 || node) {
    if (node) {
      Q.push(node);
      node = node.left;
    } else {
      node = Q.pop();
      cmp = compare(node.key, high);
      if (cmp > 0) {
        break;
      } else if (compare(node.key, low) >= 0) {
        if (fn.call(ctx, node)) { return this$1; } // stop if smth is returned
      }
      node = node.right;
    }
  }
  return this;
};


/**
 * Returns array of keys
 * @return {Array<Key>}
 */
Tree.prototype.keys = function keys () {
  var keys = [];
  this.forEach(function (ref) {
      var key = ref.key;

      return keys.push(key);
    });
  return keys;
};


/**
 * Returns array of all the data in the nodes
 * @return {Array<Value>}
 */
Tree.prototype.values = function values () {
  var values = [];
  this.forEach(function (ref) {
      var data = ref.data;

      return values.push(data);
    });
  return values;
};


/**
 * @return {Key|null}
 */
Tree.prototype.min = function min () {
  if (this._root) { return this.minNode(this._root).key; }
  return null;
};


/**
 * @return {Key|null}
 */
Tree.prototype.max = function max () {
  if (this._root) { return this.maxNode(this._root).key; }
  return null;
};


/**
 * @return {Node|null}
 */
Tree.prototype.minNode = function minNode (t) {
    if ( t === void 0 ) t = this._root;

  if (t) { while (t.left) { t = t.left; } }
  return t;
};


/**
 * @return {Node|null}
 */
Tree.prototype.maxNode = function maxNode (t) {
    if ( t === void 0 ) t = this._root;

  if (t) { while (t.right) { t = t.right; } }
  return t;
};


/**
 * Returns node at given index
 * @param{number} index
 * @return {?Node}
 */
Tree.prototype.at = function at (index) {
  var current = this._root, done = false, i = 0;
  var Q = [];

  while (!done) {
    if (current) {
      Q.push(current);
      current = current.left;
    } else {
      if (Q.length > 0) {
        current = Q.pop();
        if (i === index) { return current; }
        i++;
        current = current.right;
      } else { done = true; }
    }
  }
  return null;
};


/**
 * @param{Node} d
 * @return {Node|null}
 */
Tree.prototype.next = function next (d) {
  var root = this._root;
  var successor = null;

  if (d.right) {
    successor = d.right;
    while (successor.left) { successor = successor.left; }
    return successor;
  }

  var comparator = this._comparator;
  while (root) {
    var cmp = comparator(d.key, root.key);
    if (cmp === 0) { break; }
    else if (cmp < 0) {
      successor = root;
      root = root.left;
    } else { root = root.right; }
  }

  return successor;
};


/**
 * @param{Node} d
 * @return {Node|null}
 */
Tree.prototype.prev = function prev (d) {
  var root = this._root;
  var predecessor = null;

  if (d.left !== null) {
    predecessor = d.left;
    while (predecessor.right) { predecessor = predecessor.right; }
    return predecessor;
  }

  var comparator = this._comparator;
  while (root) {
    var cmp = comparator(d.key, root.key);
    if (cmp === 0) { break; }
    else if (cmp < 0) { root = root.left; }
    else {
      predecessor = root;
      root = root.right;
    }
  }
  return predecessor;
};


/**
 * @return {SplayTree}
 */
Tree.prototype.clear = function clear () {
  this._root = null;
  this._size = 0;
  return this;
};


/**
 * @return {NodeList}
 */
Tree.prototype.toList = function toList$1 () {
  return toList(this._root);
};


/**
 * Bulk-load items. Both array have to be same size
 * @param{Array<Key>}  keys
 * @param{Array<Value>}[values]
 * @param{Boolean}     [presort=false] Pre-sort keys and values, using
 *                                       tree's comparator. Sorting is done
 *                                       in-place
 * @return {AVLTree}
 */
Tree.prototype.load = function load (keys, values, presort) {
    if ( keys === void 0 ) keys = [];
    if ( values === void 0 ) values = [];
    if ( presort === void 0 ) presort = false;

  var size = keys.length;
  var comparator = this._comparator;

  // sort if needed
  if (presort) { sort(keys, values, 0, size - 1, comparator); }

  if (this._root === null) { // empty tree
    this._root = loadRecursive(this._root, keys, values, 0, size);
    this._size = size;
  } else { // that re-builds the whole tree from two in-order traversals
    var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);
    size = this._size + size;
    this._root = sortedListToBST({ head: mergedList }, 0, size);
  }
  return this;
};


/**
 * @return {Boolean}
 */
Tree.prototype.isEmpty = function isEmpty () { return this._root === null; };

prototypeAccessors.size.get = function () { return this._size; };


/**
 * @param{NodePrinter=} printNode
 * @return {String}
 */
Tree.prototype.toString = function toString (printNode) {
    if ( printNode === void 0 ) printNode = function (n) { return n.key; };

  var out = [];
  printRow(this._root, '', true, function (v) { return out.push(v); }, printNode);
  return out.join('');
};


Tree.prototype.update = function update (key, newKey, newData) {
  var comparator = this._comparator;
  var ref = split(key, this._root, comparator);
    var left = ref.left;
    var right = ref.right;
  this._size--;
  if (comparator(key, newKey) < 0) {
    right = insert(newKey, newData, right, comparator, this);
  } else {
    left = insert(newKey, newData, left, comparator, this);
  }
  this._root = merge(left, right, comparator);
};


Tree.prototype.split = function split$1 (key) {
  return split(key, this._root, this._comparator);
};

Object.defineProperties( Tree.prototype, prototypeAccessors );


function loadRecursive (parent, keys, values, start, end) {
  var size = end - start;
  if (size > 0) {
    var middle = start + Math.floor(size / 2);
    var key    = keys[middle];
    var data   = values[middle];
    var node   = { key: key, data: data, parent: parent };
    node.left    = loadRecursive(node, keys, values, start, middle);
    node.right   = loadRecursive(node, keys, values, middle + 1, end);
    return node;
  }
  return null;
}


function createList(keys, values) {
  var head = { next: null };
  var p = head;
  for (var i = 0; i < keys.length; i++) {
    p = p.next = { key: keys[i], data: values[i] };
  }
  p.next = null;
  return head.next;
}


function toList (root) {
  var current = root;
  var Q = [], done = false;

  var head = { next: null };
  var p = head;

  while (!done) {
    if (current) {
      Q.push(current);
      current = current.left;
    } else {
      if (Q.length > 0) {
        current = p = p.next = Q.pop();
        current = current.right;
      } else { done = true; }
    }
  }
  p.next = null; // that'll work even if the tree was empty
  return head.next;
}


function sortedListToBST(list, start, end) {
  var size = end - start;
  if (size > 0) {
    var middle = start + Math.floor(size / 2);
    var left = sortedListToBST(list, start, middle);

    var root = list.head;
    root.left = left;

    list.head = list.head.next;

    root.right = sortedListToBST(list, middle + 1, end);
    return root;
  }
  return null;
}


function mergeLists (l1, l2, compare) {
  if ( compare === void 0 ) compare = function (a, b) { return a - b; };

  var head = {}; // dummy
  var p = head;

  var p1 = l1;
  var p2 = l2;

  while (p1 !== null && p2 !== null) {
    if (compare(p1.key, p2.key) < 0) {
      p.next = p1;
      p1 = p1.next;
    } else {
      p.next = p2;
      p2 = p2.next;
    }
    p = p.next;
  }

  if (p1 !== null)      { p.next = p1; }
  else if (p2 !== null) { p.next = p2; }

  return head.next;
}


function sort(keys, values, left, right, compare) {
  if (left >= right) { return; }

  var pivot = keys[(left + right) >> 1];
  var i = left - 1;
  var j = right + 1;

  while (true) {
    do { i++; } while (compare(keys[i], pivot) < 0);
    do { j--; } while (compare(keys[j], pivot) > 0);
    if (i >= j) { break; }

    var tmp = keys[i];
    keys[i] = keys[j];
    keys[j] = tmp;

    tmp = values[i];
    values[i] = values[j];
    values[j] = tmp;
  }

  sort(keys, values,  left,     j, compare);
  sort(keys, values, j + 1, right, compare);
}

function createEventQueue(byY) {
  var q = new Tree(byY);

  return {
    isEmpty: isEmpty,
    size: size,
    pop: pop,
    find: find,
    insert: insert
  }

  function find(p) {
    return q.find(p);
  }

  function size() {
    return q.size;
  }

  function isEmpty() {
    return q.isEmpty();
  }

  function insert(event) {
    // debugger;
    q.add(event.point, event);
  }

  function pop() {
    var node = q.pop();
    return node && node.data;
  }
}

/**
 * Just a collection of geometry related utilities
 */

// This is used for precision checking (e.g. two numbers are equal
// if their difference is smaller than this number). The value is 
// chosen empirically. We still may run into precision related issues.
// TODO: we should allow consumers to configure this.
var EPS = 1e-9;//10;

function getIntersectionXPoint(segment, xPos, yPos) {
  var dy1 = segment.from.y - yPos;
  var dy2 = yPos - segment.to.y;
  var dy = segment.to.y - segment.from.y;
  if (Math.abs(dy1) < EPS) {
    // The segment starts on the sweep line
    if (Math.abs(dy) < EPS) {
      // the segment is horizontal. Intersection is at the point
      if (xPos <= segment.from.x) { return segment.from.x; }
      if (xPos > segment.to.x) { return segment.to.x; }
      return xPos;
    }
    return segment.from.x;
  }
  
  var dx = (segment.to.x - segment.from.x); 
  var xOffset; 
  if (dy1 >= dy2) {
    xOffset = dy1 * (dx / dy); 
    return (segment.from.x - xOffset);
  } 
  xOffset = dy2 * (dx / dy);
  return (segment.to.x + xOffset);
}

function angle(dx, dy) {
  // https://stackoverflow.com/questions/16542042/fastest-way-to-sort-vectors-by-angle-without-actually-computing-that-angle
  var p = dx/(Math.abs(dx) + Math.abs(dy)); // -1 .. 1 increasing with x

  if (dy < 0) { return p - 1; }  // -2 .. 0 increasing with x
  return 1 - p               //  0 .. 2 decreasing with x
}

function intersectSegments(a, b) {
  //  https://stackoverflow.com/a/1968345/125351
  var aStart = a.from, bStart = b.from;
  var p0_x = aStart.x, p0_y = aStart.y,
      p2_x = bStart.x, p2_y = bStart.y;

  var s1_x = a.dx, s1_y = a.dy, s2_x = b.dx, s2_y = b.dy;
  var div = s1_x * s2_y - s2_x * s1_y;

  var s = (s1_y * (p0_x - p2_x) - s1_x * (p0_y - p2_y)) / div;
  if (s < 0 || s > 1) { return; }

  var t = (s2_x * (p2_y - p0_y) + s2_y * (p0_x - p2_x)) / div;

  if (t >= 0 && t <= 1) {
    return {
      x: p0_x - (t * s1_x),
      y: p0_y - (t * s1_y)
    }
  }
}

function samePoint(a, b) {
  return Math.abs(a.x - b.x) < EPS && Math.abs(a.y - b.y) < EPS;
}

/**
 * Creates a new sweep status data structure.
 */
function createSweepStatus(onError, EPS$$1) {
  var lastPointY, prevY;
  var lastPointX, prevX;
  var useBelow = false;
  var status = new Tree(compareSegments);

  // To save on GC we return mutable object.
  var currentBoundary = {
    beforeLeft: null,
    left: null,
    right: null,
    afterRight: null,
  };

  var currentLeftRight = {left: null, right: null};

  return {
    /**
     * Add new segments into the status tree.
     */
    insertSegments: insertSegments,

    /**
     * Remove segments from the status tree.
     */
    deleteSegments: deleteSegments,

    /**
     * Returns segments that are to the left and right from a given point.
     */
    getLeftRightPoint: getLeftRightPoint,

    /**
     * For a given collections of segments finds the most left and the most right
     * segments. Also returns segments immediately before left, and after right segments.
     */
    getBoundarySegments: getBoundarySegments,

    findSegmentsWithPoint: findSegmentsWithPoint,

    /**
     * Current binary search tree with segments
     */
    status: status,

    /**
     * Introspection method that verifies if there are duplicates in the segment tree.
     * If there are - `onError()` is called.
     */
    checkDuplicate: checkDuplicate,

    /**
     * Prints current segments in order of their intersection with sweep line. Introspection method.
     */
    printStatus: printStatus,

    /**
     * Returns current position of the sweep line.
     */
    getLastPoint: function getLastPoint() {
      return {x: lastPointX, y: lastPointY};
    }
  }

  function compareSegments(a, b) {
    if (a === b) { return 0; }

    var ak = getIntersectionXPoint(a, lastPointX, lastPointY);
    var bk = getIntersectionXPoint(b, lastPointX, lastPointY);

    var res = ak - bk;
    if (Math.abs(res) >= EPS$$1) {
      // We are okay fine. Intersection distance between two segments
      // is good to give conclusive answer
      return res;
    }

    var aIsHorizontal = Math.abs(a.dy) < EPS$$1;
    var bIsHorizontal = Math.abs(b.dy) < EPS$$1;
    if (aIsHorizontal && bIsHorizontal) {
      return b.to.x - a.to.x;
    }
    // TODO: What if both a and b is horizontal?
    // move horizontal to end
    if (aIsHorizontal) { 
      return useBelow ? -1 : 1;
    }

    if (bIsHorizontal) {
      if (useBelow) {
        return (b.from.x >= lastPointX) ? -1 : 1
      }
      return -1;
      // return useBelow ? 1 : -1;
    }
    var pa = a.angle;
    var pb = b.angle;
    if (Math.abs(pa - pb) >= EPS$$1) {
      return useBelow ? pa - pb : pb - pa;
    }

    var segDist = a.from.y - b.from.y;
    if (Math.abs(segDist) >= EPS$$1) {
      return -segDist;
    }
    segDist = a.to.y - b.to.y;
    if (Math.abs(segDist) >= EPS$$1) {
      // TODO: Is this accurate?
      return -segDist;
    }

    return 0;
    // Could also use:
    // var aAngle = Math.atan2(a.from.y - a.to.y, a.from.x - a.to.x);
    // var bAngle = Math.atan2(b.from.y - b.to.y, b.from.x - b.to.x);
    // return useBelow ? bAngle - aAngle : aAngle - bAngle;
  }

  function getBoundarySegments(upper, interior) {
    var leftMost, rightMost, i;
    var uLength = upper.length;

    if (uLength > 0) {
      leftMost = rightMost = upper[0];
    } else {
      leftMost = rightMost = interior[0];
    }

    for (i = 1; i < uLength; ++i) {
      var s = upper[i];
      var cmp = compareSegments(leftMost, s);
      if (cmp > 0) { leftMost = s; }

      cmp = compareSegments(rightMost, s);
      if (cmp < 0) { rightMost = s; }
    }

    var startFrom = uLength > 0 ? 0 : 1;
    for (i = startFrom; i < interior.length; ++i) {
      s = interior[i];
      cmp = compareSegments(leftMost, s);
      if (cmp > 0) { leftMost = s; }

      cmp = compareSegments(rightMost, s);
      if (cmp < 0) { rightMost = s; }
    }

    // at this point we have our left/right segments in the status.
    // Let's find their prev/next elements and report them back:
    var left = status.find(leftMost);
    if (!left) {
      onError('Left is missing. Precision error?');
    }

    var right = status.find(rightMost);
    if (!right) {
      onError('Right is missing. Precision error?');
    }

    var beforeLeft = left && status.prev(left);
    var afterRight = right && status.next(right);

    while (afterRight && right.key.dy === 0 && afterRight.key.dy === 0) {
      // horizontal segments are special :(
      afterRight = status.next(afterRight);
    }

    currentBoundary.beforeLeft = beforeLeft && beforeLeft.key;
    currentBoundary.left = left && left.key;
    currentBoundary.right = right && right.key;
    currentBoundary.afterRight = afterRight && afterRight.key;

    return currentBoundary;
  }

  function getLeftRightPoint(p) {
    // We are trying to find left and right segments that are nearest to the
    // point p. For this we traverse the binary search tree, and remember
    // node with the shortest distance to p.
    var lastLeft;
    var current = status._root;
    var minX = Number.POSITIVE_INFINITY;
    while (current) {
      var x = getIntersectionXPoint(current.key, p.x, p.y);
      var dx = p.x - x;
      if (dx >= 0) {
        if (dx < minX) {
          minX = dx;
          lastLeft = current;
          current = current.left;
        } else {
          break;
        }
      } else {
        if (-dx < minX) {
          minX = -dx;
          lastLeft = current;
          current = current.right;
        } else {
          break;
        }
      }
    }

    currentLeftRight.left = lastLeft && lastLeft.key;
    var next = lastLeft && status.next(lastLeft);
    currentLeftRight.right = next && next.key;
    return currentLeftRight;

    // Conceptually, the code above should be equivalent to the code below;
    // The code below is easier to understand, but intuitively, the code above
    // should have better performance (as we do not traverse the entire status
    // tree)

    // var right, left,  x;
    // var all = status.keys()
    // for (var i = 0; i < all.length; ++i) {
    //   var segment = all[i];
    //   x = getIntersectionXPoint(segment, p.x, p.y);
    //   if (x > p.x && !right) {
    //     right = segment;
    //     break;
    //   } else if (x < p.x) {
    //     left = segment;
    //   }
    // }

    // currentLeftRight.left = left;
    // currentLeftRight.right = right;

    // return currentLeftRight;
  }

  function findSegmentsWithPoint(p, onFound) {
    // Option 1.
    // var arrResults = [];
    // status.forEach(current => {
    //   var x = getIntersectionXPoint(current.key, p.x, p.y);
    //   var dx = p.x - x;
    //   if (Math.abs(dx) < EPS) {
    //     onFound(current.key);
    //    // arrResults.push(current.key)
    //   }
    // });
    // return arrResults;

    // Option 2.

    // let current = status._root;
    // const Q = [];  /* Initialize stack s */
    // let done = false;
    // var res = [];
    // var breakEarly = false;

    // while (!done) {
    //   if (current !==  null) {
    //     Q.push(current);
    //     current = current.left;
    //   } else {
    //     if (Q.length !== 0) {
    //       current = Q.pop();

    //       var x = getIntersectionXPoint(current.key, p.x, p.y);
    //       var dx = p.x - x;
    //       if (Math.abs(dx) < EPS) {
    //         res.push(current.key)
    //         breakEarly = true;
    //       } else if (breakEarly) {
    //         done = true;
    //       }

    //       current = current.right;
    //     } else done = true;
    //   }
    // }

    // return res;

    // option 3.
    var current = status._root;

    while (current) {
      var x = getIntersectionXPoint(current.key, p.x, p.y);
      var dx = p.x - x;
      if (Math.abs(dx) < EPS$$1) {
        collectAdjacentNodes(current, p, onFound);
        break;
      } else if (dx < 0) {
        current = current.left;
      } else {
        current = current.right;
      }
    }
  }

  function collectAdjacentNodes(root, p, onFound) {
    onFound(root.key);
    goOverPredecessors(root.left, p, onFound);
    goOverSuccessors(root.right, p, onFound);
  }

  function goOverPredecessors(root, p, res) {
    if (!root) { return; }
    var x = getIntersectionXPoint(root.key, p.x, p.y);
    var dx = p.x - x;
    if (Math.abs(dx) < EPS$$1) {
      collectAdjacentNodes(root, p, res);
    } else {
      goOverPredecessors(root.right, p, res);
    }
  }

  function goOverSuccessors(root, p, res) {
    if (!root) { return; }
    var x = getIntersectionXPoint(root.key, p.x, p.y);
    var dx = p.x - x;
    if (Math.abs(dx) < EPS$$1) {
      collectAdjacentNodes(root, p, res);
    } else {
      goOverSuccessors(root.left, p, res);
    }
  }

  function checkDuplicate() {
    var prev;
    status.forEach(function (node) {
      var current = node.key;

      if (prev) {
        if (samePoint(prev.from, current.from) && samePoint(prev.to, current.to)) {
          // Likely you have received error before during segment removal.
          onError('Duplicate key in the status! This may be caused by Floating Point rounding error');
        }
      }
      prev = current;
    });
  }

  function printStatus(prefix) {
    if ( prefix === void 0 ) prefix = '';

    // eslint-disable-next-line
    console.log(prefix, 'status line: ', lastPointX, lastPointY);
    status.forEach(function (node) {
      var x = getIntersectionXPoint(node.key, lastPointX, lastPointY);
      // eslint-disable-next-line
      console.log(x + ' ' + node.key.name);
    });
  }

  function insertSegments(interior, upper, sweepLinePos) {
    lastPointY = sweepLinePos.y;
    lastPointX = sweepLinePos.x;
    var key;

    for (var i = 0; i < interior.length; ++i) {
      key = interior[i];
      status.add(key);
    }
    for (i = 0; i < upper.length; ++i) {
      key = upper[i];
      status.add(key);
    }
  }

  function deleteSegments(lower, interior, sweepLinePos) {
    // I spent most of the time debugging this method. Depending on the
    // algorithm state we can run into situation when dynamic keys of the
    // `status` tree predict wrong branch, and thus we are not able to find
    // the segment that needs to be deleted. If that happens I'm trying to
    // use previous point and repeat the process. This may result in 
    // incorrect state. In that case I report an error. 
    var i;
    var prevCount = status._size;
    prevX = lastPointX;
    prevY = lastPointY;
    lastPointY = sweepLinePos.y;
    lastPointX = sweepLinePos.x;

    useBelow = true;
    for(i = 0; i < lower.length; ++i) {
      removeSegment(lower[i], sweepLinePos);
    }
    for(i = 0; i < interior.length; ++i) {
      removeSegment(interior[i], sweepLinePos);
    }
    useBelow = false;

    if (status._size !== prevCount - interior.length - lower.length) {
      // This can happen when rounding error occurs. You can try scaling your input
      onError('Segments were not removed from a tree properly. Precision error?');
    }
  }

  function removeSegment(key, sweepLinePos) {
    if (status.find(key)) {
      status.remove(key);
    } else {
      lastPointX = prevX;
      lastPointY = prevY;
      if (status.find(key)) {
        status.remove(key);
      }
      lastPointY = sweepLinePos.y;
      lastPointX = sweepLinePos.x;
    }
  }
}

/**
 * Represents a single event in the sweep-line algorithm
 */
var SweepEvent = function SweepEvent(point, segment) {
  this.point = point;
  if (segment) { this.from = [segment]; }
};

/**
 * A point on a line
 * 
 * @typedef {Object} Point
 * @property {number} x coordinate
 * @property {number} y coordinate
 */


/**
 * @typedef {Object} Segment 
 * @property {Point} from start of the segment
 * @property {Point} to end of the segment
 */

/**
 * @typedef {function(point : Point, interior : Segment[], lower : Segment[], upper : Segment[])} ReportIntersectionCallback
 */

/**
 * @typedef {Object} ISectOptions 
 * @property {ReportIntersectionCallback} onFound 
 */

 /**
  * @typedef {Object} ISectResult
  */

// We use EMPTY array to avoid pressure on garbage collector. Need to be
// very cautious to not mutate this array.
var EMPTY = [];

/**
 * Finds all intersections among given segments.
 * 
 * The algorithm follows "Computation Geometry, Algorithms and Applications" book
 * by Mark de Berg, Otfried Cheong, Marc van Kreveld, and Mark Overmars.
 * 
 * Line is swept top-down
 * 
 * @param {Segment[]} segments
 * @param {ISectOptions=} options
 * @returns {ISectResult}
 */
function isect(segments, options) {
  var results = [];
  var reportIntersection = (options && options.onFound) || defaultIntersectionReporter;

  var onError = (options && options.onError) || defaultErrorReporter;

  var eventQueue = createEventQueue(byY);
  var sweepStatus = createSweepStatus(onError, EPS);
  var lower, interior, lastPoint;

  segments.forEach(addSegment);

  return {
    /**
     * Find all intersections synchronously.
     * 
     * @returns array of found intersections.
     */
    run: run,

    /**
     * Performs a single step in the sweep line algorithm
     * 
     * @returns true if there was something to process; False if no more work to do
     */
    step: step,

    // Methods below are low level API for fine-grained control.
    // Don't use it unless you understand this code thoroughly

    /**
     * Add segment into the 
     */
    addSegment: addSegment,

    /**
     * Direct access to event queue. Queue contains segment endpoints and
     * pending detected intersections.
     */
    eventQueue: eventQueue, 

    /**
     * Direct access to sweep line status. "Status" holds information about
     * all intersected segments.
     */
    sweepStatus: sweepStatus,

    /**
     * Access to results array. Works only when you use default onFound() handler
     */
    results: results
  }

  function run() {
    while (!eventQueue.isEmpty()) {
      var eventPoint = eventQueue.pop();
      if (handleEventPoint(eventPoint)) {
        // they decided to stop.
        return;
      }    }

    return results;
  }

  function step() {
    if (!eventQueue.isEmpty()) {
      var eventPoint = eventQueue.pop();
      handleEventPoint(eventPoint);
      // Note: we don't check results of `handleEventPoint()`
      // assumption is that client controls `step()` and thus they 
      // know better if they want to stop.
      return true;
    }
    return false;
  }

  function handleEventPoint(p) {
    lastPoint = p.point;
    var upper = p.from || EMPTY;

    lower = interior = undefined;
    // TODO: move lower/interior into sweep status method?

    sweepStatus.findSegmentsWithPoint(lastPoint, addLowerOrInterior);
    // if (segmentsWithPoint) {
    //   segmentsWithPoint.forEach()
    // } 

    if (!lower) { lower = EMPTY; }
    if (!interior) { interior = EMPTY; }

    var uLength = upper.length;
    var iLength = interior.length;
    var lLength = lower.length;
    var hasIntersection = uLength + iLength + lLength > 1;
    var hasPointIntersection = !hasIntersection && (uLength === 0 && lLength === 0 && iLength > 0);

    if (hasIntersection || hasPointIntersection) {
      p.isReported = true;
      if (reportIntersection(lastPoint, union(interior, union(lower, upper)))) {
        return true;
      }
    }

    sweepStatus.deleteSegments(lower, interior, lastPoint);
    sweepStatus.insertSegments(interior, upper, lastPoint);

    var sLeft, sRight;

    var hasNoCrossing = (uLength + iLength === 0);

    if (hasNoCrossing) {
      var leftRight = sweepStatus.getLeftRightPoint(lastPoint);
      sLeft = leftRight.left;
      if (!sLeft) { return; }

      sRight = leftRight.right;
      if (!sRight) { return; }

      findNewEvent(sLeft, sRight, p);
    } else {
      var boundarySegments = sweepStatus.getBoundarySegments(upper, interior);

      findNewEvent(boundarySegments.beforeLeft, boundarySegments.left, p);
      findNewEvent(boundarySegments.right, boundarySegments.afterRight, p);
    }

    return false;
  }

  function addLowerOrInterior(s) {
    if (samePoint(s.to, lastPoint)) {
      if (!lower) { lower = [s]; }
      else { lower.push(s); }
    } else if (!samePoint(s.from, lastPoint)) {
      if (!interior) { interior = [s]; }
      else { interior.push(s); }
    }
  }

  function findNewEvent(left, right, p) {
    if (!left || !right) { return; }

    var intersection = intersectSegments(left, right);
    if (!intersection) {
        return;
    }

    var dy = p.point.y - intersection.y;
    // TODO: should I add dy to intersection.y?
    if (dy < -EPS) {
      // this means intersection happened after the sweep line. 
      // We already processed it.
      return;
    }
    if (Math.abs(dy) < EPS && intersection.x <= p.point.x) {
      return;
    }

    // Need to adjust floating point for this special case,
    // since otherwise it gives rounding errors:
    roundNearZero(intersection);

    var current = eventQueue.find(intersection);

    if (current && current.isReported) {
      // We already reported this event. No need to add it one more time
      // TODO: Is this case even possible?
      onError('We already reported this event.');
      return;
    }

    if (!current) {
      var event = new SweepEvent(intersection);
      eventQueue.insert(event);
    }
  }

  function defaultIntersectionReporter(p, segments) {
    results.push({
      point: p, 
      segments: segments
    });
  }

  function addSegment(segment) {
    var from = segment.from;
    var to = segment.to;

    // Small numbers give more precision errors. Rounding them to 0.
    roundNearZero(from);
    roundNearZero(to);

    var dy = from.y - to.y;

    // Note: dy is much smaller then EPS on purpose. I found that higher
    // precision here does less good - getting way more rounding errors.
    if (Math.abs(dy) < 1e-5) {
      from.y = to.y;
      segment.dy = 0;
    }
    if ((from.y < to.y) || (
        (from.y === to.y) && (from.x > to.x))
      ) {
      var temp = from;
      from = segment.from = to; 
      to = segment.to = temp;
    }

    // We pre-compute some immutable properties of the segment
    // They are used quite often in the tree traversal, and pre-computation
    // gives significant boost:
    segment.dy = from.y - to.y;
    segment.dx = from.x - to.x;
    segment.angle = angle(segment.dy, segment.dx);

    var isPoint = segment.dy === segment.dx && segment.dy === 0;
    var prev = eventQueue.find(from);
    if (prev && !isPoint) {
      // this detects identical segments early. Without this check
      // the algorithm would break since sweep line has no means to
      // detect identical segments.
      var prevFrom = prev.data.from;
      if (prevFrom) {
        for (var i = 0; i < prevFrom.length; ++i) {
          var s = prevFrom[i];
          if (samePoint(s.to, to)) {
            reportIntersection(s.from, [s.from, s.to]);
            reportIntersection(s.to, [s.from, s.to]);
            return;
          }
        }
      }
    }

    if (!isPoint) {
      if (prev) {
        if (prev.data.from) { prev.data.from.push(segment); }
        else { prev.data.from = [segment]; }
      } else {
        var e = new SweepEvent(from, segment);
        eventQueue.insert(e);
      }
      var event = new SweepEvent(to);
      eventQueue.insert(event);
    } else {
      var event = new SweepEvent(to);
      eventQueue.insert(event);
    }
  } 
}

function roundNearZero(point) {
  if (Math.abs(point.x) < EPS) { point.x = 0; }
  if (Math.abs(point.y) < EPS) { point.y = 0; }
}

function defaultErrorReporter(errorMessage) {
  throw new Error(errorMessage);
}

function union(a, b) {
  if (!a) { return b; }
  if (!b) { return a; }

  return a.concat(b);
}

function byY(a, b) {
  // decreasing Y 
  var res = b.y - a.y;
  // TODO: This might mess up the status tree.
  if (Math.abs(res) < EPS) {
    // increasing x.
    res = a.x - b.x;
    if (Math.abs(res) < EPS) { res = 0; }
  }

  return res;
}

function intersectSegments$1(a, b) {
  // Note: this is almost the same as geom.intersectSegments()
  // The main difference is that we don't have a pre-computed
  // value for dx/dy on the segments.
  //  https://stackoverflow.com/a/1968345/125351
  var aStart = a.from, bStart = b.from;
  var p0_x = aStart.x, p0_y = aStart.y,
      p2_x = bStart.x, p2_y = bStart.y;

  var s1_x = a.from.x - a.to.x, s1_y = a.from.y - a.to.y, s2_x = b.from.x - b.to.x, s2_y = b.from.y - b.to.y;
  var div = s1_x * s2_y - s2_x * s1_y;

  var s = (s1_y * (p0_x - p2_x) - s1_x * (p0_y - p2_y)) / div;
  if (s < 0 || s > 1) { return; }

  var t = (s2_x * (p2_y - p0_y) + s2_y * (p0_x - p2_x)) / div;

  if (t >= 0 && t <= 1) {
    return {
      x: p0_x - (t * s1_x),
      y: p0_y - (t * s1_y)
    }
  }
}

/**
 * This is a brute force solution with O(n^2) performance.
 * (`n` is number of segments).
 * 
 * Use this when number of lines is low, and number of intersections
 * is high.
 */
function brute(lines, options) {
  var results = [];
  var reportIntersection = (options && options.onFound) || 
                            defaultIntersectionReporter;
  var asyncState;

  return {
    /**
     * Execute brute force of the segment intersection search
     */
    run: run,
    /**
     * Access to results array. Works only when you use default onFound() handler
     */
    results: results,

    /**
     * Performs a single step in the brute force algorithm ()
     */
    step: step
  }

  function step() {
    if (!asyncState) {
      asyncState = {
        i: 0
      };
    }
    var test = lines[asyncState.i];
    for (var j = asyncState.i + 1; j < lines.length; ++j) {
      var other = lines[j];
      var pt = intersectSegments$1(test, other);
      if (pt) {
        if (reportIntersection(pt, [test, other])) {
          return;
        }
      }
    }
    asyncState.i += 1;
    return asyncState.i < lines.length;
  }

  function run() {
    for(var i = 0; i < lines.length; ++i) {
      var test = lines[i];
      for (var j = i + 1; j < lines.length; ++j) {
        var other = lines[j];
        var pt = intersectSegments$1(test, other);
        if (pt) {
          if (reportIntersection(pt, [test, other])) {
            return;
          }
        }
      }
    }
    return results;
  }

  function defaultIntersectionReporter(p, interior) {
    results.push({
      point: p, 
      segments: interior
    });
  }
}

var ARRAY_TYPES = [
    Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,
    Int32Array, Uint32Array, Float32Array, Float64Array
];

var VERSION = 3; // serialized format version

var Flatbush = function Flatbush(numItems, nodeSize, ArrayType, data) {
    var this$1 = this;

    if (numItems === undefined) { throw new Error('Missing required argument: numItems.'); }
    if (isNaN(numItems) || numItems <= 0) { throw new Error(("Unpexpected numItems value: " + numItems + ".")); }

    this.numItems = +numItems;
    this.nodeSize = Math.min(Math.max(+nodeSize || 16, 2), 65535);

    // calculate the total number of nodes in the R-tree to allocate space for
    // and the index of each tree level (used in search later)
    var n = numItems;
    var numNodes = n;
    this._levelBounds = [n * 4];
    do {
        n = Math.ceil(n / this$1.nodeSize);
        numNodes += n;
        this$1._levelBounds.push(numNodes * 4);
    } while (n !== 1);

    this.ArrayType = ArrayType || Float64Array;
    this.IndexArrayType = numNodes < 16384 ? Uint16Array : Uint32Array;

    var arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);
    var nodesByteSize = numNodes * 4 * this.ArrayType.BYTES_PER_ELEMENT;

    if (arrayTypeIndex < 0) {
        throw new Error(("Unexpected typed array class: " + ArrayType + "."));
    }

    if (data && (data instanceof ArrayBuffer)) {
        this.data = data;
        this._boxes = new this.ArrayType(this.data, 8, numNodes * 4);
        this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes);

        this._pos = numNodes * 4;
        this.minX = this._boxes[this._pos - 4];
        this.minY = this._boxes[this._pos - 3];
        this.maxX = this._boxes[this._pos - 2];
        this.maxY = this._boxes[this._pos - 1];

    } else {
        this.data = new ArrayBuffer(8 + nodesByteSize + numNodes * this.IndexArrayType.BYTES_PER_ELEMENT);
        this._boxes = new this.ArrayType(this.data, 8, numNodes * 4);
        this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes);
        this._pos = 0;
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;

        new Uint8Array(this.data, 0, 2).set([0xfb, (VERSION << 4) + arrayTypeIndex]);
        new Uint16Array(this.data, 2, 1)[0] = nodeSize;
        new Uint32Array(this.data, 4, 1)[0] = numItems;
    }
};

Flatbush.from = function from (data) {
    if (!(data instanceof ArrayBuffer)) {
        throw new Error('Data must be an instance of ArrayBuffer.');
    }
    var ref = new Uint8Array(data, 0, 2);
        var magic = ref[0];
        var versionAndType = ref[1];
    if (magic !== 0xfb) {
        throw new Error('Data does not appear to be in a Flatbush format.');
    }
    if (versionAndType >> 4 !== VERSION) {
        throw new Error(("Got v" + (versionAndType >> 4) + " data when expected v" + VERSION + "."));
    }
    var ref$1 = new Uint16Array(data, 2, 1);
        var nodeSize = ref$1[0];
    var ref$2 = new Uint32Array(data, 4, 1);
        var numItems = ref$2[0];

    return new Flatbush(numItems, nodeSize, ARRAY_TYPES[versionAndType & 0x0f], data);
};

Flatbush.prototype.add = function add (minX, minY, maxX, maxY) {
    var index = this._pos >> 2;
    this._indices[index] = index;
    this._boxes[this._pos++] = minX;
    this._boxes[this._pos++] = minY;
    this._boxes[this._pos++] = maxX;
    this._boxes[this._pos++] = maxY;

    if (minX < this.minX) { this.minX = minX; }
    if (minY < this.minY) { this.minY = minY; }
    if (maxX > this.maxX) { this.maxX = maxX; }
    if (maxY > this.maxY) { this.maxY = maxY; }
};

Flatbush.prototype.finish = function finish () {
        var this$1 = this;

    if (this._pos >> 2 !== this.numItems) {
        throw new Error(("Added " + (this._pos >> 2) + " items when expected " + (this.numItems) + "."));
    }

    var width = this.maxX - this.minX;
    var height = this.maxY - this.minY;
    var hilbertValues = new Uint32Array(this.numItems);
    var hilbertMax = (1 << 16) - 1;

    // map item centers into Hilbert coordinate space and calculate Hilbert values
    for (var i = 0; i < this.numItems; i++) {
        var pos = 4 * i;
        var minX = this$1._boxes[pos++];
        var minY = this$1._boxes[pos++];
        var maxX = this$1._boxes[pos++];
        var maxY = this$1._boxes[pos++];
        var x = Math.floor(hilbertMax * ((minX + maxX) / 2 - this$1.minX) / width);
        var y = Math.floor(hilbertMax * ((minY + maxY) / 2 - this$1.minY) / height);
        hilbertValues[i] = hilbert(x, y);
    }

    // sort items by their Hilbert value (for packing later)
    sort$1(hilbertValues, this._boxes, this._indices, 0, this.numItems - 1);

    // generate nodes at each tree level, bottom-up
    for (var i$1 = 0, pos$1 = 0; i$1 < this._levelBounds.length - 1; i$1++) {
        var end = this$1._levelBounds[i$1];

        // generate a parent node for each block of consecutive <nodeSize> nodes
        while (pos$1 < end) {
            var nodeMinX = Infinity;
            var nodeMinY = Infinity;
            var nodeMaxX = -Infinity;
            var nodeMaxY = -Infinity;
            var nodeIndex = pos$1;

            // calculate bbox for the new node
            for (var i$2 = 0; i$2 < this.nodeSize && pos$1 < end; i$2++) {
                var minX$1 = this$1._boxes[pos$1++];
                var minY$1 = this$1._boxes[pos$1++];
                var maxX$1 = this$1._boxes[pos$1++];
                var maxY$1 = this$1._boxes[pos$1++];
                if (minX$1 < nodeMinX) { nodeMinX = minX$1; }
                if (minY$1 < nodeMinY) { nodeMinY = minY$1; }
                if (maxX$1 > nodeMaxX) { nodeMaxX = maxX$1; }
                if (maxY$1 > nodeMaxY) { nodeMaxY = maxY$1; }
            }

            // add the new node to the tree data
            this$1._indices[this$1._pos >> 2] = nodeIndex;
            this$1._boxes[this$1._pos++] = nodeMinX;
            this$1._boxes[this$1._pos++] = nodeMinY;
            this$1._boxes[this$1._pos++] = nodeMaxX;
            this$1._boxes[this$1._pos++] = nodeMaxY;
        }
    }
};

Flatbush.prototype.search = function search (minX, minY, maxX, maxY, filterFn) {
        var this$1 = this;

    if (this._pos !== this._boxes.length) {
        throw new Error('Data not yet indexed - call index.finish().');
    }

    var nodeIndex = this._boxes.length - 4;
    var level = this._levelBounds.length - 1;
    var queue = [];
    var results = [];

    while (nodeIndex !== undefined) {
        // find the end index of the node
        var end = Math.min(nodeIndex + this$1.nodeSize * 4, this$1._levelBounds[level]);

        // search through child nodes
        for (var pos = nodeIndex; pos < end; pos += 4) {
            var index = this$1._indices[pos >> 2];

            // check if node bbox intersects with query bbox
            if (maxX < this$1._boxes[pos]) { continue; } // maxX < nodeMinX
            if (maxY < this$1._boxes[pos + 1]) { continue; } // maxY < nodeMinY
            if (minX > this$1._boxes[pos + 2]) { continue; } // minX > nodeMaxX
            if (minY > this$1._boxes[pos + 3]) { continue; } // minY > nodeMaxY

            if (nodeIndex < this$1.numItems * 4) {
                if (filterFn === undefined || filterFn(index)) {
                    results.push(index); // leaf item
                }

            } else {
                queue.push(index); // node; add it to the search queue
                queue.push(level - 1);
            }
        }

        level = queue.pop();
        nodeIndex = queue.pop();
    }

    return results;
};

// custom quicksort that sorts bbox data alongside the hilbert values
function sort$1(values, boxes, indices, left, right) {
    if (left >= right) { return; }

    var pivot = values[(left + right) >> 1];
    var i = left - 1;
    var j = right + 1;

    while (true) {
        do { i++; } while (values[i] < pivot);
        do { j--; } while (values[j] > pivot);
        if (i >= j) { break; }
        swap(values, boxes, indices, i, j);
    }

    sort$1(values, boxes, indices, left, j);
    sort$1(values, boxes, indices, j + 1, right);
}

// swap two values and two corresponding boxes
function swap(values, boxes, indices, i, j) {
    var temp = values[i];
    values[i] = values[j];
    values[j] = temp;

    var k = 4 * i;
    var m = 4 * j;

    var a = boxes[k];
    var b = boxes[k + 1];
    var c = boxes[k + 2];
    var d = boxes[k + 3];
    boxes[k] = boxes[m];
    boxes[k + 1] = boxes[m + 1];
    boxes[k + 2] = boxes[m + 2];
    boxes[k + 3] = boxes[m + 3];
    boxes[m] = a;
    boxes[m + 1] = b;
    boxes[m + 2] = c;
    boxes[m + 3] = d;

    var e = indices[i];
    indices[i] = indices[j];
    indices[j] = e;
}

// Fast Hilbert curve algorithm by http://threadlocalmutex.com/
// Ported from C++ https://github.com/rawrunprotected/hilbert_curves (public domain)
function hilbert(x, y) {
    var a = x ^ y;
    var b = 0xFFFF ^ a;
    var c = 0xFFFF ^ (x | y);
    var d = x & (y ^ 0xFFFF);

    var A = a | (b >> 1);
    var B = (a >> 1) ^ a;
    var C = ((c >> 1) ^ (b & (d >> 1))) ^ c;
    var D = ((a & (c >> 1)) ^ (d >> 1)) ^ d;

    a = A; b = B; c = C; d = D;
    A = ((a & (a >> 2)) ^ (b & (b >> 2)));
    B = ((a & (b >> 2)) ^ (b & ((a ^ b) >> 2)));
    C ^= ((a & (c >> 2)) ^ (b & (d >> 2)));
    D ^= ((b & (c >> 2)) ^ ((a ^ b) & (d >> 2)));

    a = A; b = B; c = C; d = D;
    A = ((a & (a >> 4)) ^ (b & (b >> 4)));
    B = ((a & (b >> 4)) ^ (b & ((a ^ b) >> 4)));
    C ^= ((a & (c >> 4)) ^ (b & (d >> 4)));
    D ^= ((b & (c >> 4)) ^ ((a ^ b) & (d >> 4)));

    a = A; b = B; c = C; d = D;
    C ^= ((a & (c >> 8)) ^ (b & (d >> 8)));
    D ^= ((b & (c >> 8)) ^ ((a ^ b) & (d >> 8)));

    a = C ^ (C >> 1);
    b = D ^ (D >> 1);

    var i0 = x ^ y;
    var i1 = b | (0xFFFF ^ (i0 | a));

    i0 = (i0 | (i0 << 8)) & 0x00FF00FF;
    i0 = (i0 | (i0 << 4)) & 0x0F0F0F0F;
    i0 = (i0 | (i0 << 2)) & 0x33333333;
    i0 = (i0 | (i0 << 1)) & 0x55555555;

    i1 = (i1 | (i1 << 8)) & 0x00FF00FF;
    i1 = (i1 | (i1 << 4)) & 0x0F0F0F0F;
    i1 = (i1 | (i1 << 2)) & 0x33333333;
    i1 = (i1 | (i1 << 1)) & 0x55555555;

    return ((i1 << 1) | i0) >>> 0;
}

/**
 * This implementation is inspired by discussion here 
 * https://twitter.com/mourner/status/1049325199617921024 and 
 * here https://github.com/anvaka/isect/issues/1
 * 
 * It builds an index of all segments using static spatial index
 * and then for each segment it queries overlapping rectangles.
 */
function bush(lines, options) {
  var results = [];
  var reportIntersection = (options && options.onFound) || 
                            defaultIntersectionReporter;
  var asyncState;

  var index = new Flatbush(lines.length);
  lines.forEach(addToIndex);
  index.finish();

  return {
    run: run,
    step: step,
    results: results,

    // undocumented, don't use unless you know what you are doing:
    checkIntersection: checkIntersection
  }

  function run() {
    for (var i = 0; i < lines.length; ++i) {
      if (checkIntersection(lines[i], i)) {
        return; // stop early
      }
    }
    return results;
  }

  function checkIntersection(currentSegment, currentId) {
    // sorry about code duplication.
    var minX = currentSegment.from.x; var maxX = currentSegment.to.x;
    var minY = currentSegment.from.y; var maxY = currentSegment.to.y;
    var t;
    if (minX > maxX) { t = minX; minX = maxX; maxX = t; }
    if (minY > maxY) { t = minY; minY = maxY; maxY = t; }

    var ids = index.search(minX, minY, maxX, maxY);

    for (var i = 0; i < ids.length; ++i) {
      var segmentIndex = ids[i];
      if (segmentIndex <= currentId) { continue; } // we have either reported it, or it is current.

      var otherSegment = lines[segmentIndex];
      var point = intersectSegments$1(otherSegment, currentSegment);

      if (point) {
        if (reportIntersection(point, [currentSegment, otherSegment])) {
          // stop early
          return true;
        }
      }
    }
  }

  function step() {
    if (!asyncState) {
      asyncState = {i: 0};
    }
    var test = lines[asyncState.i];
    checkIntersection(test, asyncState.i);
    asyncState.i += 1;
    return asyncState.i < lines.length;
  }


  function addToIndex(line) {
    var minX = line.from.x; var maxX = line.to.x;
    var minY = line.from.y; var maxY = line.to.y;
    var t;
    if (minX > maxX) { t = minX; minX = maxX; maxX = t; }
    if (minY > maxY) { t = minY; minY = maxY; maxY = t; }
    index.add(minX, minY, maxX, maxY);
  }

  function defaultIntersectionReporter(p, interior) {
    results.push({
      point: p, 
      segments: interior
    });
  }
}




/***/ }),

/***/ "./node_modules/loglevel/lib/loglevel.js":
/*!***********************************************!*\
  !*** ./node_modules/loglevel/lib/loglevel.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";
    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (
        /Trident\/|MSIE /.test(window.navigator.userAgent)
    );

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    var _loggersByName = {};
    var defaultLogger = null;

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Trace() doesn't print the message in IE, so for that case we need to wrap it
    function traceForIE() {
        if (console.log) {
            if (console.log.apply) {
                console.log.apply(console, arguments);
            } else {
                // In old IE, native console methods themselves don't have apply().
                Function.prototype.apply.apply(console.log, [console, arguments]);
            }
        }
        if (console.trace) console.trace();
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (methodName === 'trace' && isIE) {
            return traceForIE;
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods() {
        /*jshint validthis:true */
        var level = this.getLevel();

        // Replace the actual methods.
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, this.name);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;

        // Return any important warnings.
        if (typeof console === undefinedType && level < this.levels.SILENT) {
            return "No console available for logging";
        }
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, _level, _loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, factory) {
      // Private instance variables.
      var self = this;
      /**
       * The level inherited from a parent logger (or a global default). We
       * cache this here rather than delegating to the parent so that it stays
       * in sync with the actual logging methods that we have installed (the
       * parent could change levels but we might not have rebuilt the loggers
       * in this child yet).
       * @type {number}
       */
      var inheritedLevel;
      /**
       * The default level for this logger, if any. If set, this overrides
       * `inheritedLevel`.
       * @type {number|null}
       */
      var defaultLevel;
      /**
       * A user-specific level for this logger. If set, this overrides
       * `defaultLevel`.
       * @type {number|null}
       */
      var userLevel;

      var storageKey = "loglevel";
      if (typeof name === "string") {
        storageKey += ":" + name;
      } else if (typeof name === "symbol") {
        storageKey = undefined;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType || !storageKey) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType || !storageKey) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var cookieName = encodeURIComponent(storageKey);
                  var location = cookie.indexOf(cookieName + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(
                          cookie.slice(location + cookieName.length + 1)
                      )[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      function clearPersistedLevel() {
          if (typeof window === undefinedType || !storageKey) return;

          // Use localStorage if available
          try {
              window.localStorage.removeItem(storageKey);
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch (ignore) {}
      }

      function normalizeLevel(input) {
          var level = input;
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              return level;
          } else {
              throw new TypeError("log.setLevel() called with invalid level: " + input);
          }
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          if (userLevel != null) {
            return userLevel;
          } else if (defaultLevel != null) {
            return defaultLevel;
          } else {
            return inheritedLevel;
          }
      };

      self.setLevel = function (level, persist) {
          userLevel = normalizeLevel(level);
          if (persist !== false) {  // defaults to true
              persistLevelIfPossible(userLevel);
          }

          // NOTE: in v2, this should call rebuild(), which updates children.
          return replaceLoggingMethods.call(self);
      };

      self.setDefaultLevel = function (level) {
          defaultLevel = normalizeLevel(level);
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.resetLevel = function () {
          userLevel = null;
          clearPersistedLevel();
          replaceLoggingMethods.call(self);
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      self.rebuild = function () {
          if (defaultLogger !== self) {
              inheritedLevel = normalizeLevel(defaultLogger.getLevel());
          }
          replaceLoggingMethods.call(self);

          if (defaultLogger === self) {
              for (var childName in _loggersByName) {
                _loggersByName[childName].rebuild();
              }
          }
      };

      // Initialize all the internal levels.
      inheritedLevel = normalizeLevel(
          defaultLogger ? defaultLogger.getLevel() : "WARN"
      );
      var initialLevel = getPersistedLevel();
      if (initialLevel != null) {
          userLevel = normalizeLevel(initialLevel);
      }
      replaceLoggingMethods.call(self);
    }

    /*
     *
     * Top-level API
     *
     */

    defaultLogger = new Logger();

    defaultLogger.getLogger = function getLogger(name) {
        if ((typeof name !== "symbol" && typeof name !== "string") || name === "") {
            throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
            logger = _loggersByName[name] = new Logger(
                name,
                defaultLogger.methodFactory
            );
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    // ES6 default export, for compatibility
    defaultLogger['default'] = defaultLogger;

    return defaultLogger;
}));


/***/ }),

/***/ "./node_modules/polyk/dist/polyk.js":
/*!******************************************!*\
  !*** ./node_modules/polyk/dist/polyk.js ***!
  \******************************************/
/***/ (function(module) {

(function (global, factory) {
	 true ? factory() :
	0;
}(this, (function () { 'use strict';

/**
 * Checks, if polygon is simple. Polygon is simple, when its edges don't cross each other.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @returns {boolean} true if Polygon is simple
 */
function IsSimple (polygon) {
  var p = polygon;
  var n = p.length >> 1;
  if (n < 4) return true
  var a1 = Point();
  var a2 = Point();
  var b1 = Point();
  var b2 = Point();
  var c = Point();

  for (var i = 0; i < n; i++) {
    a1.x = p[2 * i];
    a1.y = p[2 * i + 1];
    if (i == n - 1) {
      a2.x = p[0];
      a2.y = p[1];
    } else {
      a2.x = p[2 * i + 2];
      a2.y = p[2 * i + 3];
    }

    for (var j = 0; j < n; j++) {
      if (Math.abs(i - j) < 2) continue
      if (j == n - 1 && i == 0) continue
      if (i == n - 1 && j == 0) continue

      b1.x = p[2 * j];
      b1.y = p[2 * j + 1];
      if (j == n - 1) {
        b2.x = p[0];
        b2.y = p[1];
      } else {
        b2.x = p[2 * j + 2];
        b2.y = p[2 * j + 3];
      }

      if (GetLineIntersection(a1, a2, b1, b2, c) != null) return false
    }
  }
  return true
}
module.exports.IsSimple = IsSimple;

/**
 * Checks, if polygon is convex. Polygon is convex, when each inner angle is <= 180.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @returns {boolean}
 */
function IsConvex (polygon) {
  var p = polygon;
  if (p.length < 6) return true
  var l = p.length - 4;
  for (var i = 0; i < l; i += 2) {
    if (!convex(p[i], p[i + 1], p[i + 2], p[i + 3], p[i + 4], p[i + 5])) return false
  }
  if (!convex(p[l], p[l + 1], p[l + 2], p[l + 3], p[0], p[1])) return false
  if (!convex(p[l + 2], p[l + 3], p[0], p[1], p[2], p[3])) return false
  return true
}
module.exports.IsConvex = IsConvex;

/**
 * Returns the area of polygon.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @returns {number}
 */
function GetArea (polygon) {
  var p = polygon;
  if (p.length < 6) return 0
  var l = p.length - 2;
  var sum = 0;
  for (var i = 0; i < l; i += 2) {
    sum += (p[i + 2] - p[i]) * (p[i + 1] + p[i + 3]);
  }
  sum += (p[0] - p[l]) * (p[l + 1] + p[1]);
  return -sum * 0.5
}
module.exports.GetArea = GetArea;

/**
 * Returns the Axis-aligned Bounding Box of polygon
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @returns {AABB}
 * @example
 * //={x:0, y:0, width:0, height:0}
 */
function GetAABB (polygon) {
  var p = polygon;
  var minx = Infinity;
  var miny = Infinity;
  var maxx = -minx;
  var maxy = -miny;
  for (var i = 0; i < p.length; i += 2) {
    minx = Math.min(minx, p[i]);
    maxx = Math.max(maxx, p[i]);
    miny = Math.min(miny, p[i + 1]);
    maxy = Math.max(maxy, p[i + 1]);
  }
  return {x: minx, y: miny, width: maxx - minx, height: maxy - miny}
}
module.exports.GetAABB = GetAABB;

/**
 * Computes the triangulation. Output array is array of triangles (triangle = 3 indices of polygon vertices).
 *
 * Works with simple polygons only.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @returns {number[]} array of triangles (triangle = 3 indices of polygon vertices)
 * @example
 * var ids = PolyK.Triangulate([0, 0, 1, 0, 1, 1, 0, 1]);
 * //=[0, 1, 2, 0, 2, 3]
 */
function Triangulate (polygon) {
  var p = polygon;
  var n = p.length >> 1;
  if (n < 3) return []
  var tgs = [];
  var avl = [];
  for (var i = 0; i < n; i++) { avl.push(i); }

  var i = 0;
  var al = n;
  while (al > 3) {
    var i0 = avl[(i + 0) % al];
    var i1 = avl[(i + 1) % al];
    var i2 = avl[(i + 2) % al];

    var ax = p[2 * i0];
    var ay = p[2 * i0 + 1];
    var bx = p[2 * i1];
    var by = p[2 * i1 + 1];
    var cx = p[2 * i2];
    var cy = p[2 * i2 + 1];

    var earFound = false;
    if (convex(ax, ay, bx, by, cx, cy)) {
      earFound = true;
      for (var j = 0; j < al; j++) {
        var vi = avl[j];
        if (vi == i0 || vi == i1 || vi == i2) continue
        if (PointInTriangle(p[2 * vi], p[2 * vi + 1], ax, ay, bx, by, cx, cy)) {
          earFound = false;
          break
        }
      }
    }
    if (earFound) {
      tgs.push(i0, i1, i2);
      avl.splice((i + 1) % al, 1);
      al--;
      i = 0;
    } else if (i++ > 3 * al) break    // no convex angles :(
  }
  tgs.push(avl[0], avl[1], avl[2]);
  return tgs
}
module.exports.Triangulate = Triangulate;

/**
 * Slices the polygon with line segment A-B, defined by [ax,ay] and [bx,by]. A, B must not lay inside a polygon. Returns an array of polygons.
 *
 * Works with simple polygons only.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @param {number} startX Start Coordinate [x]
 * @param {number} startY Start Coordinate [y]
 * @param {number} endX End Coordinate [x]
 * @param {number} endY End Coordinate [y]
 * @returns {number[][]} Array of Polygon
 */
function Slice (polygon, startX, startY, endX, endY) {
  var p = polygon;
  var ax = startX;
  var ay = startY;
  var bx = endX;
  var by = endY;
  if (ContainsPoint(p, ax, ay) || ContainsPoint(p, bx, by)) {
    return [p.slice(0)]
  }

  var a = Point(ax, ay);
  var b = Point(bx, by);
  var iscs = [];  // intersections
  var ps = [];  // points
  for (var i = 0; i < p.length; i += 2) {
    ps.push(Point(p[i], p[i + 1]));
  }
  for (var i = 0; i < ps.length; i++) {
    var isc = Point(0, 0);
    isc = GetLineIntersection(a, b, ps[i], ps[(i + 1) % ps.length], isc);
    var fisc = iscs[0];
    var lisc = iscs[iscs.length - 1];
    // && (isc.x!=ps[i].x || isc.y!=ps[i].y) )
    if (isc && (fisc == null || distance(isc, fisc) > 1e-10) && (lisc == null || distance(isc, lisc) > 1e-10)) {
      isc.flag = true;
      iscs.push(isc);
      ps.splice(i + 1, 0, isc);
      i++;
    }
  }

  if (iscs.length < 2) return [p.slice(0)]
  var comp = function (u, v) { return distance(a, u) - distance(a, v) };
  iscs.sort(comp);

  var pgs = [];
  var dir = 0;
  while (iscs.length > 0) {
    // var n = ps.length // is assigned a value but never used. (no-unused-vars)
    var i0 = iscs[0];
    var i1 = iscs[1];
    // if(i0.x==i1.x && i0.y==i1.y) { iscs.splice(0,2); continue;}
    var index0 = ps.indexOf(i0);
    var index1 = ps.indexOf(i1);
    var solved = false;

    if (firstWithFlag(ps, index0) === index1) {
      solved = true;
    } else {
      i0 = iscs[1];
      i1 = iscs[0];
      index0 = ps.indexOf(i0);
      index1 = ps.indexOf(i1);
      if (firstWithFlag(ps, index0) === index1) solved = true;
    }
    if (solved) {
      dir--;
      var pgn = getPoints(ps, index0, index1);
      pgs.push(pgn);
      ps = getPoints(ps, index1, index0);
      i0.flag = i1.flag = false;
      iscs.splice(0, 2);
      if (iscs.length == 0) pgs.push(ps);
    } else {
      dir++;
      iscs.reverse();
    }
    if (dir > 1) break
  }
  var result = [];
  for (var i = 0; i < pgs.length; i++) {
    var pg = pgs[i];
    var npg = [];
    for (var j = 0; j < pg.length; j++) { npg.push(pg[j].x, pg[j].y); }
    result.push(npg);
  }
  return result
}
module.exports.Slice = Slice;

/**
 * Checks, if polygon contains [x, y].
 *
 * Works with simple polygons only.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @param {number} pointX Coordinate [x]
 * @param {number} pointY Coordinate [y]
 * @returns {boolean} depth
 */
function ContainsPoint (polygon, pointX, pointY) {
  var p = polygon;
  var px = pointX;
  var py = pointY;
  var n = p.length >> 1;
  var ax;
  var ay = p[2 * n - 3] - py;
  var bx = p[2 * n - 2] - px;
  var by = p[2 * n - 1] - py;

  // var lup = by > ay;
  for (var i = 0; i < n; i++) {
    ax = bx;
    ay = by;
    bx = p[2 * i] - px;
    by = p[2 * i + 1] - py;
    if (ay === by) continue
    var lup = by > ay;
  }

  var depth = 0;
  for (var i = 0; i < n; i++) {
    ax = bx;
    ay = by;
    bx = p[2 * i] - px;
    by = p[2 * i + 1] - py;
    if (ay < 0 && by < 0) continue  // both "up" or both "down"
    if (ay > 0 && by > 0) continue  // both "up" or both "down"
    if (ax < 0 && bx < 0) continue   // both points on the left

    if (ay === by && Math.min(ax, bx) <= 0) return true
    if (ay === by) continue

    var lx = ax + (bx - ax) * (-ay) / (by - ay);
    if (lx === 0) return true      // point on edge
    if (lx > 0) depth++;
    if (ay === 0 && lup && by > ay) depth--;  // hit vertex, both up
    if (ay === 0 && !lup && by < ay) depth--; // hit vertex, both down
    lup = by > ay;
  }
  return (depth & 1) === 1
}
module.exports.ContainsPoint = ContainsPoint;

/**
 * Finds the closest point of polygon, which lays on ray defined by [x,y] (origin) and [dx,dy] (direction).
 *
 * "dist" is the distance of the polygon point, "edge" is the number of the edge, on which intersection occurs, "norm" is the normal in that place, "refl" is reflected direction.
 *
 * Works with simple polygons only.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @param {number} originX Origin [x]
 * @param {number} originY Origin [y]
 * @param {number} directionX Direction [x]
 * @param {number} directionY Direction [y]
 * @returns {Raycast}
 * @example
 * //={dist:0, edge:0, norm:{x:0, y:0}, refl:{x:0, y:0}}
 */
function Raycast (polygon, originX, originY, directionX, directionY, isc) {
  var p = polygon;
  var x = originX;
  var y = originY;
  var dx = directionX;
  var dy = directionY;
  var l = p.length - 2;
  var empty = emptyPoints();
  var a1 = empty[0];
  var a2 = empty[1];
  var b1 = empty[2];
  var b2 = empty[3];
  var c = empty[4];
  a1.x = x;
  a1.y = y;
  a2.x = x + dx;
  a2.y = y + dy;

  if (isc === null || isc === undefined) {
    isc = {dist: 0, edge: 0, norm: {x: 0, y: 0}, refl: {x: 0, y: 0}};
  }
  isc.dist = Infinity;

  var nisc;
  for (var i = 0; i < l; i += 2) {
    b1.x = p[i];
    b1.y = p[i + 1];
    b2.x = p[i + 2];
    b2.y = p[i + 3];
    nisc = RayLineIntersection(a1, a2, b1, b2, c);
    if (nisc) {
      isc = updateISC(dx, dy, a1, b1, b2, c, i / 2, isc);
    }
  }
  b1.x = b2.x;
  b1.y = b2.y;
  b2.x = p[0];
  b2.y = p[1];
  nisc = RayLineIntersection(a1, a2, b1, b2, c);
  if (nisc) {
    isc = updateISC(dx, dy, a1, b1, b2, c, (p.length / 2) - 1, isc);
  }

  return (isc.dist !== Infinity) ? isc : null
}
module.exports.Raycast = Raycast;

/**
 * Finds the point on polygon edges, which is closest to [x,y]. Returns an object in this format
 *
 * "dist" is the distance of the polygon point, "edge" is the number of the closest edge, "point" is the closest point on that edge, "norm" is the normal from "point" to [x,y].
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @param {number} x Coordinate [x]
 * @param {number} y Coordinate [y]
 * @returns {ClosestEdge}
 * @example
 * //={dist:0, edge:0, point:{x:0, y:0}, norm:{x:0, y:0}}
 */
function ClosestEdge (polygon, x, y, isc) {
  var p = polygon;
  var l = p.length - 2;
  var empty = emptyPoints();
  var a1 = empty[0];
  var b1 = empty[2];
  var b2 = empty[3];
  // var c = tp[4] // is assigned a value but never used.
  a1.x = x;
  a1.y = y;

  if (isc == null) {
    isc = {dist: 0, edge: 0, point: {x: 0, y: 0}, norm: {x: 0, y: 0}};
  }
  isc.dist = Infinity;

  for (var i = 0; i < l; i += 2) {
    b1.x = p[i];
    b1.y = p[i + 1];
    b2.x = p[i + 2];
    b2.y = p[i + 3];
    isc = pointLineDist(a1, b1, b2, i >> 1, isc);
  }
  b1.x = b2.x;
  b1.y = b2.y;
  b2.x = p[0];
  b2.y = p[1];
  isc = pointLineDist(a1, b1, b2, l >> 1, isc);

  var idst = 1 / isc.dist;
  isc.norm.x = (x - isc.point.x) * idst;
  isc.norm.y = (y - isc.point.y) * idst;
  return isc
}
module.exports.ClosestEdge = ClosestEdge;

/**
 * Reverse
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 */
function Reverse (polygon) {
  var p = polygon;
  var np = [];
  for (var j = p.length - 2; j >= 0; j -= 2) { np.push(p[j], p[j + 1]); }
  return np
}
module.exports.Reverse = Reverse;

/**
 * Point Line Distance
 *
 * @private
 * @param {Point} p
 * @param {Point} a
 * @param {Point} b
 * @param {??} edge
 * @param {??} isc
 * @returns {??} ISC
 */
function pointLineDist (p, a, b, edge, isc) {
  var x = p.x;
  var y = p.y;
  var x1 = a.x;
  var y1 = a.y;
  var x2 = b.x;
  var y2 = b.y;

  var A = x - x1;
  var B = y - y1;
  var C = x2 - x1;
  var D = y2 - y1;

  var dot = A * C + B * D;
  var lenSq = C * C + D * D;
  var param = dot / lenSq;

  var xx;
  var yy;

  if (param < 0 || (x1 == x2 && y1 == y2)) {
    xx = x1;
    yy = y1;
  } else if (param > 1) {
    xx = x2;
    yy = y2;
  } else {
    xx = x1 + param * C;
    yy = y1 + param * D;
  }

  var dx = x - xx;
  var dy = y - yy;
  var dst = Math.sqrt(dx * dx + dy * dy);
  if (dst < isc.dist) {
    isc.dist = dst;
    isc.edge = edge;
    isc.point.x = xx;
    isc.point.y = yy;
  }
  return isc
}

/**
 * Update ISC
 *
 * @private
 * @param {number} dx
 * @param {number} dy
 * @param {Point} a1
 * @param {Point} b1
 * @param {Point} b2
 * @param {Point} c
 * @param {??} edge
 * @param {??} isc
 * @returns {??}
 */
function updateISC (dx, dy, a1, b1, b2, c, edge, isc) {
  var nrl = distance(a1, c);
  if (nrl < isc.dist) {
    var ibl = 1 / distance(b1, b2);
    var nx = -(b2.y - b1.y) * ibl;
    var ny = (b2.x - b1.x) * ibl;
    var ddot = 2 * (dx * nx + dy * ny);
    isc.dist = nrl;
    isc.norm.x = nx;
    isc.norm.y = ny;
    isc.refl.x = -ddot * nx + dx;
    isc.refl.y = -ddot * ny + dy;
    isc.edge = edge;
  }
  return isc
}

/**
 * Get Points
 *
 * @private
 * @param {number[]} points
 * @param {number} index0
 * @param {number} index1
 * @returns {number[]} points
 */
function getPoints (points, index0, index1) {
  var n = points.length;
  var result = [];
  if (index1 < index0) index1 += n;
  for (var i = index0; i <= index1; i++) { result.push(points[i % n]); }
  return result
}

/**
 * First With Flag
 *
 * @private
 * @param {Point[]} points
 * @param {number} index
 * @returns {number}
 */
function firstWithFlag (points, index) {
  var n = points.length;
  while (true) {
    index = (index + 1) % n;
    if (points[index].flag) {
      return index
    }
  }
}

/**
 * Point in Triangle
 *
 * @private
 * @param {number} px
 * @param {number} py
 * @param {number} ax
 * @param {number} ay
 * @param {number} bx
 * @param {number} by
 * @param {number} cx
 * @param {number} cy
 * @returns {boolean}
 */
function PointInTriangle (px, py, ax, ay, bx, by, cx, cy) {
  var v0x = cx - ax;
  var v0y = cy - ay;
  var v1x = bx - ax;
  var v1y = by - ay;
  var v2x = px - ax;
  var v2y = py - ay;

  var dot00 = v0x * v0x + v0y * v0y;
  var dot01 = v0x * v1x + v0y * v1y;
  var dot02 = v0x * v2x + v0y * v2y;
  var dot11 = v1x * v1x + v1y * v1y;
  var dot12 = v1x * v2x + v1y * v2y;

  var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
  var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
  var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

  // Check if point is in triangle
  return (u >= 0) && (v >= 0) && (u + v < 1)
}

/**
 * RayLine Intersection
 *
 * @private
 * @param {Point} a1
 * @param {Point} a2
 * @param {Point} b1
 * @param {Point} b2
 * @param {Point} c
 */
function RayLineIntersection (a1, a2, b1, b2, c) {
  var dax = (a1.x - a2.x);
  var dbx = (b1.x - b2.x);
  var day = (a1.y - a2.y);
  var dby = (b1.y - b2.y);

  var Den = dax * dby - day * dbx;
  if (Den == 0) return null  // parallel

  var A = (a1.x * a2.y - a1.y * a2.x);
  var B = (b1.x * b2.y - b1.y * b2.x);

  var I = c;
  var iDen = 1 / Den;
  I.x = (A * dbx - dax * B) * iDen;
  I.y = (A * dby - day * B) * iDen;

  if (!InRectangle(I, b1, b2)) return null
  if ((day > 0 && I.y > a1.y) || (day < 0 && I.y < a1.y)) return null
  if ((dax > 0 && I.x > a1.x) || (dax < 0 && I.x < a1.x)) return null
  return I
}

/**
 * Get Line Intersection
 *
 * @private
 * @param {Point} a1
 * @param {Point} a2
 * @param {Point} b1
 * @param {Point} b2
 * @param {Point} c
 * @returns {Point}
 */
function GetLineIntersection (a1, a2, b1, b2, c) {
  var dax = (a1.x - a2.x);
  var dbx = (b1.x - b2.x);
  var day = (a1.y - a2.y);
  var dby = (b1.y - b2.y);

  var Den = dax * dby - day * dbx;

  if (Den === 0) { return null } // parallel

  var A = (a1.x * a2.y - a1.y * a2.x);
  var B = (b1.x * b2.y - b1.y * b2.x);

  var I = c;
  I.x = (A * dbx - dax * B) / Den;
  I.y = (A * dby - day * B) / Den;

  if (InRectangle(I, a1, a2) && InRectangle(I, b1, b2)) {
    return I
  }
  return null
}

/**
 * In Rectangle
 *
 * @private
 * @param {Point} a
 * @param {Point} b
 * @param {Point} c
 * @return {boolean}
 */
function InRectangle (a, b, c) {
  var minx = Math.min(b.x, c.x);
  var maxx = Math.max(b.x, c.x);
  var miny = Math.min(b.y, c.y);
  var maxy = Math.max(b.y, c.y);

  if (minx === maxx) { return (miny <= a.y && a.y <= maxy) }
  if (miny === maxy) { return (minx <= a.x && a.x <= maxx) }

  // return (minx <= a.x && a.x <= maxx && miny <= a.y && a.y <= maxy)
  return (minx <= a.x + 1e-10 && a.x - 1e-10 <= maxx && miny <= a.y + 1e-10 && a.y - 1e-10 <= maxy)
}

/**
 * Convex
 *
 * @private
 * @param {Point} ax
 * @param {Point} ay
 * @param {Point} bx
 * @param {Point} by
 * @param {Point} cx
 * @param {Point} cy
 * @returns {boolean}
 */
function convex (ax, ay, bx, by, cx, cy) {
  return (ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0
}

/**
 * Point
 *
 * @private
 * @param {number} x
 * @param {number} y
 * @returns {Point}
 */
function Point (x, y) {
  return {
    x: x,
    y: y,
    flag: false,
    toString: function () { return 'Point [' + x + ', ' + y + ']' }
  }
}

/**
 * Distance
 *
 * @private
 * @param {Point} a
 * @param {Point} b
 * @returns {number}
 */
function distance (a, b) {
  var dx = b.x - a.x;
  var dy = b.y - a.y;
  return Math.sqrt(dx * dx + dy * dy)
}

/**
 * Creates an array of empty Points
 *
 * @private
 * @param {number} [num=10] Number of points
 * @returns {Point[]}
 */
function emptyPoints (num) {
  num = num || 10;
  var container = [];
  for (var i = 0; i < num; i++) { container.push(Point(0, 0)); }
  return container
}

})));
//# sourceMappingURL=polyk.js.map


/***/ }),

/***/ "./node_modules/roughjs/bundled/rough.cjs.js":
/*!***************************************************!*\
  !*** ./node_modules/roughjs/bundled/rough.cjs.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
var t=function(e,n){return t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n])},t(e,n)};function e(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Class extends value "+String(n)+" is not a constructor or null");function r(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}var n=function(){return n=Object.assign||function(t){for(var e,n=1,r=arguments.length;n<r;n++)for(var a in e=arguments[n])Object.prototype.hasOwnProperty.call(e,a)&&(t[a]=e[a]);return t},n.apply(this,arguments)};function r(t,e,n){if(n||2===arguments.length)for(var r,a=0,s=e.length;a<s;a++)!r&&a in e||(r||(r=Array.prototype.slice.call(e,0,a)),r[a]=e[a]);return t.concat(r||Array.prototype.slice.call(e))}function a(t,e,n){if(t&&t.length){const[r,a]=e,s=Math.PI/180*n,o=Math.cos(s),i=Math.sin(s);for(const e of t){const[t,n]=e;e[0]=(t-r)*o-(n-a)*i+r,e[1]=(t-r)*i+(n-a)*o+a}}}function s(t,e){return t[0]===e[0]&&t[1]===e[1]}function o(t,e,n,r=1){const o=n,i=Math.max(e,.1),h=t[0]&&t[0][0]&&"number"==typeof t[0][0]?[t]:t,u=[0,0];if(o)for(const t of h)a(t,u,o);const p=function(t,e,n){const r=[];for(const e of t){const t=[...e];s(t[0],t[t.length-1])||t.push([t[0][0],t[0][1]]),t.length>2&&r.push(t)}const a=[];e=Math.max(e,.1);const o=[];for(const t of r)for(let e=0;e<t.length-1;e++){const n=t[e],r=t[e+1];if(n[1]!==r[1]){const t=Math.min(n[1],r[1]);o.push({ymin:t,ymax:Math.max(n[1],r[1]),x:t===n[1]?n[0]:r[0],islope:(r[0]-n[0])/(r[1]-n[1])})}}if(o.sort(((t,e)=>t.ymin<e.ymin?-1:t.ymin>e.ymin?1:t.x<e.x?-1:t.x>e.x?1:t.ymax===e.ymax?0:(t.ymax-e.ymax)/Math.abs(t.ymax-e.ymax))),!o.length)return a;let i=[],h=o[0].ymin,u=0;for(;i.length||o.length;){if(o.length){let t=-1;for(let e=0;e<o.length&&!(o[e].ymin>h);e++)t=e;o.splice(0,t+1).forEach((t=>{i.push({s:h,edge:t})}))}if(i=i.filter((t=>!(t.edge.ymax<=h))),i.sort(((t,e)=>t.edge.x===e.edge.x?0:(t.edge.x-e.edge.x)/Math.abs(t.edge.x-e.edge.x))),(1!==n||u%e==0)&&i.length>1)for(let t=0;t<i.length;t+=2){const e=t+1;if(e>=i.length)break;const n=i[t].edge,r=i[e].edge;a.push([[Math.round(n.x),h],[Math.round(r.x),h]])}h+=n,i.forEach((t=>{t.edge.x=t.edge.x+n*t.edge.islope})),u++}return a}(h,i,r);if(o){for(const t of h)a(t,u,-o);!function(t,e,n){const r=[];t.forEach((t=>r.push(...t))),a(r,e,n)}(p,u,-o)}return p}function i(t,e){var n,r=e.hachureAngle+90,a=e.hachureGap;a<0&&(a=4*e.strokeWidth),a=Math.round(Math.max(a,.1));var s=1;return e.roughness>=1&&((null===(n=e.randomizer)||void 0===n?void 0:n.next())||Math.random())>.7&&(s=a),o(t,a,r,s||1)}"function"==typeof SuppressedError&&SuppressedError;var h=function(){function t(t){this.helper=t}return t.prototype.fillPolygons=function(t,e){return this._fillPolygons(t,e)},t.prototype._fillPolygons=function(t,e){var n=i(t,e);return{type:"fillSketch",ops:this.renderLines(n,e)}},t.prototype.renderLines=function(t,e){for(var n=[],r=0,a=t;r<a.length;r++){var s=a[r];n.push.apply(n,this.helper.doubleLineOps(s[0][0],s[0][1],s[1][0],s[1][1],e))}return n},t}();function u(t){var e=t[0],n=t[1];return Math.sqrt(Math.pow(e[0]-n[0],2)+Math.pow(e[1]-n[1],2))}var p=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return e(n,t),n.prototype.fillPolygons=function(t,e){var n=e.hachureGap;n<0&&(n=4*e.strokeWidth),n=Math.max(n,.1);for(var a=i(t,Object.assign({},e,{hachureGap:n})),s=Math.PI/180*e.hachureAngle,o=[],h=.5*n*Math.cos(s),p=.5*n*Math.sin(s),l=0,c=a;l<c.length;l++){var f=c[l],d=f[0],g=f[1];u([d,g])&&o.push([[d[0]-h,d[1]+p],r([],g,!0)],[[d[0]+h,d[1]-p],r([],g,!0)])}return{type:"fillSketch",ops:this.renderLines(o,e)}},n}(h),l=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return e(n,t),n.prototype.fillPolygons=function(t,e){var n=this._fillPolygons(t,e),r=Object.assign({},e,{hachureAngle:e.hachureAngle+90}),a=this._fillPolygons(t,r);return n.ops=n.ops.concat(a.ops),n},n}(h),c=function(){function t(t){this.helper=t}return t.prototype.fillPolygons=function(t,e){var n=i(t,e=Object.assign({},e,{hachureAngle:0}));return this.dotsOnLines(n,e)},t.prototype.dotsOnLines=function(t,e){var n=[],r=e.hachureGap;r<0&&(r=4*e.strokeWidth),r=Math.max(r,.1);var a=e.fillWeight;a<0&&(a=e.strokeWidth/2);for(var s=r/4,o=0,i=t;o<i.length;o++)for(var h=i[o],p=u(h),l=p/r,c=Math.ceil(l)-1,f=p-c*r,d=(h[0][0]+h[1][0])/2-r/4,g=Math.min(h[0][1],h[1][1]),y=0;y<c;y++){var v=g+f+y*r,M=d-s+2*Math.random()*s,k=v-s+2*Math.random()*s,b=this.helper.ellipse(M,k,a,a,e);n.push.apply(n,b.ops)}return{type:"fillSketch",ops:n}},t}(),f=function(){function t(t){this.helper=t}return t.prototype.fillPolygons=function(t,e){var n=i(t,e);return{type:"fillSketch",ops:this.dashedLine(n,e)}},t.prototype.dashedLine=function(t,e){var n=this,r=e.dashOffset<0?e.hachureGap<0?4*e.strokeWidth:e.hachureGap:e.dashOffset,a=e.dashGap<0?e.hachureGap<0?4*e.strokeWidth:e.hachureGap:e.dashGap,s=[];return t.forEach((function(t){var o=u(t),i=Math.floor(o/(r+a)),h=(o+a-i*(r+a))/2,p=t[0],l=t[1];p[0]>l[0]&&(p=t[1],l=t[0]);for(var c=Math.atan((l[1]-p[1])/(l[0]-p[0])),f=0;f<i;f++){var d=f*(r+a),g=d+r,y=[p[0]+d*Math.cos(c)+h*Math.cos(c),p[1]+d*Math.sin(c)+h*Math.sin(c)],v=[p[0]+g*Math.cos(c)+h*Math.cos(c),p[1]+g*Math.sin(c)+h*Math.sin(c)];s.push.apply(s,n.helper.doubleLineOps(y[0],y[1],v[0],v[1],e))}})),s},t}(),d=function(){function t(t){this.helper=t}return t.prototype.fillPolygons=function(t,e){var n=e.hachureGap<0?4*e.strokeWidth:e.hachureGap,r=e.zigzagOffset<0?n:e.zigzagOffset,a=i(t,e=Object.assign({},e,{hachureGap:n+r}));return{type:"fillSketch",ops:this.zigzagLines(a,r,e)}},t.prototype.zigzagLines=function(t,e,n){var a=this,s=[];return t.forEach((function(t){var o=u(t),i=Math.round(o/(2*e)),h=t[0],p=t[1];h[0]>p[0]&&(h=t[1],p=t[0]);for(var l=Math.atan((p[1]-h[1])/(p[0]-h[0])),c=0;c<i;c++){var f=2*c*e,d=2*(c+1)*e,g=Math.sqrt(2*Math.pow(e,2)),y=[h[0]+f*Math.cos(l),h[1]+f*Math.sin(l)],v=[h[0]+d*Math.cos(l),h[1]+d*Math.sin(l)],M=[y[0]+g*Math.cos(l+Math.PI/4),y[1]+g*Math.sin(l+Math.PI/4)];s.push.apply(s,r(r([],a.helper.doubleLineOps(y[0],y[1],M[0],M[1],n),!1),a.helper.doubleLineOps(M[0],M[1],v[0],v[1],n),!1))}})),s},t}(),g={};var y=function(){function t(t){this.seed=t}return t.prototype.next=function(){return this.seed?(Math.pow(2,31)-1&(this.seed=Math.imul(48271,this.seed)))/Math.pow(2,31):Math.random()},t}();const v=0,M=1,k=2,b={A:7,a:7,C:6,c:6,H:1,h:1,L:2,l:2,M:2,m:2,Q:4,q:4,S:4,s:4,T:2,t:2,V:1,v:1,Z:0,z:0};function m(t,e){return t.type===e}function w(t){const e=[],n=function(t){const e=new Array;for(;""!==t;)if(t.match(/^([ \t\r\n,]+)/))t=t.substr(RegExp.$1.length);else if(t.match(/^([aAcChHlLmMqQsStTvVzZ])/))e[e.length]={type:v,text:RegExp.$1},t=t.substr(RegExp.$1.length);else{if(!t.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/))return[];e[e.length]={type:M,text:`${parseFloat(RegExp.$1)}`},t=t.substr(RegExp.$1.length)}return e[e.length]={type:k,text:""},e}(t);let r="BOD",a=0,s=n[a];for(;!m(s,k);){let o=0;const i=[];if("BOD"===r){if("M"!==s.text&&"m"!==s.text)return w("M0,0"+t);a++,o=b[s.text],r=s.text}else m(s,M)?o=b[r]:(a++,o=b[s.text],r=s.text);if(!(a+o<n.length))throw new Error("Path data ended short");for(let t=a;t<a+o;t++){const e=n[t];if(!m(e,M))throw new Error("Param not a number: "+r+","+e.text);i[i.length]=+e.text}if("number"!=typeof b[r])throw new Error("Bad segment: "+r);{const t={key:r,data:i};e.push(t),a+=o,s=n[a],"M"===r&&(r="L"),"m"===r&&(r="l")}}return e}function P(t){let e=0,n=0,r=0,a=0;const s=[];for(const{key:o,data:i}of t)switch(o){case"M":s.push({key:"M",data:[...i]}),[e,n]=i,[r,a]=i;break;case"m":e+=i[0],n+=i[1],s.push({key:"M",data:[e,n]}),r=e,a=n;break;case"L":s.push({key:"L",data:[...i]}),[e,n]=i;break;case"l":e+=i[0],n+=i[1],s.push({key:"L",data:[e,n]});break;case"C":s.push({key:"C",data:[...i]}),e=i[4],n=i[5];break;case"c":{const t=i.map(((t,r)=>r%2?t+n:t+e));s.push({key:"C",data:t}),e=t[4],n=t[5];break}case"Q":s.push({key:"Q",data:[...i]}),e=i[2],n=i[3];break;case"q":{const t=i.map(((t,r)=>r%2?t+n:t+e));s.push({key:"Q",data:t}),e=t[2],n=t[3];break}case"A":s.push({key:"A",data:[...i]}),e=i[5],n=i[6];break;case"a":e+=i[5],n+=i[6],s.push({key:"A",data:[i[0],i[1],i[2],i[3],i[4],e,n]});break;case"H":s.push({key:"H",data:[...i]}),e=i[0];break;case"h":e+=i[0],s.push({key:"H",data:[e]});break;case"V":s.push({key:"V",data:[...i]}),n=i[0];break;case"v":n+=i[0],s.push({key:"V",data:[n]});break;case"S":s.push({key:"S",data:[...i]}),e=i[2],n=i[3];break;case"s":{const t=i.map(((t,r)=>r%2?t+n:t+e));s.push({key:"S",data:t}),e=t[2],n=t[3];break}case"T":s.push({key:"T",data:[...i]}),e=i[0],n=i[1];break;case"t":e+=i[0],n+=i[1],s.push({key:"T",data:[e,n]});break;case"Z":case"z":s.push({key:"Z",data:[]}),e=r,n=a}return s}function x(t){const e=[];let n="",r=0,a=0,s=0,o=0,i=0,h=0;for(const{key:u,data:p}of t){switch(u){case"M":e.push({key:"M",data:[...p]}),[r,a]=p,[s,o]=p;break;case"C":e.push({key:"C",data:[...p]}),r=p[4],a=p[5],i=p[2],h=p[3];break;case"L":e.push({key:"L",data:[...p]}),[r,a]=p;break;case"H":r=p[0],e.push({key:"L",data:[r,a]});break;case"V":a=p[0],e.push({key:"L",data:[r,a]});break;case"S":{let t=0,s=0;"C"===n||"S"===n?(t=r+(r-i),s=a+(a-h)):(t=r,s=a),e.push({key:"C",data:[t,s,...p]}),i=p[0],h=p[1],r=p[2],a=p[3];break}case"T":{const[t,s]=p;let o=0,u=0;"Q"===n||"T"===n?(o=r+(r-i),u=a+(a-h)):(o=r,u=a);const l=r+2*(o-r)/3,c=a+2*(u-a)/3,f=t+2*(o-t)/3,d=s+2*(u-s)/3;e.push({key:"C",data:[l,c,f,d,t,s]}),i=o,h=u,r=t,a=s;break}case"Q":{const[t,n,s,o]=p,u=r+2*(t-r)/3,l=a+2*(n-a)/3,c=s+2*(t-s)/3,f=o+2*(n-o)/3;e.push({key:"C",data:[u,l,c,f,s,o]}),i=t,h=n,r=s,a=o;break}case"A":{const t=Math.abs(p[0]),n=Math.abs(p[1]),s=p[2],o=p[3],i=p[4],h=p[5],u=p[6];if(0===t||0===n)e.push({key:"C",data:[r,a,h,u,h,u]}),r=h,a=u;else if(r!==h||a!==u){O(r,a,h,u,t,n,s,o,i).forEach((function(t){e.push({key:"C",data:t})})),r=h,a=u}break}case"Z":e.push({key:"Z",data:[]}),r=s,a=o}n=u}return e}function S(t,e,n){return[t*Math.cos(n)-e*Math.sin(n),t*Math.sin(n)+e*Math.cos(n)]}function O(t,e,n,r,a,s,o,i,h,u){const p=(l=o,Math.PI*l/180);var l;let c=[],f=0,d=0,g=0,y=0;if(u)[f,d,g,y]=u;else{[t,e]=S(t,e,-p),[n,r]=S(n,r,-p);const o=(t-n)/2,u=(e-r)/2;let l=o*o/(a*a)+u*u/(s*s);l>1&&(l=Math.sqrt(l),a*=l,s*=l);const c=a*a,v=s*s,M=c*v-c*u*u-v*o*o,k=c*u*u+v*o*o,b=(i===h?-1:1)*Math.sqrt(Math.abs(M/k));g=b*a*u/s+(t+n)/2,y=b*-s*o/a+(e+r)/2,f=Math.asin(parseFloat(((e-y)/s).toFixed(9))),d=Math.asin(parseFloat(((r-y)/s).toFixed(9))),t<g&&(f=Math.PI-f),n<g&&(d=Math.PI-d),f<0&&(f=2*Math.PI+f),d<0&&(d=2*Math.PI+d),h&&f>d&&(f-=2*Math.PI),!h&&d>f&&(d-=2*Math.PI)}let v=d-f;if(Math.abs(v)>120*Math.PI/180){const t=d,e=n,i=r;d=h&&d>f?f+120*Math.PI/180*1:f+120*Math.PI/180*-1,c=O(n=g+a*Math.cos(d),r=y+s*Math.sin(d),e,i,a,s,o,0,h,[d,t,g,y])}v=d-f;const M=Math.cos(f),k=Math.sin(f),b=Math.cos(d),m=Math.sin(d),w=Math.tan(v/4),P=4/3*a*w,x=4/3*s*w,L=[t,e],T=[t+P*k,e-x*M],_=[n+P*m,r-x*b],D=[n,r];if(T[0]=2*L[0]-T[0],T[1]=2*L[1]-T[1],u)return[T,_,D].concat(c);{c=[T,_,D].concat(c);const t=[];for(let e=0;e<c.length;e+=3){const n=S(c[e][0],c[e][1],p),r=S(c[e+1][0],c[e+1][1],p),a=S(c[e+2][0],c[e+2][1],p);t.push([n[0],n[1],r[0],r[1],a[0],a[1]])}return t}}var L={randOffset:function(t,e){return F(t,e)},randOffsetWithRange:function(t,e,n){return q(t,e,n)},ellipse:function(t,e,n,r,a){var s=I(n,r,a);return C(t,e,a,s).opset},doubleLineOps:function(t,e,n,r,a){return V(t,e,n,r,a,!0)}};function T(t,e,n,r,a){return{type:"path",ops:V(t,e,n,r,a)}}function _(t,e,n){var r=(t||[]).length;if(r>2){for(var a=[],s=0;s<r-1;s++)a.push.apply(a,V(t[s][0],t[s][1],t[s+1][0],t[s+1][1],n));return e&&a.push.apply(a,V(t[r-1][0],t[r-1][1],t[0][0],t[0][1],n)),{type:"path",ops:a}}return 2===r?T(t[0][0],t[0][1],t[1][0],t[1][1],n):{type:"path",ops:[]}}function D(t,e,n,r,a){return function(t,e){return _(t,!0,e)}([[t,e],[t+n,e],[t+n,e+r],[t,e+r]],a)}function A(t,e){if(t.length){for(var n="number"==typeof t[0][0]?[t]:t,r=Q(n[0],1*(1+.2*e.roughness),e),a=e.disableMultiStroke?[]:Q(n[0],1.5*(1+.22*e.roughness),R(e)),s=1;s<n.length;s++){var o=n[s];if(o.length){for(var i=Q(o,1*(1+.2*e.roughness),e),h=e.disableMultiStroke?[]:Q(o,1.5*(1+.22*e.roughness),R(e)),u=0,p=i;u<p.length;u++){"move"!==(f=p[u]).op&&r.push(f)}for(var l=0,c=h;l<c.length;l++){var f;"move"!==(f=c[l]).op&&a.push(f)}}}return{type:"path",ops:r.concat(a)}}return{type:"path",ops:[]}}function I(t,e,n){var r=Math.sqrt(2*Math.PI*Math.sqrt((Math.pow(t/2,2)+Math.pow(e/2,2))/2)),a=Math.ceil(Math.max(n.curveStepCount,n.curveStepCount/Math.sqrt(200)*r)),s=2*Math.PI/a,o=Math.abs(t/2),i=Math.abs(e/2),h=1-n.curveFitting;return{increment:s,rx:o+=F(o*h,n),ry:i+=F(i*h,n)}}function C(t,e,n,r){var a=$(r.increment,t,e,r.rx,r.ry,1,r.increment*q(.1,q(.4,1,n),n),n),s=a[0],o=a[1],i=H(s,null,n);if(!n.disableMultiStroke&&0!==n.roughness){var h=H($(r.increment,t,e,r.rx,r.ry,1.5,0,n)[0],null,n);i=i.concat(h)}return{estimatedPoints:o,opset:{type:"path",ops:i}}}function z(t,e,n,a,s,o,i,h,u){var p=t,l=e,c=Math.abs(n/2),f=Math.abs(a/2);c+=F(.01*c,u),f+=F(.01*f,u);for(var d=s,g=o;d<0;)d+=2*Math.PI,g+=2*Math.PI;g-d>2*Math.PI&&(d=0,g=2*Math.PI);var y=2*Math.PI/u.curveStepCount,v=Math.min(y/2,(g-d)/2),M=N(v,p,l,c,f,d,g,1,u);if(!u.disableMultiStroke){var k=N(v,p,l,c,f,d,g,1.5,u);M.push.apply(M,k)}return i&&(h?M.push.apply(M,r(r([],V(p,l,p+c*Math.cos(d),l+f*Math.sin(d),u),!1),V(p,l,p+c*Math.cos(g),l+f*Math.sin(g),u),!1)):M.push({op:"lineTo",data:[p,l]},{op:"lineTo",data:[p+c*Math.cos(d),l+f*Math.sin(d)]})),{type:"path",ops:M}}function W(t,e){for(var n=[],r=[0,0],a=[0,0],s=0,o=x(P(w(t)));s<o.length;s++){var i=o[s],h=i.key,u=i.data;switch(h){case"M":a=[u[0],u[1]],r=[u[0],u[1]];break;case"L":n.push.apply(n,V(a[0],a[1],u[0],u[1],e)),a=[u[0],u[1]];break;case"C":var p=u[0],l=u[1],c=u[2],f=u[3],d=u[4],g=u[5];n.push.apply(n,B(p,l,c,f,d,g,a,e)),a=[d,g];break;case"Z":n.push.apply(n,V(a[0],a[1],r[0],r[1],e)),a=[r[0],r[1]]}}return{type:"path",ops:n}}function E(t,e){for(var n=[],r=0,a=t;r<a.length;r++){var s=a[r];if(s.length){var o=e.maxRandomnessOffset||0,i=s.length;if(i>2){n.push({op:"move",data:[s[0][0]+F(o,e),s[0][1]+F(o,e)]});for(var h=1;h<i;h++)n.push({op:"lineTo",data:[s[h][0]+F(o,e),s[h][1]+F(o,e)]})}}}return{type:"fillPath",ops:n}}function G(t,e){return function(t,e){var n=t.fillStyle||"hachure";if(!g[n])switch(n){case"zigzag":g[n]||(g[n]=new p(e));break;case"cross-hatch":g[n]||(g[n]=new l(e));break;case"dots":g[n]||(g[n]=new c(e));break;case"dashed":g[n]||(g[n]=new f(e));break;case"zigzag-line":g[n]||(g[n]=new d(e));break;default:g[n="hachure"]||(g[n]=new h(e))}return g[n]}(e,L).fillPolygons(t,e)}function R(t){var e=n({},t);return e.randomizer=void 0,t.seed&&(e.seed=t.seed+1),e}function j(t){return t.randomizer||(t.randomizer=new y(t.seed||0)),t.randomizer.next()}function q(t,e,n,r){return void 0===r&&(r=1),n.roughness*r*(j(n)*(e-t)+t)}function F(t,e,n){return void 0===n&&(n=1),q(-t,t,e,n)}function V(t,e,n,r,a,s){void 0===s&&(s=!1);var o=s?a.disableMultiStrokeFill:a.disableMultiStroke,i=Z(t,e,n,r,a,!0,!1);if(o)return i;var h=Z(t,e,n,r,a,!0,!0);return i.concat(h)}function Z(t,e,n,r,a,s,o){var i=Math.pow(t-n,2)+Math.pow(e-r,2),h=Math.sqrt(i),u=1;u=h<200?1:h>500?.4:-.0016668*h+1.233334;var p=a.maxRandomnessOffset||0;p*p*100>i&&(p=h/10);var l=p/2,c=.2+.2*j(a),f=a.bowing*a.maxRandomnessOffset*(r-e)/200,d=a.bowing*a.maxRandomnessOffset*(t-n)/200;f=F(f,a,u),d=F(d,a,u);var g=[],y=function(){return F(l,a,u)},v=function(){return F(p,a,u)},M=a.preserveVertices;return s&&(o?g.push({op:"move",data:[t+(M?0:y()),e+(M?0:y())]}):g.push({op:"move",data:[t+(M?0:F(p,a,u)),e+(M?0:F(p,a,u))]})),o?g.push({op:"bcurveTo",data:[f+t+(n-t)*c+y(),d+e+(r-e)*c+y(),f+t+2*(n-t)*c+y(),d+e+2*(r-e)*c+y(),n+(M?0:y()),r+(M?0:y())]}):g.push({op:"bcurveTo",data:[f+t+(n-t)*c+v(),d+e+(r-e)*c+v(),f+t+2*(n-t)*c+v(),d+e+2*(r-e)*c+v(),n+(M?0:v()),r+(M?0:v())]}),g}function Q(t,e,n){if(!t.length)return[];var r=[];r.push([t[0][0]+F(e,n),t[0][1]+F(e,n)]),r.push([t[0][0]+F(e,n),t[0][1]+F(e,n)]);for(var a=1;a<t.length;a++)r.push([t[a][0]+F(e,n),t[a][1]+F(e,n)]),a===t.length-1&&r.push([t[a][0]+F(e,n),t[a][1]+F(e,n)]);return H(r,null,n)}function H(t,e,n){var r=t.length,a=[];if(r>3){var s=[],o=1-n.curveTightness;a.push({op:"move",data:[t[1][0],t[1][1]]});for(var i=1;i+2<r;i++){var h=t[i];s[0]=[h[0],h[1]],s[1]=[h[0]+(o*t[i+1][0]-o*t[i-1][0])/6,h[1]+(o*t[i+1][1]-o*t[i-1][1])/6],s[2]=[t[i+1][0]+(o*t[i][0]-o*t[i+2][0])/6,t[i+1][1]+(o*t[i][1]-o*t[i+2][1])/6],s[3]=[t[i+1][0],t[i+1][1]],a.push({op:"bcurveTo",data:[s[1][0],s[1][1],s[2][0],s[2][1],s[3][0],s[3][1]]})}if(e&&2===e.length){var u=n.maxRandomnessOffset;a.push({op:"lineTo",data:[e[0]+F(u,n),e[1]+F(u,n)]})}}else 3===r?(a.push({op:"move",data:[t[1][0],t[1][1]]}),a.push({op:"bcurveTo",data:[t[1][0],t[1][1],t[2][0],t[2][1],t[2][0],t[2][1]]})):2===r&&a.push.apply(a,Z(t[0][0],t[0][1],t[1][0],t[1][1],n,!0,!0));return a}function $(t,e,n,r,a,s,o,i){var h=[],u=[];if(0===i.roughness){t/=4,u.push([e+r*Math.cos(-t),n+a*Math.sin(-t)]);for(var p=0;p<=2*Math.PI;p+=t){var l=[e+r*Math.cos(p),n+a*Math.sin(p)];h.push(l),u.push(l)}u.push([e+r*Math.cos(0),n+a*Math.sin(0)]),u.push([e+r*Math.cos(t),n+a*Math.sin(t)])}else{var c=F(.5,i)-Math.PI/2;u.push([F(s,i)+e+.9*r*Math.cos(c-t),F(s,i)+n+.9*a*Math.sin(c-t)]);var f=2*Math.PI+c-.01;for(p=c;p<f;p+=t){l=[F(s,i)+e+r*Math.cos(p),F(s,i)+n+a*Math.sin(p)];h.push(l),u.push(l)}u.push([F(s,i)+e+r*Math.cos(c+2*Math.PI+.5*o),F(s,i)+n+a*Math.sin(c+2*Math.PI+.5*o)]),u.push([F(s,i)+e+.98*r*Math.cos(c+o),F(s,i)+n+.98*a*Math.sin(c+o)]),u.push([F(s,i)+e+.9*r*Math.cos(c+.5*o),F(s,i)+n+.9*a*Math.sin(c+.5*o)])}return[u,h]}function N(t,e,n,r,a,s,o,i,h){var u=s+F(.1,h),p=[];p.push([F(i,h)+e+.9*r*Math.cos(u-t),F(i,h)+n+.9*a*Math.sin(u-t)]);for(var l=u;l<=o;l+=t)p.push([F(i,h)+e+r*Math.cos(l),F(i,h)+n+a*Math.sin(l)]);return p.push([e+r*Math.cos(o),n+a*Math.sin(o)]),p.push([e+r*Math.cos(o),n+a*Math.sin(o)]),H(p,null,h)}function B(t,e,n,r,a,s,o,i){for(var h=[],u=[i.maxRandomnessOffset||1,(i.maxRandomnessOffset||1)+.3],p=[0,0],l=i.disableMultiStroke?1:2,c=i.preserveVertices,f=0;f<l;f++)0===f?h.push({op:"move",data:[o[0],o[1]]}):h.push({op:"move",data:[o[0]+(c?0:F(u[0],i)),o[1]+(c?0:F(u[0],i))]}),p=c?[a,s]:[a+F(u[f],i),s+F(u[f],i)],h.push({op:"bcurveTo",data:[t+F(u[f],i),e+F(u[f],i),n+F(u[f],i),r+F(u[f],i),p[0],p[1]]});return h}function J(t){return[...t]}function K(t,e=0){const n=t.length;if(n<3)throw new Error("A curve must have at least three points.");const r=[];if(3===n)r.push(J(t[0]),J(t[1]),J(t[2]),J(t[2]));else{const n=[];n.push(t[0],t[0]);for(let e=1;e<t.length;e++)n.push(t[e]),e===t.length-1&&n.push(t[e]);const a=[],s=1-e;r.push(J(n[0]));for(let t=1;t+2<n.length;t++){const e=n[t];a[0]=[e[0],e[1]],a[1]=[e[0]+(s*n[t+1][0]-s*n[t-1][0])/6,e[1]+(s*n[t+1][1]-s*n[t-1][1])/6],a[2]=[n[t+1][0]+(s*n[t][0]-s*n[t+2][0])/6,n[t+1][1]+(s*n[t][1]-s*n[t+2][1])/6],a[3]=[n[t+1][0],n[t+1][1]],r.push(a[1],a[2],a[3])}}return r}function U(t,e){return Math.pow(t[0]-e[0],2)+Math.pow(t[1]-e[1],2)}function X(t,e,n){const r=U(e,n);if(0===r)return U(t,e);let a=((t[0]-e[0])*(n[0]-e[0])+(t[1]-e[1])*(n[1]-e[1]))/r;return a=Math.max(0,Math.min(1,a)),U(t,Y(e,n,a))}function Y(t,e,n){return[t[0]+(e[0]-t[0])*n,t[1]+(e[1]-t[1])*n]}function tt(t,e,n,r){const a=r||[];if(function(t,e){const n=t[e+0],r=t[e+1],a=t[e+2],s=t[e+3];let o=3*r[0]-2*n[0]-s[0];o*=o;let i=3*r[1]-2*n[1]-s[1];i*=i;let h=3*a[0]-2*s[0]-n[0];h*=h;let u=3*a[1]-2*s[1]-n[1];return u*=u,o<h&&(o=h),i<u&&(i=u),o+i}(t,e)<n){const n=t[e+0];if(a.length){(s=a[a.length-1],o=n,Math.sqrt(U(s,o)))>1&&a.push(n)}else a.push(n);a.push(t[e+3])}else{const r=.5,s=t[e+0],o=t[e+1],i=t[e+2],h=t[e+3],u=Y(s,o,r),p=Y(o,i,r),l=Y(i,h,r),c=Y(u,p,r),f=Y(p,l,r),d=Y(c,f,r);tt([s,u,c,d],0,n,a),tt([d,f,l,h],0,n,a)}var s,o;return a}function et(t,e){return nt(t,0,t.length,e)}function nt(t,e,n,r,a){const s=a||[],o=t[e],i=t[n-1];let h=0,u=1;for(let r=e+1;r<n-1;++r){const e=X(t[r],o,i);e>h&&(h=e,u=r)}return Math.sqrt(h)>r?(nt(t,e,u+1,r,s),nt(t,u,n,r,s)):(s.length||s.push(o),s.push(i)),s}function rt(t,e=.15,n){const r=[],a=(t.length-1)/3;for(let n=0;n<a;n++){tt(t,3*n,e,r)}return n&&n>0?nt(r,0,r.length,n):r}var at="none",st=function(){function t(t){this.defaultOptions={maxRandomnessOffset:2,roughness:1,bowing:1,stroke:"#000",strokeWidth:1,curveTightness:0,curveFitting:.95,curveStepCount:9,fillStyle:"hachure",fillWeight:-1,hachureAngle:-41,hachureGap:-1,dashOffset:-1,dashGap:-1,zigzagOffset:-1,seed:0,disableMultiStroke:!1,disableMultiStrokeFill:!1,preserveVertices:!1,fillShapeRoughnessGain:.8},this.config=t||{},this.config.options&&(this.defaultOptions=this._o(this.config.options))}return t.newSeed=function(){return Math.floor(Math.random()*Math.pow(2,31))},t.prototype._o=function(t){return t?Object.assign({},this.defaultOptions,t):this.defaultOptions},t.prototype._d=function(t,e,n){return{shape:t,sets:e||[],options:n||this.defaultOptions}},t.prototype.line=function(t,e,n,r,a){var s=this._o(a);return this._d("line",[T(t,e,n,r,s)],s)},t.prototype.rectangle=function(t,e,n,r,a){var s=this._o(a),o=[],i=D(t,e,n,r,s);if(s.fill){var h=[[t,e],[t+n,e],[t+n,e+r],[t,e+r]];"solid"===s.fillStyle?o.push(E([h],s)):o.push(G([h],s))}return s.stroke!==at&&o.push(i),this._d("rectangle",o,s)},t.prototype.ellipse=function(t,e,n,r,a){var s=this._o(a),o=[],i=I(n,r,s),h=C(t,e,s,i);if(s.fill)if("solid"===s.fillStyle){var u=C(t,e,s,i).opset;u.type="fillPath",o.push(u)}else o.push(G([h.estimatedPoints],s));return s.stroke!==at&&o.push(h.opset),this._d("ellipse",o,s)},t.prototype.circle=function(t,e,n,r){var a=this.ellipse(t,e,n,n,r);return a.shape="circle",a},t.prototype.linearPath=function(t,e){var n=this._o(e);return this._d("linearPath",[_(t,!1,n)],n)},t.prototype.arc=function(t,e,r,a,s,o,i,h){void 0===i&&(i=!1);var u=this._o(h),p=[],l=z(t,e,r,a,s,o,i,!0,u);if(i&&u.fill)if("solid"===u.fillStyle){var c=n({},u);c.disableMultiStroke=!0;var f=z(t,e,r,a,s,o,!0,!1,c);f.type="fillPath",p.push(f)}else p.push(function(t,e,n,r,a,s,o){var i=t,h=e,u=Math.abs(n/2),p=Math.abs(r/2);u+=F(.01*u,o),p+=F(.01*p,o);for(var l=a,c=s;l<0;)l+=2*Math.PI,c+=2*Math.PI;c-l>2*Math.PI&&(l=0,c=2*Math.PI);for(var f=(c-l)/o.curveStepCount,d=[],g=l;g<=c;g+=f)d.push([i+u*Math.cos(g),h+p*Math.sin(g)]);return d.push([i+u*Math.cos(c),h+p*Math.sin(c)]),d.push([i,h]),G([d],o)}(t,e,r,a,s,o,u));return u.stroke!==at&&p.push(l),this._d("arc",p,u)},t.prototype.curve=function(t,e){var r=this._o(e),a=[],s=A(t,r);if(r.fill&&r.fill!==at)if("solid"===r.fillStyle){var o=A(t,n(n({},r),{disableMultiStroke:!0,roughness:r.roughness?r.roughness+r.fillShapeRoughnessGain:0}));a.push({type:"fillPath",ops:this._mergedShape(o.ops)})}else{var i=[],h=t;if(h.length)for(var u=0,p="number"==typeof h[0][0]?[h]:h;u<p.length;u++){var l=p[u];l.length<3?i.push.apply(i,l):3===l.length?i.push.apply(i,rt(K([l[0],l[0],l[1],l[2]]),10,(1+r.roughness)/2)):i.push.apply(i,rt(K(l),10,(1+r.roughness)/2))}i.length&&a.push(G([i],r))}return r.stroke!==at&&a.push(s),this._d("curve",a,r)},t.prototype.polygon=function(t,e){var n=this._o(e),r=[],a=_(t,!0,n);return n.fill&&("solid"===n.fillStyle?r.push(E([t],n)):r.push(G([t],n))),n.stroke!==at&&r.push(a),this._d("polygon",r,n)},t.prototype.path=function(t,e){var r=this._o(e),a=[];if(!t)return this._d("path",a,r);t=(t||"").replace(/\n/g," ").replace(/(-\s)/g,"-").replace("/(ss)/g"," ");var s=r.fill&&"transparent"!==r.fill&&r.fill!==at,o=r.stroke!==at,i=!!(r.simplification&&r.simplification<1),h=function(t,e,n){const r=x(P(w(t))),a=[];let s=[],o=[0,0],i=[];const h=()=>{i.length>=4&&s.push(...rt(i,e)),i=[]},u=()=>{h(),s.length&&(a.push(s),s=[])};for(const{key:t,data:e}of r)switch(t){case"M":u(),o=[e[0],e[1]],s.push(o);break;case"L":h(),s.push([e[0],e[1]]);break;case"C":if(!i.length){const t=s.length?s[s.length-1]:o;i.push([t[0],t[1]])}i.push([e[0],e[1]]),i.push([e[2],e[3]]),i.push([e[4],e[5]]);break;case"Z":h(),s.push([o[0],o[1]])}if(u(),!n)return a;const p=[];for(const t of a){const e=et(t,n);e.length&&p.push(e)}return p}(t,1,i?4-4*(r.simplification||1):(1+r.roughness)/2),u=W(t,r);if(s)if("solid"===r.fillStyle)if(1===h.length){var p=W(t,n(n({},r),{disableMultiStroke:!0,roughness:r.roughness?r.roughness+r.fillShapeRoughnessGain:0}));a.push({type:"fillPath",ops:this._mergedShape(p.ops)})}else a.push(E(h,r));else a.push(G(h,r));return o&&(i?h.forEach((function(t){a.push(_(t,!1,r))})):a.push(u)),this._d("path",a,r)},t.prototype.opsToPath=function(t,e){for(var n="",r=0,a=t.ops;r<a.length;r++){var s=a[r],o="number"==typeof e&&e>=0?s.data.map((function(t){return+t.toFixed(e)})):s.data;switch(s.op){case"move":n+="M".concat(o[0]," ").concat(o[1]," ");break;case"bcurveTo":n+="C".concat(o[0]," ").concat(o[1],", ").concat(o[2]," ").concat(o[3],", ").concat(o[4]," ").concat(o[5]," ");break;case"lineTo":n+="L".concat(o[0]," ").concat(o[1]," ")}}return n.trim()},t.prototype.toPaths=function(t){for(var e=t.sets||[],n=t.options||this.defaultOptions,r=[],a=0,s=e;a<s.length;a++){var o=s[a],i=null;switch(o.type){case"path":i={d:this.opsToPath(o),stroke:n.stroke,strokeWidth:n.strokeWidth,fill:at};break;case"fillPath":i={d:this.opsToPath(o),stroke:at,strokeWidth:0,fill:n.fill||at};break;case"fillSketch":i=this.fillSketch(o,n)}i&&r.push(i)}return r},t.prototype.fillSketch=function(t,e){var n=e.fillWeight;return n<0&&(n=e.strokeWidth/2),{d:this.opsToPath(t),stroke:e.fill||at,strokeWidth:n,fill:at}},t.prototype._mergedShape=function(t){return t.filter((function(t,e){return 0===e||"move"!==t.op}))},t}(),ot=function(){function t(t,e){this.canvas=t,this.ctx=this.canvas.getContext("2d"),this.gen=new st(e)}return t.prototype.draw=function(t){for(var e=t.sets||[],n=t.options||this.getDefaultOptions(),r=this.ctx,a=t.options.fixedDecimalPlaceDigits,s=0,o=e;s<o.length;s++){var i=o[s];switch(i.type){case"path":r.save(),r.strokeStyle="none"===n.stroke?"transparent":n.stroke,r.lineWidth=n.strokeWidth,n.strokeLineDash&&r.setLineDash(n.strokeLineDash),n.strokeLineDashOffset&&(r.lineDashOffset=n.strokeLineDashOffset),this._drawToContext(r,i,a),r.restore();break;case"fillPath":r.save(),r.fillStyle=n.fill||"";var h="curve"===t.shape||"polygon"===t.shape||"path"===t.shape?"evenodd":"nonzero";this._drawToContext(r,i,a,h),r.restore();break;case"fillSketch":this.fillSketch(r,i,n)}}},t.prototype.fillSketch=function(t,e,n){var r=n.fillWeight;r<0&&(r=n.strokeWidth/2),t.save(),n.fillLineDash&&t.setLineDash(n.fillLineDash),n.fillLineDashOffset&&(t.lineDashOffset=n.fillLineDashOffset),t.strokeStyle=n.fill||"",t.lineWidth=r,this._drawToContext(t,e,n.fixedDecimalPlaceDigits),t.restore()},t.prototype._drawToContext=function(t,e,n,r){void 0===r&&(r="nonzero"),t.beginPath();for(var a=0,s=e.ops;a<s.length;a++){var o=s[a],i="number"==typeof n&&n>=0?o.data.map((function(t){return+t.toFixed(n)})):o.data;switch(o.op){case"move":t.moveTo(i[0],i[1]);break;case"bcurveTo":t.bezierCurveTo(i[0],i[1],i[2],i[3],i[4],i[5]);break;case"lineTo":t.lineTo(i[0],i[1])}}"fillPath"===e.type?t.fill(r):t.stroke()},Object.defineProperty(t.prototype,"generator",{get:function(){return this.gen},enumerable:!1,configurable:!0}),t.prototype.getDefaultOptions=function(){return this.gen.defaultOptions},t.prototype.line=function(t,e,n,r,a){var s=this.gen.line(t,e,n,r,a);return this.draw(s),s},t.prototype.rectangle=function(t,e,n,r,a){var s=this.gen.rectangle(t,e,n,r,a);return this.draw(s),s},t.prototype.ellipse=function(t,e,n,r,a){var s=this.gen.ellipse(t,e,n,r,a);return this.draw(s),s},t.prototype.circle=function(t,e,n,r){var a=this.gen.circle(t,e,n,r);return this.draw(a),a},t.prototype.linearPath=function(t,e){var n=this.gen.linearPath(t,e);return this.draw(n),n},t.prototype.polygon=function(t,e){var n=this.gen.polygon(t,e);return this.draw(n),n},t.prototype.arc=function(t,e,n,r,a,s,o,i){void 0===o&&(o=!1);var h=this.gen.arc(t,e,n,r,a,s,o,i);return this.draw(h),h},t.prototype.curve=function(t,e){var n=this.gen.curve(t,e);return this.draw(n),n},t.prototype.path=function(t,e){var n=this.gen.path(t,e);return this.draw(n),n},t}(),it="http://www.w3.org/2000/svg",ht=function(){function t(t,e){this.svg=t,this.gen=new st(e)}return t.prototype.draw=function(t){for(var e=t.sets||[],n=t.options||this.getDefaultOptions(),r=this.svg.ownerDocument||window.document,a=r.createElementNS(it,"g"),s=t.options.fixedDecimalPlaceDigits,o=0,i=e;o<i.length;o++){var h=i[o],u=null;switch(h.type){case"path":(u=r.createElementNS(it,"path")).setAttribute("d",this.opsToPath(h,s)),u.setAttribute("stroke",n.stroke),u.setAttribute("stroke-width",n.strokeWidth+""),u.setAttribute("fill","none"),n.strokeLineDash&&u.setAttribute("stroke-dasharray",n.strokeLineDash.join(" ").trim()),n.strokeLineDashOffset&&u.setAttribute("stroke-dashoffset","".concat(n.strokeLineDashOffset));break;case"fillPath":(u=r.createElementNS(it,"path")).setAttribute("d",this.opsToPath(h,s)),u.setAttribute("stroke","none"),u.setAttribute("stroke-width","0"),u.setAttribute("fill",n.fill||""),"curve"!==t.shape&&"polygon"!==t.shape||u.setAttribute("fill-rule","evenodd");break;case"fillSketch":u=this.fillSketch(r,h,n)}u&&a.appendChild(u)}return a},t.prototype.fillSketch=function(t,e,n){var r=n.fillWeight;r<0&&(r=n.strokeWidth/2);var a=t.createElementNS(it,"path");return a.setAttribute("d",this.opsToPath(e,n.fixedDecimalPlaceDigits)),a.setAttribute("stroke",n.fill||""),a.setAttribute("stroke-width",r+""),a.setAttribute("fill","none"),n.fillLineDash&&a.setAttribute("stroke-dasharray",n.fillLineDash.join(" ").trim()),n.fillLineDashOffset&&a.setAttribute("stroke-dashoffset","".concat(n.fillLineDashOffset)),a},Object.defineProperty(t.prototype,"generator",{get:function(){return this.gen},enumerable:!1,configurable:!0}),t.prototype.getDefaultOptions=function(){return this.gen.defaultOptions},t.prototype.opsToPath=function(t,e){return this.gen.opsToPath(t,e)},t.prototype.line=function(t,e,n,r,a){var s=this.gen.line(t,e,n,r,a);return this.draw(s)},t.prototype.rectangle=function(t,e,n,r,a){var s=this.gen.rectangle(t,e,n,r,a);return this.draw(s)},t.prototype.ellipse=function(t,e,n,r,a){var s=this.gen.ellipse(t,e,n,r,a);return this.draw(s)},t.prototype.circle=function(t,e,n,r){var a=this.gen.circle(t,e,n,r);return this.draw(a)},t.prototype.linearPath=function(t,e){var n=this.gen.linearPath(t,e);return this.draw(n)},t.prototype.polygon=function(t,e){var n=this.gen.polygon(t,e);return this.draw(n)},t.prototype.arc=function(t,e,n,r,a,s,o,i){void 0===o&&(o=!1);var h=this.gen.arc(t,e,n,r,a,s,o,i);return this.draw(h)},t.prototype.curve=function(t,e){var n=this.gen.curve(t,e);return this.draw(n)},t.prototype.path=function(t,e){var n=this.gen.path(t,e);return this.draw(n)},t}(),ut={canvas:function(t,e){return new ot(t,e)},svg:function(t,e){return new ht(t,e)},generator:function(t){return new st(t)},newSeed:function(){return st.newSeed()}};module.exports=ut;


/***/ }),

/***/ "./node_modules/simplex-noise/dist/cjs/simplex-noise.js":
/*!**************************************************************!*\
  !*** ./node_modules/simplex-noise/dist/cjs/simplex-noise.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * A fast javascript implementation of simplex noise by Jonas Wagner

Based on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.
Which is based on example code by Stefan Gustavson (stegu@itn.liu.se).
With Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
Better rank ordering method by Stefan Gustavson in 2012.

 Copyright (c) 2022 Jonas Wagner

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildPermutationTable = exports.createNoise4D = exports.createNoise3D = exports.createNoise2D = void 0;
// these #__PURE__ comments help uglifyjs with dead code removal
// 
const F2 = /*#__PURE__*/ 0.5 * (Math.sqrt(3.0) - 1.0);
const G2 = /*#__PURE__*/ (3.0 - Math.sqrt(3.0)) / 6.0;
const F3 = 1.0 / 3.0;
const G3 = 1.0 / 6.0;
const F4 = /*#__PURE__*/ (Math.sqrt(5.0) - 1.0) / 4.0;
const G4 = /*#__PURE__*/ (5.0 - Math.sqrt(5.0)) / 20.0;
// I'm really not sure why this | 0 (basically a coercion to int)
// is making this faster but I get ~5 million ops/sec more on the
// benchmarks across the board or a ~10% speedup.
const fastFloor = (x) => Math.floor(x) | 0;
const grad2 = /*#__PURE__*/ new Float64Array([1, 1,
    -1, 1,
    1, -1,
    -1, -1,
    1, 0,
    -1, 0,
    1, 0,
    -1, 0,
    0, 1,
    0, -1,
    0, 1,
    0, -1]);
// double seems to be faster than single or int's
// probably because most operations are in double precision
const grad3 = /*#__PURE__*/ new Float64Array([1, 1, 0,
    -1, 1, 0,
    1, -1, 0,
    -1, -1, 0,
    1, 0, 1,
    -1, 0, 1,
    1, 0, -1,
    -1, 0, -1,
    0, 1, 1,
    0, -1, 1,
    0, 1, -1,
    0, -1, -1]);
// double is a bit quicker here as well
const grad4 = /*#__PURE__*/ new Float64Array([0, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1,
    0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1,
    1, 0, 1, 1, 1, 0, 1, -1, 1, 0, -1, 1, 1, 0, -1, -1,
    -1, 0, 1, 1, -1, 0, 1, -1, -1, 0, -1, 1, -1, 0, -1, -1,
    1, 1, 0, 1, 1, 1, 0, -1, 1, -1, 0, 1, 1, -1, 0, -1,
    -1, 1, 0, 1, -1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, -1,
    1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0,
    -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 0]);
/**
 * Creates a 2D noise function
 * @param random the random function that will be used to build the permutation table
 * @returns {NoiseFunction2D}
 */
function createNoise2D(random = Math.random) {
    const perm = buildPermutationTable(random);
    // precalculating this yields a little ~3% performance improvement.
    const permGrad2x = new Float64Array(perm).map(v => grad2[(v % 12) * 2]);
    const permGrad2y = new Float64Array(perm).map(v => grad2[(v % 12) * 2 + 1]);
    return function noise2D(x, y) {
        // if(!isFinite(x) || !isFinite(y)) return 0;
        let n0 = 0; // Noise contributions from the three corners
        let n1 = 0;
        let n2 = 0;
        // Skew the input space to determine which simplex cell we're in
        const s = (x + y) * F2; // Hairy factor for 2D
        const i = fastFloor(x + s);
        const j = fastFloor(y + s);
        const t = (i + j) * G2;
        const X0 = i - t; // Unskew the cell origin back to (x,y) space
        const Y0 = j - t;
        const x0 = x - X0; // The x,y distances from the cell origin
        const y0 = y - Y0;
        // For the 2D case, the simplex shape is an equilateral triangle.
        // Determine which simplex we are in.
        let i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
        if (x0 > y0) {
            i1 = 1;
            j1 = 0;
        } // lower triangle, XY order: (0,0)->(1,0)->(1,1)
        else {
            i1 = 0;
            j1 = 1;
        } // upper triangle, YX order: (0,0)->(0,1)->(1,1)
        // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
        // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
        // c = (3-sqrt(3))/6
        const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
        const y1 = y0 - j1 + G2;
        const x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
        const y2 = y0 - 1.0 + 2.0 * G2;
        // Work out the hashed gradient indices of the three simplex corners
        const ii = i & 255;
        const jj = j & 255;
        // Calculate the contribution from the three corners
        let t0 = 0.5 - x0 * x0 - y0 * y0;
        if (t0 >= 0) {
            const gi0 = ii + perm[jj];
            const g0x = permGrad2x[gi0];
            const g0y = permGrad2y[gi0];
            t0 *= t0;
            // n0 = t0 * t0 * (grad2[gi0] * x0 + grad2[gi0 + 1] * y0); // (x,y) of grad3 used for 2D gradient
            n0 = t0 * t0 * (g0x * x0 + g0y * y0);
        }
        let t1 = 0.5 - x1 * x1 - y1 * y1;
        if (t1 >= 0) {
            const gi1 = ii + i1 + perm[jj + j1];
            const g1x = permGrad2x[gi1];
            const g1y = permGrad2y[gi1];
            t1 *= t1;
            // n1 = t1 * t1 * (grad2[gi1] * x1 + grad2[gi1 + 1] * y1);
            n1 = t1 * t1 * (g1x * x1 + g1y * y1);
        }
        let t2 = 0.5 - x2 * x2 - y2 * y2;
        if (t2 >= 0) {
            const gi2 = ii + 1 + perm[jj + 1];
            const g2x = permGrad2x[gi2];
            const g2y = permGrad2y[gi2];
            t2 *= t2;
            // n2 = t2 * t2 * (grad2[gi2] * x2 + grad2[gi2 + 1] * y2);
            n2 = t2 * t2 * (g2x * x2 + g2y * y2);
        }
        // Add contributions from each corner to get the final noise value.
        // The result is scaled to return values in the interval [-1,1].
        return 70.0 * (n0 + n1 + n2);
    };
}
exports.createNoise2D = createNoise2D;
/**
 * Creates a 3D noise function
 * @param random the random function that will be used to build the permutation table
 * @returns {NoiseFunction3D}
 */
function createNoise3D(random = Math.random) {
    const perm = buildPermutationTable(random);
    // precalculating these seems to yield a speedup of over 15%
    const permGrad3x = new Float64Array(perm).map(v => grad3[(v % 12) * 3]);
    const permGrad3y = new Float64Array(perm).map(v => grad3[(v % 12) * 3 + 1]);
    const permGrad3z = new Float64Array(perm).map(v => grad3[(v % 12) * 3 + 2]);
    return function noise3D(x, y, z) {
        let n0, n1, n2, n3; // Noise contributions from the four corners
        // Skew the input space to determine which simplex cell we're in
        const s = (x + y + z) * F3; // Very nice and simple skew factor for 3D
        const i = fastFloor(x + s);
        const j = fastFloor(y + s);
        const k = fastFloor(z + s);
        const t = (i + j + k) * G3;
        const X0 = i - t; // Unskew the cell origin back to (x,y,z) space
        const Y0 = j - t;
        const Z0 = k - t;
        const x0 = x - X0; // The x,y,z distances from the cell origin
        const y0 = y - Y0;
        const z0 = z - Z0;
        // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
        // Determine which simplex we are in.
        let i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
        let i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
        if (x0 >= y0) {
            if (y0 >= z0) {
                i1 = 1;
                j1 = 0;
                k1 = 0;
                i2 = 1;
                j2 = 1;
                k2 = 0;
            } // X Y Z order
            else if (x0 >= z0) {
                i1 = 1;
                j1 = 0;
                k1 = 0;
                i2 = 1;
                j2 = 0;
                k2 = 1;
            } // X Z Y order
            else {
                i1 = 0;
                j1 = 0;
                k1 = 1;
                i2 = 1;
                j2 = 0;
                k2 = 1;
            } // Z X Y order
        }
        else { // x0<y0
            if (y0 < z0) {
                i1 = 0;
                j1 = 0;
                k1 = 1;
                i2 = 0;
                j2 = 1;
                k2 = 1;
            } // Z Y X order
            else if (x0 < z0) {
                i1 = 0;
                j1 = 1;
                k1 = 0;
                i2 = 0;
                j2 = 1;
                k2 = 1;
            } // Y Z X order
            else {
                i1 = 0;
                j1 = 1;
                k1 = 0;
                i2 = 1;
                j2 = 1;
                k2 = 0;
            } // Y X Z order
        }
        // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
        // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
        // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
        // c = 1/6.
        const x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
        const y1 = y0 - j1 + G3;
        const z1 = z0 - k1 + G3;
        const x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords
        const y2 = y0 - j2 + 2.0 * G3;
        const z2 = z0 - k2 + 2.0 * G3;
        const x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords
        const y3 = y0 - 1.0 + 3.0 * G3;
        const z3 = z0 - 1.0 + 3.0 * G3;
        // Work out the hashed gradient indices of the four simplex corners
        const ii = i & 255;
        const jj = j & 255;
        const kk = k & 255;
        // Calculate the contribution from the four corners
        let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
        if (t0 < 0)
            n0 = 0.0;
        else {
            const gi0 = ii + perm[jj + perm[kk]];
            t0 *= t0;
            n0 = t0 * t0 * (permGrad3x[gi0] * x0 + permGrad3y[gi0] * y0 + permGrad3z[gi0] * z0);
        }
        let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
        if (t1 < 0)
            n1 = 0.0;
        else {
            const gi1 = ii + i1 + perm[jj + j1 + perm[kk + k1]];
            t1 *= t1;
            n1 = t1 * t1 * (permGrad3x[gi1] * x1 + permGrad3y[gi1] * y1 + permGrad3z[gi1] * z1);
        }
        let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
        if (t2 < 0)
            n2 = 0.0;
        else {
            const gi2 = ii + i2 + perm[jj + j2 + perm[kk + k2]];
            t2 *= t2;
            n2 = t2 * t2 * (permGrad3x[gi2] * x2 + permGrad3y[gi2] * y2 + permGrad3z[gi2] * z2);
        }
        let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
        if (t3 < 0)
            n3 = 0.0;
        else {
            const gi3 = ii + 1 + perm[jj + 1 + perm[kk + 1]];
            t3 *= t3;
            n3 = t3 * t3 * (permGrad3x[gi3] * x3 + permGrad3y[gi3] * y3 + permGrad3z[gi3] * z3);
        }
        // Add contributions from each corner to get the final noise value.
        // The result is scaled to stay just inside [-1,1]
        return 32.0 * (n0 + n1 + n2 + n3);
    };
}
exports.createNoise3D = createNoise3D;
/**
 * Creates a 4D noise function
 * @param random the random function that will be used to build the permutation table
 * @returns {NoiseFunction4D}
 */
function createNoise4D(random = Math.random) {
    const perm = buildPermutationTable(random);
    // precalculating these leads to a ~10% speedup
    const permGrad4x = new Float64Array(perm).map(v => grad4[(v % 32) * 4]);
    const permGrad4y = new Float64Array(perm).map(v => grad4[(v % 32) * 4 + 1]);
    const permGrad4z = new Float64Array(perm).map(v => grad4[(v % 32) * 4 + 2]);
    const permGrad4w = new Float64Array(perm).map(v => grad4[(v % 32) * 4 + 3]);
    return function noise4D(x, y, z, w) {
        let n0, n1, n2, n3, n4; // Noise contributions from the five corners
        // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in
        const s = (x + y + z + w) * F4; // Factor for 4D skewing
        const i = fastFloor(x + s);
        const j = fastFloor(y + s);
        const k = fastFloor(z + s);
        const l = fastFloor(w + s);
        const t = (i + j + k + l) * G4; // Factor for 4D unskewing
        const X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space
        const Y0 = j - t;
        const Z0 = k - t;
        const W0 = l - t;
        const x0 = x - X0; // The x,y,z,w distances from the cell origin
        const y0 = y - Y0;
        const z0 = z - Z0;
        const w0 = w - W0;
        // For the 4D case, the simplex is a 4D shape I won't even try to describe.
        // To find out which of the 24 possible simplices we're in, we need to
        // determine the magnitude ordering of x0, y0, z0 and w0.
        // Six pair-wise comparisons are performed between each possible pair
        // of the four coordinates, and the results are used to rank the numbers.
        let rankx = 0;
        let ranky = 0;
        let rankz = 0;
        let rankw = 0;
        if (x0 > y0)
            rankx++;
        else
            ranky++;
        if (x0 > z0)
            rankx++;
        else
            rankz++;
        if (x0 > w0)
            rankx++;
        else
            rankw++;
        if (y0 > z0)
            ranky++;
        else
            rankz++;
        if (y0 > w0)
            ranky++;
        else
            rankw++;
        if (z0 > w0)
            rankz++;
        else
            rankw++;
        // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.
        // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w
        // impossible. Only the 24 indices which have non-zero entries make any sense.
        // We use a thresholding to set the coordinates in turn from the largest magnitude.
        // Rank 3 denotes the largest coordinate.
        // Rank 2 denotes the second largest coordinate.
        // Rank 1 denotes the second smallest coordinate.
        // The integer offsets for the second simplex corner
        const i1 = rankx >= 3 ? 1 : 0;
        const j1 = ranky >= 3 ? 1 : 0;
        const k1 = rankz >= 3 ? 1 : 0;
        const l1 = rankw >= 3 ? 1 : 0;
        // The integer offsets for the third simplex corner
        const i2 = rankx >= 2 ? 1 : 0;
        const j2 = ranky >= 2 ? 1 : 0;
        const k2 = rankz >= 2 ? 1 : 0;
        const l2 = rankw >= 2 ? 1 : 0;
        // The integer offsets for the fourth simplex corner
        const i3 = rankx >= 1 ? 1 : 0;
        const j3 = ranky >= 1 ? 1 : 0;
        const k3 = rankz >= 1 ? 1 : 0;
        const l3 = rankw >= 1 ? 1 : 0;
        // The fifth corner has all coordinate offsets = 1, so no need to compute that.
        const x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords
        const y1 = y0 - j1 + G4;
        const z1 = z0 - k1 + G4;
        const w1 = w0 - l1 + G4;
        const x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords
        const y2 = y0 - j2 + 2.0 * G4;
        const z2 = z0 - k2 + 2.0 * G4;
        const w2 = w0 - l2 + 2.0 * G4;
        const x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords
        const y3 = y0 - j3 + 3.0 * G4;
        const z3 = z0 - k3 + 3.0 * G4;
        const w3 = w0 - l3 + 3.0 * G4;
        const x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords
        const y4 = y0 - 1.0 + 4.0 * G4;
        const z4 = z0 - 1.0 + 4.0 * G4;
        const w4 = w0 - 1.0 + 4.0 * G4;
        // Work out the hashed gradient indices of the five simplex corners
        const ii = i & 255;
        const jj = j & 255;
        const kk = k & 255;
        const ll = l & 255;
        // Calculate the contribution from the five corners
        let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
        if (t0 < 0)
            n0 = 0.0;
        else {
            const gi0 = ii + perm[jj + perm[kk + perm[ll]]];
            t0 *= t0;
            n0 = t0 * t0 * (permGrad4x[gi0] * x0 + permGrad4y[gi0] * y0 + permGrad4z[gi0] * z0 + permGrad4w[gi0] * w0);
        }
        let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
        if (t1 < 0)
            n1 = 0.0;
        else {
            const gi1 = ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]];
            t1 *= t1;
            n1 = t1 * t1 * (permGrad4x[gi1] * x1 + permGrad4y[gi1] * y1 + permGrad4z[gi1] * z1 + permGrad4w[gi1] * w1);
        }
        let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
        if (t2 < 0)
            n2 = 0.0;
        else {
            const gi2 = ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]];
            t2 *= t2;
            n2 = t2 * t2 * (permGrad4x[gi2] * x2 + permGrad4y[gi2] * y2 + permGrad4z[gi2] * z2 + permGrad4w[gi2] * w2);
        }
        let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
        if (t3 < 0)
            n3 = 0.0;
        else {
            const gi3 = ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]];
            t3 *= t3;
            n3 = t3 * t3 * (permGrad4x[gi3] * x3 + permGrad4y[gi3] * y3 + permGrad4z[gi3] * z3 + permGrad4w[gi3] * w3);
        }
        let t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
        if (t4 < 0)
            n4 = 0.0;
        else {
            const gi4 = ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]];
            t4 *= t4;
            n4 = t4 * t4 * (permGrad4x[gi4] * x4 + permGrad4y[gi4] * y4 + permGrad4z[gi4] * z4 + permGrad4w[gi4] * w4);
        }
        // Sum up and scale the result to cover the range [-1,1]
        return 27.0 * (n0 + n1 + n2 + n3 + n4);
    };
}
exports.createNoise4D = createNoise4D;
/**
 * Builds a random permutation table.
 * This is exported only for (internal) testing purposes.
 * Do not rely on this export.
 * @private
 */
function buildPermutationTable(random) {
    const tableSize = 512;
    const p = new Uint8Array(tableSize);
    for (let i = 0; i < tableSize / 2; i++) {
        p[i] = i;
    }
    for (let i = 0; i < tableSize / 2 - 1; i++) {
        const r = i + ~~(random() * (256 - i));
        const aux = p[i];
        p[i] = p[r];
        p[r] = aux;
    }
    for (let i = 256; i < tableSize; i++) {
        p[i] = p[i - 256];
    }
    return p;
}
exports.buildPermutationTable = buildPermutationTable;
//# sourceMappingURL=simplex-noise.js.map

/***/ }),

/***/ "./node_modules/simplify-js/simplify.js":
/*!**********************************************!*\
  !*** ./node_modules/simplify-js/simplify.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

(function () { 'use strict';

// to suit your point format, run search/replace for '.x' and '.y';
// for 3D version, see 3d branch (configurability would draw significant performance overhead)

// square distance between 2 points
function getSqDist(p1, p2) {

    var dx = p1.x - p2.x,
        dy = p1.y - p2.y;

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2) {

    var x = p1.x,
        y = p1.y,
        dx = p2.x - x,
        dy = p2.y - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2.x;
            y = p2.y;

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p.x - x;
    dy = p.y - y;

    return dx * dx + dy * dy;
}
// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance) {

    var prevPoint = points[0],
        newPoints = [prevPoint],
        point;

    for (var i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified) {
    var maxSqDist = sqTolerance,
        index;

    for (var i = first + 1; i < last; i++) {
        var sqDist = getSqSegDist(points[i], points[first], points[last]);

        if (sqDist > maxSqDist) {
            index = i;
            maxSqDist = sqDist;
        }
    }

    if (maxSqDist > sqTolerance) {
        if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
        simplified.push(points[index]);
        if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
    }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance) {
    var last = points.length - 1;

    var simplified = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

// both algorithms combined for awesome performance
function simplify(points, tolerance, highestQuality) {

    if (points.length <= 2) return points;

    var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}

// export as AMD module / Node module / browser or worker variable
if (true) !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return simplify; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
else {}

})();


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const log = __importStar(__webpack_require__(/*! loglevel */ "./node_modules/loglevel/lib/loglevel.js"));
const dat = __importStar(__webpack_require__(/*! dat.gui */ "./node_modules/dat.gui/build/dat.gui.module.js"));
const tensor_field_gui_1 = __importDefault(__webpack_require__(/*! ./ts/ui/tensor_field_gui */ "./src/ts/ui/tensor_field_gui.ts"));
const main_gui_1 = __importDefault(__webpack_require__(/*! ./ts/ui/main_gui */ "./src/ts/ui/main_gui.ts"));
const canvas_wrapper_1 = __webpack_require__(/*! ./ts/ui/canvas_wrapper */ "./src/ts/ui/canvas_wrapper.ts");
const util_1 = __importDefault(__webpack_require__(/*! ./ts/util */ "./src/ts/util.ts"));
const drag_controller_1 = __importDefault(__webpack_require__(/*! ./ts/ui/drag_controller */ "./src/ts/ui/drag_controller.ts"));
const domain_controller_1 = __importDefault(__webpack_require__(/*! ./ts/ui/domain_controller */ "./src/ts/ui/domain_controller.ts"));
const style_1 = __webpack_require__(/*! ./ts/ui/style */ "./src/ts/ui/style.ts");
const ColourSchemes = __importStar(__webpack_require__(/*! ./colour_schemes.json */ "./src/colour_schemes.json"));
const vector_1 = __importDefault(__webpack_require__(/*! ./ts/vector */ "./src/ts/vector.ts"));
const svg_js_1 = __webpack_require__(/*! @svgdotjs/svg.js */ "./node_modules/@svgdotjs/svg.js/dist/svg.esm.js");
const file_saver_1 = __webpack_require__(/*! file-saver */ "./node_modules/file-saver/dist/FileSaver.min.js");
class Main {
    STARTING_WIDTH = 1440; // Initially zooms in if width > STARTING_WIDTH
    // UI
    gui = new dat.GUI({ width: 300 });
    tensorFolder;
    roadsFolder;
    styleFolder;
    optionsFolder;
    downloadsFolder;
    domainController = domain_controller_1.default.getInstance();
    dragController = new drag_controller_1.default(this.gui);
    tensorField;
    mainGui; // In charge of glueing everything together
    // Options
    imageScale = 3; // Multiplier for res of downloaded image
    highDPI = true; // Increases resolution for hiDPI displays
    // Style options
    canvas;
    tensorCanvas;
    _style;
    colourScheme = "Google"; // See colour_schemes.json
    zoomBuildings = false; // Show buildings only when zoomed in?
    buildingModels = true; // Draw pseudo-3D buildings?
    showFrame = false;
    // Force redraw of roads when switching from tensor vis to map vis
    previousFrameDrawTensor = true;
    // 3D camera position
    cameraX = 0;
    cameraY = 0;
    firstGenerate = true; // Don't randomise tensor field on first generate
    modelGenerator;
    constructor() {
        // GUI Setup
        const zoomController = this.gui.add(this.domainController, 'zoom');
        this.domainController.setZoomUpdate(() => zoomController.updateDisplay());
        this.gui.add(this, 'generate');
        this.tensorFolder = this.gui.addFolder('Tensor Field');
        this.roadsFolder = this.gui.addFolder('Map');
        this.styleFolder = this.gui.addFolder('Style');
        this.optionsFolder = this.gui.addFolder('Options');
        this.downloadsFolder = this.gui.addFolder('Download');
        // Canvas setup
        this.canvas = document.getElementById(util_1.default.CANVAS_ID);
        this.tensorCanvas = new canvas_wrapper_1.DefaultCanvasWrapper(this.canvas);
        // Make sure we're not too zoomed out for large resolutions
        const screenWidth = this.domainController.screenDimensions.x;
        if (screenWidth > this.STARTING_WIDTH) {
            this.domainController.zoom = screenWidth / this.STARTING_WIDTH;
        }
        // Style setup
        this.styleFolder.add(this, 'colourScheme', Object.keys(ColourSchemes)).onChange((val) => this.changeColourScheme(val));
        this.styleFolder.add(this, 'zoomBuildings').onChange((val) => {
            // Force redraw
            this.previousFrameDrawTensor = true;
            this._style.zoomBuildings = val;
        });
        this.styleFolder.add(this, 'buildingModels').onChange((val) => {
            // Force redraw
            this.previousFrameDrawTensor = true;
            this._style.showBuildingModels = val;
        });
        this.styleFolder.add(this, 'showFrame').onChange((val) => {
            this.previousFrameDrawTensor = true;
            this._style.showFrame = val;
        });
        this.styleFolder.add(this.domainController, 'orthographic');
        this.styleFolder.add(this, 'cameraX', -15, 15).step(1).onChange(() => this.setCameraDirection());
        this.styleFolder.add(this, 'cameraY', -15, 15).step(1).onChange(() => this.setCameraDirection());
        var noiseParamsPlaceholder = {
            globalNoise: false,
            noiseSizePark: 20,
            noiseAnglePark: 90,
            noiseSizeGlobal: 30,
            noiseAngleGlobal: 20
        };
        this.tensorField = new tensor_field_gui_1.default(this.tensorFolder, this.dragController, true, noiseParamsPlaceholder);
        this.mainGui = new main_gui_1.default(this.roadsFolder, this.tensorField, () => this.tensorFolder.close());
        this.optionsFolder.add(this.tensorField, 'drawCentre');
        this.optionsFolder.add(this, 'highDPI').onChange((high) => this.changeCanvasScale(high));
        this.downloadsFolder.add(this, 'imageScale', 1, 5).step(1);
        this.downloadsFolder.add({ "PNG": () => this.downloadPng() }, 'PNG'); // This allows custom naming of button
        this.downloadsFolder.add({ "SVG": () => this.downloadSVG() }, 'SVG');
        this.downloadsFolder.add({ "Heightmap": () => this.downloadHeightmap() }, 'Heightmap');
        this.changeColourScheme(this.colourScheme);
        this.tensorField.setRecommended();
        requestAnimationFrame(() => this.update());
    }
    /**
     * Generate an entire map with no control over the process
     */
    generate() {
        if (!this.firstGenerate) {
            this.tensorField.setRecommended();
        }
        else {
            this.firstGenerate = false;
        }
        this.mainGui.generateEverything();
    }
    /**
     * @param {string} scheme Matches a scheme name in colour_schemes.json
     */
    changeColourScheme(scheme) {
        const colourScheme = ColourSchemes[scheme];
        this.zoomBuildings = colourScheme.zoomBuildings;
        this.buildingModels = colourScheme.buildingModels;
        util_1.default.updateGui(this.styleFolder);
        if (scheme.startsWith("Drawn")) {
            this._style = new style_1.RoughStyle(this.canvas, this.dragController, Object.assign({}, colourScheme));
        }
        else {
            this._style = new style_1.DefaultStyle(this.canvas, this.dragController, Object.assign({}, colourScheme), scheme.startsWith("Heightmap"));
        }
        this._style.showFrame = this.showFrame;
        this.changeCanvasScale(this.highDPI);
    }
    /**
     * Scale up canvas resolution for hiDPI displays
     */
    changeCanvasScale(high) {
        const value = high ? 2 : 1;
        this._style.canvasScale = value;
        this.tensorCanvas.canvasScale = value;
    }
    /**
     * Change camera position for pseudo3D buildings
     */
    setCameraDirection() {
        this.domainController.cameraDirection = new vector_1.default(this.cameraX / 10, this.cameraY / 10);
    }
    downloadFile(filename, file) {
        (0, file_saver_1.saveAs)(file, filename);
    }
    /**
     * Downloads image of map
     * Draws onto hidden canvas at requested resolution
     */
    downloadPng() {
        const c = document.getElementById(util_1.default.IMG_CANVAS_ID);
        // Draw
        if (this.showTensorField()) {
            this.tensorField.draw(new canvas_wrapper_1.DefaultCanvasWrapper(c, this.imageScale, false));
        }
        else {
            const imgCanvas = this._style.createCanvasWrapper(c, this.imageScale, false);
            this.mainGui.draw(this._style, true, imgCanvas);
        }
        const link = document.createElement('a');
        link.download = 'map.png';
        link.href = document.getElementById(util_1.default.IMG_CANVAS_ID).toDataURL();
        link.click();
    }
    /**
     * Same as downloadPng but uses Heightmap style
     */
    downloadHeightmap() {
        const oldColourScheme = this.colourScheme;
        this.changeColourScheme("Heightmap");
        this.downloadPng();
        this.changeColourScheme(oldColourScheme);
    }
    /**
     * Downloads svg of map
     * Draws onto hidden svg at requested resolution
     */
    downloadSVG() {
        const c = document.getElementById(util_1.default.IMG_CANVAS_ID);
        const svgElement = document.getElementById(util_1.default.SVG_ID);
        if (this.showTensorField()) {
            const imgCanvas = new canvas_wrapper_1.DefaultCanvasWrapper(c, 1, false);
            imgCanvas.createSVG(svgElement);
            this.tensorField.draw(imgCanvas);
        }
        else {
            const imgCanvas = this._style.createCanvasWrapper(c, 1, false);
            imgCanvas.createSVG(svgElement);
            this.mainGui.draw(this._style, true, imgCanvas);
        }
        const serializer = new XMLSerializer();
        let source = serializer.serializeToString(svgElement);
        //add xml declaration
        source = '<?xml version="1.0" standalone="no"?>\r\n' + source;
        //convert svg source to URI data scheme.
        const url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(source);
        const link = document.createElement('a');
        link.download = 'map.svg';
        link.href = url;
        link.click();
        // Clear SVG
        const element = (0, svg_js_1.SVG)(svgElement);
        element.clear();
    }
    showTensorField() {
        return !this.tensorFolder.closed || this.mainGui.roadsEmpty();
    }
    draw() {
        if (this.showTensorField()) {
            this.previousFrameDrawTensor = true;
            this.dragController.setDragDisabled(false);
            this.tensorField.draw(this.tensorCanvas);
        }
        else {
            // Disable field drag and drop
            this.dragController.setDragDisabled(true);
            if (this.previousFrameDrawTensor === true) {
                this.previousFrameDrawTensor = false;
                // Force redraw if switching from tensor field
                this.mainGui.draw(this._style, true);
            }
            else {
                this.mainGui.draw(this._style);
            }
        }
    }
    update() {
        if (this.modelGenerator) {
            let continueUpdate = true;
            const start = performance.now();
            while (continueUpdate && performance.now() - start < 100) {
                continueUpdate = this.modelGenerator.update();
            }
        }
        this._style.update();
        this.mainGui.update();
        this.draw();
        requestAnimationFrame(this.update.bind(this));
    }
}
// Add log to window so we can use log.setlevel from the console
window.log = log;
window.addEventListener('load', () => {
    new Main();
});


/***/ }),

/***/ "./src/ts/impl/basis_field.ts":
/*!************************************!*\
  !*** ./src/ts/impl/basis_field.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Radial = exports.Grid = exports.BasisField = void 0;
const tensor_1 = __importDefault(__webpack_require__(/*! ./tensor */ "./src/ts/impl/tensor.ts"));
;
/**
 * Grid or Radial field to be combined with others to create the tensor field
 */
class BasisField {
    _size;
    _decay;
    static folderNameIndex = 0;
    parentFolder;
    folder;
    _centre;
    constructor(centre, _size, _decay) {
        this._size = _size;
        this._decay = _decay;
        this._centre = centre.clone();
    }
    set centre(centre) {
        this._centre.copy(centre);
    }
    get centre() {
        return this._centre.clone();
    }
    set decay(decay) {
        this._decay = decay;
    }
    set size(size) {
        this._size = size;
    }
    dragStartListener() {
        this.setFolder();
    }
    dragMoveListener(delta) {
        // Delta assumed to be in world space (only relevant when zoomed)
        this._centre.add(delta);
    }
    getWeightedTensor(point, smooth) {
        return this.getTensor(point).scale(this.getTensorWeight(point, smooth));
    }
    setFolder() {
        if (this.parentFolder.__folders) {
            for (const folderName in this.parentFolder.__folders) {
                this.parentFolder.__folders[folderName].close();
            }
            this.folder.open();
        }
    }
    removeFolderFromParent() {
        if (this.parentFolder.__folders && Object.values(this.parentFolder.__folders).indexOf(this.folder) >= 0) {
            this.parentFolder.removeFolder(this.folder);
        }
    }
    /**
     * Creates a folder and adds it to the GUI to control params
     */
    setGui(parent, folder) {
        this.parentFolder = parent;
        this.folder = folder;
        folder.add(this._centre, 'x');
        folder.add(this._centre, 'y');
        folder.add(this, '_size');
        folder.add(this, '_decay', -50, 50);
    }
    /**
     * Interpolates between (0 and 1)^decay
     */
    getTensorWeight(point, smooth) {
        const normDistanceToCentre = point.clone().sub(this._centre).length() / this._size;
        if (smooth) {
            return normDistanceToCentre ** -this._decay;
        }
        // Stop (** 0) turning weight into 1, filling screen even when outside 'size'
        if (this._decay === 0 && normDistanceToCentre >= 1) {
            return 0;
        }
        return Math.max(0, (1 - normDistanceToCentre)) ** this._decay;
    }
}
exports.BasisField = BasisField;
class Grid extends BasisField {
    _theta;
    FOLDER_NAME = `Grid ${Grid.folderNameIndex++}`;
    FIELD_TYPE = 1 /* FIELD_TYPE.Grid */;
    constructor(centre, size, decay, _theta) {
        super(centre, size, decay);
        this._theta = _theta;
    }
    set theta(theta) {
        this._theta = theta;
    }
    setGui(parent, folder) {
        super.setGui(parent, folder);
        // GUI in degrees, convert to rads
        const thetaProp = { theta: this._theta * 180 / Math.PI };
        const thetaController = folder.add(thetaProp, 'theta', -90, 90);
        thetaController.onChange(theta => this._theta = theta * (Math.PI / 180));
    }
    getTensor(point) {
        const cos = Math.cos(2 * this._theta);
        const sin = Math.sin(2 * this._theta);
        return new tensor_1.default(1, [cos, sin]);
    }
}
exports.Grid = Grid;
class Radial extends BasisField {
    FOLDER_NAME = `Radial ${Radial.folderNameIndex++}`;
    FIELD_TYPE = 0 /* FIELD_TYPE.Radial */;
    constructor(centre, size, decay) {
        super(centre, size, decay);
    }
    getTensor(point) {
        const t = point.clone().sub(this._centre);
        const t1 = t.y ** 2 - t.x ** 2;
        const t2 = -2 * t.x * t.y;
        return new tensor_1.default(1, [t1, t2]);
    }
}
exports.Radial = Radial;


/***/ }),

/***/ "./src/ts/impl/graph.ts":
/*!******************************!*\
  !*** ./src/ts/impl/graph.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Node = void 0;
const log = __importStar(__webpack_require__(/*! loglevel */ "./node_modules/loglevel/lib/loglevel.js"));
const isect = __importStar(__webpack_require__(/*! isect */ "./node_modules/isect/build/isect.module.js"));
const d3 = __importStar(__webpack_require__(/*! d3-quadtree */ "./node_modules/d3-quadtree/src/index.js"));
const vector_1 = __importDefault(__webpack_require__(/*! ../vector */ "./src/ts/vector.ts"));
/**
 * Node located along any intersection or point along the simplified road polylines
 */
class Node {
    value;
    neighbors;
    segments = new Set();
    adj;
    constructor(value, neighbors = new Set()) {
        this.value = value;
        this.neighbors = neighbors;
    }
    addSegment(segment) {
        this.segments.add(segment);
    }
    addNeighbor(node) {
        if (node !== this) {
            this.neighbors.add(node);
            node.neighbors.add(this);
        }
    }
}
exports.Node = Node;
class Graph {
    nodes;
    intersections;
    /**
     * Create a graph from a set of streamlines
     * Finds all intersections, and creates a list of Nodes
     */
    constructor(streamlines, dstep, deleteDangling = false) {
        const intersections = isect.bush(this.streamlinesToSegment(streamlines)).run();
        const quadtree = d3.quadtree().x(n => n.value.x).y(n => n.value.y);
        const nodeAddRadius = 0.001;
        // Add all segment start and endpoints
        for (const streamline of streamlines) {
            for (let i = 0; i < streamline.length; i++) {
                const node = new Node(streamline[i]);
                if (i > 0) {
                    node.addSegment(this.vectorsToSegment(streamline[i - 1], streamline[i]));
                }
                if (i < streamline.length - 1) {
                    node.addSegment(this.vectorsToSegment(streamline[i], streamline[i + 1]));
                }
                this.fuzzyAddToQuadtree(quadtree, node, nodeAddRadius);
            }
        }
        // Add all intersections
        for (const intersection of intersections) {
            const node = new Node(new vector_1.default(intersection.point.x, intersection.point.y));
            for (const s of intersection.segments)
                node.addSegment(s);
            this.fuzzyAddToQuadtree(quadtree, node, nodeAddRadius);
        }
        // For each simplified streamline, build list of nodes in order along streamline
        for (const streamline of streamlines) {
            for (let i = 0; i < streamline.length - 1; i++) {
                const nodesAlongSegment = this.getNodesAlongSegment(this.vectorsToSegment(streamline[i], streamline[i + 1]), quadtree, nodeAddRadius, dstep);
                if (nodesAlongSegment.length > 1) {
                    for (let j = 0; j < nodesAlongSegment.length - 1; j++) {
                        nodesAlongSegment[j].addNeighbor(nodesAlongSegment[j + 1]);
                    }
                }
                else {
                    log.error("Error Graph.js: segment with less than 2 nodes");
                }
            }
        }
        for (const n of quadtree.data()) {
            if (deleteDangling) {
                this.deleteDanglingNodes(n, quadtree);
            }
            n.adj = Array.from(n.neighbors);
        }
        this.nodes = quadtree.data();
        this.intersections = [];
        for (const i of intersections)
            this.intersections.push(new vector_1.default(i.point.x, i.point.y));
    }
    /**
     * Remove dangling edges from graph to facilitate polygon finding
     */
    deleteDanglingNodes(n, quadtree) {
        if (n.neighbors.size === 1) {
            quadtree.remove(n);
            for (let neighbor of n.neighbors) {
                neighbor.neighbors.delete(n);
                this.deleteDanglingNodes(neighbor, quadtree);
            }
        }
    }
    /**
     * Given a segment, step along segment and find all nodes along it
     */
    getNodesAlongSegment(segment, quadtree, radius, step) {
        // Walk dstep along each streamline, adding nodes within dstep/2
        // and connected to this streamline (fuzzy - nodeAddRadius) to list, removing from
        // quadtree and adding them all back at the end
        const foundNodes = [];
        const nodesAlongSegment = [];
        const start = new vector_1.default(segment.from.x, segment.from.y);
        const end = new vector_1.default(segment.to.x, segment.to.y);
        const differenceVector = end.clone().sub(start);
        step = Math.min(step, differenceVector.length() / 2); // Min of 2 step along vector
        const steps = Math.ceil(differenceVector.length() / step);
        const differenceVectorLength = differenceVector.length();
        for (let i = 0; i <= steps; i++) {
            let currentPoint = start.clone().add(differenceVector.clone().multiplyScalar(i / steps));
            // Order nodes, not by 'closeness', but by dot product
            let nodesToAdd = [];
            let closestNode = quadtree.find(currentPoint.x, currentPoint.y, radius + step / 2);
            while (closestNode !== undefined) {
                quadtree.remove(closestNode);
                foundNodes.push(closestNode);
                let nodeOnSegment = false;
                for (let s of closestNode.segments) {
                    if (this.fuzzySegmentsEqual(s, segment)) {
                        nodeOnSegment = true;
                        break;
                    }
                }
                if (nodeOnSegment) {
                    nodesToAdd.push(closestNode);
                }
                closestNode = quadtree.find(currentPoint.x, currentPoint.y, radius + step / 2);
            }
            nodesToAdd.sort((first, second) => this.dotProductToSegment(first, start, differenceVector) - this.dotProductToSegment(second, start, differenceVector));
            nodesAlongSegment.push(...nodesToAdd);
        }
        quadtree.addAll(foundNodes);
        return nodesAlongSegment;
    }
    fuzzySegmentsEqual(s1, s2, tolerance = 0.0001) {
        // From
        if (s1.from.x - s2.from.x > tolerance) {
            return false;
        }
        if (s1.from.y - s2.from.y > tolerance) {
            return false;
        }
        // To
        if (s1.to.x - s2.to.x > tolerance) {
            return false;
        }
        if (s1.to.y - s2.to.y > tolerance) {
            return false;
        }
        return true;
    }
    dotProductToSegment(node, start, differenceVector) {
        const dotVector = node.value.clone().sub(start);
        return differenceVector.dot(dotVector);
    }
    fuzzyAddToQuadtree(quadtree, node, radius) {
        // Only add if there isn't a node within radius
        // Remember to check for double radius when querying tree, or point might be missed
        const existingNode = quadtree.find(node.value.x, node.value.y, radius);
        if (existingNode === undefined) {
            quadtree.add(node);
        }
        else {
            for (const neighbor of node.neighbors)
                existingNode.addNeighbor(neighbor);
            for (const segment of node.segments)
                existingNode.addSegment(segment);
        }
    }
    streamlinesToSegment(streamlines) {
        const out = [];
        for (const s of streamlines) {
            for (let i = 0; i < s.length - 1; i++) {
                out.push(this.vectorsToSegment(s[i], s[i + 1]));
            }
        }
        return out;
    }
    vectorsToSegment(v1, v2) {
        return {
            from: v1,
            to: v2
        };
    }
}
exports["default"] = Graph;


/***/ }),

/***/ "./src/ts/impl/grid_storage.ts":
/*!*************************************!*\
  !*** ./src/ts/impl/grid_storage.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const vector_1 = __importDefault(__webpack_require__(/*! ../vector */ "./src/ts/vector.ts"));
/**
 * Cartesian grid accelerated data structure
 * Grid of cells, each containing a list of vectors
 */
class GridStorage {
    worldDimensions;
    origin;
    dsep;
    gridDimensions;
    grid;
    dsepSq;
    /**
     * worldDimensions assumes origin of 0,0
     * @param {number} dsep Separation distance between samples
     */
    constructor(worldDimensions, origin, dsep) {
        this.worldDimensions = worldDimensions;
        this.origin = origin;
        this.dsep = dsep;
        this.dsepSq = this.dsep * this.dsep;
        this.gridDimensions = worldDimensions.clone().divideScalar(this.dsep);
        this.grid = [];
        for (let x = 0; x < this.gridDimensions.x; x++) {
            this.grid.push([]);
            for (let y = 0; y < this.gridDimensions.y; y++) {
                this.grid[x].push([]);
            }
        }
    }
    /**
     * Add all samples from another grid to this one
     */
    addAll(gridStorage) {
        for (const row of gridStorage.grid) {
            for (const cell of row) {
                for (const sample of cell) {
                    this.addSample(sample);
                }
            }
        }
    }
    addPolyline(line) {
        for (const v of line) {
            this.addSample(v);
        }
    }
    /**
     * Does not enforce separation
     * Does not clone
     */
    addSample(v, coords) {
        if (!coords) {
            coords = this.getSampleCoords(v);
        }
        this.grid[coords.x][coords.y].push(v);
    }
    /**
     * Tests whether v is at least d away from samples
     * Performance very important - this is called at every integration step
     * @param dSq=this.dsepSq squared test distance
     * Could be dtest if we are integrating a streamline
     */
    isValidSample(v, dSq = this.dsepSq) {
        // Code duplication with this.getNearbyPoints but much slower when calling
        // this.getNearbyPoints due to array creation in that method
        const coords = this.getSampleCoords(v);
        // Check samples in 9 cells in 3x3 grid
        for (let x = -1; x <= 1; x++) {
            for (let y = -1; y <= 1; y++) {
                const cell = coords.clone().add(new vector_1.default(x, y));
                if (!this.vectorOutOfBounds(cell, this.gridDimensions)) {
                    if (!this.vectorFarFromVectors(v, this.grid[cell.x][cell.y], dSq)) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
    /**
     * Test whether v is at least d away from vectors
     * Performance very important - this is called at every integration step
     * @param {number}   dSq     squared test distance
     */
    vectorFarFromVectors(v, vectors, dSq) {
        for (const sample of vectors) {
            if (sample !== v) {
                const distanceSq = sample.distanceToSquared(v);
                if (distanceSq < dSq) {
                    return false;
                }
            }
        }
        return true;
    }
    /**
     * Returns points in cells surrounding v
     * Results include v, if it exists in the grid
     * @param {number} returns samples (kind of) closer than distance - returns all samples in
     * cells so approximation (square to approximate circle)
     */
    getNearbyPoints(v, distance) {
        const radius = Math.ceil((distance / this.dsep) - 0.5);
        const coords = this.getSampleCoords(v);
        const out = [];
        for (let x = -1 * radius; x <= 1 * radius; x++) {
            for (let y = -1 * radius; y <= 1 * radius; y++) {
                const cell = coords.clone().add(new vector_1.default(x, y));
                if (!this.vectorOutOfBounds(cell, this.gridDimensions)) {
                    for (const v2 of this.grid[cell.x][cell.y]) {
                        out.push(v2);
                    }
                }
            }
        }
        return out;
    }
    worldToGrid(v) {
        return v.clone().sub(this.origin);
    }
    gridToWorld(v) {
        return v.clone().add(this.origin);
    }
    vectorOutOfBounds(gridV, bounds) {
        return (gridV.x < 0 || gridV.y < 0 ||
            gridV.x >= bounds.x || gridV.y >= bounds.y);
    }
    /**
     * @return {Vector}   Cell coords corresponding to vector
     * Performance important - called at every integration step
     */
    getSampleCoords(worldV) {
        const v = this.worldToGrid(worldV);
        if (this.vectorOutOfBounds(v, this.worldDimensions)) {
            // log.error("Tried to access out-of-bounds sample in grid");
            return vector_1.default.zeroVector();
        }
        return new vector_1.default(Math.floor(v.x / this.dsep), Math.floor(v.y / this.dsep));
    }
}
exports["default"] = GridStorage;


/***/ }),

/***/ "./src/ts/impl/integrator.ts":
/*!***********************************!*\
  !*** ./src/ts/impl/integrator.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RK4Integrator = exports.EulerIntegrator = void 0;
const vector_1 = __importDefault(__webpack_require__(/*! ../vector */ "./src/ts/vector.ts"));
class FieldIntegrator {
    field;
    constructor(field) {
        this.field = field;
    }
    sampleFieldVector(point, major) {
        const tensor = this.field.samplePoint(point);
        if (major)
            return tensor.getMajor();
        return tensor.getMinor();
    }
    onLand(point) {
        return this.field.onLand(point);
    }
}
exports["default"] = FieldIntegrator;
class EulerIntegrator extends FieldIntegrator {
    params;
    constructor(field, params) {
        super(field);
        this.params = params;
    }
    integrate(point, major) {
        return this.sampleFieldVector(point, major).multiplyScalar(this.params.dstep);
    }
}
exports.EulerIntegrator = EulerIntegrator;
class RK4Integrator extends FieldIntegrator {
    params;
    constructor(field, params) {
        super(field);
        this.params = params;
    }
    integrate(point, major) {
        const k1 = this.sampleFieldVector(point, major);
        const k23 = this.sampleFieldVector(point.clone().add(vector_1.default.fromScalar(this.params.dstep / 2)), major);
        const k4 = this.sampleFieldVector(point.clone().add(vector_1.default.fromScalar(this.params.dstep)), major);
        return k1.add(k23.multiplyScalar(4)).add(k4).multiplyScalar(this.params.dstep / 6);
    }
}
exports.RK4Integrator = RK4Integrator;


/***/ }),

/***/ "./src/ts/impl/polygon_finder.ts":
/*!***************************************!*\
  !*** ./src/ts/impl/polygon_finder.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const log = __importStar(__webpack_require__(/*! loglevel */ "./node_modules/loglevel/lib/loglevel.js"));
const polygon_util_1 = __importDefault(__webpack_require__(/*! ./polygon_util */ "./src/ts/impl/polygon_util.ts"));
/**
 * Finds polygons in a graph, used for finding lots and parks
 */
class PolygonFinder {
    nodes;
    params;
    tensorField;
    _polygons = [];
    _shrunkPolygons = [];
    _dividedPolygons = [];
    toShrink = [];
    resolveShrink;
    toDivide = [];
    resolveDivide;
    constructor(nodes, params, tensorField) {
        this.nodes = nodes;
        this.params = params;
        this.tensorField = tensorField;
    }
    get polygons() {
        if (this._dividedPolygons.length > 0) {
            return this._dividedPolygons;
        }
        if (this._shrunkPolygons.length > 0) {
            return this._shrunkPolygons;
        }
        return this._polygons;
    }
    reset() {
        this.toShrink = [];
        this.toDivide = [];
        this._polygons = [];
        this._shrunkPolygons = [];
        this._dividedPolygons = [];
    }
    update() {
        let change = false;
        if (this.toShrink.length > 0) {
            const resolve = this.toShrink.length === 1;
            if (this.stepShrink(this.toShrink.pop())) {
                change = true;
            }
            if (resolve)
                this.resolveShrink();
        }
        if (this.toDivide.length > 0) {
            const resolve = this.toDivide.length === 1;
            if (this.stepDivide(this.toDivide.pop())) {
                change = true;
            }
            if (resolve)
                this.resolveDivide();
        }
        return change;
    }
    /**
     * Properly shrink polygon so the edges are all the same distance from the road
     */
    async shrink(animate = false) {
        return new Promise(resolve => {
            if (this._polygons.length === 0) {
                this.findPolygons();
            }
            if (animate) {
                if (this._polygons.length === 0) {
                    resolve();
                    return;
                }
                this.toShrink = this._polygons.slice();
                this.resolveShrink = resolve;
            }
            else {
                this._shrunkPolygons = [];
                for (const p of this._polygons) {
                    this.stepShrink(p);
                }
                resolve();
            }
        });
    }
    stepShrink(polygon) {
        const shrunk = polygon_util_1.default.resizeGeometry(polygon, -this.params.shrinkSpacing);
        if (shrunk.length > 0) {
            this._shrunkPolygons.push(shrunk);
            return true;
        }
        return false;
    }
    async divide(animate = false) {
        return new Promise(resolve => {
            if (this._polygons.length === 0) {
                this.findPolygons();
            }
            let polygons = this._polygons;
            if (this._shrunkPolygons.length > 0) {
                polygons = this._shrunkPolygons;
            }
            if (animate) {
                if (polygons.length === 0) {
                    resolve();
                    return;
                }
                this.toDivide = polygons.slice();
                this.resolveDivide = resolve;
            }
            else {
                this._dividedPolygons = [];
                for (const p of polygons) {
                    this.stepDivide(p);
                }
                resolve();
            }
        });
    }
    stepDivide(polygon) {
        // TODO need to filter shrunk polygons using aspect ratio, area 
        // this skips the filter in PolygonUtil.subdividePolygon
        if (this.params.chanceNoDivide > 0 && Math.random() < this.params.chanceNoDivide) {
            this._dividedPolygons.push(polygon);
            return true;
        }
        const divided = polygon_util_1.default.subdividePolygon(polygon, this.params.minArea);
        if (divided.length > 0) {
            this._dividedPolygons.push(...divided);
            return true;
        }
        return false;
    }
    findPolygons() {
        // Node
        // x, y, value (Vector2), adj (list of node refs)
        // Gonna edit adj for now
        // Walk a clockwise path until polygon found or limit reached
        // When we find a polygon, mark all edges as traversed (in particular direction)
        // Each edge separates two polygons
        // If edge already traversed in this direction, this polygon has already been found
        this._shrunkPolygons = [];
        this._dividedPolygons = [];
        const polygons = [];
        for (const node of this.nodes) {
            if (node.adj.length < 2)
                continue;
            for (const nextNode of node.adj) {
                const polygon = this.recursiveWalk([node, nextNode]);
                if (polygon !== null && polygon.length < this.params.maxLength) {
                    this.removePolygonAdjacencies(polygon);
                    polygons.push(polygon.map(n => n.value.clone()));
                }
            }
        }
        this._polygons = this.filterPolygonsByWater(polygons);
    }
    filterPolygonsByWater(polygons) {
        const out = [];
        for (const p of polygons) {
            const averagePoint = polygon_util_1.default.averagePoint(p);
            if (this.tensorField.onLand(averagePoint) && !this.tensorField.inParks(averagePoint))
                out.push(p);
        }
        return out;
    }
    removePolygonAdjacencies(polygon) {
        for (let i = 0; i < polygon.length; i++) {
            const current = polygon[i];
            const next = polygon[(i + 1) % polygon.length];
            const index = current.adj.indexOf(next);
            if (index >= 0) {
                current.adj.splice(index, 1);
            }
            else {
                log.error("PolygonFinder - node not in adj");
            }
        }
    }
    recursiveWalk(visited, count = 0) {
        if (count >= this.params.maxLength)
            return null;
        // TODO backtracking to find polygons with dead end roads inside them
        const nextNode = this.getRightmostNode(visited[visited.length - 2], visited[visited.length - 1]);
        if (nextNode === null) {
            return null; // Currently ignores polygons with dead end inside
        }
        const visitedIndex = visited.indexOf(nextNode);
        if (visitedIndex >= 0) {
            return visited.slice(visitedIndex);
        }
        else {
            visited.push(nextNode);
            return this.recursiveWalk(visited, count++);
        }
    }
    getRightmostNode(nodeFrom, nodeTo) {
        // We want to turn right at every junction
        if (nodeTo.adj.length === 0)
            return null;
        const backwardsDifferenceVector = nodeFrom.value.clone().sub(nodeTo.value);
        const transformAngle = Math.atan2(backwardsDifferenceVector.y, backwardsDifferenceVector.x);
        let rightmostNode = null;
        let smallestTheta = Math.PI * 2;
        for (const nextNode of nodeTo.adj) {
            if (nextNode !== nodeFrom) {
                const nextVector = nextNode.value.clone().sub(nodeTo.value);
                let nextAngle = Math.atan2(nextVector.y, nextVector.x) - transformAngle;
                if (nextAngle < 0) {
                    nextAngle += Math.PI * 2;
                }
                if (nextAngle < smallestTheta) {
                    smallestTheta = nextAngle;
                    rightmostNode = nextNode;
                }
            }
        }
        return rightmostNode;
    }
}
exports["default"] = PolygonFinder;


/***/ }),

/***/ "./src/ts/impl/polygon_util.ts":
/*!*************************************!*\
  !*** ./src/ts/impl/polygon_util.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const log = __importStar(__webpack_require__(/*! loglevel */ "./node_modules/loglevel/lib/loglevel.js"));
const PolyK = __importStar(__webpack_require__(/*! polyk */ "./node_modules/polyk/dist/polyk.js"));
const vector_1 = __importDefault(__webpack_require__(/*! ../vector */ "./src/ts/vector.ts"));
class PolygonUtil {
    static geometryFactory = new jsts.geom.GeometryFactory();
    /**
     * Slices rectangle by line, returning smallest polygon
     */
    static sliceRectangle(origin, worldDimensions, p1, p2) {
        const rectangle = [
            origin.x, origin.y,
            origin.x + worldDimensions.x, origin.y,
            origin.x + worldDimensions.x, origin.y + worldDimensions.y,
            origin.x, origin.y + worldDimensions.y,
        ];
        const sliced = PolyK.Slice(rectangle, p1.x, p1.y, p2.x, p2.y).map(p => PolygonUtil.polygonArrayToPolygon(p));
        const minArea = PolygonUtil.calcPolygonArea(sliced[0]);
        if (sliced.length > 1 && PolygonUtil.calcPolygonArea(sliced[1]) < minArea) {
            return sliced[1];
        }
        return sliced[0];
    }
    /**
     * Used to create sea polygon
     */
    static lineRectanglePolygonIntersection(origin, worldDimensions, line) {
        const jstsLine = PolygonUtil.lineToJts(line);
        const bounds = [
            origin,
            new vector_1.default(origin.x + worldDimensions.x, origin.y),
            new vector_1.default(origin.x + worldDimensions.x, origin.y + worldDimensions.y),
            new vector_1.default(origin.x, origin.y + worldDimensions.y),
        ];
        const boundingPoly = PolygonUtil.polygonToJts(bounds);
        const union = boundingPoly.getExteriorRing().union(jstsLine);
        const polygonizer = new jsts.operation.polygonize.Polygonizer();
        polygonizer.add(union);
        const polygons = polygonizer.getPolygons();
        let smallestArea = Infinity;
        let smallestPoly;
        for (let i = polygons.iterator(); i.hasNext();) {
            const polygon = i.next();
            const area = polygon.getArea();
            if (area < smallestArea) {
                smallestArea = area;
                smallestPoly = polygon;
            }
        }
        if (!smallestPoly)
            return [];
        return smallestPoly.getCoordinates().map((c) => new vector_1.default(c.x, c.y));
    }
    static calcPolygonArea(polygon) {
        let total = 0;
        for (let i = 0; i < polygon.length; i++) {
            const addX = polygon[i].x;
            const addY = polygon[i == polygon.length - 1 ? 0 : i + 1].y;
            const subX = polygon[i == polygon.length - 1 ? 0 : i + 1].x;
            const subY = polygon[i].y;
            total += (addX * addY * 0.5);
            total -= (subX * subY * 0.5);
        }
        return Math.abs(total);
    }
    /**
     * Recursively divide a polygon by its longest side until the minArea stopping condition is met
     */
    static subdividePolygon(p, minArea) {
        const area = PolygonUtil.calcPolygonArea(p);
        if (area < 0.5 * minArea) {
            return [];
        }
        const divided = []; // Array of polygons
        let longestSideLength = 0;
        let longestSide = [p[0], p[1]];
        let perimeter = 0;
        for (let i = 0; i < p.length; i++) {
            const sideLength = p[i].clone().sub(p[(i + 1) % p.length]).length();
            perimeter += sideLength;
            if (sideLength > longestSideLength) {
                longestSideLength = sideLength;
                longestSide = [p[i], p[(i + 1) % p.length]];
            }
        }
        // Shape index
        // Using rectangle ratio of 1:4 as limit
        // if (area / perimeter * perimeter < 0.04) {
        if (area / (perimeter * perimeter) < 0.04) {
            return [];
        }
        if (area < 2 * minArea) {
            return [p];
        }
        // Between 0.4 and 0.6
        const deviation = (Math.random() * 0.2) + 0.4;
        const averagePoint = longestSide[0].clone().add(longestSide[1]).multiplyScalar(deviation);
        const differenceVector = longestSide[0].clone().sub(longestSide[1]);
        const perpVector = (new vector_1.default(differenceVector.y, -1 * differenceVector.x))
            .normalize()
            .multiplyScalar(100);
        const bisect = [averagePoint.clone().add(perpVector), averagePoint.clone().sub(perpVector)];
        // Array of polygons
        try {
            const sliced = PolyK.Slice(PolygonUtil.polygonToPolygonArray(p), bisect[0].x, bisect[0].y, bisect[1].x, bisect[1].y);
            // Recursive call
            for (const s of sliced) {
                divided.push(...PolygonUtil.subdividePolygon(PolygonUtil.polygonArrayToPolygon(s), minArea));
            }
            return divided;
        }
        catch (error) {
            log.error(error);
            return [];
        }
    }
    /**
     * Shrink or expand polygon
     */
    static resizeGeometry(geometry, spacing, isPolygon = true) {
        try {
            const jstsGeometry = isPolygon ? PolygonUtil.polygonToJts(geometry) : PolygonUtil.lineToJts(geometry);
            const resized = jstsGeometry.buffer(spacing, undefined, jsts.operation.buffer.BufferParameters.CAP_FLAT);
            if (!resized.isSimple()) {
                return [];
            }
            return resized.getCoordinates().map(c => new vector_1.default(c.x, c.y));
        }
        catch (error) {
            log.error(error);
            return [];
        }
    }
    static averagePoint(polygon) {
        if (polygon.length === 0)
            return vector_1.default.zeroVector();
        const sum = vector_1.default.zeroVector();
        for (const v of polygon) {
            sum.add(v);
        }
        return sum.divideScalar(polygon.length);
    }
    static insidePolygon(point, polygon) {
        // ray-casting algorithm based on
        // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
        if (polygon.length === 0) {
            return false;
        }
        let inside = false;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
            const xi = polygon[i].x, yi = polygon[i].y;
            const xj = polygon[j].x, yj = polygon[j].y;
            const intersect = ((yi > point.y) != (yj > point.y))
                && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
            if (intersect)
                inside = !inside;
        }
        return inside;
    }
    static pointInRectangle(point, origin, dimensions) {
        return point.x >= origin.x && point.y >= origin.y && point.x <= dimensions.x && point.y <= dimensions.y;
    }
    static lineToJts(line) {
        const coords = line.map(v => new jsts.geom.Coordinate(v.x, v.y));
        return PolygonUtil.geometryFactory.createLineString(coords);
    }
    static polygonToJts(polygon) {
        const geoInput = polygon.map(v => new jsts.geom.Coordinate(v.x, v.y));
        geoInput.push(geoInput[0]); // Create loop
        return PolygonUtil.geometryFactory.createPolygon(PolygonUtil.geometryFactory.createLinearRing(geoInput), []);
    }
    /**
     * [ v.x, v.y, v.x, v.y ]...
     */
    static polygonToPolygonArray(p) {
        const outP = [];
        for (const v of p) {
            outP.push(v.x);
            outP.push(v.y);
        }
        return outP;
    }
    /**
     * [ v.x, v.y, v.x, v.y ]...
     */
    static polygonArrayToPolygon(p) {
        const outP = [];
        for (let i = 0; i < p.length / 2; i++) {
            outP.push(new vector_1.default(p[2 * i], p[2 * i + 1]));
        }
        return outP;
    }
}
exports["default"] = PolygonUtil;


/***/ }),

/***/ "./src/ts/impl/streamlines.ts":
/*!************************************!*\
  !*** ./src/ts/impl/streamlines.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const log = __importStar(__webpack_require__(/*! loglevel */ "./node_modules/loglevel/lib/loglevel.js"));
const simplify = __importStar(__webpack_require__(/*! simplify-js */ "./node_modules/simplify-js/simplify.js"));
const vector_1 = __importDefault(__webpack_require__(/*! ../vector */ "./src/ts/vector.ts"));
const grid_storage_1 = __importDefault(__webpack_require__(/*! ./grid_storage */ "./src/ts/impl/grid_storage.ts"));
/**
 * Creates polylines that make up the roads by integrating the tensor field
 * See the paper 'Interactive Procedural Street Modeling' for a thorough explanation
 */
class StreamlineGenerator {
    integrator;
    origin;
    worldDimensions;
    params;
    SEED_AT_ENDPOINTS = false;
    NEAR_EDGE = 3; // Sample near edge
    majorGrid;
    minorGrid;
    paramsSq;
    // How many samples to skip when checking streamline collision with itself
    nStreamlineStep;
    // How many samples to ignore backwards when checking streamline collision with itself
    nStreamlineLookBack;
    dcollideselfSq;
    candidateSeedsMajor = [];
    candidateSeedsMinor = [];
    streamlinesDone = true;
    resolve;
    lastStreamlineMajor = true;
    allStreamlines = [];
    streamlinesMajor = [];
    streamlinesMinor = [];
    allStreamlinesSimple = []; // Reduced vertex count
    /**
     * Uses world-space coordinates
     */
    constructor(integrator, origin, worldDimensions, params) {
        this.integrator = integrator;
        this.origin = origin;
        this.worldDimensions = worldDimensions;
        this.params = params;
        if (params.dstep > params.dsep) {
            log.error("STREAMLINE SAMPLE DISTANCE BIGGER THAN DSEP");
        }
        // Enforce test < sep
        params.dtest = Math.min(params.dtest, params.dsep);
        // Needs to be less than circlejoin
        this.dcollideselfSq = (params.dcirclejoin / 2) ** 2;
        this.nStreamlineStep = Math.floor(params.dcirclejoin / params.dstep);
        this.nStreamlineLookBack = 2 * this.nStreamlineStep;
        this.majorGrid = new grid_storage_1.default(this.worldDimensions, this.origin, params.dsep);
        this.minorGrid = new grid_storage_1.default(this.worldDimensions, this.origin, params.dsep);
        this.setParamsSq();
    }
    clearStreamlines() {
        this.allStreamlinesSimple = [];
        this.streamlinesMajor = [];
        this.streamlinesMinor = [];
        this.allStreamlines = [];
    }
    /**
     * Edits streamlines
     */
    joinDanglingStreamlines() {
        // TODO do in update method
        for (const major of [true, false]) {
            for (const streamline of this.streamlines(major)) {
                // Ignore circles
                if (streamline[0].equals(streamline[streamline.length - 1])) {
                    continue;
                }
                const newStart = this.getBestNextPoint(streamline[0], streamline[4], streamline);
                if (newStart !== null) {
                    for (const p of this.pointsBetween(streamline[0], newStart, this.params.dstep)) {
                        streamline.unshift(p);
                        this.grid(major).addSample(p);
                    }
                }
                const newEnd = this.getBestNextPoint(streamline[streamline.length - 1], streamline[streamline.length - 4], streamline);
                if (newEnd !== null) {
                    for (const p of this.pointsBetween(streamline[streamline.length - 1], newEnd, this.params.dstep)) {
                        streamline.push(p);
                        this.grid(major).addSample(p);
                    }
                }
            }
        }
        // Reset simplified streamlines
        this.allStreamlinesSimple = [];
        for (const s of this.allStreamlines) {
            this.allStreamlinesSimple.push(this.simplifyStreamline(s));
        }
    }
    /**
     * Returns array of points from v1 to v2 such that they are separated by at most dsep
     * not including v1
     */
    pointsBetween(v1, v2, dstep) {
        const d = v1.distanceTo(v2);
        const nPoints = Math.floor(d / dstep);
        if (nPoints === 0)
            return [];
        const stepVector = v2.clone().sub(v1);
        const out = [];
        let i = 1;
        let next = v1.clone().add(stepVector.clone().multiplyScalar(i / nPoints));
        for (i = 1; i <= nPoints; i++) {
            if (this.integrator.integrate(next, true).lengthSq() > 0.001) { // Test for degenerate point
                out.push(next);
            }
            else {
                return out;
            }
            next = v1.clone().add(stepVector.clone().multiplyScalar(i / nPoints));
        }
        return out;
    }
    /**
     * Gets next best point to join streamline
     * returns null if there are no good candidates
     */
    getBestNextPoint(point, previousPoint, streamline) {
        const nearbyPoints = this.majorGrid.getNearbyPoints(point, this.params.dlookahead);
        nearbyPoints.push(...this.minorGrid.getNearbyPoints(point, this.params.dlookahead));
        const direction = point.clone().sub(previousPoint);
        let closestSample = null;
        let closestDistance = Infinity;
        for (const sample of nearbyPoints) {
            if (!sample.equals(point) && !sample.equals(previousPoint)) { // && !streamline.includes(sample)) {
                const differenceVector = sample.clone().sub(point);
                if (differenceVector.dot(direction) < 0) {
                    // Backwards
                    continue;
                }
                // Acute angle between vectors (agnostic of CW, ACW)
                const distanceToSample = point.distanceToSquared(sample);
                if (distanceToSample < 2 * this.paramsSq.dstep) {
                    closestSample = sample;
                    break;
                }
                const angleBetween = Math.abs(vector_1.default.angleBetween(direction, differenceVector));
                // Filter by angle
                if (angleBetween < this.params.joinangle && distanceToSample < closestDistance) {
                    closestDistance = distanceToSample;
                    closestSample = sample;
                }
            }
        }
        // TODO is reimplement simplify-js to preserve intersection points
        //  - this is the primary reason polygons aren't found
        // If trying to find intersections in the simplified graph
        // prevent ends getting pulled away from simplified lines
        if (closestSample !== null) {
            closestSample = closestSample.clone().add(direction.setLength(this.params.simplifyTolerance * 4));
        }
        return closestSample;
    }
    /**
     * Assumes s has already generated
     */
    addExistingStreamlines(s) {
        this.majorGrid.addAll(s.majorGrid);
        this.minorGrid.addAll(s.minorGrid);
    }
    setGrid(s) {
        this.majorGrid = s.majorGrid;
        this.minorGrid = s.minorGrid;
    }
    /**
     * returns true if state updates
     */
    update() {
        if (!this.streamlinesDone) {
            this.lastStreamlineMajor = !this.lastStreamlineMajor;
            if (!this.createStreamline(this.lastStreamlineMajor)) {
                this.streamlinesDone = true;
                this.resolve();
            }
            return true;
        }
        return false;
    }
    /**
     * All at once - will freeze if dsep small
     */
    async createAllStreamlines(animate = false) {
        return new Promise(resolve => {
            this.resolve = resolve;
            this.streamlinesDone = false;
            if (!animate) {
                let major = true;
                while (this.createStreamline(major)) {
                    major = !major;
                }
            }
        }).then(() => this.joinDanglingStreamlines());
    }
    simplifyStreamline(streamline) {
        const simplified = [];
        for (const point of simplify(streamline, this.params.simplifyTolerance)) {
            simplified.push(new vector_1.default(point.x, point.y));
        }
        return simplified;
    }
    /**
     * Finds seed and creates a streamline from that point
     * Pushes new candidate seeds to queue
     * @return {Vector[]} returns false if seed isn't found within params.seedTries
     */
    createStreamline(major) {
        const seed = this.getSeed(major);
        if (seed === null) {
            return false;
        }
        const streamline = this.integrateStreamline(seed, major);
        if (this.validStreamline(streamline)) {
            this.grid(major).addPolyline(streamline);
            this.streamlines(major).push(streamline);
            this.allStreamlines.push(streamline);
            this.allStreamlinesSimple.push(this.simplifyStreamline(streamline));
            // Add candidate seeds
            if (!streamline[0].equals(streamline[streamline.length - 1])) {
                this.candidateSeeds(!major).push(streamline[0]);
                this.candidateSeeds(!major).push(streamline[streamline.length - 1]);
            }
        }
        return true;
    }
    validStreamline(s) {
        return s.length > 5;
    }
    setParamsSq() {
        this.paramsSq = Object.assign({}, this.params);
        for (const p in this.paramsSq) {
            if (typeof this.paramsSq[p] === "number") {
                this.paramsSq[p] *= this.paramsSq[p];
            }
        }
    }
    samplePoint() {
        // TODO better seeding scheme
        return new vector_1.default(Math.random() * this.worldDimensions.x, Math.random() * this.worldDimensions.y)
            .add(this.origin);
    }
    /**
     * Tries this.candidateSeeds first, then samples using this.samplePoint
     */
    getSeed(major) {
        // Candidate seeds first
        if (this.SEED_AT_ENDPOINTS && this.candidateSeeds(major).length > 0) {
            while (this.candidateSeeds(major).length > 0) {
                const seed = this.candidateSeeds(major).pop();
                if (this.isValidSample(major, seed, this.paramsSq.dsep)) {
                    return seed;
                }
            }
        }
        let seed = this.samplePoint();
        let i = 0;
        while (!this.isValidSample(major, seed, this.paramsSq.dsep)) {
            if (i >= this.params.seedTries) {
                return null;
            }
            seed = this.samplePoint();
            i++;
        }
        return seed;
    }
    isValidSample(major, point, dSq, bothGrids = false) {
        // dSq = dSq * point.distanceToSquared(Vector.zeroVector());
        let gridValid = this.grid(major).isValidSample(point, dSq);
        if (bothGrids) {
            gridValid = gridValid && this.grid(!major).isValidSample(point, dSq);
        }
        return this.integrator.onLand(point) && gridValid;
    }
    candidateSeeds(major) {
        return major ? this.candidateSeedsMajor : this.candidateSeedsMinor;
    }
    streamlines(major) {
        return major ? this.streamlinesMajor : this.streamlinesMinor;
    }
    grid(major) {
        return major ? this.majorGrid : this.minorGrid;
    }
    pointInBounds(v) {
        return (v.x >= this.origin.x
            && v.y >= this.origin.y
            && v.x < this.worldDimensions.x + this.origin.x
            && v.y < this.worldDimensions.y + this.origin.y);
    }
    /**
     * Didn't end up using - bit expensive, used streamlineTurned instead
     * Stops spirals from forming
     * uses 0.5 dcirclejoin so that circles are still joined up
     * testSample is candidate to pushed on end of streamlineForwards
     * returns true if streamline collides with itself
     */
    doesStreamlineCollideSelf(testSample, streamlineForwards, streamlineBackwards) {
        // Streamline long enough
        if (streamlineForwards.length > this.nStreamlineLookBack) {
            // Forwards check
            for (let i = 0; i < streamlineForwards.length - this.nStreamlineLookBack; i += this.nStreamlineStep) {
                if (testSample.distanceToSquared(streamlineForwards[i]) < this.dcollideselfSq) {
                    return true;
                }
            }
            // Backwards check
            for (let i = 0; i < streamlineBackwards.length; i += this.nStreamlineStep) {
                if (testSample.distanceToSquared(streamlineBackwards[i]) < this.dcollideselfSq) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Tests whether streamline has turned through greater than 180 degrees
     */
    streamlineTurned(seed, originalDir, point, direction) {
        if (originalDir.dot(direction) < 0) {
            // TODO optimise
            const perpendicularVector = new vector_1.default(originalDir.y, -originalDir.x);
            const isLeft = point.clone().sub(seed).dot(perpendicularVector) < 0;
            const directionUp = direction.dot(perpendicularVector) > 0;
            return isLeft === directionUp;
        }
        return false;
    }
    /**
     * // TODO this doesn't work well - consider something disallowing one direction (F/B) to turn more than 180 deg
     * One step of the streamline integration process
     */
    streamlineIntegrationStep(params, major, collideBoth) {
        if (params.valid) {
            params.streamline.push(params.previousPoint);
            const nextDirection = this.integrator.integrate(params.previousPoint, major);
            // Stop at degenerate point
            if (nextDirection.lengthSq() < 0.01) {
                params.valid = false;
                return;
            }
            // Make sure we travel in the same direction
            if (nextDirection.dot(params.previousDirection) < 0) {
                nextDirection.negate();
            }
            const nextPoint = params.previousPoint.clone().add(nextDirection);
            // Visualise stopping points
            // if (this.streamlineTurned(params.seed, params.originalDir, nextPoint, nextDirection)) {
            //     params.valid = false;
            //     params.streamline.push(Vector.zeroVector());
            // }
            if (this.pointInBounds(nextPoint)
                && this.isValidSample(major, nextPoint, this.paramsSq.dtest, collideBoth)
                && !this.streamlineTurned(params.seed, params.originalDir, nextPoint, nextDirection)) {
                params.previousPoint = nextPoint;
                params.previousDirection = nextDirection;
            }
            else {
                // One more step
                params.streamline.push(nextPoint);
                params.valid = false;
            }
        }
    }
    /**
     * By simultaneously integrating in both directions we reduce the impact of circles not joining
     * up as the error matches at the join
     */
    integrateStreamline(seed, major) {
        let count = 0;
        let pointsEscaped = false; // True once two integration fronts have moved dlookahead away
        // Whether or not to test validity using both grid storages
        // (Collide with both major and minor)
        const collideBoth = Math.random() < this.params.collideEarly;
        const d = this.integrator.integrate(seed, major);
        const forwardParams = {
            seed: seed,
            originalDir: d,
            streamline: [seed],
            previousDirection: d,
            previousPoint: seed.clone().add(d),
            valid: true,
        };
        forwardParams.valid = this.pointInBounds(forwardParams.previousPoint);
        const negD = d.clone().negate();
        const backwardParams = {
            seed: seed,
            originalDir: negD,
            streamline: [],
            previousDirection: negD,
            previousPoint: seed.clone().add(negD),
            valid: true,
        };
        backwardParams.valid = this.pointInBounds(backwardParams.previousPoint);
        while (count < this.params.pathIterations && (forwardParams.valid || backwardParams.valid)) {
            this.streamlineIntegrationStep(forwardParams, major, collideBoth);
            this.streamlineIntegrationStep(backwardParams, major, collideBoth);
            // Join up circles
            const sqDistanceBetweenPoints = forwardParams.previousPoint.distanceToSquared(backwardParams.previousPoint);
            if (!pointsEscaped && sqDistanceBetweenPoints > this.paramsSq.dcirclejoin) {
                pointsEscaped = true;
            }
            if (pointsEscaped && sqDistanceBetweenPoints <= this.paramsSq.dcirclejoin) {
                forwardParams.streamline.push(forwardParams.previousPoint);
                forwardParams.streamline.push(backwardParams.previousPoint);
                backwardParams.streamline.push(backwardParams.previousPoint);
                break;
            }
            count++;
        }
        backwardParams.streamline.reverse().push(...forwardParams.streamline);
        return backwardParams.streamline;
    }
}
exports["default"] = StreamlineGenerator;


/***/ }),

/***/ "./src/ts/impl/tensor.ts":
/*!*******************************!*\
  !*** ./src/ts/impl/tensor.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const vector_1 = __importDefault(__webpack_require__(/*! ../vector */ "./src/ts/vector.ts"));
class Tensor {
    r;
    matrix;
    oldTheta;
    _theta;
    constructor(r, matrix) {
        this.r = r;
        this.matrix = matrix;
        // Represent the matrix as a 2 element list
        // [ 0, 1
        //   1, -0 ]
        this.oldTheta = false;
        this._theta = this.calculateTheta();
    }
    static fromAngle(angle) {
        return new Tensor(1, [Math.cos(angle * 4), Math.sin(angle * 4)]);
    }
    static fromVector(vector) {
        const t1 = vector.x ** 2 - vector.y ** 2;
        const t2 = 2 * vector.x * vector.y;
        const t3 = t1 ** 2 - t2 ** 2;
        const t4 = 2 * t1 * t2;
        return new Tensor(1, [t3, t4]);
    }
    static get zero() {
        return new Tensor(0, [0, 0]);
    }
    get theta() {
        if (this.oldTheta) {
            this._theta = this.calculateTheta();
            this.oldTheta = false;
        }
        return this._theta;
    }
    add(tensor, smooth) {
        this.matrix = this.matrix.map((v, i) => v * this.r + tensor.matrix[i] * tensor.r);
        if (smooth) {
            this.r = Math.hypot(...this.matrix);
            this.matrix = this.matrix.map(v => v / this.r);
        }
        else {
            this.r = 2;
        }
        this.oldTheta = true;
        return this;
    }
    scale(s) {
        this.r *= s;
        this.oldTheta = true;
        return this;
    }
    // Radians
    rotate(theta) {
        if (theta === 0) {
            return this;
        }
        let newTheta = this.theta + theta;
        if (newTheta < Math.PI) {
            newTheta += Math.PI;
        }
        if (newTheta >= Math.PI) {
            newTheta -= Math.PI;
        }
        this.matrix[0] = Math.cos(2 * newTheta) * this.r;
        this.matrix[1] = Math.sin(2 * newTheta) * this.r;
        this._theta = newTheta;
        return this;
    }
    getMajor() {
        // Degenerate case
        if (this.r === 0) {
            return vector_1.default.zeroVector();
        }
        return new vector_1.default(Math.cos(this.theta), Math.sin(this.theta));
    }
    getMinor() {
        // Degenerate case
        if (this.r === 0) {
            return vector_1.default.zeroVector();
        }
        const angle = this.theta + Math.PI / 2;
        return new vector_1.default(Math.cos(angle), Math.sin(angle));
    }
    calculateTheta() {
        if (this.r === 0) {
            return 0;
        }
        return Math.atan2(this.matrix[1] / this.r, this.matrix[0] / this.r) / 2;
    }
}
exports["default"] = Tensor;


/***/ }),

/***/ "./src/ts/impl/tensor_field.ts":
/*!*************************************!*\
  !*** ./src/ts/impl/tensor_field.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const simplex_noise_1 = __webpack_require__(/*! simplex-noise */ "./node_modules/simplex-noise/dist/cjs/simplex-noise.js");
const tensor_1 = __importDefault(__webpack_require__(/*! ./tensor */ "./src/ts/impl/tensor.ts"));
const basis_field_1 = __webpack_require__(/*! ./basis_field */ "./src/ts/impl/basis_field.ts");
const polygon_util_1 = __importDefault(__webpack_require__(/*! ./polygon_util */ "./src/ts/impl/polygon_util.ts"));
/* Combines basis fields Noise added when sampling a point in a park */
class TensorField {
    noiseParams;
    basisFields = [];
    noise;
    parks = [];
    sea = [];
    river = [];
    ignoreRiver = false;
    smooth = false;
    constructor(noiseParams) {
        this.noiseParams = noiseParams;
        this.noise;
    }
    /* Used when integrating coastline and river */
    enableGlobalNoise(angle, size) {
        this.noiseParams.globalNoise = true;
        this.noiseParams.noiseAngleGlobal = angle;
        this.noiseParams.noiseSizeGlobal = size;
    }
    disableGlobalNoise() {
        this.noiseParams.globalNoise = false;
    }
    addGrid(centre, size, decay, theta) {
        const grid = new basis_field_1.Grid(centre, size, decay, theta);
        this.addField(grid);
    }
    addRadial(centre, size, decay) {
        const radial = new basis_field_1.Radial(centre, size, decay);
        this.addField(radial);
    }
    addField(field) {
        this.basisFields.push(field);
    }
    removeField(field) {
        const index = this.basisFields.indexOf(field);
        if (index > -1) {
            this.basisFields.splice(index, 1);
        }
    }
    reset() {
        this.basisFields = [];
        this.parks = [];
        this.sea = [];
        this.river = [];
    }
    getCentrePoints() {
        return this.basisFields.map(field => field.centre);
    }
    getBasisFields() {
        return this.basisFields;
    }
    samplePoint(point) {
        if (!this.onLand(point)) {
            // Degenerate point
            return tensor_1.default.zero;
        }
        // Default field is a grid
        if (this.basisFields.length === 0) {
            return new tensor_1.default(1, [0, 0]);
        }
        const tensorAcc = tensor_1.default.zero;
        this.basisFields.forEach(field => tensorAcc.add(field.getWeightedTensor(point, this.smooth), this.smooth));
        // Add rotational noise for parks - range -pi/2 to pi/2
        if (this.parks.some(p => polygon_util_1.default.insidePolygon(point, p))) {
            // TODO optimise insidePolygon e.g. distance
            tensorAcc.rotate(this.getRotationalNoise(point, this.noiseParams.noiseSizePark, this.noiseParams.noiseAnglePark));
        }
        if (this.noiseParams.globalNoise) {
            tensorAcc.rotate(this.getRotationalNoise(point, this.noiseParams.noiseSizeGlobal, this.noiseParams.noiseAngleGlobal));
        }
        return tensorAcc;
    }
    /* Noise Angle is in degrees */
    getRotationalNoise(point, noiseSize, noiseAngle) {
        const noise2D = (0, simplex_noise_1.createNoise2D)();
        return noise2D(point.x / noiseSize, point.y / noiseSize) * noiseAngle * Math.PI / 180;
    }
    onLand(point) {
        const inSea = polygon_util_1.default.insidePolygon(point, this.sea);
        if (this.ignoreRiver) {
            return !inSea;
        }
        return !inSea && !polygon_util_1.default.insidePolygon(point, this.river);
    }
    inParks(point) {
        for (const p of this.parks) {
            if (polygon_util_1.default.insidePolygon(point, p))
                return true;
        }
        return false;
    }
}
exports["default"] = TensorField;


/***/ }),

/***/ "./src/ts/impl/water_generator.ts":
/*!****************************************!*\
  !*** ./src/ts/impl/water_generator.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const log = __importStar(__webpack_require__(/*! loglevel */ "./node_modules/loglevel/lib/loglevel.js"));
const streamlines_1 = __importDefault(__webpack_require__(/*! ./streamlines */ "./src/ts/impl/streamlines.ts"));
const polygon_util_1 = __importDefault(__webpack_require__(/*! ./polygon_util */ "./src/ts/impl/polygon_util.ts"));
/**
 * Integrates polylines to create coastline and river, with controllable noise
 */
class WaterGenerator extends streamlines_1.default {
    params;
    tensorField;
    TRIES = 100;
    coastlineMajor = true;
    _coastline = []; // Noisy line
    _seaPolygon = []; // Uses screen rectangle and simplified road
    _riverPolygon = []; // Simplified
    _riverSecondaryRoad = [];
    constructor(integrator, origin, worldDimensions, params, tensorField) {
        super(integrator, origin, worldDimensions, params);
        this.params = params;
        this.tensorField = tensorField;
    }
    get coastline() {
        return this._coastline;
    }
    get seaPolygon() {
        return this._seaPolygon;
    }
    get riverPolygon() {
        return this._riverPolygon;
    }
    get riverSecondaryRoad() {
        return this._riverSecondaryRoad;
    }
    createCoast() {
        let coastStreamline;
        let seed;
        let major;
        if (this.params.coastNoise.noiseEnabled) {
            this.tensorField.enableGlobalNoise(this.params.coastNoise.noiseAngle, this.params.coastNoise.noiseSize);
        }
        for (let i = 0; i < this.TRIES; i++) {
            major = Math.random() < 0.5;
            seed = this.getSeed(major);
            coastStreamline = this.extendStreamline(this.integrateStreamline(seed, major));
            if (this.reachesEdges(coastStreamline)) {
                break;
            }
        }
        this.tensorField.disableGlobalNoise();
        this._coastline = coastStreamline;
        this.coastlineMajor = major;
        const road = this.simplifyStreamline(coastStreamline);
        this._seaPolygon = this.getSeaPolygon(road);
        this.allStreamlinesSimple.push(road);
        this.tensorField.sea = (this._seaPolygon);
        // Create intermediate samples
        const complex = this.complexifyStreamline(road);
        this.grid(major).addPolyline(complex);
        this.streamlines(major).push(complex);
        this.allStreamlines.push(complex);
    }
    createRiver() {
        let riverStreamline;
        let seed;
        // Need to ignore sea when integrating for edge check
        const oldSea = this.tensorField.sea;
        this.tensorField.sea = [];
        if (this.params.riverNoise.noiseEnabled) {
            this.tensorField.enableGlobalNoise(this.params.riverNoise.noiseAngle, this.params.riverNoise.noiseSize);
        }
        for (let i = 0; i < this.TRIES; i++) {
            seed = this.getSeed(!this.coastlineMajor);
            riverStreamline = this.extendStreamline(this.integrateStreamline(seed, !this.coastlineMajor));
            if (this.reachesEdges(riverStreamline)) {
                break;
            }
            else if (i === this.TRIES - 1) {
                log.error('Failed to find river reaching edge');
            }
        }
        this.tensorField.sea = oldSea;
        this.tensorField.disableGlobalNoise();
        // Create river roads
        const expandedNoisy = this.complexifyStreamline(polygon_util_1.default.resizeGeometry(riverStreamline, this.params.riverSize, false));
        this._riverPolygon = polygon_util_1.default.resizeGeometry(riverStreamline, this.params.riverSize - this.params.riverBankSize, false);
        // Make sure riverPolygon[0] is off screen
        const firstOffScreen = expandedNoisy.findIndex(v => this.vectorOffScreen(v));
        for (let i = 0; i < firstOffScreen; i++) {
            expandedNoisy.push(expandedNoisy.shift());
        }
        // Create river roads
        const riverSplitPoly = this.getSeaPolygon(riverStreamline);
        const road1 = expandedNoisy.filter(v => !polygon_util_1.default.insidePolygon(v, this._seaPolygon)
            && !this.vectorOffScreen(v)
            && polygon_util_1.default.insidePolygon(v, riverSplitPoly));
        const road1Simple = this.simplifyStreamline(road1);
        const road2 = expandedNoisy.filter(v => !polygon_util_1.default.insidePolygon(v, this._seaPolygon)
            && !this.vectorOffScreen(v)
            && !polygon_util_1.default.insidePolygon(v, riverSplitPoly));
        const road2Simple = this.simplifyStreamline(road2);
        if (road1.length === 0 || road2.length === 0)
            return;
        if (road1[0].distanceToSquared(road2[0]) < road1[0].distanceToSquared(road2[road2.length - 1])) {
            road2Simple.reverse();
        }
        this.tensorField.river = road1Simple.concat(road2Simple);
        // Road 1
        this.allStreamlinesSimple.push(road1Simple);
        this._riverSecondaryRoad = road2Simple;
        this.grid(!this.coastlineMajor).addPolyline(road1);
        this.grid(!this.coastlineMajor).addPolyline(road2);
        this.streamlines(!this.coastlineMajor).push(road1);
        this.streamlines(!this.coastlineMajor).push(road2);
        this.allStreamlines.push(road1);
        this.allStreamlines.push(road2);
    }
    /**
     * Assumes simplified
     * Used for adding river roads
     */
    manuallyAddStreamline(s, major) {
        this.allStreamlinesSimple.push(s);
        // Create intermediate samples
        const complex = this.complexifyStreamline(s);
        this.grid(major).addPolyline(complex);
        this.streamlines(major).push(complex);
        this.allStreamlines.push(complex);
    }
    /**
     * Might reverse input array
     */
    getSeaPolygon(polyline) {
        // const seaPolygon = PolygonUtil.sliceRectangle(this.origin, this.worldDimensions,
        //     polyline[0], polyline[polyline.length - 1]);
        // // Replace the longest side with coastline
        // let longestIndex = 0;
        // let longestLength = 0;
        // for (let i = 0; i < seaPolygon.length; i++) {
        //     const next = (i + 1) % seaPolygon.length;
        //     const d = seaPolygon[i].distanceToSquared(seaPolygon[next]);
        //     if (d > longestLength) {
        //         longestLength = d;
        //         longestIndex = i;
        //     }
        // }
        // const insertBackwards = seaPolygon[longestIndex].distanceToSquared(polyline[0]) > seaPolygon[longestIndex].distanceToSquared(polyline[polyline.length - 1]);
        // if (insertBackwards) {
        //     polyline.reverse();
        // }
        // seaPolygon.splice((longestIndex + 1) % seaPolygon.length, 0, ...polyline);
        return polygon_util_1.default.lineRectanglePolygonIntersection(this.origin, this.worldDimensions, polyline);
        // return PolygonUtil.boundPolyToScreen(this.origin, this.worldDimensions, seaPolygon);
    }
    /**
     * Insert samples in streamline until separated by dstep
     */
    complexifyStreamline(s) {
        const out = [];
        for (let i = 0; i < s.length - 1; i++) {
            out.push(...this.complexifyStreamlineRecursive(s[i], s[i + 1]));
        }
        return out;
    }
    complexifyStreamlineRecursive(v1, v2) {
        if (v1.distanceToSquared(v2) <= this.paramsSq.dstep) {
            return [v1, v2];
        }
        const d = v2.clone().sub(v1);
        const halfway = v1.clone().add(d.multiplyScalar(0.5));
        const complex = this.complexifyStreamlineRecursive(v1, halfway);
        complex.push(...this.complexifyStreamlineRecursive(halfway, v2));
        return complex;
    }
    /**
     * Mutates streamline
     */
    extendStreamline(streamline) {
        streamline.unshift(streamline[0].clone().add(streamline[0].clone().sub(streamline[1]).setLength(this.params.dstep * 5)));
        streamline.push(streamline[streamline.length - 1].clone().add(streamline[streamline.length - 1].clone().sub(streamline[streamline.length - 2]).setLength(this.params.dstep * 5)));
        return streamline;
    }
    reachesEdges(streamline) {
        return this.vectorOffScreen(streamline[0]) && this.vectorOffScreen(streamline[streamline.length - 1]);
    }
    vectorOffScreen(v) {
        const toOrigin = v.clone().sub(this.origin);
        return toOrigin.x <= 0 || toOrigin.y <= 0 ||
            toOrigin.x >= this.worldDimensions.x || toOrigin.y >= this.worldDimensions.y;
    }
}
exports["default"] = WaterGenerator;


/***/ }),

/***/ "./src/ts/ui/buildings.ts":
/*!********************************!*\
  !*** ./src/ts/ui/buildings.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const domain_controller_1 = __importDefault(__webpack_require__(/*! ./domain_controller */ "./src/ts/ui/domain_controller.ts"));
const graph_1 = __importDefault(__webpack_require__(/*! ../impl/graph */ "./src/ts/impl/graph.ts"));
const polygon_finder_1 = __importDefault(__webpack_require__(/*! ../impl/polygon_finder */ "./src/ts/impl/polygon_finder.ts"));
/**
 * Pseudo 3D buildings //https://www.youtube.com/watch?v=h6cyNPe5kZg
 */
class BuildingModels {
    domainController = domain_controller_1.default.getInstance();
    _buildingModels = [];
    constructor(lots) {
        for (const lot of lots) {
            this._buildingModels.push({
                height: Math.random() * 20 + 20,
                lotWorld: lot,
                lotScreen: [],
                roof: [],
                sides: []
            });
        }
        this._buildingModels.sort((a, b) => a.height - b.height);
    }
    get buildingModels() {
        return this._buildingModels;
    }
    /**
     * Recalculated when the camera moves
     */
    setBuildingProjections() {
        const d = 1000 / this.domainController.zoom;
        const cameraPos = this.domainController.getCameraPosition();
        for (const b of this._buildingModels) {
            b.lotScreen = b.lotWorld.map(v => this.domainController.worldToScreen(v.clone()));
            b.roof = b.lotScreen.map(v => this.heightVectorToScreen(v, b.height, d, cameraPos));
            b.sides = this.getBuildingSides(b);
        }
    }
    heightVectorToScreen(v, h, d, camera) {
        const scale = (d / (d - h)); // 0.1
        if (this.domainController.orthographic) {
            const diff = this.domainController.cameraDirection.multiplyScalar(-h * scale);
            return v.clone().add(diff);
        }
        else {
            return v.clone().sub(camera).multiplyScalar(scale).add(camera);
        }
    }
    /**
     * Get sides of buildings by joining corresponding edges between the roof and ground
     */
    getBuildingSides(b) {
        const polygons = [];
        for (let i = 0; i < b.lotScreen.length; i++) {
            const next = (i + 1) % b.lotScreen.length;
            polygons.push([b.lotScreen[i], b.lotScreen[next], b.roof[next], b.roof[i]]);
        }
        return polygons;
    }
}
/**
 * Finds building lots and optionally pseudo3D buildings
 */
class Buildings {
    tensorField;
    redraw;
    dstep;
    _animate;
    polygonFinder;
    allStreamlines = [];
    domainController = domain_controller_1.default.getInstance();
    preGenerateCallback = () => { };
    postGenerateCallback = () => { };
    _models = new BuildingModels([]);
    _blocks = [];
    buildingParams = {
        maxLength: 20,
        minArea: 50,
        shrinkSpacing: 4,
        chanceNoDivide: 0.05,
    };
    constructor(tensorField, folder, redraw, dstep, _animate) {
        this.tensorField = tensorField;
        this.redraw = redraw;
        this.dstep = dstep;
        this._animate = _animate;
        folder.add({ 'AddBuildings': () => this.generate(this._animate) }, 'AddBuildings');
        folder.add(this.buildingParams, 'minArea');
        folder.add(this.buildingParams, 'shrinkSpacing');
        folder.add(this.buildingParams, 'chanceNoDivide');
        this.polygonFinder = new polygon_finder_1.default([], this.buildingParams, this.tensorField);
    }
    set animate(v) {
        this._animate = v;
    }
    get lots() {
        return this.polygonFinder.polygons.map(p => p.map(v => this.domainController.worldToScreen(v.clone())));
    }
    /**
     * Only used when creating the 3D model to 'fake' the roads
     */
    getBlocks() {
        const g = new graph_1.default(this.allStreamlines, this.dstep, true);
        const blockParams = Object.assign({}, this.buildingParams);
        blockParams.shrinkSpacing = blockParams.shrinkSpacing / 2;
        const polygonFinder = new polygon_finder_1.default(g.nodes, blockParams, this.tensorField);
        polygonFinder.findPolygons();
        return polygonFinder.shrink(false).then(() => polygonFinder.polygons.map(p => p.map(v => this.domainController.worldToScreen(v.clone()))));
    }
    get models() {
        this._models.setBuildingProjections();
        return this._models.buildingModels;
    }
    setAllStreamlines(s) {
        this.allStreamlines = s;
    }
    reset() {
        this.polygonFinder.reset();
        this._models = new BuildingModels([]);
    }
    update() {
        return this.polygonFinder.update();
    }
    /**
     * Finds blocks, shrinks and divides them to create building lots
     */
    async generate(animate) {
        this.preGenerateCallback();
        this._models = new BuildingModels([]);
        const g = new graph_1.default(this.allStreamlines, this.dstep, true);
        this.polygonFinder = new polygon_finder_1.default(g.nodes, this.buildingParams, this.tensorField);
        this.polygonFinder.findPolygons();
        await this.polygonFinder.shrink(animate);
        await this.polygonFinder.divide(animate);
        this.redraw();
        this._models = new BuildingModels(this.polygonFinder.polygons);
        this.postGenerateCallback();
    }
    setPreGenerateCallback(callback) {
        this.preGenerateCallback = callback;
    }
    setPostGenerateCallback(callback) {
        this.postGenerateCallback = callback;
    }
}
exports["default"] = Buildings;


/***/ }),

/***/ "./src/ts/ui/canvas_wrapper.ts":
/*!*************************************!*\
  !*** ./src/ts/ui/canvas_wrapper.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RoughCanvasWrapper = exports.DefaultCanvasWrapper = void 0;
const svg_js_1 = __webpack_require__(/*! @svgdotjs/svg.js */ "./node_modules/@svgdotjs/svg.js/dist/svg.esm.js");
const util_1 = __importDefault(__webpack_require__(/*! ../util */ "./src/ts/util.ts"));
/**
 * Thin wrapper around HTML canvas, abstracts drawing functions so we can use the RoughJS canvas or the default one
 */
class CanvasWrapper {
    canvas;
    _scale;
    svgNode;
    _width;
    _height;
    needsUpdate = false;
    constructor(canvas, _scale = 1, resizeToWindow = true) {
        this.canvas = canvas;
        this._scale = _scale;
        this.setDimensions();
        this.resizeCanvas();
        if (resizeToWindow) {
            window.addEventListener('resize', () => {
                this.setDimensions();
                this.resizeCanvas();
            });
        }
    }
    appendSvgNode(node) {
        if (this.svgNode) {
            this.svgNode.appendChild(node);
        }
    }
    createSVG(svgElement) {
        this.svgNode = svgElement;
    }
    setDimensions() {
        this._width = window.innerWidth * this._scale;
        this._height = window.innerHeight * this._scale;
    }
    get width() {
        return this._width;
    }
    get height() {
        return this._height;
    }
    get canvasScale() {
        return this._scale;
    }
    set canvasScale(s) {
        this._scale = s;
        this.setDimensions();
        this.resizeCanvas();
    }
    zoomVectors(vs) {
        if (this._scale === 1)
            return vs;
        return vs.map(v => v.clone().multiplyScalar(this._scale));
    }
    resizeCanvas() {
        this.canvas.width = this._width;
        this.canvas.height = this._height;
        this.needsUpdate = true;
    }
}
exports["default"] = CanvasWrapper;
class DefaultCanvasWrapper extends CanvasWrapper {
    ctx;
    svg;
    constructor(canvas, scale = 1, resizeToWindow = true) {
        super(canvas, scale, resizeToWindow);
        this.ctx = canvas.getContext("2d");
        this.ctx.fillStyle = 'black';
        this.ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
    }
    createSVG(svgElement) {
        super.createSVG(svgElement);
        this.svg = (0, svg_js_1.SVG)(svgElement);
    }
    setFillStyle(colour) {
        this.ctx.fillStyle = colour;
    }
    clearCanvas() {
        if (this.svgNode) {
            // Expanded to cover whole drawn area
            const startW = window.innerWidth * (util_1.default.DRAW_INFLATE_AMOUNT - 1) / 2;
            const startH = window.innerHeight * (util_1.default.DRAW_INFLATE_AMOUNT - 1) / 2;
            this.drawRectangle(-startW, -startH, window.innerWidth * util_1.default.DRAW_INFLATE_AMOUNT, window.innerHeight * util_1.default.DRAW_INFLATE_AMOUNT);
        }
        else {
            this.drawRectangle(0, 0, window.innerWidth, window.innerHeight);
        }
    }
    drawFrame(left, right, up, down) {
        this.drawRectangle(0, 0, this._width / this._scale, up);
        this.drawRectangle(0, 0, left, this._height / this._scale);
        this.drawRectangle(this._width / this._scale - right, 0, right, this._height / this._scale);
        this.drawRectangle(0, this._height / this._scale - down, this._width / this._scale, down);
    }
    drawCityName() {
        const fontSize = 50 * this._scale;
        this.ctx.font = `small-caps ${fontSize}px Verdana`;
        this.ctx.textAlign = "center";
        this.ctx.fillText("san francisco", this._width / 2, this._height - (80 * this._scale - fontSize));
    }
    drawRectangle(x, y, width, height) {
        if (this._scale !== 1) {
            x *= this._scale;
            y *= this._scale;
            width *= this._scale;
            height *= this._scale;
        }
        this.ctx.fillRect(x, y, width, height);
        if (this.svg) {
            this.svg.rect({
                fill: this.ctx.fillStyle,
                'fill-opacity': 1,
                stroke: this.ctx.strokeStyle,
                'stroke-width': this.ctx.lineWidth,
                x: x,
                y: y,
                width: width,
                height: height,
            });
        }
    }
    drawPolygon(polygon) {
        if (polygon.length === 0) {
            return;
        }
        polygon = this.zoomVectors(polygon);
        this.ctx.beginPath();
        this.ctx.moveTo(polygon[0].x, polygon[0].y);
        for (let i = 1; i < polygon.length; i++) {
            this.ctx.lineTo(polygon[i].x, polygon[i].y);
        }
        this.ctx.lineTo(polygon[0].x, polygon[0].y);
        this.ctx.fill();
        this.ctx.stroke();
        if (this.svg) {
            const vectorArray = polygon.map(v => [v.x, v.y]);
            vectorArray.push(vectorArray[0]);
            this.svg.polyline(vectorArray).attr({
                fill: this.ctx.fillStyle,
                'fill-opacity': 1,
                stroke: this.ctx.strokeStyle,
                'stroke-width': this.ctx.lineWidth,
            });
        }
    }
    drawCircle(centre, radius) {
        const TAU = 2 * Math.PI;
        this.ctx.beginPath();
        this.ctx.arc(centre.x, centre.y, radius, 0, TAU);
        this.ctx.fill();
    }
    drawSquare(centre, radius) {
        this.drawRectangle(centre.x - radius, centre.y - radius, 2 * radius, 2 * radius);
    }
    setLineWidth(width) {
        if (this._scale !== 1) {
            width *= this._scale;
        }
        this.ctx.lineWidth = width;
    }
    setStrokeStyle(colour) {
        this.ctx.strokeStyle = colour;
    }
    drawPolyline(line) {
        if (line.length < 2) {
            return;
        }
        line = this.zoomVectors(line);
        this.ctx.beginPath();
        this.ctx.moveTo(line[0].x, line[0].y);
        for (let i = 1; i < line.length; i++) {
            this.ctx.lineTo(line[i].x, line[i].y);
        }
        this.ctx.stroke();
        if (this.svg) {
            const vectorArray = line.map(v => [v.x, v.y]);
            this.svg.polyline(vectorArray).attr({
                'fill-opacity': 0,
                stroke: this.ctx.strokeStyle,
                'stroke-width': this.ctx.lineWidth,
            });
        }
    }
}
exports.DefaultCanvasWrapper = DefaultCanvasWrapper;
class RoughCanvasWrapper extends CanvasWrapper {
    r = __webpack_require__(/*! roughjs/bundled/rough.cjs */ "./node_modules/roughjs/bundled/rough.cjs.js");
    rc;
    options = {
        roughness: 1,
        bowing: 1,
        stroke: '#000000',
        strokeWidth: 1,
        fill: '#000000',
        fillStyle: 'solid',
    };
    constructor(canvas, scale = 1, resizeToWindow = true) {
        super(canvas, scale, resizeToWindow);
        this.rc = this.r.canvas(canvas);
    }
    createSVG(svgElement) {
        super.createSVG(svgElement);
        this.rc = this.r.svg(this.svgNode);
    }
    drawFrame(left, right, up, down) {
    }
    setOptions(options) {
        if (options.strokeWidth) {
            options.strokeWidth *= this._scale;
        }
        Object.assign(this.options, options);
    }
    clearCanvas() {
        if (this.svgNode) {
            // Expanded to cover whole drawn area
            const startW = window.innerWidth * (util_1.default.DRAW_INFLATE_AMOUNT - 1) / 2;
            const startH = window.innerHeight * (util_1.default.DRAW_INFLATE_AMOUNT - 1) / 2;
            this.drawRectangle(-startW, -startH, window.innerWidth * util_1.default.DRAW_INFLATE_AMOUNT, window.innerHeight * util_1.default.DRAW_INFLATE_AMOUNT);
        }
        else {
            this.drawRectangle(0, 0, window.innerWidth, window.innerHeight);
        }
    }
    drawRectangle(x, y, width, height) {
        if (this._scale !== 1) {
            x *= this._scale;
            y *= this._scale;
            width *= this._scale;
            height *= this._scale;
        }
        this.appendSvgNode(this.rc.rectangle(x, y, width, height, this.options));
    }
    drawPolygon(polygon) {
        if (polygon.length === 0) {
            return;
        }
        if (this._scale !== 1) {
            polygon = polygon.map(v => v.clone().multiplyScalar(this._scale));
        }
        this.appendSvgNode(this.rc.polygon(polygon.map(v => [v.x, v.y]), this.options));
    }
    drawSquare(centre, radius) {
        const prevStroke = this.options.stroke;
        this.options.stroke = 'none';
        this.drawRectangle(centre.x - radius, centre.y - radius, 2 * radius, 2 * radius);
        this.options.stroke = prevStroke;
    }
    drawPolyline(line) {
        if (line.length < 2) {
            return;
        }
        if (this._scale !== 1) {
            line = line.map(v => v.clone().multiplyScalar(this._scale));
        }
        this.appendSvgNode(this.rc.linearPath(line.map(v => [v.x, v.y]), this.options));
    }
}
exports.RoughCanvasWrapper = RoughCanvasWrapper;


/***/ }),

/***/ "./src/ts/ui/domain_controller.ts":
/*!****************************************!*\
  !*** ./src/ts/ui/domain_controller.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const vector_1 = __importDefault(__webpack_require__(/*! ../vector */ "./src/ts/vector.ts"));
const util_1 = __importDefault(__webpack_require__(/*! ../util */ "./src/ts/util.ts"));
/**
 * Singleton
 * Controls panning and zooming
 */
class DomainController {
    static instance;
    ZOOM_SPEED = 0.96;
    SCROLL_DELAY = 100;
    // Location of screen origin in world space
    _origin = vector_1.default.zeroVector();
    // Screen-space width and height
    _screenDimensions = vector_1.default.zeroVector();
    // Ratio of screen pixels to world pixels
    _zoom = 1;
    zoomCallback = () => { };
    lastScrolltime = -this.SCROLL_DELAY;
    refreshedAfterScroll = false;
    _cameraDirection = vector_1.default.zeroVector();
    _orthographic = false;
    // Set after pan or zoom
    moved = false;
    constructor() {
        this.setScreenDimensions();
        window.addEventListener('resize', () => this.setScreenDimensions());
        window.addEventListener('wheel', (e) => {
            if (e.target.id === util_1.default.CANVAS_ID) {
                this.lastScrolltime = Date.now();
                this.refreshedAfterScroll = false;
                const delta = e.deltaY;
                // TODO scale by value of delta
                if (delta > 0) {
                    this.zoom = this._zoom * this.ZOOM_SPEED;
                }
                else {
                    this.zoom = this._zoom / this.ZOOM_SPEED;
                }
            }
        });
    }
    /**
     * Used to stop drawing buildings while scrolling for certain styles
     * to keep the framerate up
     */
    get isScrolling() {
        return Date.now() - this.lastScrolltime < this.SCROLL_DELAY;
    }
    setScreenDimensions() {
        this.moved = true;
        this._screenDimensions.setX(window.innerWidth);
        this._screenDimensions.setY(window.innerHeight);
    }
    static getInstance() {
        if (!DomainController.instance) {
            DomainController.instance = new DomainController();
        }
        return DomainController.instance;
    }
    /**
     * @param {Vector} delta in world space
     */
    pan(delta) {
        this.moved = true;
        this._origin.sub(delta);
    }
    /**
     * Screen origin in world space
     */
    get origin() {
        return this._origin.clone();
    }
    get zoom() {
        return this._zoom;
    }
    get screenDimensions() {
        return this._screenDimensions.clone();
    }
    /**
     * @return {Vector} world-space w/h visible on screen
     */
    get worldDimensions() {
        return this.screenDimensions.divideScalar(this._zoom);
    }
    set screenDimensions(v) {
        this.moved = true;
        this._screenDimensions.copy(v);
    }
    set zoom(z) {
        if (z >= 0.3 && z <= 20) {
            this.moved = true;
            const oldWorldSpaceMidpoint = this.origin.add(this.worldDimensions.divideScalar(2));
            this._zoom = z;
            const newWorldSpaceMidpoint = this.origin.add(this.worldDimensions.divideScalar(2));
            this.pan(newWorldSpaceMidpoint.sub(oldWorldSpaceMidpoint));
            this.zoomCallback();
        }
    }
    onScreen(v) {
        const screenSpace = this.worldToScreen(v.clone());
        return screenSpace.x >= 0 && screenSpace.y >= 0
            && screenSpace.x <= this.screenDimensions.x && screenSpace.y <= this.screenDimensions.y;
    }
    set orthographic(v) {
        this._orthographic = v;
        this.moved = true;
    }
    get orthographic() {
        return this._orthographic;
    }
    set cameraDirection(v) {
        this._cameraDirection = v;
        // Screen update
        this.moved = true;
    }
    get cameraDirection() {
        return this._cameraDirection.clone();
    }
    getCameraPosition() {
        const centre = new vector_1.default(this._screenDimensions.x / 2, this._screenDimensions.y / 2);
        if (this._orthographic) {
            return centre.add(centre.clone().multiply(this._cameraDirection).multiplyScalar(100));
        }
        return centre.add(centre.clone().multiply(this._cameraDirection));
        // this.screenDimensions.divideScalar(2);
    }
    setZoomUpdate(callback) {
        this.zoomCallback = callback;
    }
    /**
     * Edits vector
     */
    zoomToWorld(v) {
        return v.divideScalar(this._zoom);
    }
    /**
     * Edits vector
     */
    zoomToScreen(v) {
        return v.multiplyScalar(this._zoom);
    }
    /**
     * Edits vector
     */
    screenToWorld(v) {
        return this.zoomToWorld(v).add(this._origin);
    }
    /**
     * Edits vector
     */
    worldToScreen(v) {
        return this.zoomToScreen(v.sub(this._origin));
    }
}
exports["default"] = DomainController;


/***/ }),

/***/ "./src/ts/ui/drag_controller.ts":
/*!**************************************!*\
  !*** ./src/ts/ui/drag_controller.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const interactjs_1 = __importDefault(__webpack_require__(/*! interactjs */ "./node_modules/interactjs/dist/interact.min.js"));
const util_1 = __importDefault(__webpack_require__(/*! ../util */ "./src/ts/util.ts"));
const vector_1 = __importDefault(__webpack_require__(/*! ../vector */ "./src/ts/vector.ts"));
const domain_controller_1 = __importDefault(__webpack_require__(/*! ./domain_controller */ "./src/ts/ui/domain_controller.ts"));
/**
* Register multiple centre points
* Closest one to mouse click will be selected to drag
* Up to caller to actually move their centre point via callback
*/
class DragController {
    gui;
    // How close to drag handle pointer needs to be
    MIN_DRAG_DISTANCE = 50;
    draggables = [];
    currentlyDragging = null; // Tensor field
    _isDragging = false;
    disabled = false;
    domainController = domain_controller_1.default.getInstance();
    constructor(gui) {
        this.gui = gui;
        (0, interactjs_1.default)(`#${util_1.default.CANVAS_ID}`).draggable({
            onstart: this.dragStart.bind(this),
            onmove: this.dragMove.bind(this),
            onend: this.dragEnd.bind(this),
            cursorChecker: this.getCursor.bind(this),
        });
    }
    setDragDisabled(disable) {
        this.disabled = disable;
    }
    /**
     * Change cursor style
     */
    getCursor(action, interactable, element, interacting) {
        if (interacting)
            return 'grabbing';
        return 'grab';
    }
    dragStart(event) {
        this._isDragging = true;
        // Transform screen space to world space
        const origin = this.domainController.screenToWorld(new vector_1.default(event.x0, event.y0));
        let closestDistance = Infinity;
        this.draggables.forEach(draggable => {
            const d = draggable.getCentre().distanceTo(origin);
            if (d < closestDistance) {
                closestDistance = d;
                this.currentlyDragging = draggable;
            }
        });
        // Zoom screen size to world size for consistent drag distance while zoomed in
        const scaledDragDistance = this.MIN_DRAG_DISTANCE / this.domainController.zoom;
        if (closestDistance > scaledDragDistance) {
            this.currentlyDragging = null;
        }
        else {
            this.currentlyDragging.startListener();
        }
    }
    dragMove(event) {
        const delta = new vector_1.default(event.delta.x, event.delta.y);
        this.domainController.zoomToWorld(delta);
        if (!this.disabled && this.currentlyDragging !== null) {
            // Drag field
            this.currentlyDragging.moveListener(delta);
        }
        else {
            // Move map
            this.domainController.pan(delta);
        }
    }
    dragEnd() {
        this._isDragging = false;
        this.domainController.pan(vector_1.default.zeroVector()); // Triggers canvas update
        this.currentlyDragging = null;
        util_1.default.updateGui(this.gui);
    }
    get isDragging() {
        return this._isDragging;
    }
    /**
     * @param {(() => Vector)} Gets centre point
     * @param {((v: Vector) => void)} Called on move with delta vector
     * @param {(() => void)} Called on start
     * @returns {(() => void)} Function to deregister callback
     */
    register(getCentre, onMove, onStart) {
        const draggable = {
            getCentre: getCentre,
            moveListener: onMove,
            startListener: onStart,
        };
        this.draggables.push(draggable);
        return (() => {
            const index = this.draggables.indexOf(draggable);
            if (index >= 0) {
                this.draggables.splice(index, 1);
            }
        }).bind(this);
    }
}
exports["default"] = DragController;


/***/ }),

/***/ "./src/ts/ui/main_gui.ts":
/*!*******************************!*\
  !*** ./src/ts/ui/main_gui.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const domain_controller_1 = __importDefault(__webpack_require__(/*! ./domain_controller */ "./src/ts/ui/domain_controller.ts"));
const integrator_1 = __webpack_require__(/*! ../impl/integrator */ "./src/ts/impl/integrator.ts");
const graph_1 = __importDefault(__webpack_require__(/*! ../impl/graph */ "./src/ts/impl/graph.ts"));
const road_gui_1 = __importDefault(__webpack_require__(/*! ./road_gui */ "./src/ts/ui/road_gui.ts"));
const water_gui_1 = __importDefault(__webpack_require__(/*! ./water_gui */ "./src/ts/ui/water_gui.ts"));
const polygon_finder_1 = __importDefault(__webpack_require__(/*! ../impl/polygon_finder */ "./src/ts/impl/polygon_finder.ts"));
const style_1 = __webpack_require__(/*! ./style */ "./src/ts/ui/style.ts");
const buildings_1 = __importDefault(__webpack_require__(/*! ./buildings */ "./src/ts/ui/buildings.ts"));
const polygon_util_1 = __importDefault(__webpack_require__(/*! ../impl/polygon_util */ "./src/ts/impl/polygon_util.ts"));
/**
 * Handles Map folder, glues together impl
 */
class MainGUI {
    guiFolder;
    tensorField;
    closeTensorFolder;
    numBigParks = 20;
    numSmallParks = 10;
    clusterBigParks = true;
    domainController = domain_controller_1.default.getInstance();
    intersections = [];
    bigParks = [];
    smallParks = [];
    animate = true;
    animationSpeed = 30;
    coastline;
    mainRoads;
    majorRoads;
    minorRoads;
    buildings;
    // Params
    coastlineParams;
    mainParams;
    majorParams;
    minorParams = {
        dsep: 20,
        dtest: 15,
        dstep: 1,
        dlookahead: 40,
        dcirclejoin: 5,
        joinangle: 0.1, // approx 30deg
        pathIterations: 1000,
        seedTries: 300,
        simplifyTolerance: 0.5,
        collideEarly: 0,
    };
    redraw = true;
    constructor(guiFolder, tensorField, closeTensorFolder) {
        this.guiFolder = guiFolder;
        this.tensorField = tensorField;
        this.closeTensorFolder = closeTensorFolder;
        guiFolder.add(this, 'generateEverything');
        // guiFolder.add(this, 'simpleBenchMark');
        const animateController = guiFolder.add(this, 'animate');
        guiFolder.add(this, 'animationSpeed');
        this.coastlineParams = Object.assign({
            coastNoise: {
                noiseEnabled: true,
                noiseSize: 30,
                noiseAngle: 20,
            },
            riverNoise: {
                noiseEnabled: true,
                noiseSize: 30,
                noiseAngle: 20,
            },
            riverBankSize: 10,
            riverSize: 30,
        }, this.minorParams);
        this.coastlineParams.pathIterations = 10000;
        this.coastlineParams.simplifyTolerance = 10;
        this.majorParams = Object.assign({}, this.minorParams);
        this.majorParams.dsep = 100;
        this.majorParams.dtest = 30;
        this.majorParams.dlookahead = 200;
        this.majorParams.collideEarly = 0;
        this.mainParams = Object.assign({}, this.minorParams);
        this.mainParams.dsep = 400;
        this.mainParams.dtest = 200;
        this.mainParams.dlookahead = 500;
        this.mainParams.collideEarly = 0;
        const integrator = new integrator_1.RK4Integrator(tensorField, this.minorParams);
        const redraw = () => this.redraw = true;
        this.coastline = new water_gui_1.default(tensorField, this.coastlineParams, integrator, this.guiFolder, closeTensorFolder, 'Water', redraw).initFolder();
        this.mainRoads = new road_gui_1.default(this.mainParams, integrator, this.guiFolder, closeTensorFolder, 'Main', redraw).initFolder();
        this.majorRoads = new road_gui_1.default(this.majorParams, integrator, this.guiFolder, closeTensorFolder, 'Major', redraw, this.animate).initFolder();
        this.minorRoads = new road_gui_1.default(this.minorParams, integrator, this.guiFolder, closeTensorFolder, 'Minor', redraw, this.animate).initFolder();
        const parks = guiFolder.addFolder('Parks');
        parks.add({ Generate: () => {
                this.buildings.reset();
                this.addParks();
                this.redraw = true;
            } }, 'Generate');
        parks.add(this, 'clusterBigParks');
        parks.add(this, 'numBigParks');
        parks.add(this, 'numSmallParks');
        const buildingsFolder = guiFolder.addFolder('Buildings');
        this.buildings = new buildings_1.default(tensorField, buildingsFolder, redraw, this.minorParams.dstep, this.animate);
        this.buildings.setPreGenerateCallback(() => {
            const allStreamlines = [];
            allStreamlines.push(...this.mainRoads.allStreamlines);
            allStreamlines.push(...this.majorRoads.allStreamlines);
            allStreamlines.push(...this.minorRoads.allStreamlines);
            allStreamlines.push(...this.coastline.streamlinesWithSecondaryRoad);
            this.buildings.setAllStreamlines(allStreamlines);
        });
        animateController.onChange((b) => {
            this.majorRoads.animate = b;
            this.minorRoads.animate = b;
            this.buildings.animate = b;
        });
        this.minorRoads.setExistingStreamlines([this.coastline, this.mainRoads, this.majorRoads]);
        this.majorRoads.setExistingStreamlines([this.coastline, this.mainRoads]);
        this.mainRoads.setExistingStreamlines([this.coastline]);
        this.coastline.setPreGenerateCallback(() => {
            this.mainRoads.clearStreamlines();
            this.majorRoads.clearStreamlines();
            this.minorRoads.clearStreamlines();
            this.bigParks = [];
            this.smallParks = [];
            this.buildings.reset();
            tensorField.parks = [];
            tensorField.sea = [];
            tensorField.river = [];
        });
        this.mainRoads.setPreGenerateCallback(() => {
            this.majorRoads.clearStreamlines();
            this.minorRoads.clearStreamlines();
            this.bigParks = [];
            this.smallParks = [];
            this.buildings.reset();
            tensorField.parks = [];
            tensorField.ignoreRiver = true;
        });
        this.mainRoads.setPostGenerateCallback(() => {
            tensorField.ignoreRiver = false;
        });
        this.majorRoads.setPreGenerateCallback(() => {
            this.minorRoads.clearStreamlines();
            this.bigParks = [];
            this.smallParks = [];
            this.buildings.reset();
            tensorField.parks = [];
            tensorField.ignoreRiver = true;
        });
        this.majorRoads.setPostGenerateCallback(() => {
            tensorField.ignoreRiver = false;
            this.addParks();
            this.redraw = true;
        });
        this.minorRoads.setPreGenerateCallback(() => {
            this.buildings.reset();
            this.smallParks = [];
            tensorField.parks = this.bigParks;
        });
        this.minorRoads.setPostGenerateCallback(() => {
            this.addParks();
        });
    }
    addParks() {
        const g = new graph_1.default(this.majorRoads.allStreamlines
            .concat(this.mainRoads.allStreamlines)
            .concat(this.minorRoads.allStreamlines), this.minorParams.dstep);
        this.intersections = g.intersections;
        const p = new polygon_finder_1.default(g.nodes, {
            maxLength: 20,
            minArea: 80,
            shrinkSpacing: 4,
            chanceNoDivide: 1,
        }, this.tensorField);
        p.findPolygons();
        const polygons = p.polygons;
        if (this.minorRoads.allStreamlines.length === 0) {
            // Big parks
            this.bigParks = [];
            this.smallParks = [];
            if (polygons.length > this.numBigParks) {
                if (this.clusterBigParks) {
                    // Group in adjacent polygons 
                    const parkIndex = Math.floor(Math.random() * (polygons.length - this.numBigParks));
                    for (let i = parkIndex; i < parkIndex + this.numBigParks; i++) {
                        this.bigParks.push(polygons[i]);
                    }
                }
                else {
                    for (let i = 0; i < this.numBigParks; i++) {
                        const parkIndex = Math.floor(Math.random() * polygons.length);
                        this.bigParks.push(polygons[parkIndex]);
                    }
                }
            }
            else {
                this.bigParks.push(...polygons);
            }
        }
        else {
            // Small parks
            this.smallParks = [];
            for (let i = 0; i < this.numSmallParks; i++) {
                const parkIndex = Math.floor(Math.random() * polygons.length);
                this.smallParks.push(polygons[parkIndex]);
            }
        }
        this.tensorField.parks = [];
        this.tensorField.parks.push(...this.bigParks);
        this.tensorField.parks.push(...this.smallParks);
    }
    async generateEverything() {
        this.coastline.generateRoads();
        await this.mainRoads.generateRoads();
        await this.majorRoads.generateRoads(this.animate);
        await this.minorRoads.generateRoads(this.animate);
        this.redraw = true;
        await this.buildings.generate(this.animate);
    }
    update() {
        let continueUpdate = true;
        const start = performance.now();
        while (continueUpdate && performance.now() - start < this.animationSpeed) {
            const minorChanged = this.minorRoads.update();
            const majorChanged = this.majorRoads.update();
            const mainChanged = this.mainRoads.update();
            const buildingsChanged = this.buildings.update();
            continueUpdate = minorChanged || majorChanged || mainChanged || buildingsChanged;
        }
        this.redraw = this.redraw || continueUpdate;
    }
    draw(style, forceDraw = false, customCanvas) {
        if (!style.needsUpdate && !forceDraw && !this.redraw && !this.domainController.moved) {
            return;
        }
        style.needsUpdate = false;
        this.domainController.moved = false;
        this.redraw = false;
        style.seaPolygon = this.coastline.seaPolygon;
        style.coastline = this.coastline.coastline;
        style.river = this.coastline.river;
        style.lots = this.buildings.lots;
        if (style instanceof style_1.DefaultStyle && style.showBuildingModels || style instanceof style_1.RoughStyle) {
            style.buildingModels = this.buildings.models;
        }
        style.parks = [];
        style.parks.push(...this.bigParks.map(p => p.map(v => this.domainController.worldToScreen(v.clone()))));
        style.parks.push(...this.smallParks.map(p => p.map(v => this.domainController.worldToScreen(v.clone()))));
        style.minorRoads = this.minorRoads.roads;
        style.majorRoads = this.majorRoads.roads;
        style.mainRoads = this.mainRoads.roads;
        style.coastlineRoads = this.coastline.roads;
        style.secondaryRiver = this.coastline.secondaryRiver;
        style.draw(customCanvas);
    }
    roadsEmpty() {
        return this.majorRoads.roadsEmpty()
            && this.minorRoads.roadsEmpty()
            && this.mainRoads.roadsEmpty()
            && this.coastline.roadsEmpty();
    }
    // OBJ Export methods
    get seaPolygon() {
        return this.coastline.seaPolygon;
    }
    get riverPolygon() {
        return this.coastline.river;
    }
    get buildingModels() {
        return this.buildings.models;
    }
    getBlocks() {
        return this.buildings.getBlocks();
    }
    get minorRoadPolygons() {
        return this.minorRoads.roads.map(r => polygon_util_1.default.resizeGeometry(r, 1 * this.domainController.zoom, false));
    }
    get majorRoadPolygons() {
        return this.majorRoads.roads.concat([this.coastline.secondaryRiver]).map(r => polygon_util_1.default.resizeGeometry(r, 2 * this.domainController.zoom, false));
    }
    get mainRoadPolygons() {
        return this.mainRoads.roads.concat(this.coastline.roads).map(r => polygon_util_1.default.resizeGeometry(r, 2.5 * this.domainController.zoom, false));
    }
    get coastlinePolygon() {
        return polygon_util_1.default.resizeGeometry(this.coastline.coastline, 15 * this.domainController.zoom, false);
    }
}
exports["default"] = MainGUI;


/***/ }),

/***/ "./src/ts/ui/road_gui.ts":
/*!*******************************!*\
  !*** ./src/ts/ui/road_gui.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const domain_controller_1 = __importDefault(__webpack_require__(/*! ./domain_controller */ "./src/ts/ui/domain_controller.ts"));
const util_1 = __importDefault(__webpack_require__(/*! ../util */ "./src/ts/util.ts"));
const streamlines_1 = __importDefault(__webpack_require__(/*! ../impl/streamlines */ "./src/ts/impl/streamlines.ts"));
/**
 * Handles creation of roads
 */
class RoadGUI {
    params;
    integrator;
    guiFolder;
    closeTensorFolder;
    folderName;
    redraw;
    _animate;
    streamlines;
    existingStreamlines = [];
    domainController = domain_controller_1.default.getInstance();
    preGenerateCallback = () => { };
    postGenerateCallback = () => { };
    streamlinesInProgress = false;
    constructor(params, integrator, guiFolder, closeTensorFolder, folderName, redraw, _animate = false) {
        this.params = params;
        this.integrator = integrator;
        this.guiFolder = guiFolder;
        this.closeTensorFolder = closeTensorFolder;
        this.folderName = folderName;
        this.redraw = redraw;
        this._animate = _animate;
        this.streamlines = new streamlines_1.default(this.integrator, this.domainController.origin, this.domainController.worldDimensions, this.params);
        // Update path iterations based on window size
        this.setPathIterations();
        window.addEventListener('resize', () => this.setPathIterations());
    }
    initFolder() {
        const roadGUI = {
            Generate: () => this.generateRoads(this._animate).then(() => this.redraw()),
            JoinDangling: () => {
                this.streamlines.joinDanglingStreamlines();
                this.redraw();
            },
        };
        const folder = this.guiFolder.addFolder(this.folderName);
        folder.add(roadGUI, 'Generate');
        // folder.add(roadGUI, 'JoinDangling');
        const paramsFolder = folder.addFolder('Params');
        paramsFolder.add(this.params, 'dsep');
        paramsFolder.add(this.params, 'dtest');
        const devParamsFolder = paramsFolder.addFolder('Dev');
        this.addDevParamsToFolder(this.params, devParamsFolder);
        return this;
    }
    set animate(b) {
        this._animate = b;
    }
    get allStreamlines() {
        return this.streamlines.allStreamlinesSimple;
    }
    get roads() {
        // For drawing not generation, probably fine to leave map
        return this.streamlines.allStreamlinesSimple.map(s => s.map(v => this.domainController.worldToScreen(v.clone())));
    }
    roadsEmpty() {
        return this.streamlines.allStreamlinesSimple.length === 0;
    }
    setExistingStreamlines(existingStreamlines) {
        this.existingStreamlines = existingStreamlines;
    }
    setPreGenerateCallback(callback) {
        this.preGenerateCallback = callback;
    }
    setPostGenerateCallback(callback) {
        this.postGenerateCallback = callback;
    }
    clearStreamlines() {
        this.streamlines.clearStreamlines();
    }
    async generateRoads(animate = false) {
        this.preGenerateCallback();
        this.domainController.zoom = this.domainController.zoom / util_1.default.DRAW_INFLATE_AMOUNT;
        this.streamlines = new streamlines_1.default(this.integrator, this.domainController.origin, this.domainController.worldDimensions, Object.assign({}, this.params));
        this.domainController.zoom = this.domainController.zoom * util_1.default.DRAW_INFLATE_AMOUNT;
        for (const s of this.existingStreamlines) {
            this.streamlines.addExistingStreamlines(s.streamlines);
        }
        this.closeTensorFolder();
        this.redraw();
        return this.streamlines.createAllStreamlines(animate).then(() => this.postGenerateCallback());
    }
    /**
     * Returns true if streamlines changes
     */
    update() {
        return this.streamlines.update();
    }
    addDevParamsToFolder(params, folder) {
        folder.add(params, 'pathIterations');
        folder.add(params, 'seedTries');
        folder.add(params, 'dstep');
        folder.add(params, 'dlookahead');
        folder.add(params, 'dcirclejoin');
        folder.add(params, 'joinangle');
        folder.add(params, 'simplifyTolerance');
        folder.add(params, 'collideEarly');
    }
    /**
     * Sets path iterations so that a road can cover the screen
     */
    setPathIterations() {
        const max = 1.5 * Math.max(window.innerWidth, window.innerHeight);
        this.params.pathIterations = max / this.params.dstep;
        util_1.default.updateGui(this.guiFolder);
    }
}
exports["default"] = RoadGUI;


/***/ }),

/***/ "./src/ts/ui/style.ts":
/*!****************************!*\
  !*** ./src/ts/ui/style.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RoughStyle = exports.DefaultStyle = void 0;
const log = __importStar(__webpack_require__(/*! loglevel */ "./node_modules/loglevel/lib/loglevel.js"));
const canvas_wrapper_1 = __webpack_require__(/*! ./canvas_wrapper */ "./src/ts/ui/canvas_wrapper.ts");
const util_1 = __importDefault(__webpack_require__(/*! ../util */ "./src/ts/util.ts"));
const domain_controller_1 = __importDefault(__webpack_require__(/*! ./domain_controller */ "./src/ts/ui/domain_controller.ts"));
/**
 * Controls how screen-space data is drawn
 */
class Style {
    dragController;
    colourScheme;
    canvas;
    domainController = domain_controller_1.default.getInstance();
    update() { }
    // Polygons
    seaPolygon = [];
    lots = [];
    buildingModels = [];
    parks = [];
    // Polylines
    coastline = [];
    river = [];
    secondaryRiver = [];
    minorRoads = [];
    majorRoads = [];
    mainRoads = [];
    coastlineRoads = [];
    showFrame;
    constructor(dragController, colourScheme) {
        this.dragController = dragController;
        this.colourScheme = colourScheme;
        if (!colourScheme.bgColour)
            log.error("ColourScheme Error - bgColour not defined");
        if (!colourScheme.seaColour)
            log.error("ColourScheme Error - seaColour not defined");
        if (!colourScheme.minorRoadColour)
            log.error("ColourScheme Error - minorRoadColour not defined");
        // Default colourscheme cascade
        if (!colourScheme.bgColourIn)
            colourScheme.bgColourIn = colourScheme.bgColour;
        if (!colourScheme.buildingColour)
            colourScheme.buildingColour = colourScheme.bgColour;
        if (!colourScheme.buildingStroke)
            colourScheme.buildingStroke = colourScheme.bgColour;
        if (!colourScheme.grassColour)
            colourScheme.grassColour = colourScheme.bgColour;
        if (!colourScheme.minorRoadOutline)
            colourScheme.minorRoadOutline = colourScheme.minorRoadColour;
        if (!colourScheme.majorRoadColour)
            colourScheme.majorRoadColour = colourScheme.minorRoadColour;
        if (!colourScheme.majorRoadOutline)
            colourScheme.majorRoadOutline = colourScheme.minorRoadOutline;
        if (!colourScheme.mainRoadColour)
            colourScheme.mainRoadColour = colourScheme.majorRoadColour;
        if (!colourScheme.mainRoadOutline)
            colourScheme.mainRoadOutline = colourScheme.majorRoadOutline;
        if (!colourScheme.outlineSize)
            colourScheme.outlineSize = 1;
        if (!colourScheme.zoomBuildings)
            colourScheme.zoomBuildings = false;
        if (!colourScheme.buildingModels)
            colourScheme.buildingModels = false;
        if (!colourScheme.minorWidth)
            colourScheme.minorWidth = 2;
        if (!colourScheme.majorWidth)
            colourScheme.majorWidth = 4;
        if (!colourScheme.mainWidth)
            colourScheme.mainWidth = 5;
        if (!colourScheme.mainWidth)
            colourScheme.mainWidth = 5;
        if (!colourScheme.frameColour)
            colourScheme.frameColour = colourScheme.bgColour;
        if (!colourScheme.frameTextColour)
            colourScheme.frameTextColour = colourScheme.minorRoadOutline;
        if (!colourScheme.buildingSideColour) {
            const parsedRgb = util_1.default.parseCSSColor(colourScheme.buildingColour).map(v => Math.max(0, v - 40));
            if (parsedRgb) {
                colourScheme.buildingSideColour = `rgb(${parsedRgb[0]},${parsedRgb[1]},${parsedRgb[2]})`;
            }
            else {
                colourScheme.buildingSideColour = colourScheme.buildingColour;
            }
        }
    }
    set zoomBuildings(b) {
        this.colourScheme.zoomBuildings = b;
    }
    set showBuildingModels(b) {
        this.colourScheme.buildingModels = b;
    }
    get showBuildingModels() {
        return this.colourScheme.buildingModels;
    }
    set canvasScale(scale) {
        this.canvas.canvasScale = scale;
    }
    get needsUpdate() {
        return this.canvas.needsUpdate;
    }
    set needsUpdate(n) {
        this.canvas.needsUpdate = n;
    }
}
exports["default"] = Style;
class DefaultStyle extends Style {
    heightmap;
    constructor(c, dragController, colourScheme, heightmap = true) {
        super(dragController, colourScheme);
        this.heightmap = heightmap;
        this.canvas = this.createCanvasWrapper(c, 1, true);
    }
    createCanvasWrapper(c, scale = 1, resizeToWindow = true) {
        return new canvas_wrapper_1.DefaultCanvasWrapper(c, scale, resizeToWindow);
    }
    draw(canvas = this.canvas) {
        let bgColour;
        if (this.colourScheme.zoomBuildings) {
            bgColour = this.domainController.zoom >= 2 ? this.colourScheme.bgColourIn : this.colourScheme.bgColour;
        }
        else {
            bgColour = this.colourScheme.bgColour;
        }
        canvas.setFillStyle(bgColour);
        canvas.clearCanvas();
        // Sea
        canvas.setFillStyle(this.colourScheme.seaColour);
        canvas.setStrokeStyle(this.colourScheme.seaColour);
        canvas.setLineWidth(0.1);
        canvas.drawPolygon(this.seaPolygon);
        // Coastline
        canvas.setStrokeStyle(bgColour);
        canvas.setLineWidth(30 * this.domainController.zoom);
        canvas.drawPolyline(this.coastline);
        // Parks
        canvas.setLineWidth(1);
        canvas.setFillStyle(this.colourScheme.grassColour);
        for (const p of this.parks)
            canvas.drawPolygon(p);
        // River
        canvas.setFillStyle(this.colourScheme.seaColour);
        canvas.setStrokeStyle(this.colourScheme.seaColour);
        canvas.setLineWidth(1);
        canvas.drawPolygon(this.river);
        // Road outline
        canvas.setStrokeStyle(this.colourScheme.minorRoadOutline);
        canvas.setLineWidth(this.colourScheme.outlineSize + this.colourScheme.minorWidth * this.domainController.zoom);
        for (const s of this.minorRoads)
            canvas.drawPolyline(s);
        canvas.setStrokeStyle(this.colourScheme.majorRoadOutline);
        canvas.setLineWidth(this.colourScheme.outlineSize + this.colourScheme.majorWidth * this.domainController.zoom);
        for (const s of this.majorRoads)
            canvas.drawPolyline(s);
        canvas.drawPolyline(this.secondaryRiver);
        canvas.setStrokeStyle(this.colourScheme.mainRoadOutline);
        canvas.setLineWidth(this.colourScheme.outlineSize + this.colourScheme.mainWidth * this.domainController.zoom);
        for (const s of this.mainRoads)
            canvas.drawPolyline(s);
        for (const s of this.coastlineRoads)
            canvas.drawPolyline(s);
        // Road inline
        canvas.setStrokeStyle(this.colourScheme.minorRoadColour);
        canvas.setLineWidth(this.colourScheme.minorWidth * this.domainController.zoom);
        for (const s of this.minorRoads)
            canvas.drawPolyline(s);
        canvas.setStrokeStyle(this.colourScheme.majorRoadColour);
        canvas.setLineWidth(this.colourScheme.majorWidth * this.domainController.zoom);
        for (const s of this.majorRoads)
            canvas.drawPolyline(s);
        canvas.drawPolyline(this.secondaryRiver);
        canvas.setStrokeStyle(this.colourScheme.mainRoadColour);
        canvas.setLineWidth(this.colourScheme.mainWidth * this.domainController.zoom);
        for (const s of this.mainRoads)
            canvas.drawPolyline(s);
        for (const s of this.coastlineRoads)
            canvas.drawPolyline(s);
        canvas.setLineWidth(1);
        if (this.heightmap) {
            for (const b of this.buildingModels) {
                // Colour based on height
                const parsedRgb = util_1.default.parseCSSColor(this.colourScheme.bgColour).map(v => Math.min(255, v + (b.height * 3.5)));
                canvas.setFillStyle(`rgb(${parsedRgb[0]},${parsedRgb[1]},${parsedRgb[2]})`);
                canvas.setStrokeStyle(`rgb(${parsedRgb[0]},${parsedRgb[1]},${parsedRgb[2]})`);
                canvas.drawPolygon(b.lotScreen);
            }
        }
        else {
            // Buildings
            if (!this.colourScheme.zoomBuildings || this.domainController.zoom >= 2) {
                canvas.setFillStyle(this.colourScheme.buildingColour);
                canvas.setStrokeStyle(this.colourScheme.buildingStroke);
                for (const b of this.lots)
                    canvas.drawPolygon(b);
            }
            // Pseudo-3D
            if (this.colourScheme.buildingModels && (!this.colourScheme.zoomBuildings || this.domainController.zoom >= 2.5)) {
                canvas.setFillStyle(this.colourScheme.buildingSideColour);
                canvas.setStrokeStyle(this.colourScheme.buildingSideColour);
                // This is a cheap approximation that often creates visual artefacts
                // Draws building sides, then rooves instead of properly clipping polygons etc.
                for (const b of this.buildingModels) {
                    for (const s of b.sides)
                        canvas.drawPolygon(s);
                }
                canvas.setFillStyle(this.colourScheme.buildingColour);
                canvas.setStrokeStyle(this.colourScheme.buildingStroke);
                for (const b of this.buildingModels)
                    canvas.drawPolygon(b.roof);
            }
        }
        if (this.showFrame) {
            canvas.setFillStyle(this.colourScheme.frameColour);
            canvas.setStrokeStyle(this.colourScheme.frameColour);
            canvas.drawFrame(30, 30, 30, 30);
            // canvas.setFillStyle(this.colourScheme.frameTextColour);
            // canvas.drawCityName();
        }
    }
}
exports.DefaultStyle = DefaultStyle;
class RoughStyle extends Style {
    dragging = false;
    constructor(c, dragController, colourScheme) {
        super(dragController, colourScheme);
        this.canvas = this.createCanvasWrapper(c, 1, true);
    }
    createCanvasWrapper(c, scale = 1, resizeToWindow = true) {
        return new canvas_wrapper_1.RoughCanvasWrapper(c, scale, resizeToWindow);
    }
    update() {
        const dragging = this.dragController.isDragging || this.domainController.isScrolling;
        if (!dragging && this.dragging)
            this.canvas.needsUpdate = true;
        this.dragging = dragging;
    }
    draw(canvas = this.canvas) {
        canvas.setOptions({
            fill: this.colourScheme.bgColour,
            roughness: 1,
            bowing: 1,
            fillStyle: 'solid',
            stroke: "none",
        });
        canvas.clearCanvas();
        // Sea
        canvas.setOptions({
            roughness: 0,
            fillWeight: 1,
            fill: this.colourScheme.seaColour,
            fillStyle: 'solid',
            stroke: "none",
            strokeWidth: 1,
        });
        canvas.drawPolygon(this.seaPolygon);
        canvas.setOptions({
            stroke: this.colourScheme.bgColour,
            strokeWidth: 30,
        });
        canvas.drawPolyline(this.coastline);
        canvas.setOptions({
            roughness: 0,
            fillWeight: 1,
            fill: this.colourScheme.seaColour,
            fillStyle: 'solid',
            stroke: "none",
            strokeWidth: 1,
        });
        canvas.drawPolygon(this.river);
        // Parks
        canvas.setOptions({
            fill: this.colourScheme.grassColour,
        });
        this.parks.forEach(p => canvas.drawPolygon(p));
        // Roads
        canvas.setOptions({
            stroke: this.colourScheme.minorRoadColour,
            strokeWidth: 1,
            fill: 'none',
        });
        this.minorRoads.forEach(s => canvas.drawPolyline(s));
        canvas.setOptions({
            strokeWidth: 2,
            stroke: this.colourScheme.majorRoadColour,
        });
        this.majorRoads.forEach(s => canvas.drawPolyline(s));
        canvas.drawPolyline(this.secondaryRiver);
        canvas.setOptions({
            strokeWidth: 3,
            stroke: this.colourScheme.mainRoadColour,
        });
        this.mainRoads.forEach(s => canvas.drawPolyline(s));
        this.coastlineRoads.forEach(s => canvas.drawPolyline(s));
        // Buildings
        if (!this.dragging) {
            // Lots
            if (!this.colourScheme.zoomBuildings || this.domainController.zoom >= 2) {
                // Lots
                canvas.setOptions({
                    roughness: 1.2,
                    stroke: this.colourScheme.buildingStroke,
                    strokeWidth: 1,
                    fill: '',
                });
                for (const b of this.lots)
                    canvas.drawPolygon(b);
            }
            // Pseudo-3D
            if (this.colourScheme.buildingModels && (!this.colourScheme.zoomBuildings || this.domainController.zoom >= 2.5)) {
                // Pseudo-3D
                canvas.setOptions({
                    roughness: 1.2,
                    stroke: this.colourScheme.buildingStroke,
                    strokeWidth: 1,
                    fill: this.colourScheme.buildingSideColour,
                });
                // TODO this can be hugely improved
                const allSidesDistances = [];
                const camera = this.domainController.getCameraPosition();
                for (const b of this.buildingModels) {
                    for (const s of b.sides) {
                        const averagePoint = s[0].clone().add(s[1]).divideScalar(2);
                        allSidesDistances.push([averagePoint.distanceToSquared(camera), s]);
                    }
                }
                allSidesDistances.sort((a, b) => b[0] - a[0]);
                for (const p of allSidesDistances)
                    canvas.drawPolygon(p[1]);
                canvas.setOptions({
                    roughness: 1.2,
                    stroke: this.colourScheme.buildingStroke,
                    strokeWidth: 1,
                    fill: this.colourScheme.buildingColour,
                });
                for (const b of this.buildingModels)
                    canvas.drawPolygon(b.roof);
            }
        }
    }
}
exports.RoughStyle = RoughStyle;


/***/ }),

/***/ "./src/ts/ui/tensor_field_gui.ts":
/*!***************************************!*\
  !*** ./src/ts/ui/tensor_field_gui.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const domain_controller_1 = __importDefault(__webpack_require__(/*! ./domain_controller */ "./src/ts/ui/domain_controller.ts"));
const tensor_field_1 = __importDefault(__webpack_require__(/*! ../impl/tensor_field */ "./src/ts/impl/tensor_field.ts"));
const util_1 = __importDefault(__webpack_require__(/*! ../util */ "./src/ts/util.ts"));
const vector_1 = __importDefault(__webpack_require__(/*! ../vector */ "./src/ts/vector.ts"));
/**
 * Extension of TensorField that handles interaction with dat.GUI
 */
class TensorFieldGUI extends tensor_field_1.default {
    guiFolder;
    dragController;
    drawCentre;
    TENSOR_LINE_DIAMETER = 20;
    TENSOR_SPAWN_SCALE = 0.7; // How much to shrink worldDimensions to find spawn point
    domainController = domain_controller_1.default.getInstance();
    constructor(guiFolder, dragController, drawCentre, noiseParams) {
        super(noiseParams);
        this.guiFolder = guiFolder;
        this.dragController = dragController;
        this.drawCentre = drawCentre;
        // For custom naming of gui buttons
        const tensorFieldGuiObj = {
            reset: () => this.reset(),
            setRecommended: () => this.setRecommended(),
            addRadial: () => this.addRadialRandom(),
            addGrid: () => this.addGridRandom(),
        };
        this.guiFolder.add(tensorFieldGuiObj, 'reset');
        this.guiFolder.add(this, 'smooth');
        this.guiFolder.add(tensorFieldGuiObj, 'setRecommended');
        this.guiFolder.add(tensorFieldGuiObj, 'addRadial');
        this.guiFolder.add(tensorFieldGuiObj, 'addGrid');
    }
    /**
     * 4 Grids, one radial
     */
    setRecommended() {
        this.reset();
        const size = this.domainController.worldDimensions.multiplyScalar(this.TENSOR_SPAWN_SCALE);
        const newOrigin = this.domainController.worldDimensions
            .multiplyScalar((1 - this.TENSOR_SPAWN_SCALE) / 2)
            .add(this.domainController.origin);
        this.addGridAtLocation(newOrigin);
        this.addGridAtLocation(newOrigin.clone().add(size));
        this.addGridAtLocation(newOrigin.clone().add(new vector_1.default(size.x, 0)));
        this.addGridAtLocation(newOrigin.clone().add(new vector_1.default(0, size.y)));
        this.addRadialRandom();
    }
    addRadialRandom() {
        const width = this.domainController.worldDimensions.x;
        this.addRadial(this.randomLocation(), util_1.default.randomRange(width / 10, width / 5), // Size
        util_1.default.randomRange(50)); // Decay
    }
    addGridRandom() {
        this.addGridAtLocation(this.randomLocation());
    }
    addGridAtLocation(location) {
        const width = this.domainController.worldDimensions.x;
        this.addGrid(location, util_1.default.randomRange(width / 4, width), // Size
        util_1.default.randomRange(50), // Decay
        util_1.default.randomRange(Math.PI / 2));
    }
    /**
     * World-space random location for tensor field spawn
     * Sampled from middle of screen (shrunk rectangle)
     */
    randomLocation() {
        const size = this.domainController.worldDimensions.multiplyScalar(this.TENSOR_SPAWN_SCALE);
        const location = new vector_1.default(Math.random(), Math.random()).multiply(size);
        const newOrigin = this.domainController.worldDimensions.multiplyScalar((1 - this.TENSOR_SPAWN_SCALE) / 2);
        return location.add(this.domainController.origin).add(newOrigin);
    }
    getCrossLocations() {
        // Gets grid of points for vector field vis in world space
        const diameter = this.TENSOR_LINE_DIAMETER / this.domainController.zoom;
        const worldDimensions = this.domainController.worldDimensions;
        const nHor = Math.ceil(worldDimensions.x / diameter) + 1; // Prevent pop-in
        const nVer = Math.ceil(worldDimensions.y / diameter) + 1;
        const originX = diameter * Math.floor(this.domainController.origin.x / diameter);
        const originY = diameter * Math.floor(this.domainController.origin.y / diameter);
        const out = [];
        for (let x = 0; x <= nHor; x++) {
            for (let y = 0; y <= nVer; y++) {
                out.push(new vector_1.default(originX + (x * diameter), originY + (y * diameter)));
            }
        }
        return out;
    }
    getTensorLine(point, tensorV) {
        const transformedPoint = this.domainController.worldToScreen(point.clone());
        const diff = tensorV.multiplyScalar(this.TENSOR_LINE_DIAMETER / 2); // Assumes normalised
        const start = transformedPoint.clone().sub(diff);
        const end = transformedPoint.clone().add(diff);
        return [start, end];
    }
    draw(canvas) {
        // Draw tensor field
        canvas.setFillStyle('black');
        canvas.clearCanvas();
        canvas.setStrokeStyle('white');
        canvas.setLineWidth(1);
        const tensorPoints = this.getCrossLocations();
        tensorPoints.forEach(p => {
            const t = this.samplePoint(p);
            canvas.drawPolyline(this.getTensorLine(p, t.getMajor()));
            canvas.drawPolyline(this.getTensorLine(p, t.getMinor()));
        });
        // Draw centre points of fields
        if (this.drawCentre) {
            canvas.setFillStyle('red');
            this.getBasisFields().forEach(field => field.FIELD_TYPE === 1 /* FIELD_TYPE.Grid */ ?
                canvas.drawSquare(this.domainController.worldToScreen(field.centre), 7) :
                canvas.drawCircle(this.domainController.worldToScreen(field.centre), 7));
        }
    }
    addField(field) {
        super.addField(field);
        const folder = this.guiFolder.addFolder(`${field.FOLDER_NAME}`);
        // Function to deregister from drag controller
        const deregisterDrag = this.dragController.register(() => field.centre, field.dragMoveListener.bind(field), field.dragStartListener.bind(field));
        const removeFieldObj = { remove: () => this.removeFieldGUI(field, deregisterDrag) };
        // Give dat gui removeField button
        folder.add(removeFieldObj, 'remove');
        field.setGui(this.guiFolder, folder);
    }
    removeFieldGUI(field, deregisterDrag) {
        super.removeField(field);
        field.removeFolderFromParent();
        // Deregister from drag controller
        deregisterDrag();
    }
    reset() {
        // TODO kind of hacky - calling remove callbacks from gui object, should store callbacks
        // in addfield and call them (requires making sure they're idempotent)
        for (const fieldFolderName in this.guiFolder.__folders) {
            const fieldFolder = this.guiFolder.__folders[fieldFolderName];
            fieldFolder.__controllers[0].initialValue();
        }
        super.reset();
    }
}
exports["default"] = TensorFieldGUI;


/***/ }),

/***/ "./src/ts/ui/water_gui.ts":
/*!********************************!*\
  !*** ./src/ts/ui/water_gui.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const util_1 = __importDefault(__webpack_require__(/*! ../util */ "./src/ts/util.ts"));
const water_generator_1 = __importDefault(__webpack_require__(/*! ../impl/water_generator */ "./src/ts/impl/water_generator.ts"));
const road_gui_1 = __importDefault(__webpack_require__(/*! ./road_gui */ "./src/ts/ui/road_gui.ts"));
//River and Coastline
class WaterGUI extends road_gui_1.default {
    tensorField;
    params;
    streamlines;
    constructor(tensorField, params, integrator, guiFolder, closeTensorFolder, folderName, redraw) {
        super(params, integrator, guiFolder, closeTensorFolder, folderName, redraw);
        this.tensorField = tensorField;
        this.params = params;
        this.streamlines = new water_generator_1.default(this.integrator, this.domainController.origin, this.domainController.worldDimensions, Object.assign({}, this.params), this.tensorField);
    }
    initFolder() {
        const folder = this.guiFolder.addFolder(this.folderName);
        folder.add({ Generate: () => this.generateRoads() }, 'Generate');
        const coastParamsFolder = folder.addFolder('CoastParams');
        coastParamsFolder.add(this.params.coastNoise, 'noiseEnabled');
        coastParamsFolder.add(this.params.coastNoise, 'noiseSize');
        coastParamsFolder.add(this.params.coastNoise, 'noiseAngle');
        const riverParamsFolder = folder.addFolder('RiverParams');
        riverParamsFolder.add(this.params.riverNoise, 'noiseEnabled');
        riverParamsFolder.add(this.params.riverNoise, 'noiseSize');
        riverParamsFolder.add(this.params.riverNoise, 'noiseAngle');
        folder.add(this.params, 'simplifyTolerance');
        const devParamsFolder = folder.addFolder('Dev');
        this.addDevParamsToFolder(this.params, devParamsFolder);
        return this;
    }
    generateRoads() {
        this.preGenerateCallback();
        this.domainController.zoom = this.domainController.zoom / util_1.default.DRAW_INFLATE_AMOUNT;
        this.streamlines = new water_generator_1.default(this.integrator, this.domainController.origin, this.domainController.worldDimensions, Object.assign({}, this.params), this.tensorField);
        this.domainController.zoom = this.domainController.zoom * util_1.default.DRAW_INFLATE_AMOUNT;
        this.streamlines.createCoast();
        this.streamlines.createRiver();
        this.closeTensorFolder();
        this.redraw();
        this.postGenerateCallback();
        return new Promise(resolve => resolve());
    }
    //Secondary road runs along other side of river
    get streamlinesWithSecondaryRoad() {
        const withSecondary = this.streamlines.allStreamlinesSimple.slice();
        withSecondary.push(this.streamlines.riverSecondaryRoad);
        return withSecondary;
    }
    get river() {
        return this.streamlines.riverPolygon.map(v => this.domainController.worldToScreen(v.clone()));
    }
    get secondaryRiver() {
        return this.streamlines.riverSecondaryRoad.map(v => this.domainController.worldToScreen(v.clone()));
    }
    get coastline() {
        // Use unsimplified noisy streamline as coastline
        // Visual only, no road logic performed using this
        return this.streamlines.coastline.map(v => this.domainController.worldToScreen(v.clone()));
    }
    get seaPolygon() {
        return this.streamlines.seaPolygon.map(v => this.domainController.worldToScreen(v.clone()));
    }
    addDevParamsToFolder(params, folder) {
        folder.add(params, 'dsep');
        folder.add(params, 'dtest');
        folder.add(params, 'pathIterations');
        folder.add(params, 'seedTries');
        folder.add(params, 'dstep');
        folder.add(params, 'dlookahead');
        folder.add(params, 'dcirclejoin');
        folder.add(params, 'joinangle');
    }
}
exports["default"] = WaterGUI;


/***/ }),

/***/ "./src/ts/util.ts":
/*!************************!*\
  !*** ./src/ts/util.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class Util {
    // Must match style.css and index.html
    static CANVAS_ID = 'map-canvas';
    static IMG_CANVAS_ID = 'img-canvas';
    static SVG_ID = 'map-svg';
    // How far to integrate streamlines beyond screen - for making buildings reach the edge
    static DRAW_INFLATE_AMOUNT = 1.2;
    // Refresh dat.GUI values
    static updateGui(gui) {
        if (gui.__controllers) {
            gui.__controllers.forEach(c => c.updateDisplay());
        }
        if (gui.__folders) {
            for (const folderName in gui.__folders) {
                this.updateGui(gui.__folders[folderName]);
            }
        }
    }
    static removeAllFolders(gui) {
        if (gui.__folders) {
            for (const folderName in gui.__folders) {
                gui.removeFolder(gui.__folders[folderName]);
            }
        }
    }
    static randomRange(max, min = 0) {
        return (Math.random() * (max - min)) + min;
    }
    // CSS colour parser:https://github.com/deanm/css-color-parser-js
    //(c) Dean McNamee <dean@gmail.com>, 2012.
    // http://www.w3.org/TR/css3-color/
    static kCSSColorTable = {
        "transparent": [0, 0, 0, 0], "aliceblue": [240, 248, 255, 1],
        "antiquewhite": [250, 235, 215, 1], "aqua": [0, 255, 255, 1],
        "aquamarine": [127, 255, 212, 1], "azure": [240, 255, 255, 1],
        "beige": [245, 245, 220, 1], "bisque": [255, 228, 196, 1],
        "black": [0, 0, 0, 1], "blanchedalmond": [255, 235, 205, 1],
        "blue": [0, 0, 255, 1], "blueviolet": [138, 43, 226, 1],
        "brown": [165, 42, 42, 1], "burlywood": [222, 184, 135, 1],
        "cadetblue": [95, 158, 160, 1], "chartreuse": [127, 255, 0, 1],
        "chocolate": [210, 105, 30, 1], "coral": [255, 127, 80, 1],
        "cornflowerblue": [100, 149, 237, 1], "cornsilk": [255, 248, 220, 1],
        "crimson": [220, 20, 60, 1], "cyan": [0, 255, 255, 1],
        "darkblue": [0, 0, 139, 1], "darkcyan": [0, 139, 139, 1],
        "darkgoldenrod": [184, 134, 11, 1], "darkgray": [169, 169, 169, 1],
        "darkgreen": [0, 100, 0, 1], "darkgrey": [169, 169, 169, 1],
        "darkkhaki": [189, 183, 107, 1], "darkmagenta": [139, 0, 139, 1],
        "darkolivegreen": [85, 107, 47, 1], "darkorange": [255, 140, 0, 1],
        "darkorchid": [153, 50, 204, 1], "darkred": [139, 0, 0, 1],
        "darksalmon": [233, 150, 122, 1], "darkseagreen": [143, 188, 143, 1],
        "darkslateblue": [72, 61, 139, 1], "darkslategray": [47, 79, 79, 1],
        "darkslategrey": [47, 79, 79, 1], "darkturquoise": [0, 206, 209, 1],
        "darkviolet": [148, 0, 211, 1], "deeppink": [255, 20, 147, 1],
        "deepskyblue": [0, 191, 255, 1], "dimgray": [105, 105, 105, 1],
        "dimgrey": [105, 105, 105, 1], "dodgerblue": [30, 144, 255, 1],
        "firebrick": [178, 34, 34, 1], "floralwhite": [255, 250, 240, 1],
        "forestgreen": [34, 139, 34, 1], "fuchsia": [255, 0, 255, 1],
        "gainsboro": [220, 220, 220, 1], "ghostwhite": [248, 248, 255, 1],
        "gold": [255, 215, 0, 1], "goldenrod": [218, 165, 32, 1],
        "gray": [128, 128, 128, 1], "green": [0, 128, 0, 1],
        "greenyellow": [173, 255, 47, 1], "grey": [128, 128, 128, 1],
        "honeydew": [240, 255, 240, 1], "hotpink": [255, 105, 180, 1],
        "indianred": [205, 92, 92, 1], "indigo": [75, 0, 130, 1],
        "ivory": [255, 255, 240, 1], "khaki": [240, 230, 140, 1],
        "lavender": [230, 230, 250, 1], "lavenderblush": [255, 240, 245, 1],
        "lawngreen": [124, 252, 0, 1], "lemonchiffon": [255, 250, 205, 1],
        "lightblue": [173, 216, 230, 1], "lightcoral": [240, 128, 128, 1],
        "lightcyan": [224, 255, 255, 1], "lightgoldenrodyellow": [250, 250, 210, 1],
        "lightgray": [211, 211, 211, 1], "lightgreen": [144, 238, 144, 1],
        "lightgrey": [211, 211, 211, 1], "lightpink": [255, 182, 193, 1],
        "lightsalmon": [255, 160, 122, 1], "lightseagreen": [32, 178, 170, 1],
        "lightskyblue": [135, 206, 250, 1], "lightslategray": [119, 136, 153, 1],
        "lightslategrey": [119, 136, 153, 1], "lightsteelblue": [176, 196, 222, 1],
        "lightyellow": [255, 255, 224, 1], "lime": [0, 255, 0, 1],
        "limegreen": [50, 205, 50, 1], "linen": [250, 240, 230, 1],
        "magenta": [255, 0, 255, 1], "maroon": [128, 0, 0, 1],
        "mediumaquamarine": [102, 205, 170, 1], "mediumblue": [0, 0, 205, 1],
        "mediumorchid": [186, 85, 211, 1], "mediumpurple": [147, 112, 219, 1],
        "mediumseagreen": [60, 179, 113, 1], "mediumslateblue": [123, 104, 238, 1],
        "mediumspringgreen": [0, 250, 154, 1], "mediumturquoise": [72, 209, 204, 1],
        "mediumvioletred": [199, 21, 133, 1], "midnightblue": [25, 25, 112, 1],
        "mintcream": [245, 255, 250, 1], "mistyrose": [255, 228, 225, 1],
        "moccasin": [255, 228, 181, 1], "navajowhite": [255, 222, 173, 1],
        "navy": [0, 0, 128, 1], "oldlace": [253, 245, 230, 1],
        "olive": [128, 128, 0, 1], "olivedrab": [107, 142, 35, 1],
        "orange": [255, 165, 0, 1], "orangered": [255, 69, 0, 1],
        "orchid": [218, 112, 214, 1], "palegoldenrod": [238, 232, 170, 1],
        "palegreen": [152, 251, 152, 1], "paleturquoise": [175, 238, 238, 1],
        "palevioletred": [219, 112, 147, 1], "papayawhip": [255, 239, 213, 1],
        "peachpuff": [255, 218, 185, 1], "peru": [205, 133, 63, 1],
        "pink": [255, 192, 203, 1], "plum": [221, 160, 221, 1],
        "powderblue": [176, 224, 230, 1], "purple": [128, 0, 128, 1],
        "rebeccapurple": [102, 51, 153, 1],
        "red": [255, 0, 0, 1], "rosybrown": [188, 143, 143, 1],
        "royalblue": [65, 105, 225, 1], "saddlebrown": [139, 69, 19, 1],
        "salmon": [250, 128, 114, 1], "sandybrown": [244, 164, 96, 1],
        "seagreen": [46, 139, 87, 1], "seashell": [255, 245, 238, 1],
        "sienna": [160, 82, 45, 1], "silver": [192, 192, 192, 1],
        "skyblue": [135, 206, 235, 1], "slateblue": [106, 90, 205, 1],
        "slategray": [112, 128, 144, 1], "slategrey": [112, 128, 144, 1],
        "snow": [255, 250, 250, 1], "springgreen": [0, 255, 127, 1],
        "steelblue": [70, 130, 180, 1], "tan": [210, 180, 140, 1],
        "teal": [0, 128, 128, 1], "thistle": [216, 191, 216, 1],
        "tomato": [255, 99, 71, 1], "turquoise": [64, 224, 208, 1],
        "violet": [238, 130, 238, 1], "wheat": [245, 222, 179, 1],
        "white": [255, 255, 255, 1], "whitesmoke": [245, 245, 245, 1],
        "yellow": [255, 255, 0, 1], "yellowgreen": [154, 205, 50, 1]
    };
    static clamp_css_byte(i) {
        i = Math.round(i); // Seems to be what Chrome does (vs truncation).
        return i < 0 ? 0 : i > 255 ? 255 : i;
    }
    static clamp_css_float(f) {
        return f < 0 ? 0 : f > 1 ? 1 : f;
    }
    static parse_css_int(str) {
        if (str[str.length - 1] === '%')
            return Util.clamp_css_byte(parseFloat(str) / 100 * 255);
        return Util.clamp_css_byte(parseInt(str));
    }
    static parse_css_float(str) {
        if (str[str.length - 1] === '%')
            return Util.clamp_css_float(parseFloat(str) / 100);
        return Util.clamp_css_float(parseFloat(str));
    }
    static css_hue_to_rgb(m1, m2, h) {
        if (h < 0)
            h += 1;
        else if (h > 1)
            h -= 1;
        if (h * 6 < 1)
            return m1 + (m2 - m1) * h * 6;
        if (h * 2 < 1)
            return m2;
        if (h * 3 < 2)
            return m1 + (m2 - m1) * (2 / 3 - h) * 6;
        return m1;
    }
    static parseCSSColor(css_str) {
        // Remove all whitespace, not compliant, but should just be more accepting.
        var str = css_str.replace(/ /g, '').toLowerCase();
        // Color keywords (and transparent) lookup.
        if (str in Util.kCSSColorTable)
            return Util.kCSSColorTable[str].slice(); // dup.
        // #abc and #abc123 syntax.
        if (str[0] === '#') {
            if (str.length === 4) {
                var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.
                if (!(iv >= 0 && iv <= 0xfff))
                    return null; // Covers NaN.
                return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
                    (iv & 0xf0) | ((iv & 0xf0) >> 4),
                    (iv & 0xf) | ((iv & 0xf) << 4),
                    1];
            }
            else if (str.length === 7) {
                var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.
                if (!(iv >= 0 && iv <= 0xffffff))
                    return null; // Covers NaN.
                return [(iv & 0xff0000) >> 16,
                    (iv & 0xff00) >> 8,
                    iv & 0xff,
                    1];
            }
            return null;
        }
        var op = str.indexOf('('), ep = str.indexOf(')');
        if (op !== -1 && ep + 1 === str.length) {
            var fname = str.substr(0, op);
            var params = str.substr(op + 1, ep - (op + 1)).split(',');
            var alpha = 1; // To allow case fallthrough.
            switch (fname) {
                case 'rgba':
                    if (params.length !== 4)
                        return null;
                    alpha = Util.parse_css_float(params.pop());
                // Fall through.
                case 'rgb':
                    if (params.length !== 3)
                        return null;
                    return [Util.parse_css_int(params[0]),
                        Util.parse_css_int(params[1]),
                        Util.parse_css_int(params[2]),
                        alpha];
                case 'hsla':
                    if (params.length !== 4)
                        return null;
                    alpha = Util.parse_css_float(params.pop());
                // Fall through.
                case 'hsl':
                    if (params.length !== 3)
                        return null;
                    var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360; // 0 .. 1
                    // NOTE(deanm): According to the CSS spec s/l should only be
                    // percentages, but we don't bother and let float or percentage.
                    var s = Util.parse_css_float(params[1]);
                    var l = Util.parse_css_float(params[2]);
                    var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
                    var m1 = l * 2 - m2;
                    return [Util.clamp_css_byte(Util.css_hue_to_rgb(m1, m2, h + 1 / 3) * 255),
                        Util.clamp_css_byte(Util.css_hue_to_rgb(m1, m2, h) * 255),
                        Util.clamp_css_byte(Util.css_hue_to_rgb(m1, m2, h - 1 / 3) * 255),
                        alpha];
                default:
                    return null;
            }
        }
        return null;
    }
}
exports["default"] = Util;


/***/ }),

/***/ "./src/ts/vector.ts":
/*!**************************!*\
  !*** ./src/ts/vector.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const log = __importStar(__webpack_require__(/*! loglevel */ "./node_modules/loglevel/lib/loglevel.js"));
class Vector {
    x;
    y;
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    static zeroVector() {
        return new Vector(0, 0);
    }
    static fromScalar(s) {
        return new Vector(s, s);
    }
    /**
     * -pi to pi
     */
    static angleBetween(v1, v2) {
        // -2pi to 2pi
        let angleBetween = v1.angle() - v2.angle();
        if (angleBetween > Math.PI) {
            angleBetween -= 2 * Math.PI;
        }
        else if (angleBetween <= -Math.PI) {
            angleBetween += 2 * Math.PI;
        }
        return angleBetween;
    }
    /**
     * Tests whether a point lies to the left of a line
     * @param  {Vector} linePoint     Point on the line
     * @param  {Vector} lineDirection
     * @param  {Vector} point
     * @return {Vector}               true if left, false otherwise
     */
    static isLeft(linePoint, lineDirection, point) {
        const perpendicularVector = new Vector(lineDirection.y, -lineDirection.x);
        return point.clone().sub(linePoint).dot(perpendicularVector) < 0;
    }
    add(v) {
        this.x += v.x;
        this.y += v.y;
        return this;
    }
    /**
     * Angle in radians to positive x-axis between -pi and pi
     */
    angle() {
        return Math.atan2(this.y, this.x);
    }
    clone() {
        return new Vector(this.x, this.y);
    }
    copy(v) {
        this.x = v.x;
        this.y = v.y;
        return this;
    }
    cross(v) {
        return this.x * v.y - this.y * v.x;
    }
    distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
        const dx = this.x - v.x;
        const dy = this.y - v.y;
        return dx * dx + dy * dy;
    }
    divide(v) {
        if (v.x === 0 || v.y === 0) {
            log.warn("Division by zero");
            return this;
        }
        this.x /= v.x;
        this.y /= v.y;
        return this;
    }
    divideScalar(s) {
        if (s === 0) {
            log.warn("Division by zero");
            return this;
        }
        return this.multiplyScalar(1 / s);
    }
    dot(v) {
        return this.x * v.x + this.y * v.y;
    }
    equals(v) {
        return ((v.x === this.x) && (v.y === this.y));
    }
    length() {
        return Math.sqrt(this.lengthSq());
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y;
    }
    multiply(v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
    }
    multiplyScalar(s) {
        this.x *= s;
        this.y *= s;
        return this;
    }
    negate() {
        return this.multiplyScalar(-1);
    }
    normalize() {
        const l = this.length();
        if (l === 0) {
            log.warn("Zero Vector");
            return this;
        }
        return this.divideScalar(this.length());
    }
    /**
     * Angle in radians
     */
    rotateAround(center, angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const x = this.x - center.x;
        const y = this.y - center.y;
        this.x = x * cos - y * sin + center.x;
        this.y = x * sin + y * cos + center.y;
        return this;
    }
    set(v) {
        this.x = v.x;
        this.y = v.y;
        return this;
    }
    setX(x) {
        this.x = x;
        return this;
    }
    setY(y) {
        this.y = y;
        return this;
    }
    setLength(length) {
        return this.normalize().multiplyScalar(length);
    }
    sub(v) {
        this.x -= v.x;
        this.y -= v.y;
        return this;
    }
}
exports["default"] = Vector;


/***/ }),

/***/ "./node_modules/d3-quadtree/src/add.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-quadtree/src/add.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addAll: () => (/* binding */ addAll),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  const x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add(this.cover(x, y), x, y, d);
}

function add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {data: d},
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return tree._root = leaf, tree;

  // Find the existing leaf for the new point, or add it.
  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }

  // Is the new point is exactly coincident with the existing point?
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

  // Otherwise, split the leaf node until the old and new point are separated.
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d, i, n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity;

  // Compute the points and their extent.
  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  }

  // If there were no (valid) points, abort.
  if (x0 > x1 || y0 > y1) return this;

  // Expand the tree to cover the new points.
  this.cover(x0, y0).cover(x1, y1);

  // Add the new points.
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/cover.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-quadtree/src/cover.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1;

  // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries dont change due to floating point error!
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  }

  // Otherwise, double repeatedly to cover.
  else {
    var z = x1 - x0 || 1,
        node = this._root,
        parent,
        i;

    while (x0 > x || x >= x1 || y0 > y || y >= y1) {
      i = (y < y0) << 1 | (x < x0);
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0: x1 = x0 + z, y1 = y0 + z; break;
        case 1: x0 = x1 - z, y1 = y0 + z; break;
        case 2: x1 = x0 + z, y0 = y1 - z; break;
        case 3: x0 = x1 - z, y0 = y1 - z; break;
      }
    }

    if (this._root && this._root.length) this._root = node;
  }

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/data.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/data.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do data.push(node.data); while (node = node.next)
  });
  return data;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/extent.js":
/*!************************************************!*\
  !*** ./node_modules/d3-quadtree/src/extent.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length
      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/find.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/find.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "./node_modules/d3-quadtree/src/quad.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;

  if (node) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {

    // Stop searching if this quadrant cant contain a closer node.
    if (!(node = q.node)
        || (x1 = q.x0) > x3
        || (y1 = q.y0) > y3
        || (x2 = q.x1) < x0
        || (y2 = q.y1) < y0) continue;

    // Bisect the current quadrant.
    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;

      quads.push(
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[3], xm, ym, x2, y2),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[2], x1, ym, xm, y2),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[1], xm, y1, x2, ym),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[0], x1, y1, xm, ym)
      );

      // Visit the closest quadrant first.
      if (i = (y >= ym) << 1 | (x >= xm)) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    }

    // Visit this point. (Visiting coincident points isnt necessary!)
    else {
      var dx = x - +this._x.call(null, node.data),
          dy = y - +this._y.call(null, node.data),
          d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x - d, y0 = y - d;
        x3 = x + d, y3 = y + d;
        data = node.data;
      }
    }
  }

  return data;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/index.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-quadtree/src/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   quadtree: () => (/* reexport safe */ _quadtree_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _quadtree_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quadtree.js */ "./node_modules/d3-quadtree/src/quadtree.js");



/***/ }),

/***/ "./node_modules/d3-quadtree/src/quad.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/quad.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/quadtree.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-quadtree/src/quadtree.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quadtree)
/* harmony export */ });
/* harmony import */ var _add_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./add.js */ "./node_modules/d3-quadtree/src/add.js");
/* harmony import */ var _cover_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cover.js */ "./node_modules/d3-quadtree/src/cover.js");
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data.js */ "./node_modules/d3-quadtree/src/data.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./extent.js */ "./node_modules/d3-quadtree/src/extent.js");
/* harmony import */ var _find_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./find.js */ "./node_modules/d3-quadtree/src/find.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-quadtree/src/remove.js");
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./root.js */ "./node_modules/d3-quadtree/src/root.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./size.js */ "./node_modules/d3-quadtree/src/size.js");
/* harmony import */ var _visit_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./visit.js */ "./node_modules/d3-quadtree/src/visit.js");
/* harmony import */ var _visitAfter_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./visitAfter.js */ "./node_modules/d3-quadtree/src/visitAfter.js");
/* harmony import */ var _x_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./x.js */ "./node_modules/d3-quadtree/src/x.js");
/* harmony import */ var _y_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./y.js */ "./node_modules/d3-quadtree/src/y.js");













function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? _x_js__WEBPACK_IMPORTED_MODULE_0__.defaultX : x, y == null ? _y_js__WEBPACK_IMPORTED_MODULE_1__.defaultY : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {data: leaf.data}, next = copy;
  while (leaf = leaf.next) next = next.next = {data: leaf.data};
  return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;

  if (!node) return copy;

  if (!node.length) return copy._root = leaf_copy(node), copy;

  nodes = [{source: node, target: copy._root = new Array(4)}];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
        else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = _add_js__WEBPACK_IMPORTED_MODULE_2__["default"];
treeProto.addAll = _add_js__WEBPACK_IMPORTED_MODULE_2__.addAll;
treeProto.cover = _cover_js__WEBPACK_IMPORTED_MODULE_3__["default"];
treeProto.data = _data_js__WEBPACK_IMPORTED_MODULE_4__["default"];
treeProto.extent = _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"];
treeProto.find = _find_js__WEBPACK_IMPORTED_MODULE_6__["default"];
treeProto.remove = _remove_js__WEBPACK_IMPORTED_MODULE_7__["default"];
treeProto.removeAll = _remove_js__WEBPACK_IMPORTED_MODULE_7__.removeAll;
treeProto.root = _root_js__WEBPACK_IMPORTED_MODULE_8__["default"];
treeProto.size = _size_js__WEBPACK_IMPORTED_MODULE_9__["default"];
treeProto.visit = _visit_js__WEBPACK_IMPORTED_MODULE_10__["default"];
treeProto.visitAfter = _visitAfter_js__WEBPACK_IMPORTED_MODULE_11__["default"];
treeProto.x = _x_js__WEBPACK_IMPORTED_MODULE_0__["default"];
treeProto.y = _y_js__WEBPACK_IMPORTED_MODULE_1__["default"];


/***/ }),

/***/ "./node_modules/d3-quadtree/src/remove.js":
/*!************************************************!*\
  !*** ./node_modules/d3-quadtree/src/remove.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   removeAll: () => (/* binding */ removeAll)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return this;

  // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.
  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
  }

  // Find the point to remove.
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;

  // If there are multiple coincident points, remove just the point.
  if (previous) return (next ? previous.next = next : delete previous.next), this;

  // If this is the root point, remove it.
  if (!parent) return this._root = next, this;

  // Remove this leaf.
  next ? parent[i] = next : delete parent[i];

  // If the parent now contains exactly one leaf, collapse superfluous parents.
  if ((node = parent[0] || parent[1] || parent[2] || parent[3])
      && node === (parent[3] || parent[2] || parent[1] || parent[0])
      && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }

  return this;
}

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/root.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/root.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this._root;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/size.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/size.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do ++size; while (node = node.next)
  });
  return size;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/visit.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-quadtree/src/visit.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "./node_modules/d3-quadtree/src/quad.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, y0, xm, ym));
    }
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/visitAfter.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-quadtree/src/visitAfter.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "./node_modules/d3-quadtree/src/quad.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/x.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-quadtree/src/x.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultX: () => (/* binding */ defaultX)
/* harmony export */ });
function defaultX(d) {
  return d[0];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/y.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-quadtree/src/y.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultY: () => (/* binding */ defaultY)
/* harmony export */ });
function defaultY(d) {
  return d[1];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}


/***/ }),

/***/ "./src/colour_schemes.json":
/*!*********************************!*\
  !*** ./src/colour_schemes.json ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"Default":{"bgColour":"rgb(236,229,219)","buildingStroke":"rgb(40, 40, 40)","seaColour":"rgb(169, 217, 254)","grassColour":"rgb(197, 232, 197)","minorRoadOutline":"rgb(2, 2, 2)","minorRoadColour":"rgb(248, 248, 248)","mainRoadOutline":"rgb(40, 40, 40)","mainRoadColour":"rgb(250, 250, 122)","buildingModels":false},"Apple":{"bgColour":"rgb(248,245,238)","buildingColour":"rgb(239,236,229)","buildingStroke":"rgb(235,234,224)","seaColour":"rgb(184,224,243)","grassColour":"rgb(224,237,205)","minorRoadColour":"rgb(255,255,255)","minorRoadOutline":"rgb(215,208,198)","majorRoadColour":"rgb(252,252,224)","majorRoadOutline":"rgb(240,210,152)","mainRoadColour":"rgb(250,224,98)","mainRoadOutline":"rgb(238,199,132)","zoomBuildings":false,"buildingModels":true,"outlineSize":2},"AppleDark":{"bgColour":"rgb(43,45,47)","buildingColour":"rgb(52,54,56)","buildingStroke":"rgb(47,49,51)","seaColour":"rgb(55,68,100)","grassColour":"rgb(40,56,56)","minorRoadColour":"rgb(65,68,71)","minorRoadOutline":"rgb(43,45,47)","majorRoadColour":"rgb(78,81,84)","majorRoadOutline":"rgb(43,45,47)","mainRoadColour":"rgb(149,108,62)","mainRoadOutline":"rgb(51,51,51)","zoomBuildings":false,"buildingModels":true,"outlineSize":1},"Assassin":{"bgColour":"rgb(77,96,89)","buildingStroke":"rgb(72,91,84)","seaColour":"rgb(36,40,43)","minorRoadColour":"rgb(127,141,137)","mainRoadColour":"rgb(149,161,157)","mainRoadOutline":"rgb(149,161,157)","buildingModels":true},"Drawn":{"bgColour":"rgb(242,236,222)","seaColour":"#dbd2bd","minorRoadColour":"#666666","majorRoadColour":"#444444","mainRoadColour":"#222222","buildingStroke":"#333333","buildingColour":"rgb(242,236,222)","buildingModels":true},"Drawn2":{"bgColour":"white","seaColour":"#c2c5bf","minorRoadColour":"#666666","majorRoadColour":"#444444","mainRoadColour":"#222222","buildingStroke":"#333333","buildingColour":"rgb(242,236,222)","buildingModels":false},"Google":{"bgColour":"rgb(236,236,236)","bgColourIn":"rgb(248,249,250)","buildingColour":"rgb(240,240,240)","buildingSideColour":"rgb(200,200,200)","buildingStroke":"rgb(220,220,220)","seaColour":"rgb(166,213,249)","grassColour":"rgb(198,232,198)","minorRoadColour":"rgb(255,255,255)","minorRoadOutline":"rgb(193,197,214)","mainRoadColour":"rgb(255,242,175)","mainRoadOutline":"rgb(246,207,101)","zoomBuildings":false,"buildingModels":false,"outlineSize":2},"GoogleNoZoom":{"bgColour":"rgb(236,236,236)","bgColourIn":"rgb(248,249,250)","buildingColour":"rgb(240,240,240)","buildingSideColour":"rgb(200,200,200)","buildingStroke":"rgb(220,220,220)","seaColour":"rgb(166,213,249)","grassColour":"rgb(198,232,198)","minorRoadColour":"rgb(255,255,255)","minorRoadOutline":"rgb(193,197,214)","mainRoadColour":"rgb(255,242,175)","mainRoadOutline":"rgb(246,207,101)","zoomBuildings":false,"buildingModels":true,"outlineSize":2},"Heightmap":{"bgColour":"rgb(30,30,30)","seaColour":"rgb(20,20,20)","minorRoadColour":"rgb(28,28,28)","zoomBuildings":false,"buildingModels":true},"Paper":{"bgColour":"white","seaColour":"rgb(233,240,255)","grassColour":"rgb(197,232,197)","minorRoadColour":"white","minorRoadOutline":"rgb(222,223,227)","outlineSize":2,"buildingModels":true},"SubtleGrey":{"bgColour":"rgb(247,247,247)","buildingColour":"rgb(251,251,251)","buildingStroke":"rgb(243,243,243)","seaColour":"rgb(162,162,157)","grassColour":"rgb(239,239,239)","minorRoadOutline":"white","minorRoadColour":"rgb(212,212,212)","mainRoadOutline":"rgb(208,208,208)","mainRoadColour":"rgb(208,208,208)","frameTextColour":"rgb(162,162,157)","buildingModels":true},"Wy":{"bgColour":"white","seaColour":"rgb(200,215,212)","buildingStroke":"rgb(238,238,238)","minorRoadOutline":"rgb(190,190,190)","minorRoadColour":"rgb(238,238,238)","buildingModels":true}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLElBQUk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFFBQVE7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixzREFBc0Q7O0FBRXREOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFFBQVE7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0EsaUVBQWlFOztBQUVqRTtBQUNBLHVFQUF1RTs7QUFFdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvSkFBb0o7QUFDcEosSUFBSTs7O0FBR0o7QUFDQSx1REFBdUQ7O0FBRXZELHlaQUF5Wjs7QUFFelo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0Esd0RBQXdEOztBQUV4RDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDRDQUE0Qzs7QUFFbEQsNk1BQTZNOztBQUU3TTtBQUNBLCtEQUErRDtBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBIQUEwSDtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGtEQUFrRCxpQkFBaUIscUJBQXFCLGFBQWE7QUFDckc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGlCQUFpQjtBQUNqRTs7QUFFQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7O0FBRTNEO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrQ0FBa0M7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEMscUVBQXFFOztBQUVyRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQSxxQ0FBcUM7O0FBRXJDLGdEQUFnRDs7QUFFaEQ7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFEQUFxRDs7QUFFckQ7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNULElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUssUUFBUTs7QUFFYjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxRQUFRO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQSx1QkFBdUI7O0FBRXZCLDhDQUE4Qzs7QUFFOUM7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxxREFBcUQ7O0FBRXJEO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBLHVEQUF1RDs7QUFFdkQ7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQSxVQUFVOzs7QUFHVjtBQUNBOztBQUVBLHdDQUF3Qzs7O0FBR3hDO0FBQ0EsMkJBQTJCO0FBQzNCLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7OztBQUdSO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQSxvREFBb0Q7O0FBRXBEO0FBQ0EsZ0VBQWdFOztBQUVoRSw4QkFBOEI7O0FBRTlCLHlDQUF5QyxNQUFNO0FBQy9DO0FBQ0E7O0FBRUEsa0NBQWtDOztBQUVsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEIsbUJBQW1COztBQUVuQjs7QUFFQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0VBQXNFO0FBQ3RFOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUMsSUFBSTtBQUNMOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEIsc0NBQXNDOztBQUV0QztBQUNBLDhFQUE4RTs7QUFFOUUsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0EsdUNBQXVDLHNDQUFzQztBQUM3RTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUMsUUFBUTtBQUN6Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQSxvREFBb0Q7O0FBRXBELDhCQUE4QixRQUFRO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjs7O0FBR0EsMERBQTBEOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLHFDQUFxQyxTQUFTOztBQUUzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRix1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7O0FBRXZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7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SDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLEVBQUU7O0FB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QTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTs7O0FBR04saUNBQWlDO0FBQ2pDOztBQUVBLCtEQUErRDs7QUFFL0QsMkRBQTJEOztBQUUzRDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxD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TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOzs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQVFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0tBQW9LLGdDQUFnQztBQUNwTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZ0ZBQWdGLHVFQUF1RTtBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0NB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QUUsQ0FBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxDQUFDLENBQUMsRUFBRSxVQUFVLEVBQUUsQ0FBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxDQUFDLENBQUM7UUFDOUQsU0FBUyxFQUFFLENBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDO1FBQy9DLFVBQVUsRUFBRSxDQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQyxFQUFFLFVBQVUsRUFBRSxDQUFDLENBQUMsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQztRQUNsRCxlQUFlLEVBQUUsQ0FBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBRSxVQUFVLEVBQUUsQ0FBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxDQUFDLENBQUM7UUFDNUQsV0FBVyxFQUFFLENBQUMsQ0FBQyxFQUFDLEdBQUcsRUFBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUUsVUFBVSxFQUFFLENBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDO1FBQ3JELFdBQVcsRUFBRSxDQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQyxFQUFFLGFBQWEsRUFBRSxDQUFDLEdBQUcsRUFBQyxDQUFDLEVBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQztRQUMxRCxnQkFBZ0IsRUFBRSxDQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFFLFlBQVksRUFBRSxDQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQztRQUM1RCxZQUFZLEVBQUUsQ0FBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLEdBQUcsRUFBQyxDQUFDLENBQUMsRUFBRSxTQUFTLEVBQUUsQ0FBQyxHQUFHLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUM7UUFDcEQsWUFBWSxFQUFFLENBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDLEVBQUUsY0FBYyxFQUFFLENBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDO1FBQzlELGVBQWUsRUFBRSxDQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQyxFQUFFLGVBQWUsRUFBRSxDQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQztRQUM3RCxlQUFlLEVBQUUsQ0FBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBRSxlQUFlLEVBQUUsQ0FBQyxDQUFDLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxDQUFDLENBQUM7UUFDN0QsWUFBWSxFQUFFLENBQUMsR0FBRyxFQUFDLENBQUMsRUFBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDLEVBQUUsVUFBVSxFQUFFLENBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDO1FBQ3ZELGFBQWEsRUFBRSxDQUFDLENBQUMsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQyxFQUFFLFNBQVMsRUFBRSxDQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQztRQUN4RCxTQUFTLEVBQUUsQ0FBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxDQUFDLENBQUMsRUFBRSxZQUFZLEVBQUUsQ0FBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxDQUFDLENBQUM7UUFDeEQsV0FBVyxFQUFFLENBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUUsYUFBYSxFQUFFLENBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDO1FBQzFELGFBQWEsRUFBRSxDQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFFLFNBQVMsRUFBRSxDQUFDLEdBQUcsRUFBQyxDQUFDLEVBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQztRQUN0RCxXQUFXLEVBQUUsQ0FBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxDQUFDLENBQUMsRUFBRSxZQUFZLEVBQUUsQ0FBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxDQUFDLENBQUM7UUFDM0QsTUFBTSxFQUFFLENBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUUsV0FBVyxFQUFFLENBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDO1FBQ2xELE1BQU0sRUFBRSxDQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUMsRUFBQyxHQUFHLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQztRQUM3QyxhQUFhLEVBQUUsQ0FBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBRSxNQUFNLEVBQUUsQ0FBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxDQUFDLENBQUM7UUFDdEQsVUFBVSxFQUFFLENBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxFQUFFLENBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDO1FBQ3ZELFdBQVcsRUFBRSxDQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxDQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQztRQUNsRCxPQUFPLEVBQUUsQ0FBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxDQUFDLENBQUMsRUFBRSxPQUFPLEVBQUUsQ0FBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxDQUFDLENBQUM7UUFDbEQsVUFBVSxFQUFFLENBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDLEVBQUUsZUFBZSxFQUFFLENBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDO1FBQzdELFdBQVcsRUFBRSxDQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFFLGNBQWMsRUFBRSxDQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQztRQUMzRCxXQUFXLEVBQUUsQ0FBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxDQUFDLENBQUMsRUFBRSxZQUFZLEVBQUUsQ0FBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxDQUFDLENBQUM7UUFDM0QsV0FBVyxFQUFFLENBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDLEVBQUUsc0JBQXNCLEVBQUUsQ0FBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxDQUFDLENBQUM7UUFDckUsV0FBVyxFQUFFLENBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDLEVBQUUsWUFBWSxFQUFFLENBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDO1FBQzNELFdBQVcsRUFBRSxDQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQyxFQUFFLFdBQVcsRUFBRSxDQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQztRQUMxRCxhQUFhLEVBQUUsQ0FBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxDQUFDLENBQUMsRUFBRSxlQUFlLEVBQUUsQ0FBQyxFQUFFLEVBQUMsR0FBRyxFQUFD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QUFXLEVBQUUsQ0FBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUM7UUFDbEQsUUFBUSxFQUFFLENBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDLEVBQUUsZUFBZSxFQUFFLENBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDO1FBQzNELFdBQVcsRUFBRSxDQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQyxFQUFFLGVBQWUsRUFBRSxDQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQztRQUM5RCxlQUFlLEVBQUUsQ0FBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxDQUFDLENBQUMsRUFBRSxZQUFZLEVBQUUsQ0FBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxDQUFDLENBQUM7UUFDL0QsV0FBVyxFQUFFLENBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxFQUFFLENBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDO1FBQ3BELE1BQU0sRUFBRSxDQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sRUFBRSxDQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQztRQUNoRCxZQUFZLEVBQUUsQ0FBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxDQUFDLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxHQUFHLEVBQUMsQ0FBQyxFQUFDLEdBQUcsRUFBQyxDQUFDLENBQUM7UUFDdEQsZUFBZSxFQUFFLENBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDO1FBQy9CLEtBQUssRUFBRSxDQUFDLEdBQUcsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFFLFdBQVcsRUFBRSxDQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQztRQUNoRCxXQUFXLEVBQUUsQ0FBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxDQUFDLENBQUMsRUFBRSxhQUFhLEVBQUUsQ0FBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUM7UUFDekQsUUFBUSxFQUFFLENBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDLEVBQUUsWUFBWSxFQUFFLENBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDO1FBQ3ZELFVBQVUsRUFBRSxDQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFFLFVBQVUsRUFBRSxDQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQztRQUN0RCxRQUFRLEVBQUUsQ0FBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxDQUFDLENBQUM7UUFDbEQsU0FBUyxFQUFFLENBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDLEVBQUUsV0FBVyxFQUFFLENBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDO1FBQ3ZELFdBQVcsRUFBRSxDQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQyxFQUFFLFdBQVcsRUFBRSxDQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQztRQUMxRCxNQUFNLEVBQUUsQ0FBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxDQUFDLENBQUMsRUFBRSxhQUFhLEVBQUUsQ0FBQyxDQUFDLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxD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QUk7QUFDOUMsMENBQTBDLGdEQUFJO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEJPO0FBQ1A7QUFDQTs7QUFFQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ05PO0FBQ1A7QUFDQTs7QUFFQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7VUNOQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDekJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EseUNBQXlDLHdDQUF3QztXQUNqRjtXQUNBO1dBQ0E7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSxHQUFHO1dBQ0g7V0FDQTtXQUNBLENBQUM7Ozs7O1dDUEQ7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7OztXQ05BO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7Ozs7O1VFSkE7VUFDQTtVQUNBO1VBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXR5Z2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9zdmcuZXNtLmpzIiwid2VicGFjazovL2NpdHlnZW5lcmF0b3IvLi9ub2RlX21vZHVsZXMvZGF0Lmd1aS9idWlsZC9kYXQuZ3VpLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9jaXR5Z2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL2ZpbGUtc2F2ZXIvZGlzdC9GaWxlU2F2ZXIubWluLmpzIiwid2VicGFjazovL2NpdHlnZW5lcmF0b3IvLi9ub2RlX21vZHVsZXMvaW50ZXJhY3Rqcy9kaXN0L2ludGVyYWN0Lm1pbi5qcyIsIndlYnBhY2s6Ly9jaXR5Z2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL2lzZWN0L2J1aWxkL2lzZWN0Lm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9jaXR5Z2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL2xvZ2xldmVsL2xpYi9sb2dsZXZlbC5qcyIsIndlYnBhY2s6Ly9jaXR5Z2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL3BvbHlrL2Rpc3QvcG9seWsuanMiLCJ3ZWJwYWNrOi8vY2l0eWdlbmVyYXRvci8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2J1bmRsZWQvcm91Z2guY2pzLmpzIiwid2VicGFjazovL2NpdHlnZW5lcmF0b3IvLi9ub2RlX21vZHVsZXMvc2ltcGxleC1ub2lzZS9kaXN0L2Nqcy9zaW1wbGV4LW5vaXNlLmpzIiwid2VicGFjazovL2NpdHlnZW5lcmF0b3IvLi9ub2RlX21vZHVsZXMvc2ltcGxpZnktanMvc2ltcGxpZnkuanMiLCJ3ZWJwYWNrOi8vY2l0eWdlbmVyYXRvci8uL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly9jaXR5Z2VuZXJhdG9yLy4vc3JjL3RzL2ltcGwvYmFzaXNfZmllbGQudHMiLCJ3ZWJwYWNrOi8vY2l0eWdlbmVyYXRvci8uL3NyYy90cy9pbXBsL2dyYXBoLnRzIiwid2VicGFjazovL2NpdHlnZW5lcmF0b3IvLi9zcmMvdHMvaW1wbC9ncmlkX3N0b3JhZ2UudHMiLCJ3ZWJwYWNrOi8vY2l0eWdlbmVyYXRvci8uL3NyYy90cy9pbXBsL2ludGVncmF0b3IudHMiLCJ3ZWJwYWNrOi8vY2l0eWdlbmVyYXRvci8uL3NyYy90cy9pbXBsL3BvbHlnb25fZmluZGVyLnRzIiwid2VicGFjazovL2NpdHlnZW5lcmF0b3IvLi9zcmMvdHMvaW1wbC9wb2x5Z29uX3V0aWwudHMiLCJ3ZWJwYWNrOi8vY2l0eWdlbmVyYXRvci8uL3NyYy90cy9pbXBsL3N0cmVhbWxpbmVzLnRzIiwid2VicGFjazovL2NpdHlnZW5lcmF0b3IvLi9zcmMvdHMvaW1wbC90ZW5zb3IudHMiLCJ3ZWJwYWNrOi8vY2l0eWdlbmVyYXRvci8uL3NyYy90cy9pbXBsL3RlbnNvcl9maWVsZC50cyIsIndlYnBhY2s6Ly9jaXR5Z2VuZXJhdG9yLy4vc3JjL3RzL2ltcGwvd2F0ZXJfZ2VuZXJhdG9yLnRzIiwid2VicGFjazovL2NpdHlnZW5lcmF0b3IvLi9zcmMvdHMvdWkvYnVpbGRpbmdzLnRzIiwid2VicGFjazovL2NpdHlnZW5lcmF0b3IvLi9zcmMvdHMvdWkvY2FudmFzX3dyYXBwZXIudHMiLCJ3ZWJwYWNrOi8vY2l0eWdlbmVyYXRvci8uL3NyYy90cy91aS9kb21haW5fY29udHJvbGxlci50cyIsIndlYnBhY2s6Ly9jaXR5Z2VuZXJhdG9yLy4vc3JjL3RzL3VpL2RyYWdfY29udHJvbGxlci50cyIsIndlYnBhY2s6Ly9jaXR5Z2VuZXJhdG9yLy4vc3JjL3RzL3VpL21haW5fZ3VpLnRzIiwid2VicGFjazovL2NpdHlnZW5lcmF0b3IvLi9zcmMvdHMvdWkvcm9hZF9ndWkudHMiLCJ3ZWJwYWNrOi8vY2l0eWdlbmVyYXRvci8uL3NyYy90cy91aS9zdHlsZS50cyIsIndlYnBhY2s6Ly9jaXR5Z2VuZXJhdG9yLy4vc3JjL3RzL3VpL3RlbnNvcl9maWVsZF9ndWkudHMiLCJ3ZWJwYWNrOi8vY2l0eWdlbmVyYXRvci8uL3NyYy90cy91aS93YXRlcl9ndWkudHMiLCJ3ZWJwYWNrOi8vY2l0eWdlbmVyYXRvci8uL3NyYy90cy91dGlsLnRzIiwid2VicGFjazovL2NpdHlnZW5lcmF0b3IvLi9zcmMvdHMvdmVjdG9yLnRzIiwid2VicGFjazovL2NpdHlnZW5lcmF0b3IvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL2FkZC5qcyIsIndlYnBhY2s6Ly9jaXR5Z2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy9jb3Zlci5qcyIsIndlYnBhY2s6Ly9jaXR5Z2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy9kYXRhLmpzIiwid2VicGFjazovL2NpdHlnZW5lcmF0b3IvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL2V4dGVudC5qcyIsIndlYnBhY2s6Ly9jaXR5Z2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy9maW5kLmpzIiwid2VicGFjazovL2NpdHlnZW5lcmF0b3IvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL2luZGV4LmpzIiwid2VicGFjazovL2NpdHlnZW5lcmF0b3IvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL3F1YWQuanMiLCJ3ZWJwYWNrOi8vY2l0eWdlbmVyYXRvci8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvcXVhZHRyZWUuanMiLCJ3ZWJwYWNrOi8vY2l0eWdlbmVyYXRvci8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvcmVtb3ZlLmpzIiwid2VicGFjazovL2NpdHlnZW5lcmF0b3IvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL3Jvb3QuanMiLCJ3ZWJwYWNrOi8vY2l0eWdlbmVyYXRvci8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvc2l6ZS5qcyIsIndlYnBhY2s6Ly9jaXR5Z2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy92aXNpdC5qcyIsIndlYnBhY2s6Ly9jaXR5Z2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy92aXNpdEFmdGVyLmpzIiwid2VicGFjazovL2NpdHlnZW5lcmF0b3IvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL3guanMiLCJ3ZWJwYWNrOi8vY2l0eWdlbmVyYXRvci8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMveS5qcyIsIndlYnBhY2s6Ly9jaXR5Z2VuZXJhdG9yL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2NpdHlnZW5lcmF0b3Ivd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL2NpdHlnZW5lcmF0b3Ivd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9jaXR5Z2VuZXJhdG9yL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vY2l0eWdlbmVyYXRvci93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL2NpdHlnZW5lcmF0b3Ivd2VicGFjay9ydW50aW1lL25vZGUgbW9kdWxlIGRlY29yYXRvciIsIndlYnBhY2s6Ly9jaXR5Z2VuZXJhdG9yL3dlYnBhY2svYmVmb3JlLXN0YXJ0dXAiLCJ3ZWJwYWNrOi8vY2l0eWdlbmVyYXRvci93ZWJwYWNrL3N0YXJ0dXAiLCJ3ZWJwYWNrOi8vY2l0eWdlbmVyYXRvci93ZWJwYWNrL2FmdGVyLXN0YXJ0dXAiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4qIEBzdmdkb3Rqcy9zdmcuanMgLSBBIGxpZ2h0d2VpZ2h0IGxpYnJhcnkgZm9yIG1hbmlwdWxhdGluZyBhbmQgYW5pbWF0aW5nIFNWRy5cbiogQHZlcnNpb24gMy4yLjBcbiogaHR0cHM6Ly9zdmdqcy5kZXYvXG4qXG4qIEBjb3B5cmlnaHQgV291dCBGaWVyZW5zIDx3b3V0QG1pY2std291dC5jb20+XG4qIEBsaWNlbnNlIE1JVFxuKlxuKiBCVUlMVDogTW9uIEp1biAxMiAyMDIzIDEwOjM0OjUxIEdNVCswMjAwIChDZW50cmFsIEV1cm9wZWFuIFN1bW1lciBUaW1lKVxuKi87XG5jb25zdCBtZXRob2RzJDEgPSB7fTtcbmNvbnN0IG5hbWVzID0gW107XG5mdW5jdGlvbiByZWdpc3Rlck1ldGhvZHMobmFtZSwgbSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShuYW1lKSkge1xuICAgIGZvciAoY29uc3QgX25hbWUgb2YgbmFtZSkge1xuICAgICAgcmVnaXN0ZXJNZXRob2RzKF9uYW1lLCBtKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yIChjb25zdCBfbmFtZSBpbiBuYW1lKSB7XG4gICAgICByZWdpc3Rlck1ldGhvZHMoX25hbWUsIG5hbWVbX25hbWVdKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBhZGRNZXRob2ROYW1lcyhPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhtKSk7XG4gIG1ldGhvZHMkMVtuYW1lXSA9IE9iamVjdC5hc3NpZ24obWV0aG9kcyQxW25hbWVdIHx8IHt9LCBtKTtcbn1cbmZ1bmN0aW9uIGdldE1ldGhvZHNGb3IobmFtZSkge1xuICByZXR1cm4gbWV0aG9kcyQxW25hbWVdIHx8IHt9O1xufVxuZnVuY3Rpb24gZ2V0TWV0aG9kTmFtZXMoKSB7XG4gIHJldHVybiBbLi4ubmV3IFNldChuYW1lcyldO1xufVxuZnVuY3Rpb24gYWRkTWV0aG9kTmFtZXMoX25hbWVzKSB7XG4gIG5hbWVzLnB1c2goLi4uX25hbWVzKTtcbn1cblxuLy8gTWFwIGZ1bmN0aW9uXG5mdW5jdGlvbiBtYXAoYXJyYXksIGJsb2NrKSB7XG4gIGxldCBpO1xuICBjb25zdCBpbCA9IGFycmF5Lmxlbmd0aDtcbiAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IGlsOyBpKyspIHtcbiAgICByZXN1bHQucHVzaChibG9jayhhcnJheVtpXSkpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn0gLy8gRmlsdGVyIGZ1bmN0aW9uXG5cbmZ1bmN0aW9uIGZpbHRlcihhcnJheSwgYmxvY2spIHtcbiAgbGV0IGk7XG4gIGNvbnN0IGlsID0gYXJyYXkubGVuZ3RoO1xuICBjb25zdCByZXN1bHQgPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgaWw7IGkrKykge1xuICAgIGlmIChibG9jayhhcnJheVtpXSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufSAvLyBEZWdyZWVzIHRvIHJhZGlhbnNcblxuZnVuY3Rpb24gcmFkaWFucyhkKSB7XG4gIHJldHVybiBkICUgMzYwICogTWF0aC5QSSAvIDE4MDtcbn0gLy8gUmFkaWFucyB0byBkZWdyZWVzXG5cbmZ1bmN0aW9uIGRlZ3JlZXMocikge1xuICByZXR1cm4gciAqIDE4MCAvIE1hdGguUEkgJSAzNjA7XG59IC8vIENvbnZlcnQgZGFzaC1zZXBhcmF0ZWQtc3RyaW5nIHRvIGNhbWVsQ2FzZVxuXG5mdW5jdGlvbiBjYW1lbENhc2Uocykge1xuICByZXR1cm4gcy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0oLikvZywgZnVuY3Rpb24gKG0sIGcpIHtcbiAgICByZXR1cm4gZy50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn0gLy8gQ29udmVydCBjYW1lbCBjYXNlZCBzdHJpbmcgdG8gZGFzaCBzZXBhcmF0ZWRcblxuZnVuY3Rpb24gdW5DYW1lbENhc2Uocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC8oW0EtWl0pL2csIGZ1bmN0aW9uIChtLCBnKSB7XG4gICAgcmV0dXJuICctJyArIGcudG9Mb3dlckNhc2UoKTtcbiAgfSk7XG59IC8vIENhcGl0YWxpemUgZmlyc3QgbGV0dGVyIG9mIGEgc3RyaW5nXG5cbmZ1bmN0aW9uIGNhcGl0YWxpemUocykge1xuICByZXR1cm4gcy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHMuc2xpY2UoMSk7XG59IC8vIENhbGN1bGF0ZSBwcm9wb3J0aW9uYWwgd2lkdGggYW5kIGhlaWdodCB2YWx1ZXMgd2hlbiBuZWNlc3NhcnlcblxuZnVuY3Rpb24gcHJvcG9ydGlvbmFsU2l6ZShlbGVtZW50LCB3aWR0aCwgaGVpZ2h0LCBib3gpIHtcbiAgaWYgKHdpZHRoID09IG51bGwgfHwgaGVpZ2h0ID09IG51bGwpIHtcbiAgICBib3ggPSBib3ggfHwgZWxlbWVudC5iYm94KCk7XG5cbiAgICBpZiAod2lkdGggPT0gbnVsbCkge1xuICAgICAgd2lkdGggPSBib3gud2lkdGggLyBib3guaGVpZ2h0ICogaGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAoaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgIGhlaWdodCA9IGJveC5oZWlnaHQgLyBib3gud2lkdGggKiB3aWR0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFkZHMgc3VwcG9ydCBmb3Igc3RyaW5nIG9yaWdpbnMuXG4gKiBJdCBzZWFyY2hlcyBmb3IgYW4gb3JpZ2luIGluIG8ub3JpZ2luIG8ub3ggYW5kIG8ub3JpZ2luWC5cbiAqIFRoaXMgd2F5LCBvcmlnaW46IHt4OiAnY2VudGVyJywgeTogNTB9IGNhbiBiZSBwYXNzZWQgYXMgd2VsbCBhcyBveDogJ2NlbnRlcicsIG95OiA1MFxuKiovXG5cbmZ1bmN0aW9uIGdldE9yaWdpbihvLCBlbGVtZW50KSB7XG4gIGNvbnN0IG9yaWdpbiA9IG8ub3JpZ2luOyAvLyBGaXJzdCBjaGVjayBpZiBvcmlnaW4gaXMgaW4gb3ggb3Igb3JpZ2luWFxuXG4gIGxldCBveCA9IG8ub3ggIT0gbnVsbCA/IG8ub3ggOiBvLm9yaWdpblggIT0gbnVsbCA/IG8ub3JpZ2luWCA6ICdjZW50ZXInO1xuICBsZXQgb3kgPSBvLm95ICE9IG51bGwgPyBvLm95IDogby5vcmlnaW5ZICE9IG51bGwgPyBvLm9yaWdpblkgOiAnY2VudGVyJzsgLy8gVGhlbiBjaGVjayBpZiBvcmlnaW4gd2FzIHVzZWQgYW5kIG92ZXJ3cml0ZSBpbiB0aGF0IGNhc2VcblxuICBpZiAob3JpZ2luICE9IG51bGwpIHtcbiAgICBbb3gsIG95XSA9IEFycmF5LmlzQXJyYXkob3JpZ2luKSA/IG9yaWdpbiA6IHR5cGVvZiBvcmlnaW4gPT09ICdvYmplY3QnID8gW29yaWdpbi54LCBvcmlnaW4ueV0gOiBbb3JpZ2luLCBvcmlnaW5dO1xuICB9IC8vIE1ha2Ugc3VyZSB0byBvbmx5IGNhbGwgYmJveCB3aGVuIGFjdHVhbGx5IG5lZWRlZFxuXG5cbiAgY29uc3QgY29uZFggPSB0eXBlb2Ygb3ggPT09ICdzdHJpbmcnO1xuICBjb25zdCBjb25kWSA9IHR5cGVvZiBveSA9PT0gJ3N0cmluZyc7XG5cbiAgaWYgKGNvbmRYIHx8IGNvbmRZKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGVpZ2h0LFxuICAgICAgd2lkdGgsXG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSBlbGVtZW50LmJib3goKTsgLy8gQW5kIG9ubHkgb3ZlcndyaXRlIGlmIHN0cmluZyB3YXMgcGFzc2VkIGZvciB0aGlzIHNwZWNpZmljIGF4aXNcblxuICAgIGlmIChjb25kWCkge1xuICAgICAgb3ggPSBveC5pbmNsdWRlcygnbGVmdCcpID8geCA6IG94LmluY2x1ZGVzKCdyaWdodCcpID8geCArIHdpZHRoIDogeCArIHdpZHRoIC8gMjtcbiAgICB9XG5cbiAgICBpZiAoY29uZFkpIHtcbiAgICAgIG95ID0gb3kuaW5jbHVkZXMoJ3RvcCcpID8geSA6IG95LmluY2x1ZGVzKCdib3R0b20nKSA/IHkgKyBoZWlnaHQgOiB5ICsgaGVpZ2h0IC8gMjtcbiAgICB9XG4gIH0gLy8gUmV0dXJuIHRoZSBvcmlnaW4gYXMgaXQgaXMgaWYgaXQgd2Fzbid0IGEgc3RyaW5nXG5cblxuICByZXR1cm4gW294LCBveV07XG59XG5cbnZhciB1dGlscyA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBtYXA6IG1hcCxcbiAgZmlsdGVyOiBmaWx0ZXIsXG4gIHJhZGlhbnM6IHJhZGlhbnMsXG4gIGRlZ3JlZXM6IGRlZ3JlZXMsXG4gIGNhbWVsQ2FzZTogY2FtZWxDYXNlLFxuICB1bkNhbWVsQ2FzZTogdW5DYW1lbENhc2UsXG4gIGNhcGl0YWxpemU6IGNhcGl0YWxpemUsXG4gIHByb3BvcnRpb25hbFNpemU6IHByb3BvcnRpb25hbFNpemUsXG4gIGdldE9yaWdpbjogZ2V0T3JpZ2luXG59O1xuXG4vLyBEZWZhdWx0IG5hbWVzcGFjZXNcbmNvbnN0IHN2ZyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG5jb25zdCBodG1sID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xuY29uc3QgeG1sbnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nO1xuY29uc3QgeGxpbmsgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5jb25zdCBzdmdqcyA9ICdodHRwOi8vc3ZnanMuZGV2L3N2Z2pzJztcblxudmFyIG5hbWVzcGFjZXMgPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgc3ZnOiBzdmcsXG4gIGh0bWw6IGh0bWwsXG4gIHhtbG5zOiB4bWxucyxcbiAgeGxpbms6IHhsaW5rLFxuICBzdmdqczogc3ZnanNcbn07XG5cbmNvbnN0IGdsb2JhbHMgPSB7XG4gIHdpbmRvdzogdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93LFxuICBkb2N1bWVudDogdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBkb2N1bWVudFxufTtcbmZ1bmN0aW9uIHJlZ2lzdGVyV2luZG93KHdpbiA9IG51bGwsIGRvYyA9IG51bGwpIHtcbiAgZ2xvYmFscy53aW5kb3cgPSB3aW47XG4gIGdsb2JhbHMuZG9jdW1lbnQgPSBkb2M7XG59XG5jb25zdCBzYXZlID0ge307XG5mdW5jdGlvbiBzYXZlV2luZG93KCkge1xuICBzYXZlLndpbmRvdyA9IGdsb2JhbHMud2luZG93O1xuICBzYXZlLmRvY3VtZW50ID0gZ2xvYmFscy5kb2N1bWVudDtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVXaW5kb3coKSB7XG4gIGdsb2JhbHMud2luZG93ID0gc2F2ZS53aW5kb3c7XG4gIGdsb2JhbHMuZG9jdW1lbnQgPSBzYXZlLmRvY3VtZW50O1xufVxuZnVuY3Rpb24gd2l0aFdpbmRvdyh3aW4sIGZuKSB7XG4gIHNhdmVXaW5kb3coKTtcbiAgcmVnaXN0ZXJXaW5kb3cod2luLCB3aW4uZG9jdW1lbnQpO1xuICBmbih3aW4sIHdpbi5kb2N1bWVudCk7XG4gIHJlc3RvcmVXaW5kb3coKTtcbn1cbmZ1bmN0aW9uIGdldFdpbmRvdygpIHtcbiAgcmV0dXJuIGdsb2JhbHMud2luZG93O1xufVxuXG5jbGFzcyBCYXNlIHsvLyBjb25zdHJ1Y3RvciAobm9kZS8qLCB7ZXh0ZW5zaW9ucyA9IFtdfSAqLykge1xuICAvLyAgIC8vIHRoaXMudGFncyA9IFtdXG4gIC8vICAgLy9cbiAgLy8gICAvLyBmb3IgKGxldCBleHRlbnNpb24gb2YgZXh0ZW5zaW9ucykge1xuICAvLyAgIC8vICAgZXh0ZW5zaW9uLnNldHVwLmNhbGwodGhpcywgbm9kZSlcbiAgLy8gICAvLyAgIHRoaXMudGFncy5wdXNoKGV4dGVuc2lvbi5uYW1lKVxuICAvLyAgIC8vIH1cbiAgLy8gfVxufVxuXG5jb25zdCBlbGVtZW50cyA9IHt9O1xuY29uc3Qgcm9vdCA9ICdfX19TWU1CT0xfX19ST09UX19fJzsgLy8gTWV0aG9kIGZvciBlbGVtZW50IGNyZWF0aW9uXG5cbmZ1bmN0aW9uIGNyZWF0ZShuYW1lLCBucyA9IHN2Zykge1xuICAvLyBjcmVhdGUgZWxlbWVudFxuICByZXR1cm4gZ2xvYmFscy5kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsIG5hbWUpO1xufVxuZnVuY3Rpb24gbWFrZUluc3RhbmNlKGVsZW1lbnQsIGlzSFRNTCA9IGZhbHNlKSB7XG4gIGlmIChlbGVtZW50IGluc3RhbmNlb2YgQmFzZSkgcmV0dXJuIGVsZW1lbnQ7XG5cbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBhZG9wdGVyKGVsZW1lbnQpO1xuICB9XG5cbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBuZXcgZWxlbWVudHNbcm9vdF0oKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgJiYgZWxlbWVudC5jaGFyQXQoMCkgIT09ICc8Jykge1xuICAgIHJldHVybiBhZG9wdGVyKGdsb2JhbHMuZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbGVtZW50KSk7XG4gIH0gLy8gTWFrZSBzdXJlLCB0aGF0IEhUTUwgZWxlbWVudHMgYXJlIGNyZWF0ZWQgd2l0aCB0aGUgY29ycmVjdCBuYW1lc3BhY2VcblxuXG4gIGNvbnN0IHdyYXBwZXIgPSBpc0hUTUwgPyBnbG9iYWxzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpIDogY3JlYXRlKCdzdmcnKTtcbiAgd3JhcHBlci5pbm5lckhUTUwgPSBlbGVtZW50OyAvLyBXZSBjYW4gdXNlIGZpcnN0Q2hpbGQgaGVyZSBiZWNhdXNlIHdlIGtub3csXG4gIC8vIHRoYXQgdGhlIGZpcnN0IGNoYXIgaXMgPCBhbmQgdGh1cyBhbiBlbGVtZW50XG5cbiAgZWxlbWVudCA9IGFkb3B0ZXIod3JhcHBlci5maXJzdENoaWxkKTsgLy8gbWFrZSBzdXJlLCB0aGF0IGVsZW1lbnQgZG9lc24ndCBoYXZlIGl0cyB3cmFwcGVyIGF0dGFjaGVkXG5cbiAgd3JhcHBlci5yZW1vdmVDaGlsZCh3cmFwcGVyLmZpcnN0Q2hpbGQpO1xuICByZXR1cm4gZWxlbWVudDtcbn1cbmZ1bmN0aW9uIG5vZGVPck5ldyhuYW1lLCBub2RlKSB7XG4gIHJldHVybiBub2RlICYmIG5vZGUub3duZXJEb2N1bWVudCAmJiBub2RlIGluc3RhbmNlb2Ygbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3Lk5vZGUgPyBub2RlIDogY3JlYXRlKG5hbWUpO1xufSAvLyBBZG9wdCBleGlzdGluZyBzdmcgZWxlbWVudHNcblxuZnVuY3Rpb24gYWRvcHQobm9kZSkge1xuICAvLyBjaGVjayBmb3IgcHJlc2VuY2Ugb2Ygbm9kZVxuICBpZiAoIW5vZGUpIHJldHVybiBudWxsOyAvLyBtYWtlIHN1cmUgYSBub2RlIGlzbid0IGFscmVhZHkgYWRvcHRlZFxuXG4gIGlmIChub2RlLmluc3RhbmNlIGluc3RhbmNlb2YgQmFzZSkgcmV0dXJuIG5vZGUuaW5zdGFuY2U7XG5cbiAgaWYgKG5vZGUubm9kZU5hbWUgPT09ICcjZG9jdW1lbnQtZnJhZ21lbnQnKSB7XG4gICAgcmV0dXJuIG5ldyBlbGVtZW50cy5GcmFnbWVudChub2RlKTtcbiAgfSAvLyBpbml0aWFsaXplIHZhcmlhYmxlc1xuXG5cbiAgbGV0IGNsYXNzTmFtZSA9IGNhcGl0YWxpemUobm9kZS5ub2RlTmFtZSB8fCAnRG9tJyk7IC8vIE1ha2Ugc3VyZSB0aGF0IGdyYWRpZW50cyBhcmUgYWRvcHRlZCBjb3JyZWN0bHlcblxuICBpZiAoY2xhc3NOYW1lID09PSAnTGluZWFyR3JhZGllbnQnIHx8IGNsYXNzTmFtZSA9PT0gJ1JhZGlhbEdyYWRpZW50Jykge1xuICAgIGNsYXNzTmFtZSA9ICdHcmFkaWVudCc7IC8vIEZhbGxiYWNrIHRvIERvbSBpZiBlbGVtZW50IGlzIG5vdCBrbm93blxuICB9IGVsc2UgaWYgKCFlbGVtZW50c1tjbGFzc05hbWVdKSB7XG4gICAgY2xhc3NOYW1lID0gJ0RvbSc7XG4gIH1cblxuICByZXR1cm4gbmV3IGVsZW1lbnRzW2NsYXNzTmFtZV0obm9kZSk7XG59XG5sZXQgYWRvcHRlciA9IGFkb3B0O1xuZnVuY3Rpb24gbW9ja0Fkb3B0KG1vY2sgPSBhZG9wdCkge1xuICBhZG9wdGVyID0gbW9jaztcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyKGVsZW1lbnQsIG5hbWUgPSBlbGVtZW50Lm5hbWUsIGFzUm9vdCA9IGZhbHNlKSB7XG4gIGVsZW1lbnRzW25hbWVdID0gZWxlbWVudDtcbiAgaWYgKGFzUm9vdCkgZWxlbWVudHNbcm9vdF0gPSBlbGVtZW50O1xuICBhZGRNZXRob2ROYW1lcyhPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlbGVtZW50LnByb3RvdHlwZSkpO1xuICByZXR1cm4gZWxlbWVudDtcbn1cbmZ1bmN0aW9uIGdldENsYXNzKG5hbWUpIHtcbiAgcmV0dXJuIGVsZW1lbnRzW25hbWVdO1xufSAvLyBFbGVtZW50IGlkIHNlcXVlbmNlXG5cbmxldCBkaWQgPSAxMDAwOyAvLyBHZXQgbmV4dCBuYW1lZCBlbGVtZW50IGlkXG5cbmZ1bmN0aW9uIGVpZChuYW1lKSB7XG4gIHJldHVybiAnU3ZnanMnICsgY2FwaXRhbGl6ZShuYW1lKSArIGRpZCsrO1xufSAvLyBEZWVwIG5ldyBpZCBhc3NpZ25tZW50XG5cbmZ1bmN0aW9uIGFzc2lnbk5ld0lkKG5vZGUpIHtcbiAgLy8gZG8gdGhlIHNhbWUgZm9yIFNWRyBjaGlsZCBub2RlcyBhcyB3ZWxsXG4gIGZvciAobGV0IGkgPSBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgYXNzaWduTmV3SWQobm9kZS5jaGlsZHJlbltpXSk7XG4gIH1cblxuICBpZiAobm9kZS5pZCkge1xuICAgIG5vZGUuaWQgPSBlaWQobm9kZS5ub2RlTmFtZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn0gLy8gTWV0aG9kIGZvciBleHRlbmRpbmcgb2JqZWN0c1xuXG5mdW5jdGlvbiBleHRlbmQobW9kdWxlcywgbWV0aG9kcykge1xuICBsZXQga2V5LCBpO1xuICBtb2R1bGVzID0gQXJyYXkuaXNBcnJheShtb2R1bGVzKSA/IG1vZHVsZXMgOiBbbW9kdWxlc107XG5cbiAgZm9yIChpID0gbW9kdWxlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIG1vZHVsZXNbaV0ucHJvdG90eXBlW2tleV0gPSBtZXRob2RzW2tleV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB3cmFwV2l0aEF0dHJDaGVjayhmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBvID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKG8gJiYgby5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICYmICEobyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3Muc2xpY2UoMCwgLTEpKS5hdHRyKG8pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBzaWJsaW5ncygpIHtcbiAgcmV0dXJuIHRoaXMucGFyZW50KCkuY2hpbGRyZW4oKTtcbn0gLy8gR2V0IHRoZSBjdXJyZW50IHBvc2l0aW9uIHNpYmxpbmdzXG5cbmZ1bmN0aW9uIHBvc2l0aW9uKCkge1xuICByZXR1cm4gdGhpcy5wYXJlbnQoKS5pbmRleCh0aGlzKTtcbn0gLy8gR2V0IHRoZSBuZXh0IGVsZW1lbnQgKHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlcmUgaXMgbm9uZSlcblxuZnVuY3Rpb24gbmV4dCgpIHtcbiAgcmV0dXJuIHRoaXMuc2libGluZ3MoKVt0aGlzLnBvc2l0aW9uKCkgKyAxXTtcbn0gLy8gR2V0IHRoZSBuZXh0IGVsZW1lbnQgKHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlcmUgaXMgbm9uZSlcblxuZnVuY3Rpb24gcHJldigpIHtcbiAgcmV0dXJuIHRoaXMuc2libGluZ3MoKVt0aGlzLnBvc2l0aW9uKCkgLSAxXTtcbn0gLy8gU2VuZCBnaXZlbiBlbGVtZW50IG9uZSBzdGVwIGZvcndhcmRcblxuZnVuY3Rpb24gZm9yd2FyZCgpIHtcbiAgY29uc3QgaSA9IHRoaXMucG9zaXRpb24oKTtcbiAgY29uc3QgcCA9IHRoaXMucGFyZW50KCk7IC8vIG1vdmUgbm9kZSBvbmUgc3RlcCBmb3J3YXJkXG5cbiAgcC5hZGQodGhpcy5yZW1vdmUoKSwgaSArIDEpO1xuICByZXR1cm4gdGhpcztcbn0gLy8gU2VuZCBnaXZlbiBlbGVtZW50IG9uZSBzdGVwIGJhY2t3YXJkXG5cbmZ1bmN0aW9uIGJhY2t3YXJkKCkge1xuICBjb25zdCBpID0gdGhpcy5wb3NpdGlvbigpO1xuICBjb25zdCBwID0gdGhpcy5wYXJlbnQoKTtcbiAgcC5hZGQodGhpcy5yZW1vdmUoKSwgaSA/IGkgLSAxIDogMCk7XG4gIHJldHVybiB0aGlzO1xufSAvLyBTZW5kIGdpdmVuIGVsZW1lbnQgYWxsIHRoZSB3YXkgdG8gdGhlIGZyb250XG5cbmZ1bmN0aW9uIGZyb250KCkge1xuICBjb25zdCBwID0gdGhpcy5wYXJlbnQoKTsgLy8gTW92ZSBub2RlIGZvcndhcmRcblxuICBwLmFkZCh0aGlzLnJlbW92ZSgpKTtcbiAgcmV0dXJuIHRoaXM7XG59IC8vIFNlbmQgZ2l2ZW4gZWxlbWVudCBhbGwgdGhlIHdheSB0byB0aGUgYmFja1xuXG5mdW5jdGlvbiBiYWNrKCkge1xuICBjb25zdCBwID0gdGhpcy5wYXJlbnQoKTsgLy8gTW92ZSBub2RlIGJhY2tcblxuICBwLmFkZCh0aGlzLnJlbW92ZSgpLCAwKTtcbiAgcmV0dXJuIHRoaXM7XG59IC8vIEluc2VydHMgYSBnaXZlbiBlbGVtZW50IGJlZm9yZSB0aGUgdGFyZ2V0ZWQgZWxlbWVudFxuXG5mdW5jdGlvbiBiZWZvcmUoZWxlbWVudCkge1xuICBlbGVtZW50ID0gbWFrZUluc3RhbmNlKGVsZW1lbnQpO1xuICBlbGVtZW50LnJlbW92ZSgpO1xuICBjb25zdCBpID0gdGhpcy5wb3NpdGlvbigpO1xuICB0aGlzLnBhcmVudCgpLmFkZChlbGVtZW50LCBpKTtcbiAgcmV0dXJuIHRoaXM7XG59IC8vIEluc2VydHMgYSBnaXZlbiBlbGVtZW50IGFmdGVyIHRoZSB0YXJnZXRlZCBlbGVtZW50XG5cbmZ1bmN0aW9uIGFmdGVyKGVsZW1lbnQpIHtcbiAgZWxlbWVudCA9IG1ha2VJbnN0YW5jZShlbGVtZW50KTtcbiAgZWxlbWVudC5yZW1vdmUoKTtcbiAgY29uc3QgaSA9IHRoaXMucG9zaXRpb24oKTtcbiAgdGhpcy5wYXJlbnQoKS5hZGQoZWxlbWVudCwgaSArIDEpO1xuICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIGluc2VydEJlZm9yZShlbGVtZW50KSB7XG4gIGVsZW1lbnQgPSBtYWtlSW5zdGFuY2UoZWxlbWVudCk7XG4gIGVsZW1lbnQuYmVmb3JlKHRoaXMpO1xuICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIGluc2VydEFmdGVyKGVsZW1lbnQpIHtcbiAgZWxlbWVudCA9IG1ha2VJbnN0YW5jZShlbGVtZW50KTtcbiAgZWxlbWVudC5hZnRlcih0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5yZWdpc3Rlck1ldGhvZHMoJ0RvbScsIHtcbiAgc2libGluZ3MsXG4gIHBvc2l0aW9uLFxuICBuZXh0LFxuICBwcmV2LFxuICBmb3J3YXJkLFxuICBiYWNrd2FyZCxcbiAgZnJvbnQsXG4gIGJhY2ssXG4gIGJlZm9yZSxcbiAgYWZ0ZXIsXG4gIGluc2VydEJlZm9yZSxcbiAgaW5zZXJ0QWZ0ZXJcbn0pO1xuXG4vLyBQYXJzZSB1bml0IHZhbHVlXG5jb25zdCBudW1iZXJBbmRVbml0ID0gL14oWystXT8oXFxkKyhcXC5cXGQqKT98XFwuXFxkKykoZVsrLV0/XFxkKyk/KShbYS16JV0qKSQvaTsgLy8gUGFyc2UgaGV4IHZhbHVlXG5cbmNvbnN0IGhleCA9IC9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2k7IC8vIFBhcnNlIHJnYiB2YWx1ZVxuXG5jb25zdCByZ2IgPSAvcmdiXFwoKFxcZCspLChcXGQrKSwoXFxkKylcXCkvOyAvLyBQYXJzZSByZWZlcmVuY2UgaWRcblxuY29uc3QgcmVmZXJlbmNlID0gLygjW2Etel9dW2EtejAtOVxcLV9dKikvaTsgLy8gc3BsaXRzIGEgdHJhbnNmb3JtYXRpb24gY2hhaW5cblxuY29uc3QgdHJhbnNmb3JtcyA9IC9cXClcXHMqLD9cXHMqLzsgLy8gV2hpdGVzcGFjZVxuXG5jb25zdCB3aGl0ZXNwYWNlID0gL1xccy9nOyAvLyBUZXN0IGhleCB2YWx1ZVxuXG5jb25zdCBpc0hleCA9IC9eI1thLWYwLTldezN9JHxeI1thLWYwLTldezZ9JC9pOyAvLyBUZXN0IHJnYiB2YWx1ZVxuXG5jb25zdCBpc1JnYiA9IC9ecmdiXFwoLzsgLy8gVGVzdCBmb3IgYmxhbmsgc3RyaW5nXG5cbmNvbnN0IGlzQmxhbmsgPSAvXihcXHMrKT8kLzsgLy8gVGVzdCBmb3IgbnVtZXJpYyBzdHJpbmdcblxuY29uc3QgaXNOdW1iZXIgPSAvXlsrLV0/KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspKGVbKy1dP1xcZCspPyQvaTsgLy8gVGVzdCBmb3IgaW1hZ2UgdXJsXG5cbmNvbnN0IGlzSW1hZ2UgPSAvXFwuKGpwZ3xqcGVnfHBuZ3xnaWZ8c3ZnKShcXD9bXj1dKy4qKT8vaTsgLy8gc3BsaXQgYXQgd2hpdGVzcGFjZSBhbmQgY29tbWFcblxuY29uc3QgZGVsaW1pdGVyID0gL1tcXHMsXSsvOyAvLyBUZXN0IGZvciBwYXRoIGxldHRlclxuXG5jb25zdCBpc1BhdGhMZXR0ZXIgPSAvW01MSFZDU1FUQVpdL2k7XG5cbnZhciByZWdleCA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBudW1iZXJBbmRVbml0OiBudW1iZXJBbmRVbml0LFxuICBoZXg6IGhleCxcbiAgcmdiOiByZ2IsXG4gIHJlZmVyZW5jZTogcmVmZXJlbmNlLFxuICB0cmFuc2Zvcm1zOiB0cmFuc2Zvcm1zLFxuICB3aGl0ZXNwYWNlOiB3aGl0ZXNwYWNlLFxuICBpc0hleDogaXNIZXgsXG4gIGlzUmdiOiBpc1JnYixcbiAgaXNCbGFuazogaXNCbGFuayxcbiAgaXNOdW1iZXI6IGlzTnVtYmVyLFxuICBpc0ltYWdlOiBpc0ltYWdlLFxuICBkZWxpbWl0ZXI6IGRlbGltaXRlcixcbiAgaXNQYXRoTGV0dGVyOiBpc1BhdGhMZXR0ZXJcbn07XG5cbmZ1bmN0aW9uIGNsYXNzZXMoKSB7XG4gIGNvbnN0IGF0dHIgPSB0aGlzLmF0dHIoJ2NsYXNzJyk7XG4gIHJldHVybiBhdHRyID09IG51bGwgPyBbXSA6IGF0dHIudHJpbSgpLnNwbGl0KGRlbGltaXRlcik7XG59IC8vIFJldHVybiB0cnVlIGlmIGNsYXNzIGV4aXN0cyBvbiB0aGUgbm9kZSwgZmFsc2Ugb3RoZXJ3aXNlXG5cbmZ1bmN0aW9uIGhhc0NsYXNzKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuY2xhc3NlcygpLmluZGV4T2YobmFtZSkgIT09IC0xO1xufSAvLyBBZGQgY2xhc3MgdG8gdGhlIG5vZGVcblxuZnVuY3Rpb24gYWRkQ2xhc3MobmFtZSkge1xuICBpZiAoIXRoaXMuaGFzQ2xhc3MobmFtZSkpIHtcbiAgICBjb25zdCBhcnJheSA9IHRoaXMuY2xhc3NlcygpO1xuICAgIGFycmF5LnB1c2gobmFtZSk7XG4gICAgdGhpcy5hdHRyKCdjbGFzcycsIGFycmF5LmpvaW4oJyAnKSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn0gLy8gUmVtb3ZlIGNsYXNzIGZyb20gdGhlIG5vZGVcblxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MobmFtZSkge1xuICBpZiAodGhpcy5oYXNDbGFzcyhuYW1lKSkge1xuICAgIHRoaXMuYXR0cignY2xhc3MnLCB0aGlzLmNsYXNzZXMoKS5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjICE9PSBuYW1lO1xuICAgIH0pLmpvaW4oJyAnKSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn0gLy8gVG9nZ2xlIHRoZSBwcmVzZW5jZSBvZiBhIGNsYXNzIG9uIHRoZSBub2RlXG5cbmZ1bmN0aW9uIHRvZ2dsZUNsYXNzKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuaGFzQ2xhc3MobmFtZSkgPyB0aGlzLnJlbW92ZUNsYXNzKG5hbWUpIDogdGhpcy5hZGRDbGFzcyhuYW1lKTtcbn1cbnJlZ2lzdGVyTWV0aG9kcygnRG9tJywge1xuICBjbGFzc2VzLFxuICBoYXNDbGFzcyxcbiAgYWRkQ2xhc3MsXG4gIHJlbW92ZUNsYXNzLFxuICB0b2dnbGVDbGFzc1xufSk7XG5cbmZ1bmN0aW9uIGNzcyhzdHlsZSwgdmFsKSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gZ2V0IGZ1bGwgc3R5bGUgYXMgb2JqZWN0XG4gICAgdGhpcy5ub2RlLnN0eWxlLmNzc1RleHQuc3BsaXQoL1xccyo7XFxzKi8pLmZpbHRlcihmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiAhIWVsLmxlbmd0aDtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgY29uc3QgdCA9IGVsLnNwbGl0KC9cXHMqOlxccyovKTtcbiAgICAgIHJldFt0WzBdXSA9IHRbMV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIC8vIGdldCBzdHlsZSBwcm9wZXJ0aWVzIGFzIGFycmF5XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUpKSB7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygc3R5bGUpIHtcbiAgICAgICAgY29uc3QgY2FzZWQgPSBjYW1lbENhc2UobmFtZSk7XG4gICAgICAgIHJldFtuYW1lXSA9IHRoaXMubm9kZS5zdHlsZVtjYXNlZF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSAvLyBnZXQgc3R5bGUgZm9yIHByb3BlcnR5XG5cblxuICAgIGlmICh0eXBlb2Ygc3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlLnN0eWxlW2NhbWVsQ2FzZShzdHlsZSldO1xuICAgIH0gLy8gc2V0IHN0eWxlcyBpbiBvYmplY3RcblxuXG4gICAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBzdHlsZSkge1xuICAgICAgICAvLyBzZXQgZW1wdHkgc3RyaW5nIGlmIG51bGwvdW5kZWZpbmVkLycnIHdhcyBnaXZlblxuICAgICAgICB0aGlzLm5vZGUuc3R5bGVbY2FtZWxDYXNlKG5hbWUpXSA9IHN0eWxlW25hbWVdID09IG51bGwgfHwgaXNCbGFuay50ZXN0KHN0eWxlW25hbWVdKSA/ICcnIDogc3R5bGVbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9IC8vIHNldCBzdHlsZSBmb3IgcHJvcGVydHlcblxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdGhpcy5ub2RlLnN0eWxlW2NhbWVsQ2FzZShzdHlsZSldID0gdmFsID09IG51bGwgfHwgaXNCbGFuay50ZXN0KHZhbCkgPyAnJyA6IHZhbDtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufSAvLyBTaG93IGVsZW1lbnRcblxuZnVuY3Rpb24gc2hvdygpIHtcbiAgcmV0dXJuIHRoaXMuY3NzKCdkaXNwbGF5JywgJycpO1xufSAvLyBIaWRlIGVsZW1lbnRcblxuZnVuY3Rpb24gaGlkZSgpIHtcbiAgcmV0dXJuIHRoaXMuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbn0gLy8gSXMgZWxlbWVudCB2aXNpYmxlP1xuXG5mdW5jdGlvbiB2aXNpYmxlKCkge1xuICByZXR1cm4gdGhpcy5jc3MoJ2Rpc3BsYXknKSAhPT0gJ25vbmUnO1xufVxucmVnaXN0ZXJNZXRob2RzKCdEb20nLCB7XG4gIGNzcyxcbiAgc2hvdyxcbiAgaGlkZSxcbiAgdmlzaWJsZVxufSk7XG5cbmZ1bmN0aW9uIGRhdGEoYSwgdiwgcikge1xuICBpZiAoYSA9PSBudWxsKSB7XG4gICAgLy8gZ2V0IGFuIG9iamVjdCBvZiBhdHRyaWJ1dGVzXG4gICAgcmV0dXJuIHRoaXMuZGF0YShtYXAoZmlsdGVyKHRoaXMubm9kZS5hdHRyaWJ1dGVzLCBlbCA9PiBlbC5ub2RlTmFtZS5pbmRleE9mKCdkYXRhLScpID09PSAwKSwgZWwgPT4gZWwubm9kZU5hbWUuc2xpY2UoNSkpKTtcbiAgfSBlbHNlIGlmIChhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICBjb25zdCBkYXRhID0ge307XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBhKSB7XG4gICAgICBkYXRhW2tleV0gPSB0aGlzLmRhdGEoa2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKHYgaW4gYSkge1xuICAgICAgdGhpcy5kYXRhKHYsIGFbdl0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLmF0dHIoJ2RhdGEtJyArIGEpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdkYXRhLScgKyBhKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hdHRyKCdkYXRhLScgKyBhLCB2ID09PSBudWxsID8gbnVsbCA6IHIgPT09IHRydWUgfHwgdHlwZW9mIHYgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2ID09PSAnbnVtYmVyJyA/IHYgOiBKU09OLnN0cmluZ2lmeSh2KSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cbnJlZ2lzdGVyTWV0aG9kcygnRG9tJywge1xuICBkYXRhXG59KTtcblxuZnVuY3Rpb24gcmVtZW1iZXIoaywgdikge1xuICAvLyByZW1lbWJlciBldmVyeSBpdGVtIGluIGFuIG9iamVjdCBpbmRpdmlkdWFsbHlcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gaykge1xuICAgICAgdGhpcy5yZW1lbWJlcihrZXksIGtba2V5XSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAvLyByZXRyaWV2ZSBtZW1vcnlcbiAgICByZXR1cm4gdGhpcy5tZW1vcnkoKVtrXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBzdG9yZSBtZW1vcnlcbiAgICB0aGlzLm1lbW9yeSgpW2tdID0gdjtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufSAvLyBFcmFzZSBhIGdpdmVuIG1lbW9yeVxuXG5mdW5jdGlvbiBmb3JnZXQoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5fbWVtb3J5ID0ge307XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgZGVsZXRlIHRoaXMubWVtb3J5KClbYXJndW1lbnRzW2ldXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn0gLy8gVGhpcyB0cmlnZ2VycyBjcmVhdGlvbiBvZiBhIG5ldyBoaWRkZW4gY2xhc3Mgd2hpY2ggaXMgbm90IHBlcmZvcm1hbnRcbi8vIEhvd2V2ZXIsIHRoaXMgZnVuY3Rpb24gaXMgbm90IHJhcmVseSB1c2VkIHNvIGl0IHdpbGwgbm90IGhhcHBlbiBmcmVxdWVudGx5XG4vLyBSZXR1cm4gbG9jYWwgbWVtb3J5IG9iamVjdFxuXG5mdW5jdGlvbiBtZW1vcnkoKSB7XG4gIHJldHVybiB0aGlzLl9tZW1vcnkgPSB0aGlzLl9tZW1vcnkgfHwge307XG59XG5yZWdpc3Rlck1ldGhvZHMoJ0RvbScsIHtcbiAgcmVtZW1iZXIsXG4gIGZvcmdldCxcbiAgbWVtb3J5XG59KTtcblxuZnVuY3Rpb24gc2l4RGlnaXRIZXgoaGV4KSB7XG4gIHJldHVybiBoZXgubGVuZ3RoID09PSA0ID8gWycjJywgaGV4LnN1YnN0cmluZygxLCAyKSwgaGV4LnN1YnN0cmluZygxLCAyKSwgaGV4LnN1YnN0cmluZygyLCAzKSwgaGV4LnN1YnN0cmluZygyLCAzKSwgaGV4LnN1YnN0cmluZygzLCA0KSwgaGV4LnN1YnN0cmluZygzLCA0KV0uam9pbignJykgOiBoZXg7XG59XG5cbmZ1bmN0aW9uIGNvbXBvbmVudEhleChjb21wb25lbnQpIHtcbiAgY29uc3QgaW50ZWdlciA9IE1hdGgucm91bmQoY29tcG9uZW50KTtcbiAgY29uc3QgYm91bmRlZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgaW50ZWdlcikpO1xuICBjb25zdCBoZXggPSBib3VuZGVkLnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIGhleC5sZW5ndGggPT09IDEgPyAnMCcgKyBoZXggOiBoZXg7XG59XG5cbmZ1bmN0aW9uIGlzKG9iamVjdCwgc3BhY2UpIHtcbiAgZm9yIChsZXQgaSA9IHNwYWNlLmxlbmd0aDsgaS0tOykge1xuICAgIGlmIChvYmplY3Rbc3BhY2VbaV1dID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyYW1ldGVycyhhLCBiKSB7XG4gIGNvbnN0IHBhcmFtcyA9IGlzKGEsICdyZ2InKSA/IHtcbiAgICBfYTogYS5yLFxuICAgIF9iOiBhLmcsXG4gICAgX2M6IGEuYixcbiAgICBfZDogMCxcbiAgICBzcGFjZTogJ3JnYidcbiAgfSA6IGlzKGEsICd4eXonKSA/IHtcbiAgICBfYTogYS54LFxuICAgIF9iOiBhLnksXG4gICAgX2M6IGEueixcbiAgICBfZDogMCxcbiAgICBzcGFjZTogJ3h5eidcbiAgfSA6IGlzKGEsICdoc2wnKSA/IHtcbiAgICBfYTogYS5oLFxuICAgIF9iOiBhLnMsXG4gICAgX2M6IGEubCxcbiAgICBfZDogMCxcbiAgICBzcGFjZTogJ2hzbCdcbiAgfSA6IGlzKGEsICdsYWInKSA/IHtcbiAgICBfYTogYS5sLFxuICAgIF9iOiBhLmEsXG4gICAgX2M6IGEuYixcbiAgICBfZDogMCxcbiAgICBzcGFjZTogJ2xhYidcbiAgfSA6IGlzKGEsICdsY2gnKSA/IHtcbiAgICBfYTogYS5sLFxuICAgIF9iOiBhLmMsXG4gICAgX2M6IGEuaCxcbiAgICBfZDogMCxcbiAgICBzcGFjZTogJ2xjaCdcbiAgfSA6IGlzKGEsICdjbXlrJykgPyB7XG4gICAgX2E6IGEuYyxcbiAgICBfYjogYS5tLFxuICAgIF9jOiBhLnksXG4gICAgX2Q6IGEuayxcbiAgICBzcGFjZTogJ2NteWsnXG4gIH0gOiB7XG4gICAgX2E6IDAsXG4gICAgX2I6IDAsXG4gICAgX2M6IDAsXG4gICAgc3BhY2U6ICdyZ2InXG4gIH07XG4gIHBhcmFtcy5zcGFjZSA9IGIgfHwgcGFyYW1zLnNwYWNlO1xuICByZXR1cm4gcGFyYW1zO1xufVxuXG5mdW5jdGlvbiBjaWVTcGFjZShzcGFjZSkge1xuICBpZiAoc3BhY2UgPT09ICdsYWInIHx8IHNwYWNlID09PSAneHl6JyB8fCBzcGFjZSA9PT0gJ2xjaCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaHVlVG9SZ2IocCwgcSwgdCkge1xuICBpZiAodCA8IDApIHQgKz0gMTtcbiAgaWYgKHQgPiAxKSB0IC09IDE7XG4gIGlmICh0IDwgMSAvIDYpIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICBpZiAodCA8IDEgLyAyKSByZXR1cm4gcTtcbiAgaWYgKHQgPCAyIC8gMykgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2O1xuICByZXR1cm4gcDtcbn1cblxuY2xhc3MgQ29sb3Ige1xuICBjb25zdHJ1Y3RvciguLi5pbnB1dHMpIHtcbiAgICB0aGlzLmluaXQoLi4uaW5wdXRzKTtcbiAgfSAvLyBUZXN0IGlmIGdpdmVuIHZhbHVlIGlzIGEgY29sb3JcblxuXG4gIHN0YXRpYyBpc0NvbG9yKGNvbG9yKSB7XG4gICAgcmV0dXJuIGNvbG9yICYmIChjb2xvciBpbnN0YW5jZW9mIENvbG9yIHx8IHRoaXMuaXNSZ2IoY29sb3IpIHx8IHRoaXMudGVzdChjb2xvcikpO1xuICB9IC8vIFRlc3QgaWYgZ2l2ZW4gdmFsdWUgaXMgYW4gcmdiIG9iamVjdFxuXG5cbiAgc3RhdGljIGlzUmdiKGNvbG9yKSB7XG4gICAgcmV0dXJuIGNvbG9yICYmIHR5cGVvZiBjb2xvci5yID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29sb3IuZyA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbG9yLmIgPT09ICdudW1iZXInO1xuICB9XG4gIC8qXG4gIEdlbmVyYXRpbmcgcmFuZG9tIGNvbG9yc1xuICAqL1xuXG5cbiAgc3RhdGljIHJhbmRvbShtb2RlID0gJ3ZpYnJhbnQnLCB0LCB1KSB7XG4gICAgLy8gR2V0IHRoZSBtYXRoIG1vZHVsZXNcbiAgICBjb25zdCB7XG4gICAgICByYW5kb20sXG4gICAgICByb3VuZCxcbiAgICAgIHNpbixcbiAgICAgIFBJOiBwaVxuICAgIH0gPSBNYXRoOyAvLyBSdW4gdGhlIGNvcnJlY3QgZ2VuZXJhdG9yXG5cbiAgICBpZiAobW9kZSA9PT0gJ3ZpYnJhbnQnKSB7XG4gICAgICBjb25zdCBsID0gKDgxIC0gNTcpICogcmFuZG9tKCkgKyA1NztcbiAgICAgIGNvbnN0IGMgPSAoODMgLSA0NSkgKiByYW5kb20oKSArIDQ1O1xuICAgICAgY29uc3QgaCA9IDM2MCAqIHJhbmRvbSgpO1xuICAgICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IobCwgYywgaCwgJ2xjaCcpO1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ3NpbmUnKSB7XG4gICAgICB0ID0gdCA9PSBudWxsID8gcmFuZG9tKCkgOiB0O1xuICAgICAgY29uc3QgciA9IHJvdW5kKDgwICogc2luKDIgKiBwaSAqIHQgLyAwLjUgKyAwLjAxKSArIDE1MCk7XG4gICAgICBjb25zdCBnID0gcm91bmQoNTAgKiBzaW4oMiAqIHBpICogdCAvIDAuNSArIDQuNikgKyAyMDApO1xuICAgICAgY29uc3QgYiA9IHJvdW5kKDEwMCAqIHNpbigyICogcGkgKiB0IC8gMC41ICsgMi4zKSArIDE1MCk7XG4gICAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcihyLCBnLCBiKTtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdwYXN0ZWwnKSB7XG4gICAgICBjb25zdCBsID0gKDk0IC0gODYpICogcmFuZG9tKCkgKyA4NjtcbiAgICAgIGNvbnN0IGMgPSAoMjYgLSA5KSAqIHJhbmRvbSgpICsgOTtcbiAgICAgIGNvbnN0IGggPSAzNjAgKiByYW5kb20oKTtcbiAgICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKGwsIGMsIGgsICdsY2gnKTtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdkYXJrJykge1xuICAgICAgY29uc3QgbCA9IDEwICsgMTAgKiByYW5kb20oKTtcbiAgICAgIGNvbnN0IGMgPSAoMTI1IC0gNzUpICogcmFuZG9tKCkgKyA4NjtcbiAgICAgIGNvbnN0IGggPSAzNjAgKiByYW5kb20oKTtcbiAgICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKGwsIGMsIGgsICdsY2gnKTtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdyZ2InKSB7XG4gICAgICBjb25zdCByID0gMjU1ICogcmFuZG9tKCk7XG4gICAgICBjb25zdCBnID0gMjU1ICogcmFuZG9tKCk7XG4gICAgICBjb25zdCBiID0gMjU1ICogcmFuZG9tKCk7XG4gICAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcihyLCBnLCBiKTtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdsYWInKSB7XG4gICAgICBjb25zdCBsID0gMTAwICogcmFuZG9tKCk7XG4gICAgICBjb25zdCBhID0gMjU2ICogcmFuZG9tKCkgLSAxMjg7XG4gICAgICBjb25zdCBiID0gMjU2ICogcmFuZG9tKCkgLSAxMjg7XG4gICAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcihsLCBhLCBiLCAnbGFiJyk7XG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfSBlbHNlIGlmIChtb2RlID09PSAnZ3JleScpIHtcbiAgICAgIGNvbnN0IGdyZXkgPSAyNTUgKiByYW5kb20oKTtcbiAgICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKGdyZXksIGdyZXksIGdyZXkpO1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHJhbmRvbSBjb2xvciBtb2RlJyk7XG4gICAgfVxuICB9IC8vIFRlc3QgaWYgZ2l2ZW4gdmFsdWUgaXMgYSBjb2xvciBzdHJpbmdcblxuXG4gIHN0YXRpYyB0ZXN0KGNvbG9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycgJiYgKGlzSGV4LnRlc3QoY29sb3IpIHx8IGlzUmdiLnRlc3QoY29sb3IpKTtcbiAgfVxuXG4gIGNteWsoKSB7XG4gICAgLy8gR2V0IHRoZSByZ2IgdmFsdWVzIGZvciB0aGUgY3VycmVudCBjb2xvclxuICAgIGNvbnN0IHtcbiAgICAgIF9hLFxuICAgICAgX2IsXG4gICAgICBfY1xuICAgIH0gPSB0aGlzLnJnYigpO1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IFtfYSwgX2IsIF9jXS5tYXAodiA9PiB2IC8gMjU1KTsgLy8gR2V0IHRoZSBjbXlrIHZhbHVlcyBpbiBhbiB1bmJvdW5kZWQgZm9ybWF0XG5cbiAgICBjb25zdCBrID0gTWF0aC5taW4oMSAtIHIsIDEgLSBnLCAxIC0gYik7XG5cbiAgICBpZiAoayA9PT0gMSkge1xuICAgICAgLy8gQ2F0Y2ggdGhlIGJsYWNrIGNhc2VcbiAgICAgIHJldHVybiBuZXcgQ29sb3IoMCwgMCwgMCwgMSwgJ2NteWsnKTtcbiAgICB9XG5cbiAgICBjb25zdCBjID0gKDEgLSByIC0gaykgLyAoMSAtIGspO1xuICAgIGNvbnN0IG0gPSAoMSAtIGcgLSBrKSAvICgxIC0gayk7XG4gICAgY29uc3QgeSA9ICgxIC0gYiAtIGspIC8gKDEgLSBrKTsgLy8gQ29uc3RydWN0IHRoZSBuZXcgY29sb3JcblxuICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKGMsIG0sIHksIGssICdjbXlrJyk7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG5cbiAgaHNsKCkge1xuICAgIC8vIEdldCB0aGUgcmdiIHZhbHVlc1xuICAgIGNvbnN0IHtcbiAgICAgIF9hLFxuICAgICAgX2IsXG4gICAgICBfY1xuICAgIH0gPSB0aGlzLnJnYigpO1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IFtfYSwgX2IsIF9jXS5tYXAodiA9PiB2IC8gMjU1KTsgLy8gRmluZCB0aGUgbWF4aW11bSBhbmQgbWluaW11bSB2YWx1ZXMgdG8gZ2V0IHRoZSBsaWdodG5lc3NcblxuICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgIGNvbnN0IGwgPSAobWF4ICsgbWluKSAvIDI7IC8vIElmIHRoZSByLCBnLCB2IHZhbHVlcyBhcmUgaWRlbnRpY2FsIHRoZW4gd2UgYXJlIGdyZXlcblxuICAgIGNvbnN0IGlzR3JleSA9IG1heCA9PT0gbWluOyAvLyBDYWxjdWxhdGUgdGhlIGh1ZSBhbmQgc2F0dXJhdGlvblxuXG4gICAgY29uc3QgZGVsdGEgPSBtYXggLSBtaW47XG4gICAgY29uc3QgcyA9IGlzR3JleSA/IDAgOiBsID4gMC41ID8gZGVsdGEgLyAoMiAtIG1heCAtIG1pbikgOiBkZWx0YSAvIChtYXggKyBtaW4pO1xuICAgIGNvbnN0IGggPSBpc0dyZXkgPyAwIDogbWF4ID09PSByID8gKChnIC0gYikgLyBkZWx0YSArIChnIDwgYiA/IDYgOiAwKSkgLyA2IDogbWF4ID09PSBnID8gKChiIC0gcikgLyBkZWx0YSArIDIpIC8gNiA6IG1heCA9PT0gYiA/ICgociAtIGcpIC8gZGVsdGEgKyA0KSAvIDYgOiAwOyAvLyBDb25zdHJ1Y3QgYW5kIHJldHVybiB0aGUgbmV3IGNvbG9yXG5cbiAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcigzNjAgKiBoLCAxMDAgKiBzLCAxMDAgKiBsLCAnaHNsJyk7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG5cbiAgaW5pdChhID0gMCwgYiA9IDAsIGMgPSAwLCBkID0gMCwgc3BhY2UgPSAncmdiJykge1xuICAgIC8vIFRoaXMgY2F0Y2hlcyB0aGUgY2FzZSB3aGVuIGEgZmFsc3kgdmFsdWUgaXMgcGFzc2VkIGxpa2UgJydcbiAgICBhID0gIWEgPyAwIDogYTsgLy8gUmVzZXQgYWxsIHZhbHVlcyBpbiBjYXNlIHRoZSBpbml0IGZ1bmN0aW9uIGlzIHJlcnVuIHdpdGggbmV3IGNvbG9yIHNwYWNlXG5cbiAgICBpZiAodGhpcy5zcGFjZSkge1xuICAgICAgZm9yIChjb25zdCBjb21wb25lbnQgaW4gdGhpcy5zcGFjZSkge1xuICAgICAgICBkZWxldGUgdGhpc1t0aGlzLnNwYWNlW2NvbXBvbmVudF1dO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYSA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIEFsbG93IGZvciB0aGUgY2FzZSB0aGF0IHdlIGRvbid0IG5lZWQgZC4uLlxuICAgICAgc3BhY2UgPSB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyBkIDogc3BhY2U7XG4gICAgICBkID0gdHlwZW9mIGQgPT09ICdzdHJpbmcnID8gMCA6IGQ7IC8vIEFzc2lnbiB0aGUgdmFsdWVzIHN0cmFpZ2h0IHRvIHRoZSBjb2xvclxuXG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtcbiAgICAgICAgX2E6IGEsXG4gICAgICAgIF9iOiBiLFxuICAgICAgICBfYzogYyxcbiAgICAgICAgX2Q6IGQsXG4gICAgICAgIHNwYWNlXG4gICAgICB9KTsgLy8gSWYgdGhlIHVzZXIgZ2F2ZSB1cyBhbiBhcnJheSwgbWFrZSB0aGUgY29sb3IgZnJvbSBpdFxuICAgIH0gZWxzZSBpZiAoYSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICB0aGlzLnNwYWNlID0gYiB8fCAodHlwZW9mIGFbM10gPT09ICdzdHJpbmcnID8gYVszXSA6IGFbNF0pIHx8ICdyZ2InO1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7XG4gICAgICAgIF9hOiBhWzBdLFxuICAgICAgICBfYjogYVsxXSxcbiAgICAgICAgX2M6IGFbMl0sXG4gICAgICAgIF9kOiBhWzNdIHx8IDBcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoYSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgLy8gU2V0IHRoZSBvYmplY3QgdXAgYW5kIGFzc2lnbiBpdHMgdmFsdWVzIGRpcmVjdGx5XG4gICAgICBjb25zdCB2YWx1ZXMgPSBnZXRQYXJhbWV0ZXJzKGEsIGIpO1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB2YWx1ZXMpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoaXNSZ2IudGVzdChhKSkge1xuICAgICAgICBjb25zdCBub1doaXRlc3BhY2UgPSBhLnJlcGxhY2Uod2hpdGVzcGFjZSwgJycpO1xuICAgICAgICBjb25zdCBbX2EsIF9iLCBfY10gPSByZ2IuZXhlYyhub1doaXRlc3BhY2UpLnNsaWNlKDEsIDQpLm1hcCh2ID0+IHBhcnNlSW50KHYpKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7XG4gICAgICAgICAgX2EsXG4gICAgICAgICAgX2IsXG4gICAgICAgICAgX2MsXG4gICAgICAgICAgX2Q6IDAsXG4gICAgICAgICAgc3BhY2U6ICdyZ2InXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChpc0hleC50ZXN0KGEpKSB7XG4gICAgICAgIGNvbnN0IGhleFBhcnNlID0gdiA9PiBwYXJzZUludCh2LCAxNik7XG5cbiAgICAgICAgY29uc3QgWywgX2EsIF9iLCBfY10gPSBoZXguZXhlYyhzaXhEaWdpdEhleChhKSkubWFwKGhleFBhcnNlKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7XG4gICAgICAgICAgX2EsXG4gICAgICAgICAgX2IsXG4gICAgICAgICAgX2MsXG4gICAgICAgICAgX2Q6IDAsXG4gICAgICAgICAgc3BhY2U6ICdyZ2InXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHRocm93IEVycm9yKCdVbnN1cHBvcnRlZCBzdHJpbmcgZm9ybWF0LCBjYW5cXCd0IGNvbnN0cnVjdCBDb2xvcicpO1xuICAgIH0gLy8gTm93IGFkZCB0aGUgY29tcG9uZW50cyBhcyBhIGNvbnZlbmllbmNlXG5cblxuICAgIGNvbnN0IHtcbiAgICAgIF9hLFxuICAgICAgX2IsXG4gICAgICBfYyxcbiAgICAgIF9kXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgY29tcG9uZW50cyA9IHRoaXMuc3BhY2UgPT09ICdyZ2InID8ge1xuICAgICAgcjogX2EsXG4gICAgICBnOiBfYixcbiAgICAgIGI6IF9jXG4gICAgfSA6IHRoaXMuc3BhY2UgPT09ICd4eXonID8ge1xuICAgICAgeDogX2EsXG4gICAgICB5OiBfYixcbiAgICAgIHo6IF9jXG4gICAgfSA6IHRoaXMuc3BhY2UgPT09ICdoc2wnID8ge1xuICAgICAgaDogX2EsXG4gICAgICBzOiBfYixcbiAgICAgIGw6IF9jXG4gICAgfSA6IHRoaXMuc3BhY2UgPT09ICdsYWInID8ge1xuICAgICAgbDogX2EsXG4gICAgICBhOiBfYixcbiAgICAgIGI6IF9jXG4gICAgfSA6IHRoaXMuc3BhY2UgPT09ICdsY2gnID8ge1xuICAgICAgbDogX2EsXG4gICAgICBjOiBfYixcbiAgICAgIGg6IF9jXG4gICAgfSA6IHRoaXMuc3BhY2UgPT09ICdjbXlrJyA/IHtcbiAgICAgIGM6IF9hLFxuICAgICAgbTogX2IsXG4gICAgICB5OiBfYyxcbiAgICAgIGs6IF9kXG4gICAgfSA6IHt9O1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgY29tcG9uZW50cyk7XG4gIH1cblxuICBsYWIoKSB7XG4gICAgLy8gR2V0IHRoZSB4eXogY29sb3JcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHpcbiAgICB9ID0gdGhpcy54eXooKTsgLy8gR2V0IHRoZSBsYWIgY29tcG9uZW50c1xuXG4gICAgY29uc3QgbCA9IDExNiAqIHkgLSAxNjtcbiAgICBjb25zdCBhID0gNTAwICogKHggLSB5KTtcbiAgICBjb25zdCBiID0gMjAwICogKHkgLSB6KTsgLy8gQ29uc3RydWN0IGFuZCByZXR1cm4gYSBuZXcgY29sb3JcblxuICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKGwsIGEsIGIsICdsYWInKTtcbiAgICByZXR1cm4gY29sb3I7XG4gIH1cblxuICBsY2goKSB7XG4gICAgLy8gR2V0IHRoZSBsYWIgY29sb3IgZGlyZWN0bHlcbiAgICBjb25zdCB7XG4gICAgICBsLFxuICAgICAgYSxcbiAgICAgIGJcbiAgICB9ID0gdGhpcy5sYWIoKTsgLy8gR2V0IHRoZSBjaHJvbWF0aWNpdHkgYW5kIHRoZSBodWUgdXNpbmcgcG9sYXIgY29vcmRpbmF0ZXNcblxuICAgIGNvbnN0IGMgPSBNYXRoLnNxcnQoYSAqKiAyICsgYiAqKiAyKTtcbiAgICBsZXQgaCA9IDE4MCAqIE1hdGguYXRhbjIoYiwgYSkgLyBNYXRoLlBJO1xuXG4gICAgaWYgKGggPCAwKSB7XG4gICAgICBoICo9IC0xO1xuICAgICAgaCA9IDM2MCAtIGg7XG4gICAgfSAvLyBNYWtlIGEgbmV3IGNvbG9yIGFuZCByZXR1cm4gaXRcblxuXG4gICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IobCwgYywgaCwgJ2xjaCcpO1xuICAgIHJldHVybiBjb2xvcjtcbiAgfVxuICAvKlxuICBDb252ZXJzaW9uIE1ldGhvZHNcbiAgKi9cblxuXG4gIHJnYigpIHtcbiAgICBpZiAodGhpcy5zcGFjZSA9PT0gJ3JnYicpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSBpZiAoY2llU3BhY2UodGhpcy5zcGFjZSkpIHtcbiAgICAgIC8vIENvbnZlcnQgdG8gdGhlIHh5eiBjb2xvciBzcGFjZVxuICAgICAgbGV0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgelxuICAgICAgfSA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLnNwYWNlID09PSAnbGFiJyB8fCB0aGlzLnNwYWNlID09PSAnbGNoJykge1xuICAgICAgICAvLyBHZXQgdGhlIHZhbHVlcyBpbiB0aGUgbGFiIHNwYWNlXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgbCxcbiAgICAgICAgICBhLFxuICAgICAgICAgIGJcbiAgICAgICAgfSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMuc3BhY2UgPT09ICdsY2gnKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIGhcbiAgICAgICAgICB9ID0gdGhpcztcbiAgICAgICAgICBjb25zdCBkVG9SID0gTWF0aC5QSSAvIDE4MDtcbiAgICAgICAgICBhID0gYyAqIE1hdGguY29zKGRUb1IgKiBoKTtcbiAgICAgICAgICBiID0gYyAqIE1hdGguc2luKGRUb1IgKiBoKTtcbiAgICAgICAgfSAvLyBVbmRvIHRoZSBub25saW5lYXIgZnVuY3Rpb25cblxuXG4gICAgICAgIGNvbnN0IHlMID0gKGwgKyAxNikgLyAxMTY7XG4gICAgICAgIGNvbnN0IHhMID0gYSAvIDUwMCArIHlMO1xuICAgICAgICBjb25zdCB6TCA9IHlMIC0gYiAvIDIwMDsgLy8gR2V0IHRoZSB4eXogdmFsdWVzXG5cbiAgICAgICAgY29uc3QgY3QgPSAxNiAvIDExNjtcbiAgICAgICAgY29uc3QgbXggPSAwLjAwODg1NjtcbiAgICAgICAgY29uc3Qgbm0gPSA3Ljc4NztcbiAgICAgICAgeCA9IDAuOTUwNDcgKiAoeEwgKiogMyA+IG14ID8geEwgKiogMyA6ICh4TCAtIGN0KSAvIG5tKTtcbiAgICAgICAgeSA9IDEuMDAwMDAgKiAoeUwgKiogMyA+IG14ID8geUwgKiogMyA6ICh5TCAtIGN0KSAvIG5tKTtcbiAgICAgICAgeiA9IDEuMDg4ODMgKiAoekwgKiogMyA+IG14ID8gekwgKiogMyA6ICh6TCAtIGN0KSAvIG5tKTtcbiAgICAgIH0gLy8gQ29udmVydCB4eXogdG8gdW5ib3VuZGVkIHJnYiB2YWx1ZXNcblxuXG4gICAgICBjb25zdCByVSA9IHggKiAzLjI0MDYgKyB5ICogLTEuNTM3MiArIHogKiAtMC40OTg2O1xuICAgICAgY29uc3QgZ1UgPSB4ICogLTAuOTY4OSArIHkgKiAxLjg3NTggKyB6ICogMC4wNDE1O1xuICAgICAgY29uc3QgYlUgPSB4ICogMC4wNTU3ICsgeSAqIC0wLjIwNDAgKyB6ICogMS4wNTcwOyAvLyBDb252ZXJ0IHRoZSB2YWx1ZXMgdG8gdHJ1ZSByZ2IgdmFsdWVzXG5cbiAgICAgIGNvbnN0IHBvdyA9IE1hdGgucG93O1xuICAgICAgY29uc3QgYmQgPSAwLjAwMzEzMDg7XG4gICAgICBjb25zdCByID0gclUgPiBiZCA/IDEuMDU1ICogcG93KHJVLCAxIC8gMi40KSAtIDAuMDU1IDogMTIuOTIgKiByVTtcbiAgICAgIGNvbnN0IGcgPSBnVSA+IGJkID8gMS4wNTUgKiBwb3coZ1UsIDEgLyAyLjQpIC0gMC4wNTUgOiAxMi45MiAqIGdVO1xuICAgICAgY29uc3QgYiA9IGJVID4gYmQgPyAxLjA1NSAqIHBvdyhiVSwgMSAvIDIuNCkgLSAwLjA1NSA6IDEyLjkyICogYlU7IC8vIE1ha2UgYW5kIHJldHVybiB0aGUgY29sb3JcblxuICAgICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IoMjU1ICogciwgMjU1ICogZywgMjU1ICogYik7XG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNwYWNlID09PSAnaHNsJykge1xuICAgICAgLy8gaHR0cHM6Ly9iZ3JpbnMuZ2l0aHViLmlvL1RpbnlDb2xvci9kb2NzL3Rpbnljb2xvci5odG1sXG4gICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgaHNsIHZhbHVlc1xuICAgICAgbGV0IHtcbiAgICAgICAgaCxcbiAgICAgICAgcyxcbiAgICAgICAgbFxuICAgICAgfSA9IHRoaXM7XG4gICAgICBoIC89IDM2MDtcbiAgICAgIHMgLz0gMTAwO1xuICAgICAgbCAvPSAxMDA7IC8vIElmIHdlIGFyZSBncmV5LCB0aGVuIGp1c3QgbWFrZSB0aGUgY29sb3IgZGlyZWN0bHlcblxuICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgbCAqPSAyNTU7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKGwsIGwsIGwpO1xuICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgICB9IC8vIFRPRE8gSSBoYXZlIG5vIGlkZWEgd2hhdCB0aGlzIGRvZXMgOkQgSWYgeW91IGZpZ3VyZSBpdCBvdXQsIHRlbGwgbWUhXG5cblxuICAgICAgY29uc3QgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICBjb25zdCBwID0gMiAqIGwgLSBxOyAvLyBHZXQgdGhlIHJnYiB2YWx1ZXNcblxuICAgICAgY29uc3QgciA9IDI1NSAqIGh1ZVRvUmdiKHAsIHEsIGggKyAxIC8gMyk7XG4gICAgICBjb25zdCBnID0gMjU1ICogaHVlVG9SZ2IocCwgcSwgaCk7XG4gICAgICBjb25zdCBiID0gMjU1ICogaHVlVG9SZ2IocCwgcSwgaCAtIDEgLyAzKTsgLy8gTWFrZSBhIG5ldyBjb2xvclxuXG4gICAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcihyLCBnLCBiKTtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3BhY2UgPT09ICdjbXlrJykge1xuICAgICAgLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZmVsaXBlc2FiaW5vLzUwNjYzMzZcbiAgICAgIC8vIEdldCB0aGUgbm9ybWFsaXNlZCBjbXlrIHZhbHVlc1xuICAgICAgY29uc3Qge1xuICAgICAgICBjLFxuICAgICAgICBtLFxuICAgICAgICB5LFxuICAgICAgICBrXG4gICAgICB9ID0gdGhpczsgLy8gR2V0IHRoZSByZ2IgdmFsdWVzXG5cbiAgICAgIGNvbnN0IHIgPSAyNTUgKiAoMSAtIE1hdGgubWluKDEsIGMgKiAoMSAtIGspICsgaykpO1xuICAgICAgY29uc3QgZyA9IDI1NSAqICgxIC0gTWF0aC5taW4oMSwgbSAqICgxIC0gaykgKyBrKSk7XG4gICAgICBjb25zdCBiID0gMjU1ICogKDEgLSBNYXRoLm1pbigxLCB5ICogKDEgLSBrKSArIGspKTsgLy8gRm9ybSB0aGUgY29sb3IgYW5kIHJldHVybiBpdFxuXG4gICAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcihyLCBnLCBiKTtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdG9BcnJheSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBfYSxcbiAgICAgIF9iLFxuICAgICAgX2MsXG4gICAgICBfZCxcbiAgICAgIHNwYWNlXG4gICAgfSA9IHRoaXM7XG4gICAgcmV0dXJuIFtfYSwgX2IsIF9jLCBfZCwgc3BhY2VdO1xuICB9XG5cbiAgdG9IZXgoKSB7XG4gICAgY29uc3QgW3IsIGcsIGJdID0gdGhpcy5fY2xhbXBlZCgpLm1hcChjb21wb25lbnRIZXgpO1xuXG4gICAgcmV0dXJuIGAjJHtyfSR7Z30ke2J9YDtcbiAgfVxuXG4gIHRvUmdiKCkge1xuICAgIGNvbnN0IFtyViwgZ1YsIGJWXSA9IHRoaXMuX2NsYW1wZWQoKTtcblxuICAgIGNvbnN0IHN0cmluZyA9IGByZ2IoJHtyVn0sJHtnVn0sJHtiVn0pYDtcbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9IZXgoKTtcbiAgfVxuXG4gIHh5eigpIHtcbiAgICAvLyBOb3JtYWxpc2UgdGhlIHJlZCwgZ3JlZW4gYW5kIGJsdWUgdmFsdWVzXG4gICAgY29uc3Qge1xuICAgICAgX2E6IHIyNTUsXG4gICAgICBfYjogZzI1NSxcbiAgICAgIF9jOiBiMjU1XG4gICAgfSA9IHRoaXMucmdiKCk7XG4gICAgY29uc3QgW3IsIGcsIGJdID0gW3IyNTUsIGcyNTUsIGIyNTVdLm1hcCh2ID0+IHYgLyAyNTUpOyAvLyBDb252ZXJ0IHRvIHRoZSBsYWIgcmdiIHNwYWNlXG5cbiAgICBjb25zdCByTCA9IHIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKHIgKyAwLjA1NSkgLyAxLjA1NSwgMi40KSA6IHIgLyAxMi45MjtcbiAgICBjb25zdCBnTCA9IGcgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKGcgKyAwLjA1NSkgLyAxLjA1NSwgMi40KSA6IGcgLyAxMi45MjtcbiAgICBjb25zdCBiTCA9IGIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKGIgKyAwLjA1NSkgLyAxLjA1NSwgMi40KSA6IGIgLyAxMi45MjsgLy8gQ29udmVydCB0byB0aGUgeHl6IGNvbG9yIHNwYWNlIHdpdGhvdXQgYm91bmRpbmcgdGhlIHZhbHVlc1xuXG4gICAgY29uc3QgeFUgPSAockwgKiAwLjQxMjQgKyBnTCAqIDAuMzU3NiArIGJMICogMC4xODA1KSAvIDAuOTUwNDc7XG4gICAgY29uc3QgeVUgPSAockwgKiAwLjIxMjYgKyBnTCAqIDAuNzE1MiArIGJMICogMC4wNzIyKSAvIDEuMDAwMDA7XG4gICAgY29uc3QgelUgPSAockwgKiAwLjAxOTMgKyBnTCAqIDAuMTE5MiArIGJMICogMC45NTA1KSAvIDEuMDg4ODM7IC8vIEdldCB0aGUgcHJvcGVyIHh5eiB2YWx1ZXMgYnkgYXBwbHlpbmcgdGhlIGJvdW5kaW5nXG5cbiAgICBjb25zdCB4ID0geFUgPiAwLjAwODg1NiA/IE1hdGgucG93KHhVLCAxIC8gMykgOiA3Ljc4NyAqIHhVICsgMTYgLyAxMTY7XG4gICAgY29uc3QgeSA9IHlVID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh5VSwgMSAvIDMpIDogNy43ODcgKiB5VSArIDE2IC8gMTE2O1xuICAgIGNvbnN0IHogPSB6VSA+IDAuMDA4ODU2ID8gTWF0aC5wb3coelUsIDEgLyAzKSA6IDcuNzg3ICogelUgKyAxNiAvIDExNjsgLy8gTWFrZSBhbmQgcmV0dXJuIHRoZSBjb2xvclxuXG4gICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IoeCwgeSwgeiwgJ3h5eicpO1xuICAgIHJldHVybiBjb2xvcjtcbiAgfVxuICAvKlxuICBJbnB1dCBhbmQgT3V0cHV0IG1ldGhvZHNcbiAgKi9cblxuXG4gIF9jbGFtcGVkKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIF9hLFxuICAgICAgX2IsXG4gICAgICBfY1xuICAgIH0gPSB0aGlzLnJnYigpO1xuICAgIGNvbnN0IHtcbiAgICAgIG1heCxcbiAgICAgIG1pbixcbiAgICAgIHJvdW5kXG4gICAgfSA9IE1hdGg7XG5cbiAgICBjb25zdCBmb3JtYXQgPSB2ID0+IG1heCgwLCBtaW4ocm91bmQodiksIDI1NSkpO1xuXG4gICAgcmV0dXJuIFtfYSwgX2IsIF9jXS5tYXAoZm9ybWF0KTtcbiAgfVxuICAvKlxuICBDb25zdHJ1Y3RpbmcgY29sb3JzXG4gICovXG5cblxufVxuXG5jbGFzcyBQb2ludCB7XG4gIC8vIEluaXRpYWxpemVcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHRoaXMuaW5pdCguLi5hcmdzKTtcbiAgfSAvLyBDbG9uZSBwb2ludFxuXG5cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzKTtcbiAgfVxuXG4gIGluaXQoeCwgeSkge1xuICAgIGNvbnN0IGJhc2UgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07IC8vIGVuc3VyZSBzb3VyY2UgYXMgb2JqZWN0XG5cbiAgICBjb25zdCBzb3VyY2UgPSBBcnJheS5pc0FycmF5KHgpID8ge1xuICAgICAgeDogeFswXSxcbiAgICAgIHk6IHhbMV1cbiAgICB9IDogdHlwZW9mIHggPT09ICdvYmplY3QnID8ge1xuICAgICAgeDogeC54LFxuICAgICAgeTogeC55XG4gICAgfSA6IHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfTsgLy8gbWVyZ2Ugc291cmNlXG5cbiAgICB0aGlzLnggPSBzb3VyY2UueCA9PSBudWxsID8gYmFzZS54IDogc291cmNlLng7XG4gICAgdGhpcy55ID0gc291cmNlLnkgPT0gbnVsbCA/IGJhc2UueSA6IHNvdXJjZS55O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gW3RoaXMueCwgdGhpcy55XTtcbiAgfVxuXG4gIHRyYW5zZm9ybShtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS50cmFuc2Zvcm1PKG0pO1xuICB9IC8vIFRyYW5zZm9ybSBwb2ludCB3aXRoIG1hdHJpeFxuXG5cbiAgdHJhbnNmb3JtTyhtKSB7XG4gICAgaWYgKCFNYXRyaXguaXNNYXRyaXhMaWtlKG0pKSB7XG4gICAgICBtID0gbmV3IE1hdHJpeChtKTtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSB0aGlzOyAvLyBQZXJmb3JtIHRoZSBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICAgIHRoaXMueCA9IG0uYSAqIHggKyBtLmMgKiB5ICsgbS5lO1xuICAgIHRoaXMueSA9IG0uYiAqIHggKyBtLmQgKiB5ICsgbS5mO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbn1cbmZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgcmV0dXJuIG5ldyBQb2ludCh4LCB5KS50cmFuc2Zvcm1PKHRoaXMuc2NyZWVuQ1RNKCkuaW52ZXJzZU8oKSk7XG59XG5cbmZ1bmN0aW9uIGNsb3NlRW5vdWdoKGEsIGIsIHRocmVzaG9sZCkge1xuICByZXR1cm4gTWF0aC5hYnMoYiAtIGEpIDwgKHRocmVzaG9sZCB8fCAxZS02KTtcbn1cblxuY2xhc3MgTWF0cml4IHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHRoaXMuaW5pdCguLi5hcmdzKTtcbiAgfVxuXG4gIHN0YXRpYyBmb3JtYXRUcmFuc2Zvcm1zKG8pIHtcbiAgICAvLyBHZXQgYWxsIG9mIHRoZSBwYXJhbWV0ZXJzIHJlcXVpcmVkIHRvIGZvcm0gdGhlIG1hdHJpeFxuICAgIGNvbnN0IGZsaXBCb3RoID0gby5mbGlwID09PSAnYm90aCcgfHwgby5mbGlwID09PSB0cnVlO1xuICAgIGNvbnN0IGZsaXBYID0gby5mbGlwICYmIChmbGlwQm90aCB8fCBvLmZsaXAgPT09ICd4JykgPyAtMSA6IDE7XG4gICAgY29uc3QgZmxpcFkgPSBvLmZsaXAgJiYgKGZsaXBCb3RoIHx8IG8uZmxpcCA9PT0gJ3knKSA/IC0xIDogMTtcbiAgICBjb25zdCBza2V3WCA9IG8uc2tldyAmJiBvLnNrZXcubGVuZ3RoID8gby5za2V3WzBdIDogaXNGaW5pdGUoby5za2V3KSA/IG8uc2tldyA6IGlzRmluaXRlKG8uc2tld1gpID8gby5za2V3WCA6IDA7XG4gICAgY29uc3Qgc2tld1kgPSBvLnNrZXcgJiYgby5za2V3Lmxlbmd0aCA/IG8uc2tld1sxXSA6IGlzRmluaXRlKG8uc2tldykgPyBvLnNrZXcgOiBpc0Zpbml0ZShvLnNrZXdZKSA/IG8uc2tld1kgOiAwO1xuICAgIGNvbnN0IHNjYWxlWCA9IG8uc2NhbGUgJiYgby5zY2FsZS5sZW5ndGggPyBvLnNjYWxlWzBdICogZmxpcFggOiBpc0Zpbml0ZShvLnNjYWxlKSA/IG8uc2NhbGUgKiBmbGlwWCA6IGlzRmluaXRlKG8uc2NhbGVYKSA/IG8uc2NhbGVYICogZmxpcFggOiBmbGlwWDtcbiAgICBjb25zdCBzY2FsZVkgPSBvLnNjYWxlICYmIG8uc2NhbGUubGVuZ3RoID8gby5zY2FsZVsxXSAqIGZsaXBZIDogaXNGaW5pdGUoby5zY2FsZSkgPyBvLnNjYWxlICogZmxpcFkgOiBpc0Zpbml0ZShvLnNjYWxlWSkgPyBvLnNjYWxlWSAqIGZsaXBZIDogZmxpcFk7XG4gICAgY29uc3Qgc2hlYXIgPSBvLnNoZWFyIHx8IDA7XG4gICAgY29uc3QgdGhldGEgPSBvLnJvdGF0ZSB8fCBvLnRoZXRhIHx8IDA7XG4gICAgY29uc3Qgb3JpZ2luID0gbmV3IFBvaW50KG8ub3JpZ2luIHx8IG8uYXJvdW5kIHx8IG8ub3ggfHwgby5vcmlnaW5YLCBvLm95IHx8IG8ub3JpZ2luWSk7XG4gICAgY29uc3Qgb3ggPSBvcmlnaW4ueDtcbiAgICBjb25zdCBveSA9IG9yaWdpbi55OyAvLyBXZSBuZWVkIFBvaW50IHRvIGJlIGludmFsaWQgaWYgbm90aGluZyB3YXMgcGFzc2VkIGJlY2F1c2Ugd2UgY2Fubm90IGRlZmF1bHQgdG8gMCBoZXJlLiBUaGF0IGlzIHdoeSBOYU5cblxuICAgIGNvbnN0IHBvc2l0aW9uID0gbmV3IFBvaW50KG8ucG9zaXRpb24gfHwgby5weCB8fCBvLnBvc2l0aW9uWCB8fCBOYU4sIG8ucHkgfHwgby5wb3NpdGlvblkgfHwgTmFOKTtcbiAgICBjb25zdCBweCA9IHBvc2l0aW9uLng7XG4gICAgY29uc3QgcHkgPSBwb3NpdGlvbi55O1xuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IG5ldyBQb2ludChvLnRyYW5zbGF0ZSB8fCBvLnR4IHx8IG8udHJhbnNsYXRlWCwgby50eSB8fCBvLnRyYW5zbGF0ZVkpO1xuICAgIGNvbnN0IHR4ID0gdHJhbnNsYXRlLng7XG4gICAgY29uc3QgdHkgPSB0cmFuc2xhdGUueTtcbiAgICBjb25zdCByZWxhdGl2ZSA9IG5ldyBQb2ludChvLnJlbGF0aXZlIHx8IG8ucnggfHwgby5yZWxhdGl2ZVgsIG8ucnkgfHwgby5yZWxhdGl2ZVkpO1xuICAgIGNvbnN0IHJ4ID0gcmVsYXRpdmUueDtcbiAgICBjb25zdCByeSA9IHJlbGF0aXZlLnk7IC8vIFBvcHVsYXRlIGFsbCBvZiB0aGUgdmFsdWVzXG5cbiAgICByZXR1cm4ge1xuICAgICAgc2NhbGVYLFxuICAgICAgc2NhbGVZLFxuICAgICAgc2tld1gsXG4gICAgICBza2V3WSxcbiAgICAgIHNoZWFyLFxuICAgICAgdGhldGEsXG4gICAgICByeCxcbiAgICAgIHJ5LFxuICAgICAgdHgsXG4gICAgICB0eSxcbiAgICAgIG94LFxuICAgICAgb3ksXG4gICAgICBweCxcbiAgICAgIHB5XG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tQXJyYXkoYSkge1xuICAgIHJldHVybiB7XG4gICAgICBhOiBhWzBdLFxuICAgICAgYjogYVsxXSxcbiAgICAgIGM6IGFbMl0sXG4gICAgICBkOiBhWzNdLFxuICAgICAgZTogYVs0XSxcbiAgICAgIGY6IGFbNV1cbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGlzTWF0cml4TGlrZShvKSB7XG4gICAgcmV0dXJuIG8uYSAhPSBudWxsIHx8IG8uYiAhPSBudWxsIHx8IG8uYyAhPSBudWxsIHx8IG8uZCAhPSBudWxsIHx8IG8uZSAhPSBudWxsIHx8IG8uZiAhPSBudWxsO1xuICB9IC8vIGxlZnQgbWF0cml4LCByaWdodCBtYXRyaXgsIHRhcmdldCBtYXRyaXggd2hpY2ggaXMgb3ZlcndyaXR0ZW5cblxuXG4gIHN0YXRpYyBtYXRyaXhNdWx0aXBseShsLCByLCBvKSB7XG4gICAgLy8gV29yayBvdXQgdGhlIHByb2R1Y3QgZGlyZWN0bHlcbiAgICBjb25zdCBhID0gbC5hICogci5hICsgbC5jICogci5iO1xuICAgIGNvbnN0IGIgPSBsLmIgKiByLmEgKyBsLmQgKiByLmI7XG4gICAgY29uc3QgYyA9IGwuYSAqIHIuYyArIGwuYyAqIHIuZDtcbiAgICBjb25zdCBkID0gbC5iICogci5jICsgbC5kICogci5kO1xuICAgIGNvbnN0IGUgPSBsLmUgKyBsLmEgKiByLmUgKyBsLmMgKiByLmY7XG4gICAgY29uc3QgZiA9IGwuZiArIGwuYiAqIHIuZSArIGwuZCAqIHIuZjsgLy8gbWFrZSBzdXJlIHRvIHVzZSBsb2NhbCB2YXJpYWJsZXMgYmVjYXVzZSBsL3IgYW5kIG8gY291bGQgYmUgdGhlIHNhbWVcblxuICAgIG8uYSA9IGE7XG4gICAgby5iID0gYjtcbiAgICBvLmMgPSBjO1xuICAgIG8uZCA9IGQ7XG4gICAgby5lID0gZTtcbiAgICBvLmYgPSBmO1xuICAgIHJldHVybiBvO1xuICB9XG5cbiAgYXJvdW5kKGN4LCBjeSwgbWF0cml4KSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5hcm91bmRPKGN4LCBjeSwgbWF0cml4KTtcbiAgfSAvLyBUcmFuc2Zvcm0gYXJvdW5kIGEgY2VudGVyIHBvaW50XG5cblxuICBhcm91bmRPKGN4LCBjeSwgbWF0cml4KSB7XG4gICAgY29uc3QgZHggPSBjeCB8fCAwO1xuICAgIGNvbnN0IGR5ID0gY3kgfHwgMDtcbiAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVPKC1keCwgLWR5KS5sbXVsdGlwbHlPKG1hdHJpeCkudHJhbnNsYXRlTyhkeCwgZHkpO1xuICB9IC8vIENsb25lcyB0aGlzIG1hdHJpeFxuXG5cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBNYXRyaXgodGhpcyk7XG4gIH0gLy8gRGVjb21wb3NlcyB0aGlzIG1hdHJpeCBpbnRvIGl0cyBhZmZpbmUgcGFyYW1ldGVyc1xuXG5cbiAgZGVjb21wb3NlKGN4ID0gMCwgY3kgPSAwKSB7XG4gICAgLy8gR2V0IHRoZSBwYXJhbWV0ZXJzIGZyb20gdGhlIG1hdHJpeFxuICAgIGNvbnN0IGEgPSB0aGlzLmE7XG4gICAgY29uc3QgYiA9IHRoaXMuYjtcbiAgICBjb25zdCBjID0gdGhpcy5jO1xuICAgIGNvbnN0IGQgPSB0aGlzLmQ7XG4gICAgY29uc3QgZSA9IHRoaXMuZTtcbiAgICBjb25zdCBmID0gdGhpcy5mOyAvLyBGaWd1cmUgb3V0IGlmIHRoZSB3aW5kaW5nIGRpcmVjdGlvbiBpcyBjbG9ja3dpc2Ugb3IgY291bnRlcmNsb2Nrd2lzZVxuXG4gICAgY29uc3QgZGV0ZXJtaW5hbnQgPSBhICogZCAtIGIgKiBjO1xuICAgIGNvbnN0IGNjdyA9IGRldGVybWluYW50ID4gMCA/IDEgOiAtMTsgLy8gU2luY2Ugd2Ugb25seSBzaGVhciBpbiB4LCB3ZSBjYW4gdXNlIHRoZSB4IGJhc2lzIHRvIGdldCB0aGUgeCBzY2FsZVxuICAgIC8vIGFuZCB0aGUgcm90YXRpb24gb2YgdGhlIHJlc3VsdGluZyBtYXRyaXhcblxuICAgIGNvbnN0IHN4ID0gY2N3ICogTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuICAgIGNvbnN0IHRoZXRhUmFkID0gTWF0aC5hdGFuMihjY3cgKiBiLCBjY3cgKiBhKTtcbiAgICBjb25zdCB0aGV0YSA9IDE4MCAvIE1hdGguUEkgKiB0aGV0YVJhZDtcbiAgICBjb25zdCBjdCA9IE1hdGguY29zKHRoZXRhUmFkKTtcbiAgICBjb25zdCBzdCA9IE1hdGguc2luKHRoZXRhUmFkKTsgLy8gV2UgY2FuIHRoZW4gc29sdmUgdGhlIHkgYmFzaXMgdmVjdG9yIHNpbXVsdGFuZW91c2x5IHRvIGdldCB0aGUgb3RoZXJcbiAgICAvLyB0d28gYWZmaW5lIHBhcmFtZXRlcnMgZGlyZWN0bHkgZnJvbSB0aGVzZSBwYXJhbWV0ZXJzXG5cbiAgICBjb25zdCBsYW0gPSAoYSAqIGMgKyBiICogZCkgLyBkZXRlcm1pbmFudDtcbiAgICBjb25zdCBzeSA9IGMgKiBzeCAvIChsYW0gKiBhIC0gYikgfHwgZCAqIHN4IC8gKGxhbSAqIGIgKyBhKTsgLy8gVXNlIHRoZSB0cmFuc2xhdGlvbnNcblxuICAgIGNvbnN0IHR4ID0gZSAtIGN4ICsgY3ggKiBjdCAqIHN4ICsgY3kgKiAobGFtICogY3QgKiBzeCAtIHN0ICogc3kpO1xuICAgIGNvbnN0IHR5ID0gZiAtIGN5ICsgY3ggKiBzdCAqIHN4ICsgY3kgKiAobGFtICogc3QgKiBzeCArIGN0ICogc3kpOyAvLyBDb25zdHJ1Y3QgdGhlIGRlY29tcG9zaXRpb24gYW5kIHJldHVybiBpdFxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFJldHVybiB0aGUgYWZmaW5lIHBhcmFtZXRlcnNcbiAgICAgIHNjYWxlWDogc3gsXG4gICAgICBzY2FsZVk6IHN5LFxuICAgICAgc2hlYXI6IGxhbSxcbiAgICAgIHJvdGF0ZTogdGhldGEsXG4gICAgICB0cmFuc2xhdGVYOiB0eCxcbiAgICAgIHRyYW5zbGF0ZVk6IHR5LFxuICAgICAgb3JpZ2luWDogY3gsXG4gICAgICBvcmlnaW5ZOiBjeSxcbiAgICAgIC8vIFJldHVybiB0aGUgbWF0cml4IHBhcmFtZXRlcnNcbiAgICAgIGE6IHRoaXMuYSxcbiAgICAgIGI6IHRoaXMuYixcbiAgICAgIGM6IHRoaXMuYyxcbiAgICAgIGQ6IHRoaXMuZCxcbiAgICAgIGU6IHRoaXMuZSxcbiAgICAgIGY6IHRoaXMuZlxuICAgIH07XG4gIH0gLy8gQ2hlY2sgaWYgdHdvIG1hdHJpY2VzIGFyZSBlcXVhbFxuXG5cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKG90aGVyID09PSB0aGlzKSByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBjb21wID0gbmV3IE1hdHJpeChvdGhlcik7XG4gICAgcmV0dXJuIGNsb3NlRW5vdWdoKHRoaXMuYSwgY29tcC5hKSAmJiBjbG9zZUVub3VnaCh0aGlzLmIsIGNvbXAuYikgJiYgY2xvc2VFbm91Z2godGhpcy5jLCBjb21wLmMpICYmIGNsb3NlRW5vdWdoKHRoaXMuZCwgY29tcC5kKSAmJiBjbG9zZUVub3VnaCh0aGlzLmUsIGNvbXAuZSkgJiYgY2xvc2VFbm91Z2godGhpcy5mLCBjb21wLmYpO1xuICB9IC8vIEZsaXAgbWF0cml4IG9uIHggb3IgeSwgYXQgYSBnaXZlbiBvZmZzZXRcblxuXG4gIGZsaXAoYXhpcywgYXJvdW5kKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5mbGlwTyhheGlzLCBhcm91bmQpO1xuICB9XG5cbiAgZmxpcE8oYXhpcywgYXJvdW5kKSB7XG4gICAgcmV0dXJuIGF4aXMgPT09ICd4JyA/IHRoaXMuc2NhbGVPKC0xLCAxLCBhcm91bmQsIDApIDogYXhpcyA9PT0gJ3knID8gdGhpcy5zY2FsZU8oMSwgLTEsIDAsIGFyb3VuZCkgOiB0aGlzLnNjYWxlTygtMSwgLTEsIGF4aXMsIGFyb3VuZCB8fCBheGlzKTsgLy8gRGVmaW5lIGFuIHgsIHkgZmxpcCBwb2ludFxuICB9IC8vIEluaXRpYWxpemVcblxuXG4gIGluaXQoc291cmNlKSB7XG4gICAgY29uc3QgYmFzZSA9IE1hdHJpeC5mcm9tQXJyYXkoWzEsIDAsIDAsIDEsIDAsIDBdKTsgLy8gZW5zdXJlIHNvdXJjZSBhcyBvYmplY3RcblxuICAgIHNvdXJjZSA9IHNvdXJjZSBpbnN0YW5jZW9mIEVsZW1lbnQgPyBzb3VyY2UubWF0cml4aWZ5KCkgOiB0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyA/IE1hdHJpeC5mcm9tQXJyYXkoc291cmNlLnNwbGl0KGRlbGltaXRlcikubWFwKHBhcnNlRmxvYXQpKSA6IEFycmF5LmlzQXJyYXkoc291cmNlKSA/IE1hdHJpeC5mcm9tQXJyYXkoc291cmNlKSA6IHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnICYmIE1hdHJpeC5pc01hdHJpeExpa2Uoc291cmNlKSA/IHNvdXJjZSA6IHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnID8gbmV3IE1hdHJpeCgpLnRyYW5zZm9ybShzb3VyY2UpIDogYXJndW1lbnRzLmxlbmd0aCA9PT0gNiA/IE1hdHJpeC5mcm9tQXJyYXkoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKSA6IGJhc2U7IC8vIE1lcmdlIHRoZSBzb3VyY2UgbWF0cml4IHdpdGggdGhlIGJhc2UgbWF0cml4XG5cbiAgICB0aGlzLmEgPSBzb3VyY2UuYSAhPSBudWxsID8gc291cmNlLmEgOiBiYXNlLmE7XG4gICAgdGhpcy5iID0gc291cmNlLmIgIT0gbnVsbCA/IHNvdXJjZS5iIDogYmFzZS5iO1xuICAgIHRoaXMuYyA9IHNvdXJjZS5jICE9IG51bGwgPyBzb3VyY2UuYyA6IGJhc2UuYztcbiAgICB0aGlzLmQgPSBzb3VyY2UuZCAhPSBudWxsID8gc291cmNlLmQgOiBiYXNlLmQ7XG4gICAgdGhpcy5lID0gc291cmNlLmUgIT0gbnVsbCA/IHNvdXJjZS5lIDogYmFzZS5lO1xuICAgIHRoaXMuZiA9IHNvdXJjZS5mICE9IG51bGwgPyBzb3VyY2UuZiA6IGJhc2UuZjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGludmVyc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbnZlcnNlTygpO1xuICB9IC8vIEludmVyc2VzIG1hdHJpeFxuXG5cbiAgaW52ZXJzZU8oKSB7XG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IHBhcmFtZXRlcnMgb3V0IG9mIHRoZSBtYXRyaXhcbiAgICBjb25zdCBhID0gdGhpcy5hO1xuICAgIGNvbnN0IGIgPSB0aGlzLmI7XG4gICAgY29uc3QgYyA9IHRoaXMuYztcbiAgICBjb25zdCBkID0gdGhpcy5kO1xuICAgIGNvbnN0IGUgPSB0aGlzLmU7XG4gICAgY29uc3QgZiA9IHRoaXMuZjsgLy8gSW52ZXJ0IHRoZSAyeDIgbWF0cml4IGluIHRoZSB0b3AgbGVmdFxuXG4gICAgY29uc3QgZGV0ID0gYSAqIGQgLSBiICogYztcbiAgICBpZiAoIWRldCkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52ZXJ0ICcgKyB0aGlzKTsgLy8gQ2FsY3VsYXRlIHRoZSB0b3AgMngyIG1hdHJpeFxuXG4gICAgY29uc3QgbmEgPSBkIC8gZGV0O1xuICAgIGNvbnN0IG5iID0gLWIgLyBkZXQ7XG4gICAgY29uc3QgbmMgPSAtYyAvIGRldDtcbiAgICBjb25zdCBuZCA9IGEgLyBkZXQ7IC8vIEFwcGx5IHRoZSBpbnZlcnRlZCBtYXRyaXggdG8gdGhlIHRvcCByaWdodFxuXG4gICAgY29uc3QgbmUgPSAtKG5hICogZSArIG5jICogZik7XG4gICAgY29uc3QgbmYgPSAtKG5iICogZSArIG5kICogZik7IC8vIENvbnN0cnVjdCB0aGUgaW52ZXJ0ZWQgbWF0cml4XG5cbiAgICB0aGlzLmEgPSBuYTtcbiAgICB0aGlzLmIgPSBuYjtcbiAgICB0aGlzLmMgPSBuYztcbiAgICB0aGlzLmQgPSBuZDtcbiAgICB0aGlzLmUgPSBuZTtcbiAgICB0aGlzLmYgPSBuZjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxtdWx0aXBseShtYXRyaXgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmxtdWx0aXBseU8obWF0cml4KTtcbiAgfVxuXG4gIGxtdWx0aXBseU8obWF0cml4KSB7XG4gICAgY29uc3QgciA9IHRoaXM7XG4gICAgY29uc3QgbCA9IG1hdHJpeCBpbnN0YW5jZW9mIE1hdHJpeCA/IG1hdHJpeCA6IG5ldyBNYXRyaXgobWF0cml4KTtcbiAgICByZXR1cm4gTWF0cml4Lm1hdHJpeE11bHRpcGx5KGwsIHIsIHRoaXMpO1xuICB9IC8vIExlZnQgbXVsdGlwbGllcyBieSB0aGUgZ2l2ZW4gbWF0cml4XG5cblxuICBtdWx0aXBseShtYXRyaXgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLm11bHRpcGx5TyhtYXRyaXgpO1xuICB9XG5cbiAgbXVsdGlwbHlPKG1hdHJpeCkge1xuICAgIC8vIEdldCB0aGUgbWF0cmljZXNcbiAgICBjb25zdCBsID0gdGhpcztcbiAgICBjb25zdCByID0gbWF0cml4IGluc3RhbmNlb2YgTWF0cml4ID8gbWF0cml4IDogbmV3IE1hdHJpeChtYXRyaXgpO1xuICAgIHJldHVybiBNYXRyaXgubWF0cml4TXVsdGlwbHkobCwgciwgdGhpcyk7XG4gIH0gLy8gUm90YXRlIG1hdHJpeFxuXG5cbiAgcm90YXRlKHIsIGN4LCBjeSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkucm90YXRlTyhyLCBjeCwgY3kpO1xuICB9XG5cbiAgcm90YXRlTyhyLCBjeCA9IDAsIGN5ID0gMCkge1xuICAgIC8vIENvbnZlcnQgZGVncmVlcyB0byByYWRpYW5zXG4gICAgciA9IHJhZGlhbnMocik7XG4gICAgY29uc3QgY29zID0gTWF0aC5jb3Mocik7XG4gICAgY29uc3Qgc2luID0gTWF0aC5zaW4ocik7XG4gICAgY29uc3Qge1xuICAgICAgYSxcbiAgICAgIGIsXG4gICAgICBjLFxuICAgICAgZCxcbiAgICAgIGUsXG4gICAgICBmXG4gICAgfSA9IHRoaXM7XG4gICAgdGhpcy5hID0gYSAqIGNvcyAtIGIgKiBzaW47XG4gICAgdGhpcy5iID0gYiAqIGNvcyArIGEgKiBzaW47XG4gICAgdGhpcy5jID0gYyAqIGNvcyAtIGQgKiBzaW47XG4gICAgdGhpcy5kID0gZCAqIGNvcyArIGMgKiBzaW47XG4gICAgdGhpcy5lID0gZSAqIGNvcyAtIGYgKiBzaW4gKyBjeSAqIHNpbiAtIGN4ICogY29zICsgY3g7XG4gICAgdGhpcy5mID0gZiAqIGNvcyArIGUgKiBzaW4gLSBjeCAqIHNpbiAtIGN5ICogY29zICsgY3k7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gU2NhbGUgbWF0cml4XG5cblxuICBzY2FsZSh4LCB5LCBjeCwgY3kpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnNjYWxlTyguLi5hcmd1bWVudHMpO1xuICB9XG5cbiAgc2NhbGVPKHgsIHkgPSB4LCBjeCA9IDAsIGN5ID0gMCkge1xuICAgIC8vIFN1cHBvcnQgdW5pZm9ybSBzY2FsaW5nXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGN5ID0gY3g7XG4gICAgICBjeCA9IHk7XG4gICAgICB5ID0geDtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBhLFxuICAgICAgYixcbiAgICAgIGMsXG4gICAgICBkLFxuICAgICAgZSxcbiAgICAgIGZcbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLmEgPSBhICogeDtcbiAgICB0aGlzLmIgPSBiICogeTtcbiAgICB0aGlzLmMgPSBjICogeDtcbiAgICB0aGlzLmQgPSBkICogeTtcbiAgICB0aGlzLmUgPSBlICogeCAtIGN4ICogeCArIGN4O1xuICAgIHRoaXMuZiA9IGYgKiB5IC0gY3kgKiB5ICsgY3k7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gU2hlYXIgbWF0cml4XG5cblxuICBzaGVhcihhLCBjeCwgY3kpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnNoZWFyTyhhLCBjeCwgY3kpO1xuICB9XG5cbiAgc2hlYXJPKGx4LCBjeCA9IDAsIGN5ID0gMCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGEsXG4gICAgICBiLFxuICAgICAgYyxcbiAgICAgIGQsXG4gICAgICBlLFxuICAgICAgZlxuICAgIH0gPSB0aGlzO1xuICAgIHRoaXMuYSA9IGEgKyBiICogbHg7XG4gICAgdGhpcy5jID0gYyArIGQgKiBseDtcbiAgICB0aGlzLmUgPSBlICsgZiAqIGx4IC0gY3kgKiBseDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBTa2V3IE1hdHJpeFxuXG5cbiAgc2tldyh4LCB5LCBjeCwgY3kpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnNrZXdPKC4uLmFyZ3VtZW50cyk7XG4gIH1cblxuICBza2V3Tyh4LCB5ID0geCwgY3ggPSAwLCBjeSA9IDApIHtcbiAgICAvLyBzdXBwb3J0IHVuaWZvcm1hbCBza2V3XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGN5ID0gY3g7XG4gICAgICBjeCA9IHk7XG4gICAgICB5ID0geDtcbiAgICB9IC8vIENvbnZlcnQgZGVncmVlcyB0byByYWRpYW5zXG5cblxuICAgIHggPSByYWRpYW5zKHgpO1xuICAgIHkgPSByYWRpYW5zKHkpO1xuICAgIGNvbnN0IGx4ID0gTWF0aC50YW4oeCk7XG4gICAgY29uc3QgbHkgPSBNYXRoLnRhbih5KTtcbiAgICBjb25zdCB7XG4gICAgICBhLFxuICAgICAgYixcbiAgICAgIGMsXG4gICAgICBkLFxuICAgICAgZSxcbiAgICAgIGZcbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLmEgPSBhICsgYiAqIGx4O1xuICAgIHRoaXMuYiA9IGIgKyBhICogbHk7XG4gICAgdGhpcy5jID0gYyArIGQgKiBseDtcbiAgICB0aGlzLmQgPSBkICsgYyAqIGx5O1xuICAgIHRoaXMuZSA9IGUgKyBmICogbHggLSBjeSAqIGx4O1xuICAgIHRoaXMuZiA9IGYgKyBlICogbHkgLSBjeCAqIGx5O1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIFNrZXdYXG5cblxuICBza2V3WCh4LCBjeCwgY3kpIHtcbiAgICByZXR1cm4gdGhpcy5za2V3KHgsIDAsIGN4LCBjeSk7XG4gIH0gLy8gU2tld1lcblxuXG4gIHNrZXdZKHksIGN4LCBjeSkge1xuICAgIHJldHVybiB0aGlzLnNrZXcoMCwgeSwgY3gsIGN5KTtcbiAgfVxuXG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIFt0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCB0aGlzLmQsIHRoaXMuZSwgdGhpcy5mXTtcbiAgfSAvLyBDb252ZXJ0IG1hdHJpeCB0byBzdHJpbmdcblxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnbWF0cml4KCcgKyB0aGlzLmEgKyAnLCcgKyB0aGlzLmIgKyAnLCcgKyB0aGlzLmMgKyAnLCcgKyB0aGlzLmQgKyAnLCcgKyB0aGlzLmUgKyAnLCcgKyB0aGlzLmYgKyAnKSc7XG4gIH0gLy8gVHJhbnNmb3JtIGEgbWF0cml4IGludG8gYW5vdGhlciBtYXRyaXggYnkgbWFuaXB1bGF0aW5nIHRoZSBzcGFjZVxuXG5cbiAgdHJhbnNmb3JtKG8pIHtcbiAgICAvLyBDaGVjayBpZiBvIGlzIGEgbWF0cml4IGFuZCB0aGVuIGxlZnQgbXVsdGlwbHkgaXQgZGlyZWN0bHlcbiAgICBpZiAoTWF0cml4LmlzTWF0cml4TGlrZShvKSkge1xuICAgICAgY29uc3QgbWF0cml4ID0gbmV3IE1hdHJpeChvKTtcbiAgICAgIHJldHVybiBtYXRyaXgubXVsdGlwbHlPKHRoaXMpO1xuICAgIH0gLy8gR2V0IHRoZSBwcm9wb3NlZCB0cmFuc2Zvcm1hdGlvbnMgYW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uc1xuXG5cbiAgICBjb25zdCB0ID0gTWF0cml4LmZvcm1hdFRyYW5zZm9ybXMobyk7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgeDogb3gsXG4gICAgICB5OiBveVxuICAgIH0gPSBuZXcgUG9pbnQodC5veCwgdC5veSkudHJhbnNmb3JtKGN1cnJlbnQpOyAvLyBDb25zdHJ1Y3QgdGhlIHJlc3VsdGluZyBtYXRyaXhcblxuICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gbmV3IE1hdHJpeCgpLnRyYW5zbGF0ZU8odC5yeCwgdC5yeSkubG11bHRpcGx5TyhjdXJyZW50KS50cmFuc2xhdGVPKC1veCwgLW95KS5zY2FsZU8odC5zY2FsZVgsIHQuc2NhbGVZKS5za2V3Tyh0LnNrZXdYLCB0LnNrZXdZKS5zaGVhck8odC5zaGVhcikucm90YXRlTyh0LnRoZXRhKS50cmFuc2xhdGVPKG94LCBveSk7IC8vIElmIHdlIHdhbnQgdGhlIG9yaWdpbiBhdCBhIHBhcnRpY3VsYXIgcGxhY2UsIHdlIGZvcmNlIGl0IHRoZXJlXG5cbiAgICBpZiAoaXNGaW5pdGUodC5weCkgfHwgaXNGaW5pdGUodC5weSkpIHtcbiAgICAgIGNvbnN0IG9yaWdpbiA9IG5ldyBQb2ludChveCwgb3kpLnRyYW5zZm9ybSh0cmFuc2Zvcm1lcik7IC8vIFRPRE86IFJlcGxhY2UgdC5weCB3aXRoIGlzRmluaXRlKHQucHgpXG4gICAgICAvLyBEb2Vzbid0IHdvcmsgYmVjYXVzZSB0LnB4IGlzIGFsc28gMCBpZiBpdCB3YXNuJ3QgcGFzc2VkXG5cbiAgICAgIGNvbnN0IGR4ID0gaXNGaW5pdGUodC5weCkgPyB0LnB4IC0gb3JpZ2luLnggOiAwO1xuICAgICAgY29uc3QgZHkgPSBpc0Zpbml0ZSh0LnB5KSA/IHQucHkgLSBvcmlnaW4ueSA6IDA7XG4gICAgICB0cmFuc2Zvcm1lci50cmFuc2xhdGVPKGR4LCBkeSk7XG4gICAgfSAvLyBUcmFuc2xhdGUgbm93IGFmdGVyIHBvc2l0aW9uaW5nXG5cblxuICAgIHRyYW5zZm9ybWVyLnRyYW5zbGF0ZU8odC50eCwgdC50eSk7XG4gICAgcmV0dXJuIHRyYW5zZm9ybWVyO1xuICB9IC8vIFRyYW5zbGF0ZSBtYXRyaXhcblxuXG4gIHRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS50cmFuc2xhdGVPKHgsIHkpO1xuICB9XG5cbiAgdHJhbnNsYXRlTyh4LCB5KSB7XG4gICAgdGhpcy5lICs9IHggfHwgMDtcbiAgICB0aGlzLmYgKz0geSB8fCAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFsdWVPZigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYTogdGhpcy5hLFxuICAgICAgYjogdGhpcy5iLFxuICAgICAgYzogdGhpcy5jLFxuICAgICAgZDogdGhpcy5kLFxuICAgICAgZTogdGhpcy5lLFxuICAgICAgZjogdGhpcy5mXG4gICAgfTtcbiAgfVxuXG59XG5mdW5jdGlvbiBjdG0oKSB7XG4gIHJldHVybiBuZXcgTWF0cml4KHRoaXMubm9kZS5nZXRDVE0oKSk7XG59XG5mdW5jdGlvbiBzY3JlZW5DVE0oKSB7XG4gIC8qIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzNDQ1MzdcbiAgICAgVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSBGRiBkb2VzIG5vdCByZXR1cm4gdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuICAgICBmb3IgdGhlIGlubmVyIGNvb3JkaW5hdGUgc3lzdGVtIHdoZW4gZ2V0U2NyZWVuQ1RNKCkgaXMgY2FsbGVkIG9uIG5lc3RlZCBzdmdzLlxuICAgICBIb3dldmVyIGFsbCBvdGhlciBCcm93c2VycyBkbyB0aGF0ICovXG4gIGlmICh0eXBlb2YgdGhpcy5pc1Jvb3QgPT09ICdmdW5jdGlvbicgJiYgIXRoaXMuaXNSb290KCkpIHtcbiAgICBjb25zdCByZWN0ID0gdGhpcy5yZWN0KDEsIDEpO1xuICAgIGNvbnN0IG0gPSByZWN0Lm5vZGUuZ2V0U2NyZWVuQ1RNKCk7XG4gICAgcmVjdC5yZW1vdmUoKTtcbiAgICByZXR1cm4gbmV3IE1hdHJpeChtKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgTWF0cml4KHRoaXMubm9kZS5nZXRTY3JlZW5DVE0oKSk7XG59XG5yZWdpc3RlcihNYXRyaXgsICdNYXRyaXgnKTtcblxuZnVuY3Rpb24gcGFyc2VyKCkge1xuICAvLyBSZXVzZSBjYWNoZWQgZWxlbWVudCBpZiBwb3NzaWJsZVxuICBpZiAoIXBhcnNlci5ub2Rlcykge1xuICAgIGNvbnN0IHN2ZyA9IG1ha2VJbnN0YW5jZSgpLnNpemUoMiwgMCk7XG4gICAgc3ZnLm5vZGUuc3R5bGUuY3NzVGV4dCA9IFsnb3BhY2l0eTogMCcsICdwb3NpdGlvbjogYWJzb2x1dGUnLCAnbGVmdDogLTEwMCUnLCAndG9wOiAtMTAwJScsICdvdmVyZmxvdzogaGlkZGVuJ10uam9pbignOycpO1xuICAgIHN2Zy5hdHRyKCdmb2N1c2FibGUnLCAnZmFsc2UnKTtcbiAgICBzdmcuYXR0cignYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgIGNvbnN0IHBhdGggPSBzdmcucGF0aCgpLm5vZGU7XG4gICAgcGFyc2VyLm5vZGVzID0ge1xuICAgICAgc3ZnLFxuICAgICAgcGF0aFxuICAgIH07XG4gIH1cblxuICBpZiAoIXBhcnNlci5ub2Rlcy5zdmcubm9kZS5wYXJlbnROb2RlKSB7XG4gICAgY29uc3QgYiA9IGdsb2JhbHMuZG9jdW1lbnQuYm9keSB8fCBnbG9iYWxzLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICBwYXJzZXIubm9kZXMuc3ZnLmFkZFRvKGIpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlci5ub2Rlcztcbn1cblxuZnVuY3Rpb24gaXNOdWxsZWRCb3goYm94KSB7XG4gIHJldHVybiAhYm94LndpZHRoICYmICFib3guaGVpZ2h0ICYmICFib3gueCAmJiAhYm94Lnk7XG59XG5mdW5jdGlvbiBkb21Db250YWlucyhub2RlKSB7XG4gIHJldHVybiBub2RlID09PSBnbG9iYWxzLmRvY3VtZW50IHx8IChnbG9iYWxzLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyB8fCBmdW5jdGlvbiAobm9kZSkge1xuICAgIC8vIFRoaXMgaXMgSUUgLSBpdCBkb2VzIG5vdCBzdXBwb3J0IGNvbnRhaW5zKCkgZm9yIHRvcC1sZXZlbCBTVkdzXG4gICAgd2hpbGUgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZSA9PT0gZ2xvYmFscy5kb2N1bWVudDtcbiAgfSkuY2FsbChnbG9iYWxzLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgbm9kZSk7XG59XG5jbGFzcyBCb3gge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgdGhpcy5pbml0KC4uLmFyZ3MpO1xuICB9XG5cbiAgYWRkT2Zmc2V0KCkge1xuICAgIC8vIG9mZnNldCBieSB3aW5kb3cgc2Nyb2xsIHBvc2l0aW9uLCBiZWNhdXNlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBjaGFuZ2VzIHdoZW4gd2luZG93IGlzIHNjcm9sbGVkXG4gICAgdGhpcy54ICs9IGdsb2JhbHMud2luZG93LnBhZ2VYT2Zmc2V0O1xuICAgIHRoaXMueSArPSBnbG9iYWxzLndpbmRvdy5wYWdlWU9mZnNldDtcbiAgICByZXR1cm4gbmV3IEJveCh0aGlzKTtcbiAgfVxuXG4gIGluaXQoc291cmNlKSB7XG4gICAgY29uc3QgYmFzZSA9IFswLCAwLCAwLCAwXTtcbiAgICBzb3VyY2UgPSB0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyA/IHNvdXJjZS5zcGxpdChkZWxpbWl0ZXIpLm1hcChwYXJzZUZsb2F0KSA6IEFycmF5LmlzQXJyYXkoc291cmNlKSA/IHNvdXJjZSA6IHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnID8gW3NvdXJjZS5sZWZ0ICE9IG51bGwgPyBzb3VyY2UubGVmdCA6IHNvdXJjZS54LCBzb3VyY2UudG9wICE9IG51bGwgPyBzb3VyY2UudG9wIDogc291cmNlLnksIHNvdXJjZS53aWR0aCwgc291cmNlLmhlaWdodF0gOiBhcmd1bWVudHMubGVuZ3RoID09PSA0ID8gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpIDogYmFzZTtcbiAgICB0aGlzLnggPSBzb3VyY2VbMF0gfHwgMDtcbiAgICB0aGlzLnkgPSBzb3VyY2VbMV0gfHwgMDtcbiAgICB0aGlzLndpZHRoID0gdGhpcy53ID0gc291cmNlWzJdIHx8IDA7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmggPSBzb3VyY2VbM10gfHwgMDsgLy8gQWRkIG1vcmUgYm91bmRpbmcgYm94IHByb3BlcnRpZXNcblxuICAgIHRoaXMueDIgPSB0aGlzLnggKyB0aGlzLnc7XG4gICAgdGhpcy55MiA9IHRoaXMueSArIHRoaXMuaDtcbiAgICB0aGlzLmN4ID0gdGhpcy54ICsgdGhpcy53IC8gMjtcbiAgICB0aGlzLmN5ID0gdGhpcy55ICsgdGhpcy5oIC8gMjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlzTnVsbGVkKCkge1xuICAgIHJldHVybiBpc051bGxlZEJveCh0aGlzKTtcbiAgfSAvLyBNZXJnZSByZWN0IGJveCB3aXRoIGFub3RoZXIsIHJldHVybiBhIG5ldyBpbnN0YW5jZVxuXG5cbiAgbWVyZ2UoYm94KSB7XG4gICAgY29uc3QgeCA9IE1hdGgubWluKHRoaXMueCwgYm94LngpO1xuICAgIGNvbnN0IHkgPSBNYXRoLm1pbih0aGlzLnksIGJveC55KTtcbiAgICBjb25zdCB3aWR0aCA9IE1hdGgubWF4KHRoaXMueCArIHRoaXMud2lkdGgsIGJveC54ICsgYm94LndpZHRoKSAtIHg7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5tYXgodGhpcy55ICsgdGhpcy5oZWlnaHQsIGJveC55ICsgYm94LmhlaWdodCkgLSB5O1xuICAgIHJldHVybiBuZXcgQm94KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICB9XG5cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gW3RoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodF07XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy54ICsgJyAnICsgdGhpcy55ICsgJyAnICsgdGhpcy53aWR0aCArICcgJyArIHRoaXMuaGVpZ2h0O1xuICB9XG5cbiAgdHJhbnNmb3JtKG0pIHtcbiAgICBpZiAoIShtIGluc3RhbmNlb2YgTWF0cml4KSkge1xuICAgICAgbSA9IG5ldyBNYXRyaXgobSk7XG4gICAgfVxuXG4gICAgbGV0IHhNaW4gPSBJbmZpbml0eTtcbiAgICBsZXQgeE1heCA9IC1JbmZpbml0eTtcbiAgICBsZXQgeU1pbiA9IEluZmluaXR5O1xuICAgIGxldCB5TWF4ID0gLUluZmluaXR5O1xuICAgIGNvbnN0IHB0cyA9IFtuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpLCBuZXcgUG9pbnQodGhpcy54MiwgdGhpcy55KSwgbmV3IFBvaW50KHRoaXMueCwgdGhpcy55MiksIG5ldyBQb2ludCh0aGlzLngyLCB0aGlzLnkyKV07XG4gICAgcHRzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgIHAgPSBwLnRyYW5zZm9ybShtKTtcbiAgICAgIHhNaW4gPSBNYXRoLm1pbih4TWluLCBwLngpO1xuICAgICAgeE1heCA9IE1hdGgubWF4KHhNYXgsIHAueCk7XG4gICAgICB5TWluID0gTWF0aC5taW4oeU1pbiwgcC55KTtcbiAgICAgIHlNYXggPSBNYXRoLm1heCh5TWF4LCBwLnkpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgQm94KHhNaW4sIHlNaW4sIHhNYXggLSB4TWluLCB5TWF4IC0geU1pbik7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBnZXRCb3goZWwsIGdldEJCb3hGbiwgcmV0cnkpIHtcbiAgbGV0IGJveDtcblxuICB0cnkge1xuICAgIC8vIFRyeSB0byBnZXQgdGhlIGJveCB3aXRoIHRoZSBwcm92aWRlZCBmdW5jdGlvblxuICAgIGJveCA9IGdldEJCb3hGbihlbC5ub2RlKTsgLy8gSWYgdGhlIGJveCBpcyB3b3J0aGxlc3MgYW5kIG5vdCBldmVuIGluIHRoZSBkb20sIHJldHJ5XG4gICAgLy8gYnkgdGhyb3dpbmcgYW4gZXJyb3IgaGVyZS4uLlxuXG4gICAgaWYgKGlzTnVsbGVkQm94KGJveCkgJiYgIWRvbUNvbnRhaW5zKGVsLm5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VsZW1lbnQgbm90IGluIHRoZSBkb20nKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyAuLi4gYW5kIGNhbGxpbmcgdGhlIHJldHJ5IGhhbmRsZXIgaGVyZVxuICAgIGJveCA9IHJldHJ5KGVsKTtcbiAgfVxuXG4gIHJldHVybiBib3g7XG59XG5cbmZ1bmN0aW9uIGJib3goKSB7XG4gIC8vIEZ1bmN0aW9uIHRvIGdldCBiYm94IGlzIGdldEJCb3goKVxuICBjb25zdCBnZXRCQm94ID0gbm9kZSA9PiBub2RlLmdldEJCb3goKTsgLy8gVGFrZSBhbGwgbWVhc3VyZXMgc28gdGhhdCBhIHN0dXBpZCBicm93c2VyIHJlbmRlcnMgdGhlIGVsZW1lbnRcbiAgLy8gc28gd2UgY2FuIGdldCB0aGUgYmJveCBmcm9tIGl0IHdoZW4gd2UgdHJ5IGFnYWluXG5cblxuICBjb25zdCByZXRyeSA9IGVsID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY2xvbmUgPSBlbC5jbG9uZSgpLmFkZFRvKHBhcnNlcigpLnN2Zykuc2hvdygpO1xuICAgICAgY29uc3QgYm94ID0gY2xvbmUubm9kZS5nZXRCQm94KCk7XG4gICAgICBjbG9uZS5yZW1vdmUoKTtcbiAgICAgIHJldHVybiBib3g7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gV2UgZ2l2ZSB1cC4uLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBHZXR0aW5nIGJib3ggb2YgZWxlbWVudCBcIiR7ZWwubm9kZS5ub2RlTmFtZX1cIiBpcyBub3QgcG9zc2libGU6ICR7ZS50b1N0cmluZygpfWApO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBib3ggPSBnZXRCb3godGhpcywgZ2V0QkJveCwgcmV0cnkpO1xuICBjb25zdCBiYm94ID0gbmV3IEJveChib3gpO1xuICByZXR1cm4gYmJveDtcbn1cbmZ1bmN0aW9uIHJib3goZWwpIHtcbiAgY29uc3QgZ2V0UkJveCA9IG5vZGUgPT4gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICBjb25zdCByZXRyeSA9IGVsID0+IHtcbiAgICAvLyBUaGVyZSBpcyBubyBwb2ludCBpbiB0cnlpbmcgdHJpY2tzIGhlcmUgYmVjYXVzZSBpZiB3ZSBpbnNlcnQgdGhlIGVsZW1lbnQgaW50byB0aGUgZG9tIG91cnNlbHZlc1xuICAgIC8vIGl0IG9idmlvdXNseSB3aWxsIGJlIGF0IHRoZSB3cm9uZyBwb3NpdGlvblxuICAgIHRocm93IG5ldyBFcnJvcihgR2V0dGluZyByYm94IG9mIGVsZW1lbnQgXCIke2VsLm5vZGUubm9kZU5hbWV9XCIgaXMgbm90IHBvc3NpYmxlYCk7XG4gIH07XG5cbiAgY29uc3QgYm94ID0gZ2V0Qm94KHRoaXMsIGdldFJCb3gsIHJldHJ5KTtcbiAgY29uc3QgcmJveCA9IG5ldyBCb3goYm94KTsgLy8gSWYgYW4gZWxlbWVudCB3YXMgcGFzc2VkLCB3ZSB3YW50IHRoZSBiYm94IGluIHRoZSBjb29yZGluYXRlIHN5c3RlbSBvZiB0aGF0IGVsZW1lbnRcblxuICBpZiAoZWwpIHtcbiAgICByZXR1cm4gcmJveC50cmFuc2Zvcm0oZWwuc2NyZWVuQ1RNKCkuaW52ZXJzZU8oKSk7XG4gIH0gLy8gRWxzZSB3ZSB3YW50IGl0IGluIGFic29sdXRlIHNjcmVlbiBjb29yZGluYXRlc1xuICAvLyBUaGVyZWZvcmUgd2UgbmVlZCB0byBhZGQgdGhlIHNjcm9sbE9mZnNldFxuXG5cbiAgcmV0dXJuIHJib3guYWRkT2Zmc2V0KCk7XG59IC8vIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBwb2ludCBpcyBpbnNpZGUgdGhlIGJvdW5kaW5nIGJveFxuXG5mdW5jdGlvbiBpbnNpZGUoeCwgeSkge1xuICBjb25zdCBib3ggPSB0aGlzLmJib3goKTtcbiAgcmV0dXJuIHggPiBib3gueCAmJiB5ID4gYm94LnkgJiYgeCA8IGJveC54ICsgYm94LndpZHRoICYmIHkgPCBib3gueSArIGJveC5oZWlnaHQ7XG59XG5yZWdpc3Rlck1ldGhvZHMoe1xuICB2aWV3Ym94OiB7XG4gICAgdmlld2JveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAvLyBhY3QgYXMgZ2V0dGVyXG4gICAgICBpZiAoeCA9PSBudWxsKSByZXR1cm4gbmV3IEJveCh0aGlzLmF0dHIoJ3ZpZXdCb3gnKSk7IC8vIGFjdCBhcyBzZXR0ZXJcblxuICAgICAgcmV0dXJuIHRoaXMuYXR0cigndmlld0JveCcsIG5ldyBCb3goeCwgeSwgd2lkdGgsIGhlaWdodCkpO1xuICAgIH0sXG5cbiAgICB6b29tKGxldmVsLCBwb2ludCkge1xuICAgICAgLy8gSXRzIGJlc3QgdG8gcmVseSBvbiB0aGUgYXR0cmlidXRlcyBoZXJlIGFuZCBoZXJlIGlzIHdoeTpcbiAgICAgIC8vIGNsaWVudFhZWjogRG9lc24ndCB3b3JrIG9uIG5vbi1yb290IHN2Z3MgYmVjYXVzZSB0aGV5IGRvbnQgaGF2ZSBhIENTU0JveCAoc2lsbHkhKVxuICAgICAgLy8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiBEb2Vzbid0IHdvcmsgYmVjYXVzZSBDaHJvbWUganVzdCBpZ25vcmVzIHdpZHRoIGFuZCBoZWlnaHQgb2YgbmVzdGVkIHN2Z3MgY29tcGxldGVseVxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICB0aGF0IG1lYW5zLCB0aGVpciBjbGllbnRSZWN0IGlzIGFsd2F5cyBhcyBiaWcgYXMgdGhlIGNvbnRlbnQuXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgIEZ1cnRoZXJtb3JlIHRoaXMgc2l6ZSBpcyBpbmNvcnJlY3QgaWYgdGhlIGVsZW1lbnQgaXMgZnVydGhlciB0cmFuc2Zvcm1lZCBieSBpdHMgcGFyZW50c1xuICAgICAgLy8gY29tcHV0ZWRTdHlsZTogT25seSByZXR1cm5zIG1lYW5pbmdmdWwgdmFsdWVzIGlmIGNzcyB3YXMgdXNlZCB3aXRoIHB4LiBXZSBkb250IGdvIHRoaXMgcm91dGUgaGVyZSFcbiAgICAgIC8vIGdldEJCb3g6IHJldHVybnMgdGhlIGJvdW5kaW5nIGJveCBvZiBpdHMgY29udGVudCAtIHRoYXQgZG9lc24ndCBoZWxwIVxuICAgICAgbGV0IHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSA9IHRoaXMuYXR0cihbJ3dpZHRoJywgJ2hlaWdodCddKTsgLy8gV2lkdGggYW5kIGhlaWdodCBpcyBhIHN0cmluZyB3aGVuIGEgbnVtYmVyIHdpdGggYSB1bml0IGlzIHByZXNlbnQgd2hpY2ggd2UgY2FuJ3QgdXNlXG4gICAgICAvLyBTbyB3ZSB0cnkgY2xpZW50WFlaXG5cbiAgICAgIGlmICghd2lkdGggJiYgIWhlaWdodCB8fCB0eXBlb2Ygd2lkdGggPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBoZWlnaHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHdpZHRoID0gdGhpcy5ub2RlLmNsaWVudFdpZHRoO1xuICAgICAgICBoZWlnaHQgPSB0aGlzLm5vZGUuY2xpZW50SGVpZ2h0O1xuICAgICAgfSAvLyBHaXZpbmcgdXAuLi5cblxuXG4gICAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbXBvc3NpYmxlIHRvIGdldCBhYnNvbHV0ZSB3aWR0aCBhbmQgaGVpZ2h0LiBQbGVhc2UgcHJvdmlkZSBhbiBhYnNvbHV0ZSB3aWR0aCBhbmQgaGVpZ2h0IGF0dHJpYnV0ZSBvbiB0aGUgem9vbWluZyBlbGVtZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHYgPSB0aGlzLnZpZXdib3goKTtcbiAgICAgIGNvbnN0IHpvb21YID0gd2lkdGggLyB2LndpZHRoO1xuICAgICAgY29uc3Qgem9vbVkgPSBoZWlnaHQgLyB2LmhlaWdodDtcbiAgICAgIGNvbnN0IHpvb20gPSBNYXRoLm1pbih6b29tWCwgem9vbVkpO1xuXG4gICAgICBpZiAobGV2ZWwgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gem9vbTtcbiAgICAgIH1cblxuICAgICAgbGV0IHpvb21BbW91bnQgPSB6b29tIC8gbGV2ZWw7IC8vIFNldCB0aGUgem9vbUFtb3VudCB0byB0aGUgaGlnaGVzdCB2YWx1ZSB3aGljaCBpcyBzYWZlIHRvIHByb2Nlc3MgYW5kIHJlY292ZXIgZnJvbVxuICAgICAgLy8gVGhlICogMTAwIGlzIGEgYml0IG9mIHdpZ2dsZSByb29tIGZvciB0aGUgbWF0cml4IHRyYW5zZm9ybWF0aW9uXG5cbiAgICAgIGlmICh6b29tQW1vdW50ID09PSBJbmZpbml0eSkgem9vbUFtb3VudCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIC8gMTAwO1xuICAgICAgcG9pbnQgPSBwb2ludCB8fCBuZXcgUG9pbnQod2lkdGggLyAyIC8gem9vbVggKyB2LngsIGhlaWdodCAvIDIgLyB6b29tWSArIHYueSk7XG4gICAgICBjb25zdCBib3ggPSBuZXcgQm94KHYpLnRyYW5zZm9ybShuZXcgTWF0cml4KHtcbiAgICAgICAgc2NhbGU6IHpvb21BbW91bnQsXG4gICAgICAgIG9yaWdpbjogcG9pbnRcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiB0aGlzLnZpZXdib3goYm94KTtcbiAgICB9XG5cbiAgfVxufSk7XG5yZWdpc3RlcihCb3gsICdCb3gnKTtcblxuY2xhc3MgTGlzdCBleHRlbmRzIEFycmF5IHtcbiAgY29uc3RydWN0b3IoYXJyID0gW10sIC4uLmFyZ3MpIHtcbiAgICBzdXBlcihhcnIsIC4uLmFyZ3MpO1xuICAgIGlmICh0eXBlb2YgYXJyID09PSAnbnVtYmVyJykgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMucHVzaCguLi5hcnIpO1xuICB9XG5cbn1cbmV4dGVuZChbTGlzdF0sIHtcbiAgZWFjaChmbk9yTWV0aG9kTmFtZSwgLi4uYXJncykge1xuICAgIGlmICh0eXBlb2YgZm5Pck1ldGhvZE5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcCgoZWwsIGksIGFycikgPT4ge1xuICAgICAgICByZXR1cm4gZm5Pck1ldGhvZE5hbWUuY2FsbChlbCwgZWwsIGksIGFycik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMubWFwKGVsID0+IHtcbiAgICAgICAgcmV0dXJuIGVsW2ZuT3JNZXRob2ROYW1lXSguLi5hcmdzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCB0aGlzKTtcbiAgfVxuXG59KTtcbmNvbnN0IHJlc2VydmVkID0gWyd0b0FycmF5JywgJ2NvbnN0cnVjdG9yJywgJ2VhY2gnXTtcblxuTGlzdC5leHRlbmQgPSBmdW5jdGlvbiAobWV0aG9kcykge1xuICBtZXRob2RzID0gbWV0aG9kcy5yZWR1Y2UoKG9iaiwgbmFtZSkgPT4ge1xuICAgIC8vIERvbid0IG92ZXJ3cml0ZSBvd24gbWV0aG9kc1xuICAgIGlmIChyZXNlcnZlZC5pbmNsdWRlcyhuYW1lKSkgcmV0dXJuIG9iajsgLy8gRG9uJ3QgYWRkIHByaXZhdGUgbWV0aG9kc1xuXG4gICAgaWYgKG5hbWVbMF0gPT09ICdfJykgcmV0dXJuIG9iajsgLy8gUmVsYXkgZXZlcnkgY2FsbCB0byBlYWNoKClcblxuICAgIG9ialtuYW1lXSA9IGZ1bmN0aW9uICguLi5hdHRycykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChuYW1lLCAuLi5hdHRycyk7XG4gICAgfTtcblxuICAgIHJldHVybiBvYmo7XG4gIH0sIHt9KTtcbiAgZXh0ZW5kKFtMaXN0XSwgbWV0aG9kcyk7XG59O1xuXG5mdW5jdGlvbiBiYXNlRmluZChxdWVyeSwgcGFyZW50KSB7XG4gIHJldHVybiBuZXcgTGlzdChtYXAoKHBhcmVudCB8fCBnbG9iYWxzLmRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gYWRvcHQobm9kZSk7XG4gIH0pKTtcbn0gLy8gU2NvcGVkIGZpbmQgbWV0aG9kXG5cbmZ1bmN0aW9uIGZpbmQocXVlcnkpIHtcbiAgcmV0dXJuIGJhc2VGaW5kKHF1ZXJ5LCB0aGlzLm5vZGUpO1xufVxuZnVuY3Rpb24gZmluZE9uZShxdWVyeSkge1xuICByZXR1cm4gYWRvcHQodGhpcy5ub2RlLnF1ZXJ5U2VsZWN0b3IocXVlcnkpKTtcbn1cblxubGV0IGxpc3RlbmVySWQgPSAwO1xuY29uc3Qgd2luZG93RXZlbnRzID0ge307XG5mdW5jdGlvbiBnZXRFdmVudHMoaW5zdGFuY2UpIHtcbiAgbGV0IG4gPSBpbnN0YW5jZS5nZXRFdmVudEhvbGRlcigpOyAvLyBXZSBkb250IHdhbnQgdG8gc2F2ZSBldmVudHMgaW4gZ2xvYmFsIHNwYWNlXG5cbiAgaWYgKG4gPT09IGdsb2JhbHMud2luZG93KSBuID0gd2luZG93RXZlbnRzO1xuICBpZiAoIW4uZXZlbnRzKSBuLmV2ZW50cyA9IHt9O1xuICByZXR1cm4gbi5ldmVudHM7XG59XG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChpbnN0YW5jZSkge1xuICByZXR1cm4gaW5zdGFuY2UuZ2V0RXZlbnRUYXJnZXQoKTtcbn1cbmZ1bmN0aW9uIGNsZWFyRXZlbnRzKGluc3RhbmNlKSB7XG4gIGxldCBuID0gaW5zdGFuY2UuZ2V0RXZlbnRIb2xkZXIoKTtcbiAgaWYgKG4gPT09IGdsb2JhbHMud2luZG93KSBuID0gd2luZG93RXZlbnRzO1xuICBpZiAobi5ldmVudHMpIG4uZXZlbnRzID0ge307XG59IC8vIEFkZCBldmVudCBiaW5kZXIgaW4gdGhlIFNWRyBuYW1lc3BhY2VcblxuZnVuY3Rpb24gb24obm9kZSwgZXZlbnRzLCBsaXN0ZW5lciwgYmluZGluZywgb3B0aW9ucykge1xuICBjb25zdCBsID0gbGlzdGVuZXIuYmluZChiaW5kaW5nIHx8IG5vZGUpO1xuICBjb25zdCBpbnN0YW5jZSA9IG1ha2VJbnN0YW5jZShub2RlKTtcbiAgY29uc3QgYmFnID0gZ2V0RXZlbnRzKGluc3RhbmNlKTtcbiAgY29uc3QgbiA9IGdldEV2ZW50VGFyZ2V0KGluc3RhbmNlKTsgLy8gZXZlbnRzIGNhbiBiZSBhbiBhcnJheSBvZiBldmVudHMgb3IgYSBzdHJpbmcgb2YgZXZlbnRzXG5cbiAgZXZlbnRzID0gQXJyYXkuaXNBcnJheShldmVudHMpID8gZXZlbnRzIDogZXZlbnRzLnNwbGl0KGRlbGltaXRlcik7IC8vIGFkZCBpZCB0byBsaXN0ZW5lclxuXG4gIGlmICghbGlzdGVuZXIuX3N2Z2pzTGlzdGVuZXJJZCkge1xuICAgIGxpc3RlbmVyLl9zdmdqc0xpc3RlbmVySWQgPSArK2xpc3RlbmVySWQ7XG4gIH1cblxuICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBjb25zdCBldiA9IGV2ZW50LnNwbGl0KCcuJylbMF07XG4gICAgY29uc3QgbnMgPSBldmVudC5zcGxpdCgnLicpWzFdIHx8ICcqJzsgLy8gZW5zdXJlIHZhbGlkIG9iamVjdFxuXG4gICAgYmFnW2V2XSA9IGJhZ1tldl0gfHwge307XG4gICAgYmFnW2V2XVtuc10gPSBiYWdbZXZdW25zXSB8fCB7fTsgLy8gcmVmZXJlbmNlIGxpc3RlbmVyXG5cbiAgICBiYWdbZXZdW25zXVtsaXN0ZW5lci5fc3ZnanNMaXN0ZW5lcklkXSA9IGw7IC8vIGFkZCBsaXN0ZW5lclxuXG4gICAgbi5hZGRFdmVudExpc3RlbmVyKGV2LCBsLCBvcHRpb25zIHx8IGZhbHNlKTtcbiAgfSk7XG59IC8vIEFkZCBldmVudCB1bmJpbmRlciBpbiB0aGUgU1ZHIG5hbWVzcGFjZVxuXG5mdW5jdGlvbiBvZmYobm9kZSwgZXZlbnRzLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICBjb25zdCBpbnN0YW5jZSA9IG1ha2VJbnN0YW5jZShub2RlKTtcbiAgY29uc3QgYmFnID0gZ2V0RXZlbnRzKGluc3RhbmNlKTtcbiAgY29uc3QgbiA9IGdldEV2ZW50VGFyZ2V0KGluc3RhbmNlKTsgLy8gbGlzdGVuZXIgY2FuIGJlIGEgZnVuY3Rpb24gb3IgYSBudW1iZXJcblxuICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5fc3ZnanNMaXN0ZW5lcklkO1xuICAgIGlmICghbGlzdGVuZXIpIHJldHVybjtcbiAgfSAvLyBldmVudHMgY2FuIGJlIGFuIGFycmF5IG9mIGV2ZW50cyBvciBhIHN0cmluZyBvciB1bmRlZmluZWRcblxuXG4gIGV2ZW50cyA9IEFycmF5LmlzQXJyYXkoZXZlbnRzKSA/IGV2ZW50cyA6IChldmVudHMgfHwgJycpLnNwbGl0KGRlbGltaXRlcik7XG4gIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgIGNvbnN0IGV2ID0gZXZlbnQgJiYgZXZlbnQuc3BsaXQoJy4nKVswXTtcbiAgICBjb25zdCBucyA9IGV2ZW50ICYmIGV2ZW50LnNwbGl0KCcuJylbMV07XG4gICAgbGV0IG5hbWVzcGFjZSwgbDtcblxuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgLy8gcmVtb3ZlIGxpc3RlbmVyIHJlZmVyZW5jZVxuICAgICAgaWYgKGJhZ1tldl0gJiYgYmFnW2V2XVtucyB8fCAnKiddKSB7XG4gICAgICAgIC8vIHJlbW92ZUxpc3RlbmVyXG4gICAgICAgIG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldiwgYmFnW2V2XVtucyB8fCAnKiddW2xpc3RlbmVyXSwgb3B0aW9ucyB8fCBmYWxzZSk7XG4gICAgICAgIGRlbGV0ZSBiYWdbZXZdW25zIHx8ICcqJ11bbGlzdGVuZXJdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXYgJiYgbnMpIHtcbiAgICAgIC8vIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciBhIG5hbWVzcGFjZWQgZXZlbnRcbiAgICAgIGlmIChiYWdbZXZdICYmIGJhZ1tldl1bbnNdKSB7XG4gICAgICAgIGZvciAobCBpbiBiYWdbZXZdW25zXSkge1xuICAgICAgICAgIG9mZihuLCBbZXYsIG5zXS5qb2luKCcuJyksIGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIGJhZ1tldl1bbnNdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobnMpIHtcbiAgICAgIC8vIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciBhIHNwZWNpZmljIG5hbWVzcGFjZVxuICAgICAgZm9yIChldmVudCBpbiBiYWcpIHtcbiAgICAgICAgZm9yIChuYW1lc3BhY2UgaW4gYmFnW2V2ZW50XSkge1xuICAgICAgICAgIGlmIChucyA9PT0gbmFtZXNwYWNlKSB7XG4gICAgICAgICAgICBvZmYobiwgW2V2ZW50LCBuc10uam9pbignLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV2KSB7XG4gICAgICAvLyByZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgdGhlIGV2ZW50XG4gICAgICBpZiAoYmFnW2V2XSkge1xuICAgICAgICBmb3IgKG5hbWVzcGFjZSBpbiBiYWdbZXZdKSB7XG4gICAgICAgICAgb2ZmKG4sIFtldiwgbmFtZXNwYWNlXS5qb2luKCcuJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIGJhZ1tldl07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlbW92ZSBhbGwgbGlzdGVuZXJzIG9uIGEgZ2l2ZW4gbm9kZVxuICAgICAgZm9yIChldmVudCBpbiBiYWcpIHtcbiAgICAgICAgb2ZmKG4sIGV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgY2xlYXJFdmVudHMoaW5zdGFuY2UpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBkaXNwYXRjaChub2RlLCBldmVudCwgZGF0YSwgb3B0aW9ucykge1xuICBjb25zdCBuID0gZ2V0RXZlbnRUYXJnZXQobm9kZSk7IC8vIERpc3BhdGNoIGV2ZW50XG5cbiAgaWYgKGV2ZW50IGluc3RhbmNlb2YgZ2xvYmFscy53aW5kb3cuRXZlbnQpIHtcbiAgICBuLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50ID0gbmV3IGdsb2JhbHMud2luZG93LkN1c3RvbUV2ZW50KGV2ZW50LCB7XG4gICAgICBkZXRhaWw6IGRhdGEsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuICAgIG4uZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH1cblxuICByZXR1cm4gZXZlbnQ7XG59XG5cbmNsYXNzIEV2ZW50VGFyZ2V0IGV4dGVuZHMgQmFzZSB7XG4gIGFkZEV2ZW50TGlzdGVuZXIoKSB7fVxuXG4gIGRpc3BhdGNoKGV2ZW50LCBkYXRhLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoKHRoaXMsIGV2ZW50LCBkYXRhLCBvcHRpb25zKTtcbiAgfVxuXG4gIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCBiYWcgPSB0aGlzLmdldEV2ZW50SG9sZGVyKCkuZXZlbnRzO1xuICAgIGlmICghYmFnKSByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBldmVudHMgPSBiYWdbZXZlbnQudHlwZV07XG5cbiAgICBmb3IgKGNvbnN0IGkgaW4gZXZlbnRzKSB7XG4gICAgICBmb3IgKGNvbnN0IGogaW4gZXZlbnRzW2ldKSB7XG4gICAgICAgIGV2ZW50c1tpXVtqXShldmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkO1xuICB9IC8vIEZpcmUgZ2l2ZW4gZXZlbnRcblxuXG4gIGZpcmUoZXZlbnQsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmRpc3BhdGNoKGV2ZW50LCBkYXRhLCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldEV2ZW50SG9sZGVyKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0RXZlbnRUYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gVW5iaW5kIGV2ZW50IGZyb20gbGlzdGVuZXJcblxuXG4gIG9mZihldmVudCwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICBvZmYodGhpcywgZXZlbnQsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBCaW5kIGdpdmVuIGV2ZW50IHRvIGxpc3RlbmVyXG5cblxuICBvbihldmVudCwgbGlzdGVuZXIsIGJpbmRpbmcsIG9wdGlvbnMpIHtcbiAgICBvbih0aGlzLCBldmVudCwgbGlzdGVuZXIsIGJpbmRpbmcsIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpIHt9XG5cbn1cbnJlZ2lzdGVyKEV2ZW50VGFyZ2V0LCAnRXZlbnRUYXJnZXQnKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9IC8vIERlZmF1bHQgYW5pbWF0aW9uIHZhbHVlc1xuXG5jb25zdCB0aW1lbGluZSA9IHtcbiAgZHVyYXRpb246IDQwMCxcbiAgZWFzZTogJz4nLFxuICBkZWxheTogMFxufTsgLy8gRGVmYXVsdCBhdHRyaWJ1dGUgdmFsdWVzXG5cbmNvbnN0IGF0dHJzID0ge1xuICAvLyBmaWxsIGFuZCBzdHJva2VcbiAgJ2ZpbGwtb3BhY2l0eSc6IDEsXG4gICdzdHJva2Utb3BhY2l0eSc6IDEsXG4gICdzdHJva2Utd2lkdGgnOiAwLFxuICAnc3Ryb2tlLWxpbmVqb2luJzogJ21pdGVyJyxcbiAgJ3N0cm9rZS1saW5lY2FwJzogJ2J1dHQnLFxuICBmaWxsOiAnIzAwMDAwMCcsXG4gIHN0cm9rZTogJyMwMDAwMDAnLFxuICBvcGFjaXR5OiAxLFxuICAvLyBwb3NpdGlvblxuICB4OiAwLFxuICB5OiAwLFxuICBjeDogMCxcbiAgY3k6IDAsXG4gIC8vIHNpemVcbiAgd2lkdGg6IDAsXG4gIGhlaWdodDogMCxcbiAgLy8gcmFkaXVzXG4gIHI6IDAsXG4gIHJ4OiAwLFxuICByeTogMCxcbiAgLy8gZ3JhZGllbnRcbiAgb2Zmc2V0OiAwLFxuICAnc3RvcC1vcGFjaXR5JzogMSxcbiAgJ3N0b3AtY29sb3InOiAnIzAwMDAwMCcsXG4gIC8vIHRleHRcbiAgJ3RleHQtYW5jaG9yJzogJ3N0YXJ0J1xufTtcblxudmFyIGRlZmF1bHRzID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIG5vb3A6IG5vb3AsXG4gIHRpbWVsaW5lOiB0aW1lbGluZSxcbiAgYXR0cnM6IGF0dHJzXG59O1xuXG5jbGFzcyBTVkdBcnJheSBleHRlbmRzIEFycmF5IHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIHRoaXMuaW5pdCguLi5hcmdzKTtcbiAgfVxuXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcbiAgfVxuXG4gIGluaXQoYXJyKSB7XG4gICAgLy8gVGhpcyBjYXRjaGVzIHRoZSBjYXNlLCB0aGF0IG5hdGl2ZSBtYXAgdHJpZXMgdG8gY3JlYXRlIGFuIGFycmF5IHdpdGggbmV3IEFycmF5KDEpXG4gICAgaWYgKHR5cGVvZiBhcnIgPT09ICdudW1iZXInKSByZXR1cm4gdGhpcztcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5wdXNoKC4uLnRoaXMucGFyc2UoYXJyKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gUGFyc2Ugd2hpdGVzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nXG5cblxuICBwYXJzZShhcnJheSA9IFtdKSB7XG4gICAgLy8gSWYgYWxyZWFkeSBpcyBhbiBhcnJheSwgbm8gbmVlZCB0byBwYXJzZSBpdFxuICAgIGlmIChhcnJheSBpbnN0YW5jZW9mIEFycmF5KSByZXR1cm4gYXJyYXk7XG4gICAgcmV0dXJuIGFycmF5LnRyaW0oKS5zcGxpdChkZWxpbWl0ZXIpLm1hcChwYXJzZUZsb2F0KTtcbiAgfVxuXG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIHRoaXMpO1xuICB9XG5cbiAgdG9TZXQoKSB7XG4gICAgcmV0dXJuIG5ldyBTZXQodGhpcyk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5qb2luKCcgJyk7XG4gIH0gLy8gRmxhdHRlbnMgdGhlIGFycmF5IGlmIG5lZWRlZFxuXG5cbiAgdmFsdWVPZigpIHtcbiAgICBjb25zdCByZXQgPSBbXTtcbiAgICByZXQucHVzaCguLi50aGlzKTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbn1cblxuY2xhc3MgU1ZHTnVtYmVyIHtcbiAgLy8gSW5pdGlhbGl6ZVxuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgdGhpcy5pbml0KC4uLmFyZ3MpO1xuICB9XG5cbiAgY29udmVydCh1bml0KSB7XG4gICAgcmV0dXJuIG5ldyBTVkdOdW1iZXIodGhpcy52YWx1ZSwgdW5pdCk7XG4gIH0gLy8gRGl2aWRlIG51bWJlclxuXG5cbiAgZGl2aWRlKG51bWJlcikge1xuICAgIG51bWJlciA9IG5ldyBTVkdOdW1iZXIobnVtYmVyKTtcbiAgICByZXR1cm4gbmV3IFNWR051bWJlcih0aGlzIC8gbnVtYmVyLCB0aGlzLnVuaXQgfHwgbnVtYmVyLnVuaXQpO1xuICB9XG5cbiAgaW5pdCh2YWx1ZSwgdW5pdCkge1xuICAgIHVuaXQgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlWzFdIDogdW5pdDtcbiAgICB2YWx1ZSA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVbMF0gOiB2YWx1ZTsgLy8gaW5pdGlhbGl6ZSBkZWZhdWx0c1xuXG4gICAgdGhpcy52YWx1ZSA9IDA7XG4gICAgdGhpcy51bml0ID0gdW5pdCB8fCAnJzsgLy8gcGFyc2UgdmFsdWVcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBlbnN1cmUgYSB2YWxpZCBudW1lcmljIHZhbHVlXG4gICAgICB0aGlzLnZhbHVlID0gaXNOYU4odmFsdWUpID8gMCA6ICFpc0Zpbml0ZSh2YWx1ZSkgPyB2YWx1ZSA8IDAgPyAtMy40ZSszOCA6ICszLjRlKzM4IDogdmFsdWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB1bml0ID0gdmFsdWUubWF0Y2gobnVtYmVyQW5kVW5pdCk7XG5cbiAgICAgIGlmICh1bml0KSB7XG4gICAgICAgIC8vIG1ha2UgdmFsdWUgbnVtZXJpY1xuICAgICAgICB0aGlzLnZhbHVlID0gcGFyc2VGbG9hdCh1bml0WzFdKTsgLy8gbm9ybWFsaXplXG5cbiAgICAgICAgaWYgKHVuaXRbNV0gPT09ICclJykge1xuICAgICAgICAgIHRoaXMudmFsdWUgLz0gMTAwO1xuICAgICAgICB9IGVsc2UgaWYgKHVuaXRbNV0gPT09ICdzJykge1xuICAgICAgICAgIHRoaXMudmFsdWUgKj0gMTAwMDtcbiAgICAgICAgfSAvLyBzdG9yZSB1bml0XG5cblxuICAgICAgICB0aGlzLnVuaXQgPSB1bml0WzVdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTVkdOdW1iZXIpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlLnZhbHVlT2YoKTtcbiAgICAgICAgdGhpcy51bml0ID0gdmFsdWUudW5pdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBTdWJ0cmFjdCBudW1iZXJcblxuXG4gIG1pbnVzKG51bWJlcikge1xuICAgIG51bWJlciA9IG5ldyBTVkdOdW1iZXIobnVtYmVyKTtcbiAgICByZXR1cm4gbmV3IFNWR051bWJlcih0aGlzIC0gbnVtYmVyLCB0aGlzLnVuaXQgfHwgbnVtYmVyLnVuaXQpO1xuICB9IC8vIEFkZCBudW1iZXJcblxuXG4gIHBsdXMobnVtYmVyKSB7XG4gICAgbnVtYmVyID0gbmV3IFNWR051bWJlcihudW1iZXIpO1xuICAgIHJldHVybiBuZXcgU1ZHTnVtYmVyKHRoaXMgKyBudW1iZXIsIHRoaXMudW5pdCB8fCBudW1iZXIudW5pdCk7XG4gIH0gLy8gTXVsdGlwbHkgbnVtYmVyXG5cblxuICB0aW1lcyhudW1iZXIpIHtcbiAgICBudW1iZXIgPSBuZXcgU1ZHTnVtYmVyKG51bWJlcik7XG4gICAgcmV0dXJuIG5ldyBTVkdOdW1iZXIodGhpcyAqIG51bWJlciwgdGhpcy51bml0IHx8IG51bWJlci51bml0KTtcbiAgfVxuXG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIFt0aGlzLnZhbHVlLCB0aGlzLnVuaXRdO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gKHRoaXMudW5pdCA9PT0gJyUnID8gfn4odGhpcy52YWx1ZSAqIDFlOCkgLyAxZTYgOiB0aGlzLnVuaXQgPT09ICdzJyA/IHRoaXMudmFsdWUgLyAxZTMgOiB0aGlzLnZhbHVlKSArIHRoaXMudW5pdDtcbiAgfVxuXG4gIHZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cblxufVxuXG5jb25zdCBob29rcyA9IFtdO1xuZnVuY3Rpb24gcmVnaXN0ZXJBdHRySG9vayhmbikge1xuICBob29rcy5wdXNoKGZuKTtcbn0gLy8gU2V0IHN2ZyBlbGVtZW50IGF0dHJpYnV0ZVxuXG5mdW5jdGlvbiBhdHRyKGF0dHIsIHZhbCwgbnMpIHtcbiAgLy8gYWN0IGFzIGZ1bGwgZ2V0dGVyXG4gIGlmIChhdHRyID09IG51bGwpIHtcbiAgICAvLyBnZXQgYW4gb2JqZWN0IG9mIGF0dHJpYnV0ZXNcbiAgICBhdHRyID0ge307XG4gICAgdmFsID0gdGhpcy5ub2RlLmF0dHJpYnV0ZXM7XG5cbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdmFsKSB7XG4gICAgICBhdHRyW25vZGUubm9kZU5hbWVdID0gaXNOdW1iZXIudGVzdChub2RlLm5vZGVWYWx1ZSkgPyBwYXJzZUZsb2F0KG5vZGUubm9kZVZhbHVlKSA6IG5vZGUubm9kZVZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBhdHRyO1xuICB9IGVsc2UgaWYgKGF0dHIgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIC8vIGxvb3AgdGhyb3VnaCBhcnJheSBhbmQgZ2V0IGFsbCB2YWx1ZXNcbiAgICByZXR1cm4gYXR0ci5yZWR1Y2UoKGxhc3QsIGN1cnIpID0+IHtcbiAgICAgIGxhc3RbY3Vycl0gPSB0aGlzLmF0dHIoY3Vycik7XG4gICAgICByZXR1cm4gbGFzdDtcbiAgICB9LCB7fSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGF0dHIgPT09ICdvYmplY3QnICYmIGF0dHIuY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgIC8vIGFwcGx5IGV2ZXJ5IGF0dHJpYnV0ZSBpbmRpdmlkdWFsbHkgaWYgYW4gb2JqZWN0IGlzIHBhc3NlZFxuICAgIGZvciAodmFsIGluIGF0dHIpIHRoaXMuYXR0cih2YWwsIGF0dHJbdmFsXSk7XG4gIH0gZWxzZSBpZiAodmFsID09PSBudWxsKSB7XG4gICAgLy8gcmVtb3ZlIHZhbHVlXG4gICAgdGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgfSBlbHNlIGlmICh2YWwgPT0gbnVsbCkge1xuICAgIC8vIGFjdCBhcyBhIGdldHRlciBpZiB0aGUgZmlyc3QgYW5kIG9ubHkgYXJndW1lbnQgaXMgbm90IGFuIG9iamVjdFxuICAgIHZhbCA9IHRoaXMubm9kZS5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgcmV0dXJuIHZhbCA9PSBudWxsID8gYXR0cnNbYXR0cl0gOiBpc051bWJlci50ZXN0KHZhbCkgPyBwYXJzZUZsb2F0KHZhbCkgOiB2YWw7XG4gIH0gZWxzZSB7XG4gICAgLy8gTG9vcCB0aHJvdWdoIGhvb2tzIGFuZCBleGVjdXRlIHRoZW0gdG8gY29udmVydCB2YWx1ZVxuICAgIHZhbCA9IGhvb2tzLnJlZHVjZSgoX3ZhbCwgaG9vaykgPT4ge1xuICAgICAgcmV0dXJuIGhvb2soYXR0ciwgX3ZhbCwgdGhpcyk7XG4gICAgfSwgdmFsKTsgLy8gZW5zdXJlIGNvcnJlY3QgbnVtZXJpYyB2YWx1ZXMgKGFsc28gYWNjZXB0cyBOYU4gYW5kIEluZmluaXR5KVxuXG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICB2YWwgPSBuZXcgU1ZHTnVtYmVyKHZhbCk7XG4gICAgfSBlbHNlIGlmIChDb2xvci5pc0NvbG9yKHZhbCkpIHtcbiAgICAgIC8vIGVuc3VyZSBmdWxsIGhleCBjb2xvclxuICAgICAgdmFsID0gbmV3IENvbG9yKHZhbCk7XG4gICAgfSBlbHNlIGlmICh2YWwuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAvLyBDaGVjayBmb3IgcGxhaW4gYXJyYXlzIGFuZCBwYXJzZSBhcnJheSB2YWx1ZXNcbiAgICAgIHZhbCA9IG5ldyBTVkdBcnJheSh2YWwpO1xuICAgIH0gLy8gaWYgdGhlIHBhc3NlZCBhdHRyaWJ1dGUgaXMgbGVhZGluZy4uLlxuXG5cbiAgICBpZiAoYXR0ciA9PT0gJ2xlYWRpbmcnKSB7XG4gICAgICAvLyAuLi4gY2FsbCB0aGUgbGVhZGluZyBtZXRob2QgaW5zdGVhZFxuICAgICAgaWYgKHRoaXMubGVhZGluZykge1xuICAgICAgICB0aGlzLmxlYWRpbmcodmFsKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2V0IGdpdmVuIGF0dHJpYnV0ZSBvbiBub2RlXG4gICAgICB0eXBlb2YgbnMgPT09ICdzdHJpbmcnID8gdGhpcy5ub2RlLnNldEF0dHJpYnV0ZU5TKG5zLCBhdHRyLCB2YWwudG9TdHJpbmcoKSkgOiB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKGF0dHIsIHZhbC50b1N0cmluZygpKTtcbiAgICB9IC8vIHJlYnVpbGQgaWYgcmVxdWlyZWRcblxuXG4gICAgaWYgKHRoaXMucmVidWlsZCAmJiAoYXR0ciA9PT0gJ2ZvbnQtc2l6ZScgfHwgYXR0ciA9PT0gJ3gnKSkge1xuICAgICAgdGhpcy5yZWJ1aWxkKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmNsYXNzIERvbSBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgdGhpcy50eXBlID0gbm9kZS5ub2RlTmFtZTtcblxuICAgIGlmIChhdHRycyAmJiBub2RlICE9PSBhdHRycykge1xuICAgICAgdGhpcy5hdHRyKGF0dHJzKTtcbiAgICB9XG4gIH0gLy8gQWRkIGdpdmVuIGVsZW1lbnQgYXQgYSBwb3NpdGlvblxuXG5cbiAgYWRkKGVsZW1lbnQsIGkpIHtcbiAgICBlbGVtZW50ID0gbWFrZUluc3RhbmNlKGVsZW1lbnQpOyAvLyBJZiBub24tcm9vdCBzdmcgbm9kZXMgYXJlIGFkZGVkIHdlIGhhdmUgdG8gcmVtb3ZlIHRoZWlyIG5hbWVzcGFjZXNcblxuICAgIGlmIChlbGVtZW50LnJlbW92ZU5hbWVzcGFjZSAmJiB0aGlzLm5vZGUgaW5zdGFuY2VvZiBnbG9iYWxzLndpbmRvdy5TVkdFbGVtZW50KSB7XG4gICAgICBlbGVtZW50LnJlbW92ZU5hbWVzcGFjZSgpO1xuICAgIH1cblxuICAgIGlmIChpID09IG51bGwpIHtcbiAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChlbGVtZW50Lm5vZGUpO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudC5ub2RlICE9PSB0aGlzLm5vZGUuY2hpbGROb2Rlc1tpXSkge1xuICAgICAgdGhpcy5ub2RlLmluc2VydEJlZm9yZShlbGVtZW50Lm5vZGUsIHRoaXMubm9kZS5jaGlsZE5vZGVzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBBZGQgZWxlbWVudCB0byBnaXZlbiBjb250YWluZXIgYW5kIHJldHVybiBzZWxmXG5cblxuICBhZGRUbyhwYXJlbnQsIGkpIHtcbiAgICByZXR1cm4gbWFrZUluc3RhbmNlKHBhcmVudCkucHV0KHRoaXMsIGkpO1xuICB9IC8vIFJldHVybnMgYWxsIGNoaWxkIGVsZW1lbnRzXG5cblxuICBjaGlsZHJlbigpIHtcbiAgICByZXR1cm4gbmV3IExpc3QobWFwKHRoaXMubm9kZS5jaGlsZHJlbiwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBhZG9wdChub2RlKTtcbiAgICB9KSk7XG4gIH0gLy8gUmVtb3ZlIGFsbCBlbGVtZW50cyBpbiB0aGlzIGNvbnRhaW5lclxuXG5cbiAgY2xlYXIoKSB7XG4gICAgLy8gcmVtb3ZlIGNoaWxkcmVuXG4gICAgd2hpbGUgKHRoaXMubm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgIHRoaXMubm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUubGFzdENoaWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBDbG9uZSBlbGVtZW50XG5cblxuICBjbG9uZShkZWVwID0gdHJ1ZSwgYXNzaWduTmV3SWRzID0gdHJ1ZSkge1xuICAgIC8vIHdyaXRlIGRvbSBkYXRhIHRvIHRoZSBkb20gc28gdGhlIGNsb25lIGNhbiBwaWNrdXAgdGhlIGRhdGFcbiAgICB0aGlzLndyaXRlRGF0YVRvRG9tKCk7IC8vIGNsb25lIGVsZW1lbnRcblxuICAgIGxldCBub2RlQ2xvbmUgPSB0aGlzLm5vZGUuY2xvbmVOb2RlKGRlZXApO1xuXG4gICAgaWYgKGFzc2lnbk5ld0lkcykge1xuICAgICAgLy8gYXNzaWduIG5ldyBpZFxuICAgICAgbm9kZUNsb25lID0gYXNzaWduTmV3SWQobm9kZUNsb25lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3Iobm9kZUNsb25lKTtcbiAgfSAvLyBJdGVyYXRlcyBvdmVyIGFsbCBjaGlsZHJlbiBhbmQgaW52b2tlcyBhIGdpdmVuIGJsb2NrXG5cblxuICBlYWNoKGJsb2NrLCBkZWVwKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuKCk7XG4gICAgbGV0IGksIGlsO1xuXG4gICAgZm9yIChpID0gMCwgaWwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBibG9jay5hcHBseShjaGlsZHJlbltpXSwgW2ksIGNoaWxkcmVuXSk7XG5cbiAgICAgIGlmIChkZWVwKSB7XG4gICAgICAgIGNoaWxkcmVuW2ldLmVhY2goYmxvY2ssIGRlZXApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZWxlbWVudChub2RlTmFtZSwgYXR0cnMpIHtcbiAgICByZXR1cm4gdGhpcy5wdXQobmV3IERvbShjcmVhdGUobm9kZU5hbWUpLCBhdHRycykpO1xuICB9IC8vIEdldCBmaXJzdCBjaGlsZFxuXG5cbiAgZmlyc3QoKSB7XG4gICAgcmV0dXJuIGFkb3B0KHRoaXMubm9kZS5maXJzdENoaWxkKTtcbiAgfSAvLyBHZXQgYSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxuXG5cbiAgZ2V0KGkpIHtcbiAgICByZXR1cm4gYWRvcHQodGhpcy5ub2RlLmNoaWxkTm9kZXNbaV0pO1xuICB9XG5cbiAgZ2V0RXZlbnRIb2xkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZTtcbiAgfVxuXG4gIGdldEV2ZW50VGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLm5vZGU7XG4gIH0gLy8gQ2hlY2tzIGlmIHRoZSBnaXZlbiBlbGVtZW50IGlzIGEgY2hpbGRcblxuXG4gIGhhcyhlbGVtZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXgoZWxlbWVudCkgPj0gMDtcbiAgfVxuXG4gIGh0bWwoaHRtbE9yRm4sIG91dGVySFRNTCkge1xuICAgIHJldHVybiB0aGlzLnhtbChodG1sT3JGbiwgb3V0ZXJIVE1MLCBodG1sKTtcbiAgfSAvLyBHZXQgLyBzZXQgaWRcblxuXG4gIGlkKGlkKSB7XG4gICAgLy8gZ2VuZXJhdGUgbmV3IGlkIGlmIG5vIGlkIHNldFxuICAgIGlmICh0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnICYmICF0aGlzLm5vZGUuaWQpIHtcbiAgICAgIHRoaXMubm9kZS5pZCA9IGVpZCh0aGlzLnR5cGUpO1xuICAgIH0gLy8gZG9uJ3Qgc2V0IGRpcmVjdGx5IHdpdGggdGhpcy5ub2RlLmlkIHRvIG1ha2UgYG51bGxgIHdvcmsgY29ycmVjdGx5XG5cblxuICAgIHJldHVybiB0aGlzLmF0dHIoJ2lkJywgaWQpO1xuICB9IC8vIEdldHMgaW5kZXggb2YgZ2l2ZW4gZWxlbWVudFxuXG5cbiAgaW5kZXgoZWxlbWVudCkge1xuICAgIHJldHVybiBbXS5zbGljZS5jYWxsKHRoaXMubm9kZS5jaGlsZE5vZGVzKS5pbmRleE9mKGVsZW1lbnQubm9kZSk7XG4gIH0gLy8gR2V0IHRoZSBsYXN0IGNoaWxkXG5cblxuICBsYXN0KCkge1xuICAgIHJldHVybiBhZG9wdCh0aGlzLm5vZGUubGFzdENoaWxkKTtcbiAgfSAvLyBtYXRjaGVzIHRoZSBlbGVtZW50IHZzIGEgY3NzIHNlbGVjdG9yXG5cblxuICBtYXRjaGVzKHNlbGVjdG9yKSB7XG4gICAgY29uc3QgZWwgPSB0aGlzLm5vZGU7XG4gICAgY29uc3QgbWF0Y2hlciA9IGVsLm1hdGNoZXMgfHwgZWwubWF0Y2hlc1NlbGVjdG9yIHx8IGVsLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IGVsLm1vek1hdGNoZXNTZWxlY3RvciB8fCBlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZWwub01hdGNoZXNTZWxlY3RvciB8fCBudWxsO1xuICAgIHJldHVybiBtYXRjaGVyICYmIG1hdGNoZXIuY2FsbChlbCwgc2VsZWN0b3IpO1xuICB9IC8vIFJldHVybnMgdGhlIHBhcmVudCBlbGVtZW50IGluc3RhbmNlXG5cblxuICBwYXJlbnQodHlwZSkge1xuICAgIGxldCBwYXJlbnQgPSB0aGlzOyAvLyBjaGVjayBmb3IgcGFyZW50XG5cbiAgICBpZiAoIXBhcmVudC5ub2RlLnBhcmVudE5vZGUpIHJldHVybiBudWxsOyAvLyBnZXQgcGFyZW50IGVsZW1lbnRcblxuICAgIHBhcmVudCA9IGFkb3B0KHBhcmVudC5ub2RlLnBhcmVudE5vZGUpO1xuICAgIGlmICghdHlwZSkgcmV0dXJuIHBhcmVudDsgLy8gbG9vcCB0aHJvdWdoIGFuY2VzdG9ycyBpZiB0eXBlIGlzIGdpdmVuXG5cbiAgICBkbyB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50Lm1hdGNoZXModHlwZSkgOiBwYXJlbnQgaW5zdGFuY2VvZiB0eXBlKSByZXR1cm4gcGFyZW50O1xuICAgIH0gd2hpbGUgKHBhcmVudCA9IGFkb3B0KHBhcmVudC5ub2RlLnBhcmVudE5vZGUpKTtcblxuICAgIHJldHVybiBwYXJlbnQ7XG4gIH0gLy8gQmFzaWNhbGx5IGRvZXMgdGhlIHNhbWUgYXMgYGFkZCgpYCBidXQgcmV0dXJucyB0aGUgYWRkZWQgZWxlbWVudCBpbnN0ZWFkXG5cblxuICBwdXQoZWxlbWVudCwgaSkge1xuICAgIGVsZW1lbnQgPSBtYWtlSW5zdGFuY2UoZWxlbWVudCk7XG4gICAgdGhpcy5hZGQoZWxlbWVudCwgaSk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0gLy8gQWRkIGVsZW1lbnQgdG8gZ2l2ZW4gY29udGFpbmVyIGFuZCByZXR1cm4gY29udGFpbmVyXG5cblxuICBwdXRJbihwYXJlbnQsIGkpIHtcbiAgICByZXR1cm4gbWFrZUluc3RhbmNlKHBhcmVudCkuYWRkKHRoaXMsIGkpO1xuICB9IC8vIFJlbW92ZSBlbGVtZW50XG5cblxuICByZW1vdmUoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50KCkpIHtcbiAgICAgIHRoaXMucGFyZW50KCkucmVtb3ZlRWxlbWVudCh0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBSZW1vdmUgYSBnaXZlbiBjaGlsZFxuXG5cbiAgcmVtb3ZlRWxlbWVudChlbGVtZW50KSB7XG4gICAgdGhpcy5ub2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQubm9kZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gUmVwbGFjZSB0aGlzIHdpdGggZWxlbWVudFxuXG5cbiAgcmVwbGFjZShlbGVtZW50KSB7XG4gICAgZWxlbWVudCA9IG1ha2VJbnN0YW5jZShlbGVtZW50KTtcblxuICAgIGlmICh0aGlzLm5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5ub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGVsZW1lbnQubm9kZSwgdGhpcy5ub2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJvdW5kKHByZWNpc2lvbiA9IDIsIG1hcCA9IG51bGwpIHtcbiAgICBjb25zdCBmYWN0b3IgPSAxMCAqKiBwcmVjaXNpb247XG4gICAgY29uc3QgYXR0cnMgPSB0aGlzLmF0dHIobWFwKTtcblxuICAgIGZvciAoY29uc3QgaSBpbiBhdHRycykge1xuICAgICAgaWYgKHR5cGVvZiBhdHRyc1tpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgYXR0cnNbaV0gPSBNYXRoLnJvdW5kKGF0dHJzW2ldICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmF0dHIoYXR0cnMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIEltcG9ydCAvIEV4cG9ydCByYXcgc3ZnXG5cblxuICBzdmcoc3ZnT3JGbiwgb3V0ZXJTVkcpIHtcbiAgICByZXR1cm4gdGhpcy54bWwoc3ZnT3JGbiwgb3V0ZXJTVkcsIHN2Zyk7XG4gIH0gLy8gUmV0dXJuIGlkIG9uIHN0cmluZyBjb252ZXJzaW9uXG5cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5pZCgpO1xuICB9XG5cbiAgd29yZHModGV4dCkge1xuICAgIC8vIFRoaXMgaXMgZmFzdGVyIHRoYW4gcmVtb3ZpbmcgYWxsIGNoaWxkcmVuIGFuZCBhZGRpbmcgYSBuZXcgb25lXG4gICAgdGhpcy5ub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHdyYXAobm9kZSkge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50KCk7XG5cbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkVG8obm9kZSk7XG4gICAgfVxuXG4gICAgY29uc3QgcG9zaXRpb24gPSBwYXJlbnQuaW5kZXgodGhpcyk7XG4gICAgcmV0dXJuIHBhcmVudC5wdXQobm9kZSwgcG9zaXRpb24pLnB1dCh0aGlzKTtcbiAgfSAvLyB3cml0ZSBzdmdqcyBkYXRhIHRvIHRoZSBkb21cblxuXG4gIHdyaXRlRGF0YVRvRG9tKCkge1xuICAgIC8vIGR1bXAgdmFyaWFibGVzIHJlY3Vyc2l2ZWx5XG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMud3JpdGVEYXRhVG9Eb20oKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBJbXBvcnQgLyBFeHBvcnQgcmF3IHN2Z1xuXG5cbiAgeG1sKHhtbE9yRm4sIG91dGVyWE1MLCBucykge1xuICAgIGlmICh0eXBlb2YgeG1sT3JGbiA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBucyA9IG91dGVyWE1MO1xuICAgICAgb3V0ZXJYTUwgPSB4bWxPckZuO1xuICAgICAgeG1sT3JGbiA9IG51bGw7XG4gICAgfSAvLyBhY3QgYXMgZ2V0dGVyIGlmIG5vIHN2ZyBzdHJpbmcgaXMgZ2l2ZW5cblxuXG4gICAgaWYgKHhtbE9yRm4gPT0gbnVsbCB8fCB0eXBlb2YgeG1sT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gVGhlIGRlZmF1bHQgZm9yIGV4cG9ydHMgaXMsIHRoYXQgdGhlIG91dGVyTm9kZSBpcyBpbmNsdWRlZFxuICAgICAgb3V0ZXJYTUwgPSBvdXRlclhNTCA9PSBudWxsID8gdHJ1ZSA6IG91dGVyWE1MOyAvLyB3cml0ZSBzdmdqcyBkYXRhIHRvIHRoZSBkb21cblxuICAgICAgdGhpcy53cml0ZURhdGFUb0RvbSgpO1xuICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzOyAvLyBBbiBleHBvcnQgbW9kaWZpZXIgd2FzIHBhc3NlZFxuXG4gICAgICBpZiAoeG1sT3JGbiAhPSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnQgPSBhZG9wdChjdXJyZW50Lm5vZGUuY2xvbmVOb2RlKHRydWUpKTsgLy8gSWYgdGhlIHVzZXIgd2FudHMgb3V0ZXJIVE1MIHdlIG5lZWQgdG8gcHJvY2VzcyB0aGlzIG5vZGUsIHRvb1xuXG4gICAgICAgIGlmIChvdXRlclhNTCkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHhtbE9yRm4oY3VycmVudCk7XG4gICAgICAgICAgY3VycmVudCA9IHJlc3VsdCB8fCBjdXJyZW50OyAvLyBUaGUgdXNlciBkb2VzIG5vdCB3YW50IHRoaXMgbm9kZT8gV2VsbCwgdGhlbiBoZSBnZXRzIG5vdGhpbmdcblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSByZXR1cm4gJyc7XG4gICAgICAgIH0gLy8gRGVlcCBsb29wIHRocm91Z2ggYWxsIGNoaWxkcmVuIGFuZCBhcHBseSBtb2RpZmllclxuXG5cbiAgICAgICAgY3VycmVudC5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSB4bWxPckZuKHRoaXMpO1xuXG4gICAgICAgICAgY29uc3QgX3RoaXMgPSByZXN1bHQgfHwgdGhpczsgLy8gSWYgbW9kaWZpZXIgcmV0dXJucyBmYWxzZSwgZGlzY2FyZCBub2RlXG5cblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpOyAvLyBJZiBtb2RpZmllciByZXR1cm5zIG5ldyBub2RlLCB1c2UgaXRcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCAmJiB0aGlzICE9PSBfdGhpcykge1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlKF90aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgfSAvLyBSZXR1cm4gb3V0ZXIgb3IgaW5uZXIgY29udGVudFxuXG5cbiAgICAgIHJldHVybiBvdXRlclhNTCA/IGN1cnJlbnQubm9kZS5vdXRlckhUTUwgOiBjdXJyZW50Lm5vZGUuaW5uZXJIVE1MO1xuICAgIH0gLy8gQWN0IGFzIHNldHRlciBpZiB3ZSBnb3QgYSBzdHJpbmdcbiAgICAvLyBUaGUgZGVmYXVsdCBmb3IgaW1wb3J0IGlzLCB0aGF0IHRoZSBjdXJyZW50IG5vZGUgaXMgbm90IHJlcGxhY2VkXG5cblxuICAgIG91dGVyWE1MID0gb3V0ZXJYTUwgPT0gbnVsbCA/IGZhbHNlIDogb3V0ZXJYTUw7IC8vIENyZWF0ZSB0ZW1wb3JhcnkgaG9sZGVyXG5cbiAgICBjb25zdCB3ZWxsID0gY3JlYXRlKCd3cmFwcGVyJywgbnMpO1xuICAgIGNvbnN0IGZyYWdtZW50ID0gZ2xvYmFscy5kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7IC8vIER1bXAgcmF3IHN2Z1xuXG4gICAgd2VsbC5pbm5lckhUTUwgPSB4bWxPckZuOyAvLyBUcmFuc3BsYW50IG5vZGVzIGludG8gdGhlIGZyYWdtZW50XG5cbiAgICBmb3IgKGxldCBsZW4gPSB3ZWxsLmNoaWxkcmVuLmxlbmd0aDsgbGVuLS07KSB7XG4gICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZCh3ZWxsLmZpcnN0RWxlbWVudENoaWxkKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudCgpOyAvLyBBZGQgdGhlIHdob2xlIGZyYWdtZW50IGF0IG9uY2VcblxuICAgIHJldHVybiBvdXRlclhNTCA/IHRoaXMucmVwbGFjZShmcmFnbWVudCkgJiYgcGFyZW50IDogdGhpcy5hZGQoZnJhZ21lbnQpO1xuICB9XG5cbn1cbmV4dGVuZChEb20sIHtcbiAgYXR0cixcbiAgZmluZCxcbiAgZmluZE9uZVxufSk7XG5yZWdpc3RlcihEb20sICdEb20nKTtcblxuY2xhc3MgRWxlbWVudCBleHRlbmRzIERvbSB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzKSB7XG4gICAgc3VwZXIobm9kZSwgYXR0cnMpOyAvLyBpbml0aWFsaXplIGRhdGEgb2JqZWN0XG5cbiAgICB0aGlzLmRvbSA9IHt9OyAvLyBjcmVhdGUgY2lyY3VsYXIgcmVmZXJlbmNlXG5cbiAgICB0aGlzLm5vZGUuaW5zdGFuY2UgPSB0aGlzO1xuXG4gICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKCdzdmdqczpkYXRhJykpIHtcbiAgICAgIC8vIHB1bGwgc3ZnanMgZGF0YSBmcm9tIHRoZSBkb20gKGdldEF0dHJpYnV0ZU5TIGRvZXNuJ3Qgd29yayBpbiBodG1sNSlcbiAgICAgIHRoaXMuc2V0RGF0YShKU09OLnBhcnNlKG5vZGUuZ2V0QXR0cmlidXRlKCdzdmdqczpkYXRhJykpIHx8IHt9KTtcbiAgICB9XG4gIH0gLy8gTW92ZSBlbGVtZW50IGJ5IGl0cyBjZW50ZXJcblxuXG4gIGNlbnRlcih4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuY3goeCkuY3koeSk7XG4gIH0gLy8gTW92ZSBieSBjZW50ZXIgb3ZlciB4LWF4aXNcblxuXG4gIGN4KHgpIHtcbiAgICByZXR1cm4geCA9PSBudWxsID8gdGhpcy54KCkgKyB0aGlzLndpZHRoKCkgLyAyIDogdGhpcy54KHggLSB0aGlzLndpZHRoKCkgLyAyKTtcbiAgfSAvLyBNb3ZlIGJ5IGNlbnRlciBvdmVyIHktYXhpc1xuXG5cbiAgY3koeSkge1xuICAgIHJldHVybiB5ID09IG51bGwgPyB0aGlzLnkoKSArIHRoaXMuaGVpZ2h0KCkgLyAyIDogdGhpcy55KHkgLSB0aGlzLmhlaWdodCgpIC8gMik7XG4gIH0gLy8gR2V0IGRlZnNcblxuXG4gIGRlZnMoKSB7XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMucm9vdCgpO1xuICAgIHJldHVybiByb290ICYmIHJvb3QuZGVmcygpO1xuICB9IC8vIFJlbGF0aXZlIG1vdmUgb3ZlciB4IGFuZCB5IGF4ZXNcblxuXG4gIGRtb3ZlKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5keCh4KS5keSh5KTtcbiAgfSAvLyBSZWxhdGl2ZSBtb3ZlIG92ZXIgeCBheGlzXG5cblxuICBkeCh4ID0gMCkge1xuICAgIHJldHVybiB0aGlzLngobmV3IFNWR051bWJlcih4KS5wbHVzKHRoaXMueCgpKSk7XG4gIH0gLy8gUmVsYXRpdmUgbW92ZSBvdmVyIHkgYXhpc1xuXG5cbiAgZHkoeSA9IDApIHtcbiAgICByZXR1cm4gdGhpcy55KG5ldyBTVkdOdW1iZXIoeSkucGx1cyh0aGlzLnkoKSkpO1xuICB9XG5cbiAgZ2V0RXZlbnRIb2xkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gU2V0IGhlaWdodCBvZiBlbGVtZW50XG5cblxuICBoZWlnaHQoaGVpZ2h0KSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cignaGVpZ2h0JywgaGVpZ2h0KTtcbiAgfSAvLyBNb3ZlIGVsZW1lbnQgdG8gZ2l2ZW4geCBhbmQgeSB2YWx1ZXNcblxuXG4gIG1vdmUoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLngoeCkueSh5KTtcbiAgfSAvLyByZXR1cm4gYXJyYXkgb2YgYWxsIGFuY2VzdG9ycyBvZiBnaXZlbiB0eXBlIHVwIHRvIHRoZSByb290IHN2Z1xuXG5cbiAgcGFyZW50cyh1bnRpbCA9IHRoaXMucm9vdCgpKSB7XG4gICAgY29uc3QgaXNTZWxlY3RvciA9IHR5cGVvZiB1bnRpbCA9PT0gJ3N0cmluZyc7XG5cbiAgICBpZiAoIWlzU2VsZWN0b3IpIHtcbiAgICAgIHVudGlsID0gbWFrZUluc3RhbmNlKHVudGlsKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJlbnRzID0gbmV3IExpc3QoKTtcbiAgICBsZXQgcGFyZW50ID0gdGhpcztcblxuICAgIHdoaWxlICgocGFyZW50ID0gcGFyZW50LnBhcmVudCgpKSAmJiBwYXJlbnQubm9kZSAhPT0gZ2xvYmFscy5kb2N1bWVudCAmJiBwYXJlbnQubm9kZU5hbWUgIT09ICcjZG9jdW1lbnQtZnJhZ21lbnQnKSB7XG4gICAgICBwYXJlbnRzLnB1c2gocGFyZW50KTtcblxuICAgICAgaWYgKCFpc1NlbGVjdG9yICYmIHBhcmVudC5ub2RlID09PSB1bnRpbC5ub2RlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNTZWxlY3RvciAmJiBwYXJlbnQubWF0Y2hlcyh1bnRpbCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJlbnQubm9kZSA9PT0gdGhpcy5yb290KCkubm9kZSkge1xuICAgICAgICAvLyBXZSB3b3JrZWQgb3VyIHdheSB0byB0aGUgcm9vdCBhbmQgZGlkbid0IG1hdGNoIGB1bnRpbGBcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmVudHM7XG4gIH0gLy8gR2V0IHJlZmVyZW5jZWQgZWxlbWVudCBmb3JtIGF0dHJpYnV0ZSB2YWx1ZVxuXG5cbiAgcmVmZXJlbmNlKGF0dHIpIHtcbiAgICBhdHRyID0gdGhpcy5hdHRyKGF0dHIpO1xuICAgIGlmICghYXR0cikgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgbSA9IChhdHRyICsgJycpLm1hdGNoKHJlZmVyZW5jZSk7XG4gICAgcmV0dXJuIG0gPyBtYWtlSW5zdGFuY2UobVsxXSkgOiBudWxsO1xuICB9IC8vIEdldCBwYXJlbnQgZG9jdW1lbnRcblxuXG4gIHJvb3QoKSB7XG4gICAgY29uc3QgcCA9IHRoaXMucGFyZW50KGdldENsYXNzKHJvb3QpKTtcbiAgICByZXR1cm4gcCAmJiBwLnJvb3QoKTtcbiAgfSAvLyBzZXQgZ2l2ZW4gZGF0YSB0byB0aGUgZWxlbWVudHMgZGF0YSBwcm9wZXJ0eVxuXG5cbiAgc2V0RGF0YShvKSB7XG4gICAgdGhpcy5kb20gPSBvO1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIFNldCBlbGVtZW50IHNpemUgdG8gZ2l2ZW4gd2lkdGggYW5kIGhlaWdodFxuXG5cbiAgc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodCk7XG4gICAgcmV0dXJuIHRoaXMud2lkdGgobmV3IFNWR051bWJlcihwLndpZHRoKSkuaGVpZ2h0KG5ldyBTVkdOdW1iZXIocC5oZWlnaHQpKTtcbiAgfSAvLyBTZXQgd2lkdGggb2YgZWxlbWVudFxuXG5cbiAgd2lkdGgod2lkdGgpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCd3aWR0aCcsIHdpZHRoKTtcbiAgfSAvLyB3cml0ZSBzdmdqcyBkYXRhIHRvIHRoZSBkb21cblxuXG4gIHdyaXRlRGF0YVRvRG9tKCkge1xuICAgIC8vIHJlbW92ZSBwcmV2aW91c2x5IHNldCBkYXRhXG4gICAgdGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZSgnc3ZnanM6ZGF0YScpO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuZG9tKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoJ3N2Z2pzOmRhdGEnLCBKU09OLnN0cmluZ2lmeSh0aGlzLmRvbSkpOyAvLyBzZWUgIzQyOFxuICAgIH1cblxuICAgIHJldHVybiBzdXBlci53cml0ZURhdGFUb0RvbSgpO1xuICB9IC8vIE1vdmUgb3ZlciB4LWF4aXNcblxuXG4gIHgoeCkge1xuICAgIHJldHVybiB0aGlzLmF0dHIoJ3gnLCB4KTtcbiAgfSAvLyBNb3ZlIG92ZXIgeS1heGlzXG5cblxuICB5KHkpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCd5JywgeSk7XG4gIH1cblxufVxuZXh0ZW5kKEVsZW1lbnQsIHtcbiAgYmJveCxcbiAgcmJveCxcbiAgaW5zaWRlLFxuICBwb2ludCxcbiAgY3RtLFxuICBzY3JlZW5DVE1cbn0pO1xucmVnaXN0ZXIoRWxlbWVudCwgJ0VsZW1lbnQnKTtcblxuY29uc3Qgc3VnYXIgPSB7XG4gIHN0cm9rZTogWydjb2xvcicsICd3aWR0aCcsICdvcGFjaXR5JywgJ2xpbmVjYXAnLCAnbGluZWpvaW4nLCAnbWl0ZXJsaW1pdCcsICdkYXNoYXJyYXknLCAnZGFzaG9mZnNldCddLFxuICBmaWxsOiBbJ2NvbG9yJywgJ29wYWNpdHknLCAncnVsZSddLFxuICBwcmVmaXg6IGZ1bmN0aW9uICh0LCBhKSB7XG4gICAgcmV0dXJuIGEgPT09ICdjb2xvcicgPyB0IDogdCArICctJyArIGE7XG4gIH1cbn0gLy8gQWRkIHN1Z2FyIGZvciBmaWxsIGFuZCBzdHJva2VcbjtcblsnZmlsbCcsICdzdHJva2UnXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gIGNvbnN0IGV4dGVuc2lvbiA9IHt9O1xuICBsZXQgaTtcblxuICBleHRlbnNpb25bbV0gPSBmdW5jdGlvbiAobykge1xuICAgIGlmICh0eXBlb2YgbyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHIobSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvID09PSAnc3RyaW5nJyB8fCBvIGluc3RhbmNlb2YgQ29sb3IgfHwgQ29sb3IuaXNSZ2IobykgfHwgbyBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuYXR0cihtLCBvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2V0IGFsbCBhdHRyaWJ1dGVzIGZyb20gc3VnYXIuZmlsbCBhbmQgc3VnYXIuc3Ryb2tlIGxpc3RcbiAgICAgIGZvciAoaSA9IHN1Z2FyW21dLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChvW3N1Z2FyW21dW2ldXSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5hdHRyKHN1Z2FyLnByZWZpeChtLCBzdWdhclttXVtpXSksIG9bc3VnYXJbbV1baV1dKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJlZ2lzdGVyTWV0aG9kcyhbJ0VsZW1lbnQnLCAnUnVubmVyJ10sIGV4dGVuc2lvbik7XG59KTtcbnJlZ2lzdGVyTWV0aG9kcyhbJ0VsZW1lbnQnLCAnUnVubmVyJ10sIHtcbiAgLy8gTGV0IHRoZSB1c2VyIHNldCB0aGUgbWF0cml4IGRpcmVjdGx5XG4gIG1hdHJpeDogZnVuY3Rpb24gKG1hdCwgYiwgYywgZCwgZSwgZikge1xuICAgIC8vIEFjdCBhcyBhIGdldHRlclxuICAgIGlmIChtYXQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBNYXRyaXgodGhpcyk7XG4gICAgfSAvLyBBY3QgYXMgYSBzZXR0ZXIsIHRoZSB1c2VyIGNhbiBwYXNzIGEgbWF0cml4IG9yIGEgc2V0IG9mIG51bWJlcnNcblxuXG4gICAgcmV0dXJuIHRoaXMuYXR0cigndHJhbnNmb3JtJywgbmV3IE1hdHJpeChtYXQsIGIsIGMsIGQsIGUsIGYpKTtcbiAgfSxcbiAgLy8gTWFwIHJvdGF0aW9uIHRvIHRyYW5zZm9ybVxuICByb3RhdGU6IGZ1bmN0aW9uIChhbmdsZSwgY3gsIGN5KSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHtcbiAgICAgIHJvdGF0ZTogYW5nbGUsXG4gICAgICBveDogY3gsXG4gICAgICBveTogY3lcbiAgICB9LCB0cnVlKTtcbiAgfSxcbiAgLy8gTWFwIHNrZXcgdG8gdHJhbnNmb3JtXG4gIHNrZXc6IGZ1bmN0aW9uICh4LCB5LCBjeCwgY3kpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAzID8gdGhpcy50cmFuc2Zvcm0oe1xuICAgICAgc2tldzogeCxcbiAgICAgIG94OiB5LFxuICAgICAgb3k6IGN4XG4gICAgfSwgdHJ1ZSkgOiB0aGlzLnRyYW5zZm9ybSh7XG4gICAgICBza2V3OiBbeCwgeV0sXG4gICAgICBveDogY3gsXG4gICAgICBveTogY3lcbiAgICB9LCB0cnVlKTtcbiAgfSxcbiAgc2hlYXI6IGZ1bmN0aW9uIChsYW0sIGN4LCBjeSkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh7XG4gICAgICBzaGVhcjogbGFtLFxuICAgICAgb3g6IGN4LFxuICAgICAgb3k6IGN5XG4gICAgfSwgdHJ1ZSk7XG4gIH0sXG4gIC8vIE1hcCBzY2FsZSB0byB0cmFuc2Zvcm1cbiAgc2NhbGU6IGZ1bmN0aW9uICh4LCB5LCBjeCwgY3kpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAzID8gdGhpcy50cmFuc2Zvcm0oe1xuICAgICAgc2NhbGU6IHgsXG4gICAgICBveDogeSxcbiAgICAgIG95OiBjeFxuICAgIH0sIHRydWUpIDogdGhpcy50cmFuc2Zvcm0oe1xuICAgICAgc2NhbGU6IFt4LCB5XSxcbiAgICAgIG94OiBjeCxcbiAgICAgIG95OiBjeVxuICAgIH0sIHRydWUpO1xuICB9LFxuICAvLyBNYXAgdHJhbnNsYXRlIHRvIHRyYW5zZm9ybVxuICB0cmFuc2xhdGU6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHtcbiAgICAgIHRyYW5zbGF0ZTogW3gsIHldXG4gICAgfSwgdHJ1ZSk7XG4gIH0sXG4gIC8vIE1hcCByZWxhdGl2ZSB0cmFuc2xhdGlvbnMgdG8gdHJhbnNmb3JtXG4gIHJlbGF0aXZlOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh7XG4gICAgICByZWxhdGl2ZTogW3gsIHldXG4gICAgfSwgdHJ1ZSk7XG4gIH0sXG4gIC8vIE1hcCBmbGlwIHRvIHRyYW5zZm9ybVxuICBmbGlwOiBmdW5jdGlvbiAoZGlyZWN0aW9uID0gJ2JvdGgnLCBvcmlnaW4gPSAnY2VudGVyJykge1xuICAgIGlmICgneHlib3RodHJ1ZScuaW5kZXhPZihkaXJlY3Rpb24pID09PSAtMSkge1xuICAgICAgb3JpZ2luID0gZGlyZWN0aW9uO1xuICAgICAgZGlyZWN0aW9uID0gJ2JvdGgnO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh7XG4gICAgICBmbGlwOiBkaXJlY3Rpb24sXG4gICAgICBvcmlnaW46IG9yaWdpblxuICAgIH0sIHRydWUpO1xuICB9LFxuICAvLyBPcGFjaXR5XG4gIG9wYWNpdHk6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmF0dHIoJ29wYWNpdHknLCB2YWx1ZSk7XG4gIH1cbn0pO1xucmVnaXN0ZXJNZXRob2RzKCdyYWRpdXMnLCB7XG4gIC8vIEFkZCB4IGFuZCB5IHJhZGl1c1xuICByYWRpdXM6IGZ1bmN0aW9uICh4LCB5ID0geCkge1xuICAgIGNvbnN0IHR5cGUgPSAodGhpcy5fZWxlbWVudCB8fCB0aGlzKS50eXBlO1xuICAgIHJldHVybiB0eXBlID09PSAncmFkaWFsR3JhZGllbnQnID8gdGhpcy5hdHRyKCdyJywgbmV3IFNWR051bWJlcih4KSkgOiB0aGlzLnJ4KHgpLnJ5KHkpO1xuICB9XG59KTtcbnJlZ2lzdGVyTWV0aG9kcygnUGF0aCcsIHtcbiAgLy8gR2V0IHBhdGggbGVuZ3RoXG4gIGxlbmd0aDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0VG90YWxMZW5ndGgoKTtcbiAgfSxcbiAgLy8gR2V0IHBvaW50IGF0IGxlbmd0aFxuICBwb2ludEF0OiBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLm5vZGUuZ2V0UG9pbnRBdExlbmd0aChsZW5ndGgpKTtcbiAgfVxufSk7XG5yZWdpc3Rlck1ldGhvZHMoWydFbGVtZW50JywgJ1J1bm5lciddLCB7XG4gIC8vIFNldCBmb250XG4gIGZvbnQ6IGZ1bmN0aW9uIChhLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yICh2IGluIGEpIHRoaXMuZm9udCh2LCBhW3ZdKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGEgPT09ICdsZWFkaW5nJyA/IHRoaXMubGVhZGluZyh2KSA6IGEgPT09ICdhbmNob3InID8gdGhpcy5hdHRyKCd0ZXh0LWFuY2hvcicsIHYpIDogYSA9PT0gJ3NpemUnIHx8IGEgPT09ICdmYW1pbHknIHx8IGEgPT09ICd3ZWlnaHQnIHx8IGEgPT09ICdzdHJldGNoJyB8fCBhID09PSAndmFyaWFudCcgfHwgYSA9PT0gJ3N0eWxlJyA/IHRoaXMuYXR0cignZm9udC0nICsgYSwgdikgOiB0aGlzLmF0dHIoYSwgdik7XG4gIH1cbn0pOyAvLyBBZGQgZXZlbnRzIHRvIGVsZW1lbnRzXG5cbmNvbnN0IG1ldGhvZHMgPSBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlZG93bicsICdtb3VzZXVwJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdtb3VzZW1vdmUnLCAnbW91c2VlbnRlcicsICdtb3VzZWxlYXZlJywgJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJywgJ3RvdWNobGVhdmUnLCAndG91Y2hlbmQnLCAndG91Y2hjYW5jZWwnXS5yZWR1Y2UoZnVuY3Rpb24gKGxhc3QsIGV2ZW50KSB7XG4gIC8vIGFkZCBldmVudCB0byBFbGVtZW50XG4gIGNvbnN0IGZuID0gZnVuY3Rpb24gKGYpIHtcbiAgICBpZiAoZiA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5vZmYoZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uKGV2ZW50LCBmKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBsYXN0W2V2ZW50XSA9IGZuO1xuICByZXR1cm4gbGFzdDtcbn0sIHt9KTtcbnJlZ2lzdGVyTWV0aG9kcygnRWxlbWVudCcsIG1ldGhvZHMpO1xuXG5mdW5jdGlvbiB1bnRyYW5zZm9ybSgpIHtcbiAgcmV0dXJuIHRoaXMuYXR0cigndHJhbnNmb3JtJywgbnVsbCk7XG59IC8vIG1lcmdlIHRoZSB3aG9sZSB0cmFuc2Zvcm1hdGlvbiBjaGFpbiBpbnRvIG9uZSBtYXRyaXggYW5kIHJldHVybnMgaXRcblxuZnVuY3Rpb24gbWF0cml4aWZ5KCkge1xuICBjb25zdCBtYXRyaXggPSAodGhpcy5hdHRyKCd0cmFuc2Zvcm0nKSB8fCAnJyAvLyBzcGxpdCB0cmFuc2Zvcm1hdGlvbnNcbiAgKS5zcGxpdCh0cmFuc2Zvcm1zKS5zbGljZSgwLCAtMSkubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAvLyBnZW5lcmF0ZSBrZXkgPT4gdmFsdWUgcGFpcnNcbiAgICBjb25zdCBrdiA9IHN0ci50cmltKCkuc3BsaXQoJygnKTtcbiAgICByZXR1cm4gW2t2WzBdLCBrdlsxXS5zcGxpdChkZWxpbWl0ZXIpLm1hcChmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChzdHIpO1xuICAgIH0pXTtcbiAgfSkucmV2ZXJzZSgpIC8vIG1lcmdlIGV2ZXJ5IHRyYW5zZm9ybWF0aW9uIGludG8gb25lIG1hdHJpeFxuICAucmVkdWNlKGZ1bmN0aW9uIChtYXRyaXgsIHRyYW5zZm9ybSkge1xuICAgIGlmICh0cmFuc2Zvcm1bMF0gPT09ICdtYXRyaXgnKSB7XG4gICAgICByZXR1cm4gbWF0cml4LmxtdWx0aXBseShNYXRyaXguZnJvbUFycmF5KHRyYW5zZm9ybVsxXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRyaXhbdHJhbnNmb3JtWzBdXS5hcHBseShtYXRyaXgsIHRyYW5zZm9ybVsxXSk7XG4gIH0sIG5ldyBNYXRyaXgoKSk7XG4gIHJldHVybiBtYXRyaXg7XG59IC8vIGFkZCBhbiBlbGVtZW50IHRvIGFub3RoZXIgcGFyZW50IHdpdGhvdXQgY2hhbmdpbmcgdGhlIHZpc3VhbCByZXByZXNlbnRhdGlvbiBvbiB0aGUgc2NyZWVuXG5cbmZ1bmN0aW9uIHRvUGFyZW50KHBhcmVudCwgaSkge1xuICBpZiAodGhpcyA9PT0gcGFyZW50KSByZXR1cm4gdGhpcztcbiAgY29uc3QgY3RtID0gdGhpcy5zY3JlZW5DVE0oKTtcbiAgY29uc3QgcEN0bSA9IHBhcmVudC5zY3JlZW5DVE0oKS5pbnZlcnNlKCk7XG4gIHRoaXMuYWRkVG8ocGFyZW50LCBpKS51bnRyYW5zZm9ybSgpLnRyYW5zZm9ybShwQ3RtLm11bHRpcGx5KGN0bSkpO1xuICByZXR1cm4gdGhpcztcbn0gLy8gc2FtZSBhcyBhYm92ZSB3aXRoIHBhcmVudCBlcXVhbHMgcm9vdC1zdmdcblxuZnVuY3Rpb24gdG9Sb290KGkpIHtcbiAgcmV0dXJuIHRoaXMudG9QYXJlbnQodGhpcy5yb290KCksIGkpO1xufSAvLyBBZGQgdHJhbnNmb3JtYXRpb25zXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybShvLCByZWxhdGl2ZSkge1xuICAvLyBBY3QgYXMgYSBnZXR0ZXIgaWYgbm8gb2JqZWN0IHdhcyBwYXNzZWRcbiAgaWYgKG8gPT0gbnVsbCB8fCB0eXBlb2YgbyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBkZWNvbXBvc2VkID0gbmV3IE1hdHJpeCh0aGlzKS5kZWNvbXBvc2UoKTtcbiAgICByZXR1cm4gbyA9PSBudWxsID8gZGVjb21wb3NlZCA6IGRlY29tcG9zZWRbb107XG4gIH1cblxuICBpZiAoIU1hdHJpeC5pc01hdHJpeExpa2UobykpIHtcbiAgICAvLyBTZXQgdGhlIG9yaWdpbiBhY2NvcmRpbmcgdG8gdGhlIGRlZmluZWQgdHJhbnNmb3JtXG4gICAgbyA9IHsgLi4ubyxcbiAgICAgIG9yaWdpbjogZ2V0T3JpZ2luKG8sIHRoaXMpXG4gICAgfTtcbiAgfSAvLyBUaGUgdXNlciBjYW4gcGFzcyBhIGJvb2xlYW4sIGFuIEVsZW1lbnQgb3IgYW4gTWF0cml4IG9yIG5vdGhpbmdcblxuXG4gIGNvbnN0IGNsZWFuUmVsYXRpdmUgPSByZWxhdGl2ZSA9PT0gdHJ1ZSA/IHRoaXMgOiByZWxhdGl2ZSB8fCBmYWxzZTtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IE1hdHJpeChjbGVhblJlbGF0aXZlKS50cmFuc2Zvcm0obyk7XG4gIHJldHVybiB0aGlzLmF0dHIoJ3RyYW5zZm9ybScsIHJlc3VsdCk7XG59XG5yZWdpc3Rlck1ldGhvZHMoJ0VsZW1lbnQnLCB7XG4gIHVudHJhbnNmb3JtLFxuICBtYXRyaXhpZnksXG4gIHRvUGFyZW50LFxuICB0b1Jvb3QsXG4gIHRyYW5zZm9ybVxufSk7XG5cbmNsYXNzIENvbnRhaW5lciBleHRlbmRzIEVsZW1lbnQge1xuICBmbGF0dGVuKHBhcmVudCA9IHRoaXMsIGluZGV4KSB7XG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQ29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYXR0ZW4oKS51bmdyb3VwKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB1bmdyb3VwKHBhcmVudCA9IHRoaXMucGFyZW50KCksIGluZGV4ID0gcGFyZW50LmluZGV4KHRoaXMpKSB7XG4gICAgLy8gd2hlbiBwYXJlbnQgIT0gdGhpcywgd2Ugd2FudCBhcHBlbmQgYWxsIGVsZW1lbnRzIHRvIHRoZSBlbmRcbiAgICBpbmRleCA9IGluZGV4ID09PSAtMSA/IHBhcmVudC5jaGlsZHJlbigpLmxlbmd0aCA6IGluZGV4O1xuICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoaSwgY2hpbGRyZW4pIHtcbiAgICAgIC8vIHJldmVyc2UgZWFjaFxuICAgICAgcmV0dXJuIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIGkgLSAxXS50b1BhcmVudChwYXJlbnQsIGluZGV4KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5yZW1vdmUoKTtcbiAgfVxuXG59XG5yZWdpc3RlcihDb250YWluZXIsICdDb250YWluZXInKTtcblxuY2xhc3MgRGVmcyBleHRlbmRzIENvbnRhaW5lciB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygnZGVmcycsIG5vZGUpLCBhdHRycyk7XG4gIH1cblxuICBmbGF0dGVuKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdW5ncm91cCgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59XG5yZWdpc3RlcihEZWZzLCAnRGVmcycpO1xuXG5jbGFzcyBTaGFwZSBleHRlbmRzIEVsZW1lbnQge31cbnJlZ2lzdGVyKFNoYXBlLCAnU2hhcGUnKTtcblxuZnVuY3Rpb24gcngocngpIHtcbiAgcmV0dXJuIHRoaXMuYXR0cigncngnLCByeCk7XG59IC8vIFJhZGl1cyB5IHZhbHVlXG5cbmZ1bmN0aW9uIHJ5KHJ5KSB7XG4gIHJldHVybiB0aGlzLmF0dHIoJ3J5JywgcnkpO1xufSAvLyBNb3ZlIG92ZXIgeC1heGlzXG5cbmZ1bmN0aW9uIHgkMyh4KSB7XG4gIHJldHVybiB4ID09IG51bGwgPyB0aGlzLmN4KCkgLSB0aGlzLnJ4KCkgOiB0aGlzLmN4KHggKyB0aGlzLnJ4KCkpO1xufSAvLyBNb3ZlIG92ZXIgeS1heGlzXG5cbmZ1bmN0aW9uIHkkMyh5KSB7XG4gIHJldHVybiB5ID09IG51bGwgPyB0aGlzLmN5KCkgLSB0aGlzLnJ5KCkgOiB0aGlzLmN5KHkgKyB0aGlzLnJ5KCkpO1xufSAvLyBNb3ZlIGJ5IGNlbnRlciBvdmVyIHgtYXhpc1xuXG5mdW5jdGlvbiBjeCQxKHgpIHtcbiAgcmV0dXJuIHRoaXMuYXR0cignY3gnLCB4KTtcbn0gLy8gTW92ZSBieSBjZW50ZXIgb3ZlciB5LWF4aXNcblxuZnVuY3Rpb24gY3kkMSh5KSB7XG4gIHJldHVybiB0aGlzLmF0dHIoJ2N5JywgeSk7XG59IC8vIFNldCB3aWR0aCBvZiBlbGVtZW50XG5cbmZ1bmN0aW9uIHdpZHRoJDIod2lkdGgpIHtcbiAgcmV0dXJuIHdpZHRoID09IG51bGwgPyB0aGlzLnJ4KCkgKiAyIDogdGhpcy5yeChuZXcgU1ZHTnVtYmVyKHdpZHRoKS5kaXZpZGUoMikpO1xufSAvLyBTZXQgaGVpZ2h0IG9mIGVsZW1lbnRcblxuZnVuY3Rpb24gaGVpZ2h0JDIoaGVpZ2h0KSB7XG4gIHJldHVybiBoZWlnaHQgPT0gbnVsbCA/IHRoaXMucnkoKSAqIDIgOiB0aGlzLnJ5KG5ldyBTVkdOdW1iZXIoaGVpZ2h0KS5kaXZpZGUoMikpO1xufVxuXG52YXIgY2lyY2xlZCA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICByeDogcngsXG4gIHJ5OiByeSxcbiAgeDogeCQzLFxuICB5OiB5JDMsXG4gIGN4OiBjeCQxLFxuICBjeTogY3kkMSxcbiAgd2lkdGg6IHdpZHRoJDIsXG4gIGhlaWdodDogaGVpZ2h0JDJcbn07XG5cbmNsYXNzIEVsbGlwc2UgZXh0ZW5kcyBTaGFwZSB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygnZWxsaXBzZScsIG5vZGUpLCBhdHRycyk7XG4gIH1cblxuICBzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBwID0gcHJvcG9ydGlvbmFsU2l6ZSh0aGlzLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICByZXR1cm4gdGhpcy5yeChuZXcgU1ZHTnVtYmVyKHAud2lkdGgpLmRpdmlkZSgyKSkucnkobmV3IFNWR051bWJlcihwLmhlaWdodCkuZGl2aWRlKDIpKTtcbiAgfVxuXG59XG5leHRlbmQoRWxsaXBzZSwgY2lyY2xlZCk7XG5yZWdpc3Rlck1ldGhvZHMoJ0NvbnRhaW5lcicsIHtcbiAgLy8gQ3JlYXRlIGFuIGVsbGlwc2VcbiAgZWxsaXBzZTogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHdpZHRoID0gMCwgaGVpZ2h0ID0gd2lkdGgpIHtcbiAgICByZXR1cm4gdGhpcy5wdXQobmV3IEVsbGlwc2UoKSkuc2l6ZSh3aWR0aCwgaGVpZ2h0KS5tb3ZlKDAsIDApO1xuICB9KVxufSk7XG5yZWdpc3RlcihFbGxpcHNlLCAnRWxsaXBzZScpO1xuXG5jbGFzcyBGcmFnbWVudCBleHRlbmRzIERvbSB7XG4gIGNvbnN0cnVjdG9yKG5vZGUgPSBnbG9iYWxzLmRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSkge1xuICAgIHN1cGVyKG5vZGUpO1xuICB9IC8vIEltcG9ydCAvIEV4cG9ydCByYXcgeG1sXG5cblxuICB4bWwoeG1sT3JGbiwgb3V0ZXJYTUwsIG5zKSB7XG4gICAgaWYgKHR5cGVvZiB4bWxPckZuID09PSAnYm9vbGVhbicpIHtcbiAgICAgIG5zID0gb3V0ZXJYTUw7XG4gICAgICBvdXRlclhNTCA9IHhtbE9yRm47XG4gICAgICB4bWxPckZuID0gbnVsbDtcbiAgICB9IC8vIGJlY2F1c2UgdGhpcyBpcyBhIGZyYWdtZW50IHdlIGhhdmUgdG8gcHV0IGFsbCBlbGVtZW50cyBpbnRvIGEgd3JhcHBlciBmaXJzdFxuICAgIC8vIGJlZm9yZSB3ZSBjYW4gZ2V0IHRoZSBpbm5lclhNTCBmcm9tIGl0XG5cblxuICAgIGlmICh4bWxPckZuID09IG51bGwgfHwgdHlwZW9mIHhtbE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnN0IHdyYXBwZXIgPSBuZXcgRG9tKGNyZWF0ZSgnd3JhcHBlcicsIG5zKSk7XG4gICAgICB3cmFwcGVyLmFkZCh0aGlzLm5vZGUuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgIHJldHVybiB3cmFwcGVyLnhtbChmYWxzZSwgbnMpO1xuICAgIH0gLy8gQWN0IGFzIHNldHRlciBpZiB3ZSBnb3QgYSBzdHJpbmdcblxuXG4gICAgcmV0dXJuIHN1cGVyLnhtbCh4bWxPckZuLCBmYWxzZSwgbnMpO1xuICB9XG5cbn1cblxucmVnaXN0ZXIoRnJhZ21lbnQsICdGcmFnbWVudCcpO1xuXG5mdW5jdGlvbiBmcm9tKHgsIHkpIHtcbiAgcmV0dXJuICh0aGlzLl9lbGVtZW50IHx8IHRoaXMpLnR5cGUgPT09ICdyYWRpYWxHcmFkaWVudCcgPyB0aGlzLmF0dHIoe1xuICAgIGZ4OiBuZXcgU1ZHTnVtYmVyKHgpLFxuICAgIGZ5OiBuZXcgU1ZHTnVtYmVyKHkpXG4gIH0pIDogdGhpcy5hdHRyKHtcbiAgICB4MTogbmV3IFNWR051bWJlcih4KSxcbiAgICB5MTogbmV3IFNWR051bWJlcih5KVxuICB9KTtcbn1cbmZ1bmN0aW9uIHRvKHgsIHkpIHtcbiAgcmV0dXJuICh0aGlzLl9lbGVtZW50IHx8IHRoaXMpLnR5cGUgPT09ICdyYWRpYWxHcmFkaWVudCcgPyB0aGlzLmF0dHIoe1xuICAgIGN4OiBuZXcgU1ZHTnVtYmVyKHgpLFxuICAgIGN5OiBuZXcgU1ZHTnVtYmVyKHkpXG4gIH0pIDogdGhpcy5hdHRyKHtcbiAgICB4MjogbmV3IFNWR051bWJlcih4KSxcbiAgICB5MjogbmV3IFNWR051bWJlcih5KVxuICB9KTtcbn1cblxudmFyIGdyYWRpZW50ZWQgPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZnJvbTogZnJvbSxcbiAgdG86IHRvXG59O1xuXG5jbGFzcyBHcmFkaWVudCBleHRlbmRzIENvbnRhaW5lciB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIGF0dHJzKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KHR5cGUgKyAnR3JhZGllbnQnLCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyBudWxsIDogdHlwZSksIGF0dHJzKTtcbiAgfSAvLyBjdXN0b20gYXR0ciB0byBoYW5kbGUgdHJhbnNmb3JtXG5cblxuICBhdHRyKGEsIGIsIGMpIHtcbiAgICBpZiAoYSA9PT0gJ3RyYW5zZm9ybScpIGEgPSAnZ3JhZGllbnRUcmFuc2Zvcm0nO1xuICAgIHJldHVybiBzdXBlci5hdHRyKGEsIGIsIGMpO1xuICB9XG5cbiAgYmJveCgpIHtcbiAgICByZXR1cm4gbmV3IEJveCgpO1xuICB9XG5cbiAgdGFyZ2V0cygpIHtcbiAgICByZXR1cm4gYmFzZUZpbmQoJ3N2ZyBbZmlsbCo9JyArIHRoaXMuaWQoKSArICddJyk7XG4gIH0gLy8gQWxpYXMgc3RyaW5nIGNvbnZlcnNpb24gdG8gZmlsbFxuXG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudXJsKCk7XG4gIH0gLy8gVXBkYXRlIGdyYWRpZW50XG5cblxuICB1cGRhdGUoYmxvY2spIHtcbiAgICAvLyByZW1vdmUgYWxsIHN0b3BzXG4gICAgdGhpcy5jbGVhcigpOyAvLyBpbnZva2UgcGFzc2VkIGJsb2NrXG5cbiAgICBpZiAodHlwZW9mIGJsb2NrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBibG9jay5jYWxsKHRoaXMsIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIFJldHVybiB0aGUgZmlsbCBpZFxuXG5cbiAgdXJsKCkge1xuICAgIHJldHVybiAndXJsKCMnICsgdGhpcy5pZCgpICsgJyknO1xuICB9XG5cbn1cbmV4dGVuZChHcmFkaWVudCwgZ3JhZGllbnRlZCk7XG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICAvLyBDcmVhdGUgZ3JhZGllbnQgZWxlbWVudCBpbiBkZWZzXG4gICAgZ3JhZGllbnQoLi4uYXJncykge1xuICAgICAgcmV0dXJuIHRoaXMuZGVmcygpLmdyYWRpZW50KC4uLmFyZ3MpO1xuICAgIH1cblxuICB9LFxuICAvLyBkZWZpbmUgZ3JhZGllbnRcbiAgRGVmczoge1xuICAgIGdyYWRpZW50OiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAodHlwZSwgYmxvY2spIHtcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgR3JhZGllbnQodHlwZSkpLnVwZGF0ZShibG9jayk7XG4gICAgfSlcbiAgfVxufSk7XG5yZWdpc3RlcihHcmFkaWVudCwgJ0dyYWRpZW50Jyk7XG5cbmNsYXNzIFBhdHRlcm4gZXh0ZW5kcyBDb250YWluZXIge1xuICAvLyBJbml0aWFsaXplIG5vZGVcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMgPSBub2RlKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KCdwYXR0ZXJuJywgbm9kZSksIGF0dHJzKTtcbiAgfSAvLyBjdXN0b20gYXR0ciB0byBoYW5kbGUgdHJhbnNmb3JtXG5cblxuICBhdHRyKGEsIGIsIGMpIHtcbiAgICBpZiAoYSA9PT0gJ3RyYW5zZm9ybScpIGEgPSAncGF0dGVyblRyYW5zZm9ybSc7XG4gICAgcmV0dXJuIHN1cGVyLmF0dHIoYSwgYiwgYyk7XG4gIH1cblxuICBiYm94KCkge1xuICAgIHJldHVybiBuZXcgQm94KCk7XG4gIH1cblxuICB0YXJnZXRzKCkge1xuICAgIHJldHVybiBiYXNlRmluZCgnc3ZnIFtmaWxsKj0nICsgdGhpcy5pZCgpICsgJ10nKTtcbiAgfSAvLyBBbGlhcyBzdHJpbmcgY29udmVyc2lvbiB0byBmaWxsXG5cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy51cmwoKTtcbiAgfSAvLyBVcGRhdGUgcGF0dGVybiBieSByZWJ1aWxkaW5nXG5cblxuICB1cGRhdGUoYmxvY2spIHtcbiAgICAvLyByZW1vdmUgY29udGVudFxuICAgIHRoaXMuY2xlYXIoKTsgLy8gaW52b2tlIHBhc3NlZCBibG9ja1xuXG4gICAgaWYgKHR5cGVvZiBibG9jayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYmxvY2suY2FsbCh0aGlzLCB0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBSZXR1cm4gdGhlIGZpbGwgaWRcblxuXG4gIHVybCgpIHtcbiAgICByZXR1cm4gJ3VybCgjJyArIHRoaXMuaWQoKSArICcpJztcbiAgfVxuXG59XG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICAvLyBDcmVhdGUgcGF0dGVybiBlbGVtZW50IGluIGRlZnNcbiAgICBwYXR0ZXJuKC4uLmFyZ3MpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZnMoKS5wYXR0ZXJuKC4uLmFyZ3MpO1xuICAgIH1cblxuICB9LFxuICBEZWZzOiB7XG4gICAgcGF0dGVybjogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIGJsb2NrKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFBhdHRlcm4oKSkudXBkYXRlKGJsb2NrKS5hdHRyKHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgcGF0dGVyblVuaXRzOiAndXNlclNwYWNlT25Vc2UnXG4gICAgICB9KTtcbiAgICB9KVxuICB9XG59KTtcbnJlZ2lzdGVyKFBhdHRlcm4sICdQYXR0ZXJuJyk7XG5cbmNsYXNzIEltYWdlIGV4dGVuZHMgU2hhcGUge1xuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ2ltYWdlJywgbm9kZSksIGF0dHJzKTtcbiAgfSAvLyAocmUpbG9hZCBpbWFnZVxuXG5cbiAgbG9hZCh1cmwsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF1cmwpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IGltZyA9IG5ldyBnbG9iYWxzLndpbmRvdy5JbWFnZSgpO1xuICAgIG9uKGltZywgJ2xvYWQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgY29uc3QgcCA9IHRoaXMucGFyZW50KFBhdHRlcm4pOyAvLyBlbnN1cmUgaW1hZ2Ugc2l6ZVxuXG4gICAgICBpZiAodGhpcy53aWR0aCgpID09PSAwICYmIHRoaXMuaGVpZ2h0KCkgPT09IDApIHtcbiAgICAgICAgdGhpcy5zaXplKGltZy53aWR0aCwgaW1nLmhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwIGluc3RhbmNlb2YgUGF0dGVybikge1xuICAgICAgICAvLyBlbnN1cmUgcGF0dGVybiBzaXplIGlmIG5vdCBzZXRcbiAgICAgICAgaWYgKHAud2lkdGgoKSA9PT0gMCAmJiBwLmhlaWdodCgpID09PSAwKSB7XG4gICAgICAgICAgcC5zaXplKHRoaXMud2lkdGgoKSwgdGhpcy5oZWlnaHQoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIGUpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIG9uKGltZywgJ2xvYWQgZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBkb250IGZvcmdldCB0byB1bmJpbmQgbWVtb3J5IGxlYWtpbmcgZXZlbnRzXG4gICAgICBvZmYoaW1nKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdocmVmJywgaW1nLnNyYyA9IHVybCwgeGxpbmspO1xuICB9XG5cbn1cbnJlZ2lzdGVyQXR0ckhvb2soZnVuY3Rpb24gKGF0dHIsIHZhbCwgX3RoaXMpIHtcbiAgLy8gY29udmVydCBpbWFnZSBmaWxsIGFuZCBzdHJva2UgdG8gcGF0dGVybnNcbiAgaWYgKGF0dHIgPT09ICdmaWxsJyB8fCBhdHRyID09PSAnc3Ryb2tlJykge1xuICAgIGlmIChpc0ltYWdlLnRlc3QodmFsKSkge1xuICAgICAgdmFsID0gX3RoaXMucm9vdCgpLmRlZnMoKS5pbWFnZSh2YWwpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh2YWwgaW5zdGFuY2VvZiBJbWFnZSkge1xuICAgIHZhbCA9IF90aGlzLnJvb3QoKS5kZWZzKCkucGF0dGVybigwLCAwLCBwYXR0ZXJuID0+IHtcbiAgICAgIHBhdHRlcm4uYWRkKHZhbCk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufSk7XG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICAvLyBjcmVhdGUgaW1hZ2UgZWxlbWVudCwgbG9hZCBpbWFnZSBhbmQgc2V0IGl0cyBzaXplXG4gICAgaW1hZ2U6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uIChzb3VyY2UsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IEltYWdlKCkpLnNpemUoMCwgMCkubG9hZChzb3VyY2UsIGNhbGxiYWNrKTtcbiAgICB9KVxuICB9XG59KTtcbnJlZ2lzdGVyKEltYWdlLCAnSW1hZ2UnKTtcblxuY2xhc3MgUG9pbnRBcnJheSBleHRlbmRzIFNWR0FycmF5IHtcbiAgLy8gR2V0IGJvdW5kaW5nIGJveCBvZiBwb2ludHNcbiAgYmJveCgpIHtcbiAgICBsZXQgbWF4WCA9IC1JbmZpbml0eTtcbiAgICBsZXQgbWF4WSA9IC1JbmZpbml0eTtcbiAgICBsZXQgbWluWCA9IEluZmluaXR5O1xuICAgIGxldCBtaW5ZID0gSW5maW5pdHk7XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgbWF4WCA9IE1hdGgubWF4KGVsWzBdLCBtYXhYKTtcbiAgICAgIG1heFkgPSBNYXRoLm1heChlbFsxXSwgbWF4WSk7XG4gICAgICBtaW5YID0gTWF0aC5taW4oZWxbMF0sIG1pblgpO1xuICAgICAgbWluWSA9IE1hdGgubWluKGVsWzFdLCBtaW5ZKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IEJveChtaW5YLCBtaW5ZLCBtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xuICB9IC8vIE1vdmUgcG9pbnQgc3RyaW5nXG5cblxuICBtb3ZlKHgsIHkpIHtcbiAgICBjb25zdCBib3ggPSB0aGlzLmJib3goKTsgLy8gZ2V0IHJlbGF0aXZlIG9mZnNldFxuXG4gICAgeCAtPSBib3gueDtcbiAgICB5IC09IGJveC55OyAvLyBtb3ZlIGV2ZXJ5IHBvaW50XG5cbiAgICBpZiAoIWlzTmFOKHgpICYmICFpc05hTih5KSkge1xuICAgICAgZm9yIChsZXQgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGhpc1tpXSA9IFt0aGlzW2ldWzBdICsgeCwgdGhpc1tpXVsxXSArIHldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIFBhcnNlIHBvaW50IHN0cmluZyBhbmQgZmxhdCBhcnJheVxuXG5cbiAgcGFyc2UoYXJyYXkgPSBbMCwgMF0pIHtcbiAgICBjb25zdCBwb2ludHMgPSBbXTsgLy8gaWYgaXQgaXMgYW4gYXJyYXksIHdlIGZsYXR0ZW4gaXQgYW5kIHRoZXJlZm9yZSBjbG9uZSBpdCB0byAxIGRlcHRoc1xuXG4gICAgaWYgKGFycmF5IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGFycmF5ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgYXJyYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFbHNlLCBpdCBpcyBjb25zaWRlcmVkIGFzIGEgc3RyaW5nXG4gICAgICAvLyBwYXJzZSBwb2ludHNcbiAgICAgIGFycmF5ID0gYXJyYXkudHJpbSgpLnNwbGl0KGRlbGltaXRlcikubWFwKHBhcnNlRmxvYXQpO1xuICAgIH0gLy8gdmFsaWRhdGUgcG9pbnRzIC0gaHR0cHM6Ly9zdmd3Zy5vcmcvc3ZnMi1kcmFmdC9zaGFwZXMuaHRtbCNEYXRhVHlwZVBvaW50c1xuICAgIC8vIE9kZCBudW1iZXIgb2YgY29vcmRpbmF0ZXMgaXMgYW4gZXJyb3IuIEluIHN1Y2ggY2FzZXMsIGRyb3AgdGhlIGxhc3Qgb2RkIGNvb3JkaW5hdGUuXG5cblxuICAgIGlmIChhcnJheS5sZW5ndGggJSAyICE9PSAwKSBhcnJheS5wb3AoKTsgLy8gd3JhcCBwb2ludHMgaW4gdHdvLXR1cGxlc1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSA9IGkgKyAyKSB7XG4gICAgICBwb2ludHMucHVzaChbYXJyYXlbaV0sIGFycmF5W2kgKyAxXV0pO1xuICAgIH1cblxuICAgIHJldHVybiBwb2ludHM7XG4gIH0gLy8gUmVzaXplIHBvbHkgc3RyaW5nXG5cblxuICBzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBsZXQgaTtcbiAgICBjb25zdCBib3ggPSB0aGlzLmJib3goKTsgLy8gcmVjYWxjdWxhdGUgcG9zaXRpb24gb2YgYWxsIHBvaW50cyBhY2NvcmRpbmcgdG8gbmV3IHNpemVcblxuICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChib3gud2lkdGgpIHRoaXNbaV1bMF0gPSAodGhpc1tpXVswXSAtIGJveC54KSAqIHdpZHRoIC8gYm94LndpZHRoICsgYm94Lng7XG4gICAgICBpZiAoYm94LmhlaWdodCkgdGhpc1tpXVsxXSA9ICh0aGlzW2ldWzFdIC0gYm94LnkpICogaGVpZ2h0IC8gYm94LmhlaWdodCArIGJveC55O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIENvbnZlcnQgYXJyYXkgdG8gbGluZSBvYmplY3RcblxuXG4gIHRvTGluZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDE6IHRoaXNbMF1bMF0sXG4gICAgICB5MTogdGhpc1swXVsxXSxcbiAgICAgIHgyOiB0aGlzWzFdWzBdLFxuICAgICAgeTI6IHRoaXNbMV1bMV1cbiAgICB9O1xuICB9IC8vIENvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG5cblxuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCBhcnJheSA9IFtdOyAvLyBjb252ZXJ0IHRvIGEgcG9seSBwb2ludCBzdHJpbmdcblxuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHRoaXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgYXJyYXkucHVzaCh0aGlzW2ldLmpvaW4oJywnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5LmpvaW4oJyAnKTtcbiAgfVxuXG4gIHRyYW5zZm9ybShtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS50cmFuc2Zvcm1PKG0pO1xuICB9IC8vIHRyYW5zZm9ybSBwb2ludHMgd2l0aCBtYXRyaXggKHNpbWlsYXIgdG8gUG9pbnQudHJhbnNmb3JtKVxuXG5cbiAgdHJhbnNmb3JtTyhtKSB7XG4gICAgaWYgKCFNYXRyaXguaXNNYXRyaXhMaWtlKG0pKSB7XG4gICAgICBtID0gbmV3IE1hdHJpeChtKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gdGhpcy5sZW5ndGg7IGktLTspIHtcbiAgICAgIC8vIFBlcmZvcm0gdGhlIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgICAgY29uc3QgW3gsIHldID0gdGhpc1tpXTtcbiAgICAgIHRoaXNbaV1bMF0gPSBtLmEgKiB4ICsgbS5jICogeSArIG0uZTtcbiAgICAgIHRoaXNbaV1bMV0gPSBtLmIgKiB4ICsgbS5kICogeSArIG0uZjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59XG5cbmNvbnN0IE1vcnBoQXJyYXkgPSBQb2ludEFycmF5OyAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lciBvdmVyIHgtYXhpc1xuXG5mdW5jdGlvbiB4JDIoeCkge1xuICByZXR1cm4geCA9PSBudWxsID8gdGhpcy5iYm94KCkueCA6IHRoaXMubW92ZSh4LCB0aGlzLmJib3goKS55KTtcbn0gLy8gTW92ZSBieSBsZWZ0IHRvcCBjb3JuZXIgb3ZlciB5LWF4aXNcblxuZnVuY3Rpb24geSQyKHkpIHtcbiAgcmV0dXJuIHkgPT0gbnVsbCA/IHRoaXMuYmJveCgpLnkgOiB0aGlzLm1vdmUodGhpcy5iYm94KCkueCwgeSk7XG59IC8vIFNldCB3aWR0aCBvZiBlbGVtZW50XG5cbmZ1bmN0aW9uIHdpZHRoJDEod2lkdGgpIHtcbiAgY29uc3QgYiA9IHRoaXMuYmJveCgpO1xuICByZXR1cm4gd2lkdGggPT0gbnVsbCA/IGIud2lkdGggOiB0aGlzLnNpemUod2lkdGgsIGIuaGVpZ2h0KTtcbn0gLy8gU2V0IGhlaWdodCBvZiBlbGVtZW50XG5cbmZ1bmN0aW9uIGhlaWdodCQxKGhlaWdodCkge1xuICBjb25zdCBiID0gdGhpcy5iYm94KCk7XG4gIHJldHVybiBoZWlnaHQgPT0gbnVsbCA/IGIuaGVpZ2h0IDogdGhpcy5zaXplKGIud2lkdGgsIGhlaWdodCk7XG59XG5cbnZhciBwb2ludGVkID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIE1vcnBoQXJyYXk6IE1vcnBoQXJyYXksXG4gIHg6IHgkMixcbiAgeTogeSQyLFxuICB3aWR0aDogd2lkdGgkMSxcbiAgaGVpZ2h0OiBoZWlnaHQkMVxufTtcblxuY2xhc3MgTGluZSBleHRlbmRzIFNoYXBlIHtcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygnbGluZScsIG5vZGUpLCBhdHRycyk7XG4gIH0gLy8gR2V0IGFycmF5XG5cblxuICBhcnJheSgpIHtcbiAgICByZXR1cm4gbmV3IFBvaW50QXJyYXkoW1t0aGlzLmF0dHIoJ3gxJyksIHRoaXMuYXR0cigneTEnKV0sIFt0aGlzLmF0dHIoJ3gyJyksIHRoaXMuYXR0cigneTInKV1dKTtcbiAgfSAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lclxuXG5cbiAgbW92ZSh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cih0aGlzLmFycmF5KCkubW92ZSh4LCB5KS50b0xpbmUoKSk7XG4gIH0gLy8gT3ZlcndyaXRlIG5hdGl2ZSBwbG90KCkgbWV0aG9kXG5cblxuICBwbG90KHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgaWYgKHgxID09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLmFycmF5KCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgeTEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB4MSA9IHtcbiAgICAgICAgeDEsXG4gICAgICAgIHkxLFxuICAgICAgICB4MixcbiAgICAgICAgeTJcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHgxID0gbmV3IFBvaW50QXJyYXkoeDEpLnRvTGluZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmF0dHIoeDEpO1xuICB9IC8vIFNldCBlbGVtZW50IHNpemUgdG8gZ2l2ZW4gd2lkdGggYW5kIGhlaWdodFxuXG5cbiAgc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodCk7XG4gICAgcmV0dXJuIHRoaXMuYXR0cih0aGlzLmFycmF5KCkuc2l6ZShwLndpZHRoLCBwLmhlaWdodCkudG9MaW5lKCkpO1xuICB9XG5cbn1cbmV4dGVuZChMaW5lLCBwb2ludGVkKTtcbnJlZ2lzdGVyTWV0aG9kcyh7XG4gIENvbnRhaW5lcjoge1xuICAgIC8vIENyZWF0ZSBhIGxpbmUgZWxlbWVudFxuICAgIGxpbmU6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgcGxvdCBpcyBjYWxsZWQgYXMgYSBzZXR0ZXJcbiAgICAgIC8vIHgxIGlzIG5vdCBuZWNlc3NhcmlseSBhIG51bWJlciwgaXQgY2FuIGFsc28gYmUgYW4gYXJyYXksIGEgc3RyaW5nIGFuZCBhIFBvaW50QXJyYXlcbiAgICAgIHJldHVybiBMaW5lLnByb3RvdHlwZS5wbG90LmFwcGx5KHRoaXMucHV0KG5ldyBMaW5lKCkpLCBhcmdzWzBdICE9IG51bGwgPyBhcmdzIDogWzAsIDAsIDAsIDBdKTtcbiAgICB9KVxuICB9XG59KTtcbnJlZ2lzdGVyKExpbmUsICdMaW5lJyk7XG5cbmNsYXNzIE1hcmtlciBleHRlbmRzIENvbnRhaW5lciB7XG4gIC8vIEluaXRpYWxpemUgbm9kZVxuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ21hcmtlcicsIG5vZGUpLCBhdHRycyk7XG4gIH0gLy8gU2V0IGhlaWdodCBvZiBlbGVtZW50XG5cblxuICBoZWlnaHQoaGVpZ2h0KSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cignbWFya2VySGVpZ2h0JywgaGVpZ2h0KTtcbiAgfVxuXG4gIG9yaWVudChvcmllbnQpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdvcmllbnQnLCBvcmllbnQpO1xuICB9IC8vIFNldCBtYXJrZXIgcmVmWCBhbmQgcmVmWVxuXG5cbiAgcmVmKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdyZWZYJywgeCkuYXR0cigncmVmWScsIHkpO1xuICB9IC8vIFJldHVybiB0aGUgZmlsbCBpZFxuXG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICd1cmwoIycgKyB0aGlzLmlkKCkgKyAnKSc7XG4gIH0gLy8gVXBkYXRlIG1hcmtlclxuXG5cbiAgdXBkYXRlKGJsb2NrKSB7XG4gICAgLy8gcmVtb3ZlIGFsbCBjb250ZW50XG4gICAgdGhpcy5jbGVhcigpOyAvLyBpbnZva2UgcGFzc2VkIGJsb2NrXG5cbiAgICBpZiAodHlwZW9mIGJsb2NrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBibG9jay5jYWxsKHRoaXMsIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIFNldCB3aWR0aCBvZiBlbGVtZW50XG5cblxuICB3aWR0aCh3aWR0aCkge1xuICAgIHJldHVybiB0aGlzLmF0dHIoJ21hcmtlcldpZHRoJywgd2lkdGgpO1xuICB9XG5cbn1cbnJlZ2lzdGVyTWV0aG9kcyh7XG4gIENvbnRhaW5lcjoge1xuICAgIG1hcmtlciguLi5hcmdzKSB7XG4gICAgICAvLyBDcmVhdGUgbWFya2VyIGVsZW1lbnQgaW4gZGVmc1xuICAgICAgcmV0dXJuIHRoaXMuZGVmcygpLm1hcmtlciguLi5hcmdzKTtcbiAgICB9XG5cbiAgfSxcbiAgRGVmczoge1xuICAgIC8vIENyZWF0ZSBtYXJrZXJcbiAgICBtYXJrZXI6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0LCBibG9jaykge1xuICAgICAgLy8gU2V0IGRlZmF1bHQgdmlld2JveCB0byBtYXRjaCB0aGUgd2lkdGggYW5kIGhlaWdodCwgc2V0IHJlZiB0byBjeCBhbmQgY3kgYW5kIHNldCBvcmllbnQgdG8gYXV0b1xuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBNYXJrZXIoKSkuc2l6ZSh3aWR0aCwgaGVpZ2h0KS5yZWYod2lkdGggLyAyLCBoZWlnaHQgLyAyKS52aWV3Ym94KDAsIDAsIHdpZHRoLCBoZWlnaHQpLmF0dHIoJ29yaWVudCcsICdhdXRvJykudXBkYXRlKGJsb2NrKTtcbiAgICB9KVxuICB9LFxuICBtYXJrZXI6IHtcbiAgICAvLyBDcmVhdGUgYW5kIGF0dGFjaCBtYXJrZXJzXG4gICAgbWFya2VyKG1hcmtlciwgd2lkdGgsIGhlaWdodCwgYmxvY2spIHtcbiAgICAgIGxldCBhdHRyID0gWydtYXJrZXInXTsgLy8gQnVpbGQgYXR0cmlidXRlIG5hbWVcblxuICAgICAgaWYgKG1hcmtlciAhPT0gJ2FsbCcpIGF0dHIucHVzaChtYXJrZXIpO1xuICAgICAgYXR0ciA9IGF0dHIuam9pbignLScpOyAvLyBTZXQgbWFya2VyIGF0dHJpYnV0ZVxuXG4gICAgICBtYXJrZXIgPSBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBNYXJrZXIgPyBhcmd1bWVudHNbMV0gOiB0aGlzLmRlZnMoKS5tYXJrZXIod2lkdGgsIGhlaWdodCwgYmxvY2spO1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cihhdHRyLCBtYXJrZXIpO1xuICAgIH1cblxuICB9XG59KTtcbnJlZ2lzdGVyKE1hcmtlciwgJ01hcmtlcicpO1xuXG4vKioqXG5CYXNlIENsYXNzXG49PT09PT09PT09XG5UaGUgYmFzZSBzdGVwcGVyIGNsYXNzIHRoYXQgd2lsbCBiZVxuKioqL1xuXG5mdW5jdGlvbiBtYWtlU2V0dGVyR2V0dGVyKGssIGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgaWYgKHYgPT0gbnVsbCkgcmV0dXJuIHRoaXNba107XG4gICAgdGhpc1trXSA9IHY7XG4gICAgaWYgKGYpIGYuY2FsbCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn1cblxuY29uc3QgZWFzaW5nID0ge1xuICAnLSc6IGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gcG9zO1xuICB9LFxuICAnPD4nOiBmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIC1NYXRoLmNvcyhwb3MgKiBNYXRoLlBJKSAvIDIgKyAwLjU7XG4gIH0sXG4gICc+JzogZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiBNYXRoLnNpbihwb3MgKiBNYXRoLlBJIC8gMik7XG4gIH0sXG4gICc8JzogZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiAtTWF0aC5jb3MocG9zICogTWF0aC5QSSAvIDIpICsgMTtcbiAgfSxcbiAgYmV6aWVyOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAvLyBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1lYXNpbmctMS8jY3ViaWMtYmV6aWVyLWFsZ29cbiAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGlmICh0IDwgMCkge1xuICAgICAgICBpZiAoeDEgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHkxIC8geDEgKiB0O1xuICAgICAgICB9IGVsc2UgaWYgKHgyID4gMCkge1xuICAgICAgICAgIHJldHVybiB5MiAvIHgyICogdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0ID4gMSkge1xuICAgICAgICBpZiAoeDIgPCAxKSB7XG4gICAgICAgICAgcmV0dXJuICgxIC0geTIpIC8gKDEgLSB4MikgKiB0ICsgKHkyIC0geDIpIC8gKDEgLSB4Mik7XG4gICAgICAgIH0gZWxzZSBpZiAoeDEgPCAxKSB7XG4gICAgICAgICAgcmV0dXJuICgxIC0geTEpIC8gKDEgLSB4MSkgKiB0ICsgKHkxIC0geDEpIC8gKDEgLSB4MSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAzICogdCAqICgxIC0gdCkgKiogMiAqIHkxICsgMyAqIHQgKiogMiAqICgxIC0gdCkgKiB5MiArIHQgKiogMztcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICAvLyBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1lYXNpbmctMS8jc3RlcC10aW1pbmctZnVuY3Rpb24tYWxnb1xuICBzdGVwczogZnVuY3Rpb24gKHN0ZXBzLCBzdGVwUG9zaXRpb24gPSAnZW5kJykge1xuICAgIC8vIGRlYWwgd2l0aCBcImp1bXAtXCIgcHJlZml4XG4gICAgc3RlcFBvc2l0aW9uID0gc3RlcFBvc2l0aW9uLnNwbGl0KCctJykucmV2ZXJzZSgpWzBdO1xuICAgIGxldCBqdW1wcyA9IHN0ZXBzO1xuXG4gICAgaWYgKHN0ZXBQb3NpdGlvbiA9PT0gJ25vbmUnKSB7XG4gICAgICAtLWp1bXBzO1xuICAgIH0gZWxzZSBpZiAoc3RlcFBvc2l0aW9uID09PSAnYm90aCcpIHtcbiAgICAgICsranVtcHM7XG4gICAgfSAvLyBUaGUgYmVmb3JlRmxhZyBpcyBlc3NlbnRpYWxseSB1c2VsZXNzXG5cblxuICAgIHJldHVybiAodCwgYmVmb3JlRmxhZyA9IGZhbHNlKSA9PiB7XG4gICAgICAvLyBTdGVwIGlzIGNhbGxlZCBjdXJyZW50U3RlcCBpbiByZWZlcmVuY2VkIHVybFxuICAgICAgbGV0IHN0ZXAgPSBNYXRoLmZsb29yKHQgKiBzdGVwcyk7XG4gICAgICBjb25zdCBqdW1waW5nID0gdCAqIHN0ZXAgJSAxID09PSAwO1xuXG4gICAgICBpZiAoc3RlcFBvc2l0aW9uID09PSAnc3RhcnQnIHx8IHN0ZXBQb3NpdGlvbiA9PT0gJ2JvdGgnKSB7XG4gICAgICAgICsrc3RlcDtcbiAgICAgIH1cblxuICAgICAgaWYgKGJlZm9yZUZsYWcgJiYganVtcGluZykge1xuICAgICAgICAtLXN0ZXA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ID49IDAgJiYgc3RlcCA8IDApIHtcbiAgICAgICAgc3RlcCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0IDw9IDEgJiYgc3RlcCA+IGp1bXBzKSB7XG4gICAgICAgIHN0ZXAgPSBqdW1wcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0ZXAgLyBqdW1wcztcbiAgICB9O1xuICB9XG59O1xuY2xhc3MgU3RlcHBlciB7XG4gIGRvbmUoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbn1cbi8qKipcbkVhc2luZyBGdW5jdGlvbnNcbj09PT09PT09PT09PT09PT1cbioqKi9cblxuY2xhc3MgRWFzZSBleHRlbmRzIFN0ZXBwZXIge1xuICBjb25zdHJ1Y3RvcihmbiA9IHRpbWVsaW5lLmVhc2UpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZWFzZSA9IGVhc2luZ1tmbl0gfHwgZm47XG4gIH1cblxuICBzdGVwKGZyb20sIHRvLCBwb3MpIHtcbiAgICBpZiAodHlwZW9mIGZyb20gIT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gcG9zIDwgMSA/IGZyb20gOiB0bztcbiAgICB9XG5cbiAgICByZXR1cm4gZnJvbSArICh0byAtIGZyb20pICogdGhpcy5lYXNlKHBvcyk7XG4gIH1cblxufVxuLyoqKlxuQ29udHJvbGxlciBUeXBlc1xuPT09PT09PT09PT09PT09PVxuKioqL1xuXG5jbGFzcyBDb250cm9sbGVyIGV4dGVuZHMgU3RlcHBlciB7XG4gIGNvbnN0cnVjdG9yKGZuKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnN0ZXBwZXIgPSBmbjtcbiAgfVxuXG4gIGRvbmUoYykge1xuICAgIHJldHVybiBjLmRvbmU7XG4gIH1cblxuICBzdGVwKGN1cnJlbnQsIHRhcmdldCwgZHQsIGMpIHtcbiAgICByZXR1cm4gdGhpcy5zdGVwcGVyKGN1cnJlbnQsIHRhcmdldCwgZHQsIGMpO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gcmVjYWxjdWxhdGUoKSB7XG4gIC8vIEFwcGx5IHRoZSBkZWZhdWx0IHBhcmFtZXRlcnNcbiAgY29uc3QgZHVyYXRpb24gPSAodGhpcy5fZHVyYXRpb24gfHwgNTAwKSAvIDEwMDA7XG4gIGNvbnN0IG92ZXJzaG9vdCA9IHRoaXMuX292ZXJzaG9vdCB8fCAwOyAvLyBDYWxjdWxhdGUgdGhlIFBJRCBuYXR1cmFsIHJlc3BvbnNlXG5cbiAgY29uc3QgZXBzID0gMWUtMTA7XG4gIGNvbnN0IHBpID0gTWF0aC5QSTtcbiAgY29uc3Qgb3MgPSBNYXRoLmxvZyhvdmVyc2hvb3QgLyAxMDAgKyBlcHMpO1xuICBjb25zdCB6ZXRhID0gLW9zIC8gTWF0aC5zcXJ0KHBpICogcGkgKyBvcyAqIG9zKTtcbiAgY29uc3Qgd24gPSAzLjkgLyAoemV0YSAqIGR1cmF0aW9uKTsgLy8gQ2FsY3VsYXRlIHRoZSBTcHJpbmcgdmFsdWVzXG5cbiAgdGhpcy5kID0gMiAqIHpldGEgKiB3bjtcbiAgdGhpcy5rID0gd24gKiB3bjtcbn1cblxuY2xhc3MgU3ByaW5nIGV4dGVuZHMgQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGR1cmF0aW9uID0gNTAwLCBvdmVyc2hvb3QgPSAwKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmR1cmF0aW9uKGR1cmF0aW9uKS5vdmVyc2hvb3Qob3ZlcnNob290KTtcbiAgfVxuXG4gIHN0ZXAoY3VycmVudCwgdGFyZ2V0LCBkdCwgYykge1xuICAgIGlmICh0eXBlb2YgY3VycmVudCA9PT0gJ3N0cmluZycpIHJldHVybiBjdXJyZW50O1xuICAgIGMuZG9uZSA9IGR0ID09PSBJbmZpbml0eTtcbiAgICBpZiAoZHQgPT09IEluZmluaXR5KSByZXR1cm4gdGFyZ2V0O1xuICAgIGlmIChkdCA9PT0gMCkgcmV0dXJuIGN1cnJlbnQ7XG4gICAgaWYgKGR0ID4gMTAwKSBkdCA9IDE2O1xuICAgIGR0IC89IDEwMDA7IC8vIEdldCB0aGUgcHJldmlvdXMgdmVsb2NpdHlcblxuICAgIGNvbnN0IHZlbG9jaXR5ID0gYy52ZWxvY2l0eSB8fCAwOyAvLyBBcHBseSB0aGUgY29udHJvbCB0byBnZXQgdGhlIG5ldyBwb3NpdGlvbiBhbmQgc3RvcmUgaXRcblxuICAgIGNvbnN0IGFjY2VsZXJhdGlvbiA9IC10aGlzLmQgKiB2ZWxvY2l0eSAtIHRoaXMuayAqIChjdXJyZW50IC0gdGFyZ2V0KTtcbiAgICBjb25zdCBuZXdQb3NpdGlvbiA9IGN1cnJlbnQgKyB2ZWxvY2l0eSAqIGR0ICsgYWNjZWxlcmF0aW9uICogZHQgKiBkdCAvIDI7IC8vIFN0b3JlIHRoZSB2ZWxvY2l0eVxuXG4gICAgYy52ZWxvY2l0eSA9IHZlbG9jaXR5ICsgYWNjZWxlcmF0aW9uICogZHQ7IC8vIEZpZ3VyZSBvdXQgaWYgd2UgaGF2ZSBjb252ZXJnZWQsIGFuZCBpZiBzbywgcGFzcyB0aGUgdmFsdWVcblxuICAgIGMuZG9uZSA9IE1hdGguYWJzKHRhcmdldCAtIG5ld1Bvc2l0aW9uKSArIE1hdGguYWJzKHZlbG9jaXR5KSA8IDAuMDAyO1xuICAgIHJldHVybiBjLmRvbmUgPyB0YXJnZXQgOiBuZXdQb3NpdGlvbjtcbiAgfVxuXG59XG5leHRlbmQoU3ByaW5nLCB7XG4gIGR1cmF0aW9uOiBtYWtlU2V0dGVyR2V0dGVyKCdfZHVyYXRpb24nLCByZWNhbGN1bGF0ZSksXG4gIG92ZXJzaG9vdDogbWFrZVNldHRlckdldHRlcignX292ZXJzaG9vdCcsIHJlY2FsY3VsYXRlKVxufSk7XG5jbGFzcyBQSUQgZXh0ZW5kcyBDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IocCA9IDAuMSwgaSA9IDAuMDEsIGQgPSAwLCB3aW5kdXAgPSAxMDAwKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnAocCkuaShpKS5kKGQpLndpbmR1cCh3aW5kdXApO1xuICB9XG5cbiAgc3RlcChjdXJyZW50LCB0YXJnZXQsIGR0LCBjKSB7XG4gICAgaWYgKHR5cGVvZiBjdXJyZW50ID09PSAnc3RyaW5nJykgcmV0dXJuIGN1cnJlbnQ7XG4gICAgYy5kb25lID0gZHQgPT09IEluZmluaXR5O1xuICAgIGlmIChkdCA9PT0gSW5maW5pdHkpIHJldHVybiB0YXJnZXQ7XG4gICAgaWYgKGR0ID09PSAwKSByZXR1cm4gY3VycmVudDtcbiAgICBjb25zdCBwID0gdGFyZ2V0IC0gY3VycmVudDtcbiAgICBsZXQgaSA9IChjLmludGVncmFsIHx8IDApICsgcCAqIGR0O1xuICAgIGNvbnN0IGQgPSAocCAtIChjLmVycm9yIHx8IDApKSAvIGR0O1xuICAgIGNvbnN0IHdpbmR1cCA9IHRoaXMuX3dpbmR1cDsgLy8gYW50aXdpbmR1cFxuXG4gICAgaWYgKHdpbmR1cCAhPT0gZmFsc2UpIHtcbiAgICAgIGkgPSBNYXRoLm1heCgtd2luZHVwLCBNYXRoLm1pbihpLCB3aW5kdXApKTtcbiAgICB9XG5cbiAgICBjLmVycm9yID0gcDtcbiAgICBjLmludGVncmFsID0gaTtcbiAgICBjLmRvbmUgPSBNYXRoLmFicyhwKSA8IDAuMDAxO1xuICAgIHJldHVybiBjLmRvbmUgPyB0YXJnZXQgOiBjdXJyZW50ICsgKHRoaXMuUCAqIHAgKyB0aGlzLkkgKiBpICsgdGhpcy5EICogZCk7XG4gIH1cblxufVxuZXh0ZW5kKFBJRCwge1xuICB3aW5kdXA6IG1ha2VTZXR0ZXJHZXR0ZXIoJ193aW5kdXAnKSxcbiAgcDogbWFrZVNldHRlckdldHRlcignUCcpLFxuICBpOiBtYWtlU2V0dGVyR2V0dGVyKCdJJyksXG4gIGQ6IG1ha2VTZXR0ZXJHZXR0ZXIoJ0QnKVxufSk7XG5cbmNvbnN0IHNlZ21lbnRQYXJhbWV0ZXJzID0ge1xuICBNOiAyLFxuICBMOiAyLFxuICBIOiAxLFxuICBWOiAxLFxuICBDOiA2LFxuICBTOiA0LFxuICBROiA0LFxuICBUOiAyLFxuICBBOiA3LFxuICBaOiAwXG59O1xuY29uc3QgcGF0aEhhbmRsZXJzID0ge1xuICBNOiBmdW5jdGlvbiAoYywgcCwgcDApIHtcbiAgICBwLnggPSBwMC54ID0gY1swXTtcbiAgICBwLnkgPSBwMC55ID0gY1sxXTtcbiAgICByZXR1cm4gWydNJywgcC54LCBwLnldO1xuICB9LFxuICBMOiBmdW5jdGlvbiAoYywgcCkge1xuICAgIHAueCA9IGNbMF07XG4gICAgcC55ID0gY1sxXTtcbiAgICByZXR1cm4gWydMJywgY1swXSwgY1sxXV07XG4gIH0sXG4gIEg6IGZ1bmN0aW9uIChjLCBwKSB7XG4gICAgcC54ID0gY1swXTtcbiAgICByZXR1cm4gWydIJywgY1swXV07XG4gIH0sXG4gIFY6IGZ1bmN0aW9uIChjLCBwKSB7XG4gICAgcC55ID0gY1swXTtcbiAgICByZXR1cm4gWydWJywgY1swXV07XG4gIH0sXG4gIEM6IGZ1bmN0aW9uIChjLCBwKSB7XG4gICAgcC54ID0gY1s0XTtcbiAgICBwLnkgPSBjWzVdO1xuICAgIHJldHVybiBbJ0MnLCBjWzBdLCBjWzFdLCBjWzJdLCBjWzNdLCBjWzRdLCBjWzVdXTtcbiAgfSxcbiAgUzogZnVuY3Rpb24gKGMsIHApIHtcbiAgICBwLnggPSBjWzJdO1xuICAgIHAueSA9IGNbM107XG4gICAgcmV0dXJuIFsnUycsIGNbMF0sIGNbMV0sIGNbMl0sIGNbM11dO1xuICB9LFxuICBROiBmdW5jdGlvbiAoYywgcCkge1xuICAgIHAueCA9IGNbMl07XG4gICAgcC55ID0gY1szXTtcbiAgICByZXR1cm4gWydRJywgY1swXSwgY1sxXSwgY1syXSwgY1szXV07XG4gIH0sXG4gIFQ6IGZ1bmN0aW9uIChjLCBwKSB7XG4gICAgcC54ID0gY1swXTtcbiAgICBwLnkgPSBjWzFdO1xuICAgIHJldHVybiBbJ1QnLCBjWzBdLCBjWzFdXTtcbiAgfSxcbiAgWjogZnVuY3Rpb24gKGMsIHAsIHAwKSB7XG4gICAgcC54ID0gcDAueDtcbiAgICBwLnkgPSBwMC55O1xuICAgIHJldHVybiBbJ1onXTtcbiAgfSxcbiAgQTogZnVuY3Rpb24gKGMsIHApIHtcbiAgICBwLnggPSBjWzVdO1xuICAgIHAueSA9IGNbNl07XG4gICAgcmV0dXJuIFsnQScsIGNbMF0sIGNbMV0sIGNbMl0sIGNbM10sIGNbNF0sIGNbNV0sIGNbNl1dO1xuICB9XG59O1xuY29uc3QgbWxodnF0Y3NheiA9ICdtbGh2cXRjc2F6Jy5zcGxpdCgnJyk7XG5cbmZvciAobGV0IGkgPSAwLCBpbCA9IG1saHZxdGNzYXoubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICBwYXRoSGFuZGxlcnNbbWxodnF0Y3NheltpXV0gPSBmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYywgcCwgcDApIHtcbiAgICAgIGlmIChpID09PSAnSCcpIGNbMF0gPSBjWzBdICsgcC54O2Vsc2UgaWYgKGkgPT09ICdWJykgY1swXSA9IGNbMF0gKyBwLnk7ZWxzZSBpZiAoaSA9PT0gJ0EnKSB7XG4gICAgICAgIGNbNV0gPSBjWzVdICsgcC54O1xuICAgICAgICBjWzZdID0gY1s2XSArIHAueTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IGMubGVuZ3RoOyBqIDwgamw7ICsraikge1xuICAgICAgICAgIGNbal0gPSBjW2pdICsgKGogJSAyID8gcC55IDogcC54KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGhIYW5kbGVyc1tpXShjLCBwLCBwMCk7XG4gICAgfTtcbiAgfShtbGh2cXRjc2F6W2ldLnRvVXBwZXJDYXNlKCkpO1xufVxuXG5mdW5jdGlvbiBtYWtlQWJzb2x1dChwYXJzZXIpIHtcbiAgY29uc3QgY29tbWFuZCA9IHBhcnNlci5zZWdtZW50WzBdO1xuICByZXR1cm4gcGF0aEhhbmRsZXJzW2NvbW1hbmRdKHBhcnNlci5zZWdtZW50LnNsaWNlKDEpLCBwYXJzZXIucCwgcGFyc2VyLnAwKTtcbn1cblxuZnVuY3Rpb24gc2VnbWVudENvbXBsZXRlKHBhcnNlcikge1xuICByZXR1cm4gcGFyc2VyLnNlZ21lbnQubGVuZ3RoICYmIHBhcnNlci5zZWdtZW50Lmxlbmd0aCAtIDEgPT09IHNlZ21lbnRQYXJhbWV0ZXJzW3BhcnNlci5zZWdtZW50WzBdLnRvVXBwZXJDYXNlKCldO1xufVxuXG5mdW5jdGlvbiBzdGFydE5ld1NlZ21lbnQocGFyc2VyLCB0b2tlbikge1xuICBwYXJzZXIuaW5OdW1iZXIgJiYgZmluYWxpemVOdW1iZXIocGFyc2VyLCBmYWxzZSk7XG4gIGNvbnN0IHBhdGhMZXR0ZXIgPSBpc1BhdGhMZXR0ZXIudGVzdCh0b2tlbik7XG5cbiAgaWYgKHBhdGhMZXR0ZXIpIHtcbiAgICBwYXJzZXIuc2VnbWVudCA9IFt0b2tlbl07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbGFzdENvbW1hbmQgPSBwYXJzZXIubGFzdENvbW1hbmQ7XG4gICAgY29uc3Qgc21hbGwgPSBsYXN0Q29tbWFuZC50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGlzU21hbGwgPSBsYXN0Q29tbWFuZCA9PT0gc21hbGw7XG4gICAgcGFyc2VyLnNlZ21lbnQgPSBbc21hbGwgPT09ICdtJyA/IGlzU21hbGwgPyAnbCcgOiAnTCcgOiBsYXN0Q29tbWFuZF07XG4gIH1cblxuICBwYXJzZXIuaW5TZWdtZW50ID0gdHJ1ZTtcbiAgcGFyc2VyLmxhc3RDb21tYW5kID0gcGFyc2VyLnNlZ21lbnRbMF07XG4gIHJldHVybiBwYXRoTGV0dGVyO1xufVxuXG5mdW5jdGlvbiBmaW5hbGl6ZU51bWJlcihwYXJzZXIsIGluTnVtYmVyKSB7XG4gIGlmICghcGFyc2VyLmluTnVtYmVyKSB0aHJvdyBuZXcgRXJyb3IoJ1BhcnNlciBFcnJvcicpO1xuICBwYXJzZXIubnVtYmVyICYmIHBhcnNlci5zZWdtZW50LnB1c2gocGFyc2VGbG9hdChwYXJzZXIubnVtYmVyKSk7XG4gIHBhcnNlci5pbk51bWJlciA9IGluTnVtYmVyO1xuICBwYXJzZXIubnVtYmVyID0gJyc7XG4gIHBhcnNlci5wb2ludFNlZW4gPSBmYWxzZTtcbiAgcGFyc2VyLmhhc0V4cG9uZW50ID0gZmFsc2U7XG5cbiAgaWYgKHNlZ21lbnRDb21wbGV0ZShwYXJzZXIpKSB7XG4gICAgZmluYWxpemVTZWdtZW50KHBhcnNlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluYWxpemVTZWdtZW50KHBhcnNlcikge1xuICBwYXJzZXIuaW5TZWdtZW50ID0gZmFsc2U7XG5cbiAgaWYgKHBhcnNlci5hYnNvbHV0ZSkge1xuICAgIHBhcnNlci5zZWdtZW50ID0gbWFrZUFic29sdXQocGFyc2VyKTtcbiAgfVxuXG4gIHBhcnNlci5zZWdtZW50cy5wdXNoKHBhcnNlci5zZWdtZW50KTtcbn1cblxuZnVuY3Rpb24gaXNBcmNGbGFnKHBhcnNlcikge1xuICBpZiAoIXBhcnNlci5zZWdtZW50Lmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBpc0FyYyA9IHBhcnNlci5zZWdtZW50WzBdLnRvVXBwZXJDYXNlKCkgPT09ICdBJztcbiAgY29uc3QgbGVuZ3RoID0gcGFyc2VyLnNlZ21lbnQubGVuZ3RoO1xuICByZXR1cm4gaXNBcmMgJiYgKGxlbmd0aCA9PT0gNCB8fCBsZW5ndGggPT09IDUpO1xufVxuXG5mdW5jdGlvbiBpc0V4cG9uZW50aWFsKHBhcnNlcikge1xuICByZXR1cm4gcGFyc2VyLmxhc3RUb2tlbi50b1VwcGVyQ2FzZSgpID09PSAnRSc7XG59XG5cbmZ1bmN0aW9uIHBhdGhQYXJzZXIoZCwgdG9BYnNvbHV0ZSA9IHRydWUpIHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgbGV0IHRva2VuID0gJyc7XG4gIGNvbnN0IHBhcnNlciA9IHtcbiAgICBzZWdtZW50OiBbXSxcbiAgICBpbk51bWJlcjogZmFsc2UsXG4gICAgbnVtYmVyOiAnJyxcbiAgICBsYXN0VG9rZW46ICcnLFxuICAgIGluU2VnbWVudDogZmFsc2UsXG4gICAgc2VnbWVudHM6IFtdLFxuICAgIHBvaW50U2VlbjogZmFsc2UsXG4gICAgaGFzRXhwb25lbnQ6IGZhbHNlLFxuICAgIGFic29sdXRlOiB0b0Fic29sdXRlLFxuICAgIHAwOiBuZXcgUG9pbnQoKSxcbiAgICBwOiBuZXcgUG9pbnQoKVxuICB9O1xuXG4gIHdoaWxlIChwYXJzZXIubGFzdFRva2VuID0gdG9rZW4sIHRva2VuID0gZC5jaGFyQXQoaW5kZXgrKykpIHtcbiAgICBpZiAoIXBhcnNlci5pblNlZ21lbnQpIHtcbiAgICAgIGlmIChzdGFydE5ld1NlZ21lbnQocGFyc2VyLCB0b2tlbikpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRva2VuID09PSAnLicpIHtcbiAgICAgIGlmIChwYXJzZXIucG9pbnRTZWVuIHx8IHBhcnNlci5oYXNFeHBvbmVudCkge1xuICAgICAgICBmaW5hbGl6ZU51bWJlcihwYXJzZXIsIGZhbHNlKTtcbiAgICAgICAgLS1pbmRleDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHBhcnNlci5pbk51bWJlciA9IHRydWU7XG4gICAgICBwYXJzZXIucG9pbnRTZWVuID0gdHJ1ZTtcbiAgICAgIHBhcnNlci5udW1iZXIgKz0gdG9rZW47XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoIWlzTmFOKHBhcnNlSW50KHRva2VuKSkpIHtcbiAgICAgIGlmIChwYXJzZXIubnVtYmVyID09PSAnMCcgfHwgaXNBcmNGbGFnKHBhcnNlcikpIHtcbiAgICAgICAgcGFyc2VyLmluTnVtYmVyID0gdHJ1ZTtcbiAgICAgICAgcGFyc2VyLm51bWJlciA9IHRva2VuO1xuICAgICAgICBmaW5hbGl6ZU51bWJlcihwYXJzZXIsIHRydWUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcGFyc2VyLmluTnVtYmVyID0gdHJ1ZTtcbiAgICAgIHBhcnNlci5udW1iZXIgKz0gdG9rZW47XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodG9rZW4gPT09ICcgJyB8fCB0b2tlbiA9PT0gJywnKSB7XG4gICAgICBpZiAocGFyc2VyLmluTnVtYmVyKSB7XG4gICAgICAgIGZpbmFsaXplTnVtYmVyKHBhcnNlciwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodG9rZW4gPT09ICctJykge1xuICAgICAgaWYgKHBhcnNlci5pbk51bWJlciAmJiAhaXNFeHBvbmVudGlhbChwYXJzZXIpKSB7XG4gICAgICAgIGZpbmFsaXplTnVtYmVyKHBhcnNlciwgZmFsc2UpO1xuICAgICAgICAtLWluZGV4O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcGFyc2VyLm51bWJlciArPSB0b2tlbjtcbiAgICAgIHBhcnNlci5pbk51bWJlciA9IHRydWU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodG9rZW4udG9VcHBlckNhc2UoKSA9PT0gJ0UnKSB7XG4gICAgICBwYXJzZXIubnVtYmVyICs9IHRva2VuO1xuICAgICAgcGFyc2VyLmhhc0V4cG9uZW50ID0gdHJ1ZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChpc1BhdGhMZXR0ZXIudGVzdCh0b2tlbikpIHtcbiAgICAgIGlmIChwYXJzZXIuaW5OdW1iZXIpIHtcbiAgICAgICAgZmluYWxpemVOdW1iZXIocGFyc2VyLCBmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKCFzZWdtZW50Q29tcGxldGUocGFyc2VyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnNlciBFcnJvcicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmluYWxpemVTZWdtZW50KHBhcnNlcik7XG4gICAgICB9XG5cbiAgICAgIC0taW5kZXg7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBhcnNlci5pbk51bWJlcikge1xuICAgIGZpbmFsaXplTnVtYmVyKHBhcnNlciwgZmFsc2UpO1xuICB9XG5cbiAgaWYgKHBhcnNlci5pblNlZ21lbnQgJiYgc2VnbWVudENvbXBsZXRlKHBhcnNlcikpIHtcbiAgICBmaW5hbGl6ZVNlZ21lbnQocGFyc2VyKTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZXIuc2VnbWVudHM7XG59XG5cbmZ1bmN0aW9uIGFycmF5VG9TdHJpbmcoYSkge1xuICBsZXQgcyA9ICcnO1xuXG4gIGZvciAobGV0IGkgPSAwLCBpbCA9IGEubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgIHMgKz0gYVtpXVswXTtcblxuICAgIGlmIChhW2ldWzFdICE9IG51bGwpIHtcbiAgICAgIHMgKz0gYVtpXVsxXTtcblxuICAgICAgaWYgKGFbaV1bMl0gIT0gbnVsbCkge1xuICAgICAgICBzICs9ICcgJztcbiAgICAgICAgcyArPSBhW2ldWzJdO1xuXG4gICAgICAgIGlmIChhW2ldWzNdICE9IG51bGwpIHtcbiAgICAgICAgICBzICs9ICcgJztcbiAgICAgICAgICBzICs9IGFbaV1bM107XG4gICAgICAgICAgcyArPSAnICc7XG4gICAgICAgICAgcyArPSBhW2ldWzRdO1xuXG4gICAgICAgICAgaWYgKGFbaV1bNV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcyArPSAnICc7XG4gICAgICAgICAgICBzICs9IGFbaV1bNV07XG4gICAgICAgICAgICBzICs9ICcgJztcbiAgICAgICAgICAgIHMgKz0gYVtpXVs2XTtcblxuICAgICAgICAgICAgaWYgKGFbaV1bN10gIT0gbnVsbCkge1xuICAgICAgICAgICAgICBzICs9ICcgJztcbiAgICAgICAgICAgICAgcyArPSBhW2ldWzddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzICsgJyAnO1xufVxuXG5jbGFzcyBQYXRoQXJyYXkgZXh0ZW5kcyBTVkdBcnJheSB7XG4gIC8vIEdldCBib3VuZGluZyBib3ggb2YgcGF0aFxuICBiYm94KCkge1xuICAgIHBhcnNlcigpLnBhdGguc2V0QXR0cmlidXRlKCdkJywgdGhpcy50b1N0cmluZygpKTtcbiAgICByZXR1cm4gbmV3IEJveChwYXJzZXIubm9kZXMucGF0aC5nZXRCQm94KCkpO1xuICB9IC8vIE1vdmUgcGF0aCBzdHJpbmdcblxuXG4gIG1vdmUoeCwgeSkge1xuICAgIC8vIGdldCBib3VuZGluZyBib3ggb2YgY3VycmVudCBzaXR1YXRpb25cbiAgICBjb25zdCBib3ggPSB0aGlzLmJib3goKTsgLy8gZ2V0IHJlbGF0aXZlIG9mZnNldFxuXG4gICAgeCAtPSBib3gueDtcbiAgICB5IC09IGJveC55O1xuXG4gICAgaWYgKCFpc05hTih4KSAmJiAhaXNOYU4oeSkpIHtcbiAgICAgIC8vIG1vdmUgZXZlcnkgcG9pbnRcbiAgICAgIGZvciAobGV0IGwsIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGwgPSB0aGlzW2ldWzBdO1xuXG4gICAgICAgIGlmIChsID09PSAnTScgfHwgbCA9PT0gJ0wnIHx8IGwgPT09ICdUJykge1xuICAgICAgICAgIHRoaXNbaV1bMV0gKz0geDtcbiAgICAgICAgICB0aGlzW2ldWzJdICs9IHk7XG4gICAgICAgIH0gZWxzZSBpZiAobCA9PT0gJ0gnKSB7XG4gICAgICAgICAgdGhpc1tpXVsxXSArPSB4O1xuICAgICAgICB9IGVsc2UgaWYgKGwgPT09ICdWJykge1xuICAgICAgICAgIHRoaXNbaV1bMV0gKz0geTtcbiAgICAgICAgfSBlbHNlIGlmIChsID09PSAnQycgfHwgbCA9PT0gJ1MnIHx8IGwgPT09ICdRJykge1xuICAgICAgICAgIHRoaXNbaV1bMV0gKz0geDtcbiAgICAgICAgICB0aGlzW2ldWzJdICs9IHk7XG4gICAgICAgICAgdGhpc1tpXVszXSArPSB4O1xuICAgICAgICAgIHRoaXNbaV1bNF0gKz0geTtcblxuICAgICAgICAgIGlmIChsID09PSAnQycpIHtcbiAgICAgICAgICAgIHRoaXNbaV1bNV0gKz0geDtcbiAgICAgICAgICAgIHRoaXNbaV1bNl0gKz0geTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobCA9PT0gJ0EnKSB7XG4gICAgICAgICAgdGhpc1tpXVs2XSArPSB4O1xuICAgICAgICAgIHRoaXNbaV1bN10gKz0geTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIEFic29sdXRpemUgYW5kIHBhcnNlIHBhdGggdG8gYXJyYXlcblxuXG4gIHBhcnNlKGQgPSAnTTAgMCcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkKSkge1xuICAgICAgZCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGQpLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhQYXJzZXIoZCk7XG4gIH0gLy8gUmVzaXplIHBhdGggc3RyaW5nXG5cblxuICBzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAvLyBnZXQgYm91bmRpbmcgYm94IG9mIGN1cnJlbnQgc2l0dWF0aW9uXG4gICAgY29uc3QgYm94ID0gdGhpcy5iYm94KCk7XG4gICAgbGV0IGksIGw7IC8vIElmIHRoZSBib3ggd2lkdGggb3IgaGVpZ2h0IGlzIDAgdGhlbiB3ZSBpZ25vcmVcbiAgICAvLyB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIHJlc3BlY3RpdmUgYXhpc1xuXG4gICAgYm94LndpZHRoID0gYm94LndpZHRoID09PSAwID8gMSA6IGJveC53aWR0aDtcbiAgICBib3guaGVpZ2h0ID0gYm94LmhlaWdodCA9PT0gMCA/IDEgOiBib3guaGVpZ2h0OyAvLyByZWNhbGN1bGF0ZSBwb3NpdGlvbiBvZiBhbGwgcG9pbnRzIGFjY29yZGluZyB0byBuZXcgc2l6ZVxuXG4gICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgbCA9IHRoaXNbaV1bMF07XG5cbiAgICAgIGlmIChsID09PSAnTScgfHwgbCA9PT0gJ0wnIHx8IGwgPT09ICdUJykge1xuICAgICAgICB0aGlzW2ldWzFdID0gKHRoaXNbaV1bMV0gLSBib3gueCkgKiB3aWR0aCAvIGJveC53aWR0aCArIGJveC54O1xuICAgICAgICB0aGlzW2ldWzJdID0gKHRoaXNbaV1bMl0gLSBib3gueSkgKiBoZWlnaHQgLyBib3guaGVpZ2h0ICsgYm94Lnk7XG4gICAgICB9IGVsc2UgaWYgKGwgPT09ICdIJykge1xuICAgICAgICB0aGlzW2ldWzFdID0gKHRoaXNbaV1bMV0gLSBib3gueCkgKiB3aWR0aCAvIGJveC53aWR0aCArIGJveC54O1xuICAgICAgfSBlbHNlIGlmIChsID09PSAnVicpIHtcbiAgICAgICAgdGhpc1tpXVsxXSA9ICh0aGlzW2ldWzFdIC0gYm94LnkpICogaGVpZ2h0IC8gYm94LmhlaWdodCArIGJveC55O1xuICAgICAgfSBlbHNlIGlmIChsID09PSAnQycgfHwgbCA9PT0gJ1MnIHx8IGwgPT09ICdRJykge1xuICAgICAgICB0aGlzW2ldWzFdID0gKHRoaXNbaV1bMV0gLSBib3gueCkgKiB3aWR0aCAvIGJveC53aWR0aCArIGJveC54O1xuICAgICAgICB0aGlzW2ldWzJdID0gKHRoaXNbaV1bMl0gLSBib3gueSkgKiBoZWlnaHQgLyBib3guaGVpZ2h0ICsgYm94Lnk7XG4gICAgICAgIHRoaXNbaV1bM10gPSAodGhpc1tpXVszXSAtIGJveC54KSAqIHdpZHRoIC8gYm94LndpZHRoICsgYm94Lng7XG4gICAgICAgIHRoaXNbaV1bNF0gPSAodGhpc1tpXVs0XSAtIGJveC55KSAqIGhlaWdodCAvIGJveC5oZWlnaHQgKyBib3gueTtcblxuICAgICAgICBpZiAobCA9PT0gJ0MnKSB7XG4gICAgICAgICAgdGhpc1tpXVs1XSA9ICh0aGlzW2ldWzVdIC0gYm94LngpICogd2lkdGggLyBib3gud2lkdGggKyBib3gueDtcbiAgICAgICAgICB0aGlzW2ldWzZdID0gKHRoaXNbaV1bNl0gLSBib3gueSkgKiBoZWlnaHQgLyBib3guaGVpZ2h0ICsgYm94Lnk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobCA9PT0gJ0EnKSB7XG4gICAgICAgIC8vIHJlc2l6ZSByYWRpaVxuICAgICAgICB0aGlzW2ldWzFdID0gdGhpc1tpXVsxXSAqIHdpZHRoIC8gYm94LndpZHRoO1xuICAgICAgICB0aGlzW2ldWzJdID0gdGhpc1tpXVsyXSAqIGhlaWdodCAvIGJveC5oZWlnaHQ7IC8vIG1vdmUgcG9zaXRpb24gdmFsdWVzXG5cbiAgICAgICAgdGhpc1tpXVs2XSA9ICh0aGlzW2ldWzZdIC0gYm94LngpICogd2lkdGggLyBib3gud2lkdGggKyBib3gueDtcbiAgICAgICAgdGhpc1tpXVs3XSA9ICh0aGlzW2ldWzddIC0gYm94LnkpICogaGVpZ2h0IC8gYm94LmhlaWdodCArIGJveC55O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIENvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG5cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYXJyYXlUb1N0cmluZyh0aGlzKTtcbiAgfVxuXG59XG5cbmNvbnN0IGdldENsYXNzRm9yVHlwZSA9IHZhbHVlID0+IHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gU1ZHTnVtYmVyO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKENvbG9yLmlzQ29sb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gQ29sb3I7XG4gICAgfSBlbHNlIGlmIChkZWxpbWl0ZXIudGVzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBpc1BhdGhMZXR0ZXIudGVzdCh2YWx1ZSkgPyBQYXRoQXJyYXkgOiBTVkdBcnJheTtcbiAgICB9IGVsc2UgaWYgKG51bWJlckFuZFVuaXQudGVzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBTVkdOdW1iZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBOb25Nb3JwaGFibGU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG1vcnBoYWJsZVR5cGVzLmluZGV4T2YodmFsdWUuY29uc3RydWN0b3IpID4gLTEpIHtcbiAgICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3I7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gU1ZHQXJyYXk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gT2JqZWN0QmFnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBOb25Nb3JwaGFibGU7XG4gIH1cbn07XG5cbmNsYXNzIE1vcnBoYWJsZSB7XG4gIGNvbnN0cnVjdG9yKHN0ZXBwZXIpIHtcbiAgICB0aGlzLl9zdGVwcGVyID0gc3RlcHBlciB8fCBuZXcgRWFzZSgnLScpO1xuICAgIHRoaXMuX2Zyb20gPSBudWxsO1xuICAgIHRoaXMuX3RvID0gbnVsbDtcbiAgICB0aGlzLl90eXBlID0gbnVsbDtcbiAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9tb3JwaE9iaiA9IG51bGw7XG4gIH1cblxuICBhdChwb3MpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9ycGhPYmoubW9ycGgodGhpcy5fZnJvbSwgdGhpcy5fdG8sIHBvcywgdGhpcy5fc3RlcHBlciwgdGhpcy5fY29udGV4dCk7XG4gIH1cblxuICBkb25lKCkge1xuICAgIGNvbnN0IGNvbXBsZXRlID0gdGhpcy5fY29udGV4dC5tYXAodGhpcy5fc3RlcHBlci5kb25lKS5yZWR1Y2UoZnVuY3Rpb24gKGxhc3QsIGN1cnIpIHtcbiAgICAgIHJldHVybiBsYXN0ICYmIGN1cnI7XG4gICAgfSwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gY29tcGxldGU7XG4gIH1cblxuICBmcm9tKHZhbCkge1xuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Zyb207XG4gICAgfVxuXG4gICAgdGhpcy5fZnJvbSA9IHRoaXMuX3NldCh2YWwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc3RlcHBlcihzdGVwcGVyKSB7XG4gICAgaWYgKHN0ZXBwZXIgPT0gbnVsbCkgcmV0dXJuIHRoaXMuX3N0ZXBwZXI7XG4gICAgdGhpcy5fc3RlcHBlciA9IHN0ZXBwZXI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0byh2YWwpIHtcbiAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLl90bztcbiAgICB9XG5cbiAgICB0aGlzLl90byA9IHRoaXMuX3NldCh2YWwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdHlwZSh0eXBlKSB7XG4gICAgLy8gZ2V0dGVyXG4gICAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gICAgfSAvLyBzZXR0ZXJcblxuXG4gICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBfc2V0KHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLl90eXBlKSB7XG4gICAgICB0aGlzLnR5cGUoZ2V0Q2xhc3NGb3JUeXBlKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdCA9IG5ldyB0aGlzLl90eXBlKHZhbHVlKTtcblxuICAgIGlmICh0aGlzLl90eXBlID09PSBDb2xvcikge1xuICAgICAgcmVzdWx0ID0gdGhpcy5fdG8gPyByZXN1bHRbdGhpcy5fdG9bNF1dKCkgOiB0aGlzLl9mcm9tID8gcmVzdWx0W3RoaXMuX2Zyb21bNF1dKCkgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3R5cGUgPT09IE9iamVjdEJhZykge1xuICAgICAgcmVzdWx0ID0gdGhpcy5fdG8gPyByZXN1bHQuYWxpZ24odGhpcy5fdG8pIDogdGhpcy5fZnJvbSA/IHJlc3VsdC5hbGlnbih0aGlzLl9mcm9tKSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQgPSByZXN1bHQudG9Db25zdW1hYmxlKCk7XG4gICAgdGhpcy5fbW9ycGhPYmogPSB0aGlzLl9tb3JwaE9iaiB8fCBuZXcgdGhpcy5fdHlwZSgpO1xuICAgIHRoaXMuX2NvbnRleHQgPSB0aGlzLl9jb250ZXh0IHx8IEFycmF5LmFwcGx5KG51bGwsIEFycmF5KHJlc3VsdC5sZW5ndGgpKS5tYXAoT2JqZWN0KS5tYXAoZnVuY3Rpb24gKG8pIHtcbiAgICAgIG8uZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbztcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbn1cbmNsYXNzIE5vbk1vcnBoYWJsZSB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICB0aGlzLmluaXQoLi4uYXJncyk7XG4gIH1cblxuICBpbml0KHZhbCkge1xuICAgIHZhbCA9IEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbFswXSA6IHZhbDtcbiAgICB0aGlzLnZhbHVlID0gdmFsO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gW3RoaXMudmFsdWVdO1xuICB9XG5cbiAgdmFsdWVPZigpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxuXG59XG5jbGFzcyBUcmFuc2Zvcm1CYWcge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgdGhpcy5pbml0KC4uLmFyZ3MpO1xuICB9XG5cbiAgaW5pdChvYmopIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICBvYmogPSB7XG4gICAgICAgIHNjYWxlWDogb2JqWzBdLFxuICAgICAgICBzY2FsZVk6IG9ialsxXSxcbiAgICAgICAgc2hlYXI6IG9ialsyXSxcbiAgICAgICAgcm90YXRlOiBvYmpbM10sXG4gICAgICAgIHRyYW5zbGF0ZVg6IG9ials0XSxcbiAgICAgICAgdHJhbnNsYXRlWTogb2JqWzVdLFxuICAgICAgICBvcmlnaW5YOiBvYmpbNl0sXG4gICAgICAgIG9yaWdpblk6IG9ials3XVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIFRyYW5zZm9ybUJhZy5kZWZhdWx0cywgb2JqKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRvQXJyYXkoKSB7XG4gICAgY29uc3QgdiA9IHRoaXM7XG4gICAgcmV0dXJuIFt2LnNjYWxlWCwgdi5zY2FsZVksIHYuc2hlYXIsIHYucm90YXRlLCB2LnRyYW5zbGF0ZVgsIHYudHJhbnNsYXRlWSwgdi5vcmlnaW5YLCB2Lm9yaWdpblldO1xuICB9XG5cbn1cblRyYW5zZm9ybUJhZy5kZWZhdWx0cyA9IHtcbiAgc2NhbGVYOiAxLFxuICBzY2FsZVk6IDEsXG4gIHNoZWFyOiAwLFxuICByb3RhdGU6IDAsXG4gIHRyYW5zbGF0ZVg6IDAsXG4gIHRyYW5zbGF0ZVk6IDAsXG4gIG9yaWdpblg6IDAsXG4gIG9yaWdpblk6IDBcbn07XG5cbmNvbnN0IHNvcnRCeUtleSA9IChhLCBiKSA9PiB7XG4gIHJldHVybiBhWzBdIDwgYlswXSA/IC0xIDogYVswXSA+IGJbMF0gPyAxIDogMDtcbn07XG5cbmNsYXNzIE9iamVjdEJhZyB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICB0aGlzLmluaXQoLi4uYXJncyk7XG4gIH1cblxuICBhbGlnbihvdGhlcikge1xuICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gdmFsdWVzLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICAgIC8vIElmIHRoZSB0eXBlIGlzIHRoZSBzYW1lIHdlIG9ubHkgbmVlZCB0byBjaGVjayBpZiB0aGUgY29sb3IgaXMgaW4gdGhlIGNvcnJlY3QgZm9ybWF0XG4gICAgICBpZiAodmFsdWVzW2kgKyAxXSA9PT0gb3RoZXJbaSArIDFdKSB7XG4gICAgICAgIGlmICh2YWx1ZXNbaSArIDFdID09PSBDb2xvciAmJiBvdGhlcltpICsgN10gIT09IHZhbHVlc1tpICsgN10pIHtcbiAgICAgICAgICBjb25zdCBzcGFjZSA9IG90aGVyW2kgKyA3XTtcbiAgICAgICAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcih0aGlzLnZhbHVlcy5zcGxpY2UoaSArIDMsIDUpKVtzcGFjZV0oKS50b0FycmF5KCk7XG4gICAgICAgICAgdGhpcy52YWx1ZXMuc3BsaWNlKGkgKyAzLCAwLCAuLi5jb2xvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpICs9IHZhbHVlc1tpICsgMl0gKyAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFvdGhlcltpICsgMV0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IC8vIFRoZSB0eXBlcyBkaWZmZXIsIHNvIHdlIG92ZXJ3cml0ZSB0aGUgbmV3IHR5cGUgd2l0aCB0aGUgb2xkIG9uZVxuICAgICAgLy8gQW5kIGluaXRpYWxpemUgaXQgd2l0aCB0aGUgdHlwZXMgZGVmYXVsdCAoZS5nLiBibGFjayBmb3IgY29sb3Igb3IgMCBmb3IgbnVtYmVyKVxuXG5cbiAgICAgIGNvbnN0IGRlZmF1bHRPYmplY3QgPSBuZXcgb3RoZXJbaSArIDFdKCkudG9BcnJheSgpOyAvLyBUaGFuIHdlIGZpeCB0aGUgdmFsdWVzIGFycmF5XG5cbiAgICAgIGNvbnN0IHRvRGVsZXRlID0gdmFsdWVzW2kgKyAyXSArIDM7XG4gICAgICB2YWx1ZXMuc3BsaWNlKGksIHRvRGVsZXRlLCBvdGhlcltpXSwgb3RoZXJbaSArIDFdLCBvdGhlcltpICsgMl0sIC4uLmRlZmF1bHRPYmplY3QpO1xuICAgICAgaSArPSB2YWx1ZXNbaSArIDJdICsgMjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGluaXQob2JqT3JBcnIpIHtcbiAgICB0aGlzLnZhbHVlcyA9IFtdO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqT3JBcnIpKSB7XG4gICAgICB0aGlzLnZhbHVlcyA9IG9iak9yQXJyLnNsaWNlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb2JqT3JBcnIgPSBvYmpPckFyciB8fCB7fTtcbiAgICBjb25zdCBlbnRyaWVzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGkgaW4gb2JqT3JBcnIpIHtcbiAgICAgIGNvbnN0IFR5cGUgPSBnZXRDbGFzc0ZvclR5cGUob2JqT3JBcnJbaV0pO1xuICAgICAgY29uc3QgdmFsID0gbmV3IFR5cGUob2JqT3JBcnJbaV0pLnRvQXJyYXkoKTtcbiAgICAgIGVudHJpZXMucHVzaChbaSwgVHlwZSwgdmFsLmxlbmd0aCwgLi4udmFsXSk7XG4gICAgfVxuXG4gICAgZW50cmllcy5zb3J0KHNvcnRCeUtleSk7XG4gICAgdGhpcy52YWx1ZXMgPSBlbnRyaWVzLnJlZHVjZSgobGFzdCwgY3VycikgPT4gbGFzdC5jb25jYXQoY3VyciksIFtdKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzO1xuICB9XG5cbiAgdmFsdWVPZigpIHtcbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBjb25zdCBhcnIgPSB0aGlzLnZhbHVlczsgLy8gZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMikge1xuXG4gICAgd2hpbGUgKGFyci5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGtleSA9IGFyci5zaGlmdCgpO1xuICAgICAgY29uc3QgVHlwZSA9IGFyci5zaGlmdCgpO1xuICAgICAgY29uc3QgbnVtID0gYXJyLnNoaWZ0KCk7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBhcnIuc3BsaWNlKDAsIG51bSk7XG4gICAgICBvYmpba2V5XSA9IG5ldyBUeXBlKHZhbHVlcyk7IC8vIC52YWx1ZU9mKClcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbn1cbmNvbnN0IG1vcnBoYWJsZVR5cGVzID0gW05vbk1vcnBoYWJsZSwgVHJhbnNmb3JtQmFnLCBPYmplY3RCYWddO1xuZnVuY3Rpb24gcmVnaXN0ZXJNb3JwaGFibGVUeXBlKHR5cGUgPSBbXSkge1xuICBtb3JwaGFibGVUeXBlcy5wdXNoKC4uLltdLmNvbmNhdCh0eXBlKSk7XG59XG5mdW5jdGlvbiBtYWtlTW9ycGhhYmxlKCkge1xuICBleHRlbmQobW9ycGhhYmxlVHlwZXMsIHtcbiAgICB0byh2YWwpIHtcbiAgICAgIHJldHVybiBuZXcgTW9ycGhhYmxlKCkudHlwZSh0aGlzLmNvbnN0cnVjdG9yKS5mcm9tKHRoaXMudG9BcnJheSgpKSAvLyB0aGlzLnZhbHVlT2YoKSlcbiAgICAgIC50byh2YWwpO1xuICAgIH0sXG5cbiAgICBmcm9tQXJyYXkoYXJyKSB7XG4gICAgICB0aGlzLmluaXQoYXJyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB0b0NvbnN1bWFibGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0FycmF5KCk7XG4gICAgfSxcblxuICAgIG1vcnBoKGZyb20sIHRvLCBwb3MsIHN0ZXBwZXIsIGNvbnRleHQpIHtcbiAgICAgIGNvbnN0IG1hcHBlciA9IGZ1bmN0aW9uIChpLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gc3RlcHBlci5zdGVwKGksIHRvW2luZGV4XSwgcG9zLCBjb250ZXh0W2luZGV4XSwgY29udGV4dCk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gdGhpcy5mcm9tQXJyYXkoZnJvbS5tYXAobWFwcGVyKSk7XG4gICAgfVxuXG4gIH0pO1xufVxuXG5jbGFzcyBQYXRoIGV4dGVuZHMgU2hhcGUge1xuICAvLyBJbml0aWFsaXplIG5vZGVcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMgPSBub2RlKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KCdwYXRoJywgbm9kZSksIGF0dHJzKTtcbiAgfSAvLyBHZXQgYXJyYXlcblxuXG4gIGFycmF5KCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheSB8fCAodGhpcy5fYXJyYXkgPSBuZXcgUGF0aEFycmF5KHRoaXMuYXR0cignZCcpKSk7XG4gIH0gLy8gQ2xlYXIgYXJyYXkgY2FjaGVcblxuXG4gIGNsZWFyKCkge1xuICAgIGRlbGV0ZSB0aGlzLl9hcnJheTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBTZXQgaGVpZ2h0IG9mIGVsZW1lbnRcblxuXG4gIGhlaWdodChoZWlnaHQpIHtcbiAgICByZXR1cm4gaGVpZ2h0ID09IG51bGwgPyB0aGlzLmJib3goKS5oZWlnaHQgOiB0aGlzLnNpemUodGhpcy5iYm94KCkud2lkdGgsIGhlaWdodCk7XG4gIH0gLy8gTW92ZSBieSBsZWZ0IHRvcCBjb3JuZXJcblxuXG4gIG1vdmUoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmF0dHIoJ2QnLCB0aGlzLmFycmF5KCkubW92ZSh4LCB5KSk7XG4gIH0gLy8gUGxvdCBuZXcgcGF0aFxuXG5cbiAgcGxvdChkKSB7XG4gICAgcmV0dXJuIGQgPT0gbnVsbCA/IHRoaXMuYXJyYXkoKSA6IHRoaXMuY2xlYXIoKS5hdHRyKCdkJywgdHlwZW9mIGQgPT09ICdzdHJpbmcnID8gZCA6IHRoaXMuX2FycmF5ID0gbmV3IFBhdGhBcnJheShkKSk7XG4gIH0gLy8gU2V0IGVsZW1lbnQgc2l6ZSB0byBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0XG5cblxuICBzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBwID0gcHJvcG9ydGlvbmFsU2l6ZSh0aGlzLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdkJywgdGhpcy5hcnJheSgpLnNpemUocC53aWR0aCwgcC5oZWlnaHQpKTtcbiAgfSAvLyBTZXQgd2lkdGggb2YgZWxlbWVudFxuXG5cbiAgd2lkdGgod2lkdGgpIHtcbiAgICByZXR1cm4gd2lkdGggPT0gbnVsbCA/IHRoaXMuYmJveCgpLndpZHRoIDogdGhpcy5zaXplKHdpZHRoLCB0aGlzLmJib3goKS5oZWlnaHQpO1xuICB9IC8vIE1vdmUgYnkgbGVmdCB0b3AgY29ybmVyIG92ZXIgeC1heGlzXG5cblxuICB4KHgpIHtcbiAgICByZXR1cm4geCA9PSBudWxsID8gdGhpcy5iYm94KCkueCA6IHRoaXMubW92ZSh4LCB0aGlzLmJib3goKS55KTtcbiAgfSAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lciBvdmVyIHktYXhpc1xuXG5cbiAgeSh5KSB7XG4gICAgcmV0dXJuIHkgPT0gbnVsbCA/IHRoaXMuYmJveCgpLnkgOiB0aGlzLm1vdmUodGhpcy5iYm94KCkueCwgeSk7XG4gIH1cblxufSAvLyBEZWZpbmUgbW9ycGhhYmxlIGFycmF5XG5cblBhdGgucHJvdG90eXBlLk1vcnBoQXJyYXkgPSBQYXRoQXJyYXk7IC8vIEFkZCBwYXJlbnQgbWV0aG9kXG5cbnJlZ2lzdGVyTWV0aG9kcyh7XG4gIENvbnRhaW5lcjoge1xuICAgIC8vIENyZWF0ZSBhIHdyYXBwZWQgcGF0aCBlbGVtZW50XG4gICAgcGF0aDogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKGQpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSBwbG90IGlzIGNhbGxlZCBhcyBhIHNldHRlclxuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBQYXRoKCkpLnBsb3QoZCB8fCBuZXcgUGF0aEFycmF5KCkpO1xuICAgIH0pXG4gIH1cbn0pO1xucmVnaXN0ZXIoUGF0aCwgJ1BhdGgnKTtcblxuZnVuY3Rpb24gYXJyYXkoKSB7XG4gIHJldHVybiB0aGlzLl9hcnJheSB8fCAodGhpcy5fYXJyYXkgPSBuZXcgUG9pbnRBcnJheSh0aGlzLmF0dHIoJ3BvaW50cycpKSk7XG59IC8vIENsZWFyIGFycmF5IGNhY2hlXG5cbmZ1bmN0aW9uIGNsZWFyKCkge1xuICBkZWxldGUgdGhpcy5fYXJyYXk7XG4gIHJldHVybiB0aGlzO1xufSAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lclxuXG5mdW5jdGlvbiBtb3ZlJDIoeCwgeSkge1xuICByZXR1cm4gdGhpcy5hdHRyKCdwb2ludHMnLCB0aGlzLmFycmF5KCkubW92ZSh4LCB5KSk7XG59IC8vIFBsb3QgbmV3IHBhdGhcblxuZnVuY3Rpb24gcGxvdChwKSB7XG4gIHJldHVybiBwID09IG51bGwgPyB0aGlzLmFycmF5KCkgOiB0aGlzLmNsZWFyKCkuYXR0cigncG9pbnRzJywgdHlwZW9mIHAgPT09ICdzdHJpbmcnID8gcCA6IHRoaXMuX2FycmF5ID0gbmV3IFBvaW50QXJyYXkocCkpO1xufSAvLyBTZXQgZWxlbWVudCBzaXplIHRvIGdpdmVuIHdpZHRoIGFuZCBoZWlnaHRcblxuZnVuY3Rpb24gc2l6ZSQxKHdpZHRoLCBoZWlnaHQpIHtcbiAgY29uc3QgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodCk7XG4gIHJldHVybiB0aGlzLmF0dHIoJ3BvaW50cycsIHRoaXMuYXJyYXkoKS5zaXplKHAud2lkdGgsIHAuaGVpZ2h0KSk7XG59XG5cbnZhciBwb2x5ID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIGFycmF5OiBhcnJheSxcbiAgY2xlYXI6IGNsZWFyLFxuICBtb3ZlOiBtb3ZlJDIsXG4gIHBsb3Q6IHBsb3QsXG4gIHNpemU6IHNpemUkMVxufTtcblxuY2xhc3MgUG9seWdvbiBleHRlbmRzIFNoYXBlIHtcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygncG9seWdvbicsIG5vZGUpLCBhdHRycyk7XG4gIH1cblxufVxucmVnaXN0ZXJNZXRob2RzKHtcbiAgQ29udGFpbmVyOiB7XG4gICAgLy8gQ3JlYXRlIGEgd3JhcHBlZCBwb2x5Z29uIGVsZW1lbnRcbiAgICBwb2x5Z29uOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAocCkge1xuICAgICAgLy8gbWFrZSBzdXJlIHBsb3QgaXMgY2FsbGVkIGFzIGEgc2V0dGVyXG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFBvbHlnb24oKSkucGxvdChwIHx8IG5ldyBQb2ludEFycmF5KCkpO1xuICAgIH0pXG4gIH1cbn0pO1xuZXh0ZW5kKFBvbHlnb24sIHBvaW50ZWQpO1xuZXh0ZW5kKFBvbHlnb24sIHBvbHkpO1xucmVnaXN0ZXIoUG9seWdvbiwgJ1BvbHlnb24nKTtcblxuY2xhc3MgUG9seWxpbmUgZXh0ZW5kcyBTaGFwZSB7XG4gIC8vIEluaXRpYWxpemUgbm9kZVxuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ3BvbHlsaW5lJywgbm9kZSksIGF0dHJzKTtcbiAgfVxuXG59XG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICAvLyBDcmVhdGUgYSB3cmFwcGVkIHBvbHlnb24gZWxlbWVudFxuICAgIHBvbHlsaW5lOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAocCkge1xuICAgICAgLy8gbWFrZSBzdXJlIHBsb3QgaXMgY2FsbGVkIGFzIGEgc2V0dGVyXG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFBvbHlsaW5lKCkpLnBsb3QocCB8fCBuZXcgUG9pbnRBcnJheSgpKTtcbiAgICB9KVxuICB9XG59KTtcbmV4dGVuZChQb2x5bGluZSwgcG9pbnRlZCk7XG5leHRlbmQoUG9seWxpbmUsIHBvbHkpO1xucmVnaXN0ZXIoUG9seWxpbmUsICdQb2x5bGluZScpO1xuXG5jbGFzcyBSZWN0IGV4dGVuZHMgU2hhcGUge1xuICAvLyBJbml0aWFsaXplIG5vZGVcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMgPSBub2RlKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KCdyZWN0Jywgbm9kZSksIGF0dHJzKTtcbiAgfVxuXG59XG5leHRlbmQoUmVjdCwge1xuICByeCxcbiAgcnlcbn0pO1xucmVnaXN0ZXJNZXRob2RzKHtcbiAgQ29udGFpbmVyOiB7XG4gICAgLy8gQ3JlYXRlIGEgcmVjdCBlbGVtZW50XG4gICAgcmVjdDogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgUmVjdCgpKS5zaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0pXG4gIH1cbn0pO1xucmVnaXN0ZXIoUmVjdCwgJ1JlY3QnKTtcblxuY2xhc3MgUXVldWUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9maXJzdCA9IG51bGw7XG4gICAgdGhpcy5fbGFzdCA9IG51bGw7XG4gIH0gLy8gU2hvd3MgdXMgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3RcblxuXG4gIGZpcnN0KCkge1xuICAgIHJldHVybiB0aGlzLl9maXJzdCAmJiB0aGlzLl9maXJzdC52YWx1ZTtcbiAgfSAvLyBTaG93cyB1cyB0aGUgbGFzdCBpdGVtIGluIHRoZSBsaXN0XG5cblxuICBsYXN0KCkge1xuICAgIHJldHVybiB0aGlzLl9sYXN0ICYmIHRoaXMuX2xhc3QudmFsdWU7XG4gIH1cblxuICBwdXNoKHZhbHVlKSB7XG4gICAgLy8gQW4gaXRlbSBzdG9yZXMgYW4gaWQgYW5kIHRoZSBwcm92aWRlZCB2YWx1ZVxuICAgIGNvbnN0IGl0ZW0gPSB0eXBlb2YgdmFsdWUubmV4dCAhPT0gJ3VuZGVmaW5lZCcgPyB2YWx1ZSA6IHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIG5leHQ6IG51bGwsXG4gICAgICBwcmV2OiBudWxsXG4gICAgfTsgLy8gRGVhbCB3aXRoIHRoZSBxdWV1ZSBiZWluZyBlbXB0eSBvciBwb3B1bGF0ZWRcblxuICAgIGlmICh0aGlzLl9sYXN0KSB7XG4gICAgICBpdGVtLnByZXYgPSB0aGlzLl9sYXN0O1xuICAgICAgdGhpcy5fbGFzdC5uZXh0ID0gaXRlbTtcbiAgICAgIHRoaXMuX2xhc3QgPSBpdGVtO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9sYXN0ID0gaXRlbTtcbiAgICAgIHRoaXMuX2ZpcnN0ID0gaXRlbTtcbiAgICB9IC8vIFJldHVybiB0aGUgY3VycmVudCBpdGVtXG5cblxuICAgIHJldHVybiBpdGVtO1xuICB9IC8vIFJlbW92ZXMgdGhlIGl0ZW0gdGhhdCB3YXMgcmV0dXJuZWQgZnJvbSB0aGUgcHVzaFxuXG5cbiAgcmVtb3ZlKGl0ZW0pIHtcbiAgICAvLyBSZWxpbmsgdGhlIHByZXZpb3VzIGl0ZW1cbiAgICBpZiAoaXRlbS5wcmV2KSBpdGVtLnByZXYubmV4dCA9IGl0ZW0ubmV4dDtcbiAgICBpZiAoaXRlbS5uZXh0KSBpdGVtLm5leHQucHJldiA9IGl0ZW0ucHJldjtcbiAgICBpZiAoaXRlbSA9PT0gdGhpcy5fbGFzdCkgdGhpcy5fbGFzdCA9IGl0ZW0ucHJldjtcbiAgICBpZiAoaXRlbSA9PT0gdGhpcy5fZmlyc3QpIHRoaXMuX2ZpcnN0ID0gaXRlbS5uZXh0OyAvLyBJbnZhbGlkYXRlIGl0ZW1cblxuICAgIGl0ZW0ucHJldiA9IG51bGw7XG4gICAgaXRlbS5uZXh0ID0gbnVsbDtcbiAgfVxuXG4gIHNoaWZ0KCkge1xuICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgYSB2YWx1ZVxuICAgIGNvbnN0IHJlbW92ZSA9IHRoaXMuX2ZpcnN0O1xuICAgIGlmICghcmVtb3ZlKSByZXR1cm4gbnVsbDsgLy8gSWYgd2UgZG8sIHJlbW92ZSBpdCBhbmQgcmVsaW5rIHRoaW5nc1xuXG4gICAgdGhpcy5fZmlyc3QgPSByZW1vdmUubmV4dDtcbiAgICBpZiAodGhpcy5fZmlyc3QpIHRoaXMuX2ZpcnN0LnByZXYgPSBudWxsO1xuICAgIHRoaXMuX2xhc3QgPSB0aGlzLl9maXJzdCA/IHRoaXMuX2xhc3QgOiBudWxsO1xuICAgIHJldHVybiByZW1vdmUudmFsdWU7XG4gIH1cblxufVxuXG5jb25zdCBBbmltYXRvciA9IHtcbiAgbmV4dERyYXc6IG51bGwsXG4gIGZyYW1lczogbmV3IFF1ZXVlKCksXG4gIHRpbWVvdXRzOiBuZXcgUXVldWUoKSxcbiAgaW1tZWRpYXRlczogbmV3IFF1ZXVlKCksXG4gIHRpbWVyOiAoKSA9PiBnbG9iYWxzLndpbmRvdy5wZXJmb3JtYW5jZSB8fCBnbG9iYWxzLndpbmRvdy5EYXRlLFxuICB0cmFuc2Zvcm1zOiBbXSxcblxuICBmcmFtZShmbikge1xuICAgIC8vIFN0b3JlIHRoZSBub2RlXG4gICAgY29uc3Qgbm9kZSA9IEFuaW1hdG9yLmZyYW1lcy5wdXNoKHtcbiAgICAgIHJ1bjogZm5cbiAgICB9KTsgLy8gUmVxdWVzdCBhbiBhbmltYXRpb24gZnJhbWUgaWYgd2UgZG9uJ3QgaGF2ZSBvbmVcblxuICAgIGlmIChBbmltYXRvci5uZXh0RHJhdyA9PT0gbnVsbCkge1xuICAgICAgQW5pbWF0b3IubmV4dERyYXcgPSBnbG9iYWxzLndpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoQW5pbWF0b3IuX2RyYXcpO1xuICAgIH0gLy8gUmV0dXJuIHRoZSBub2RlIHNvIHdlIGNhbiByZW1vdmUgaXQgZWFzaWx5XG5cblxuICAgIHJldHVybiBub2RlO1xuICB9LFxuXG4gIHRpbWVvdXQoZm4sIGRlbGF5KSB7XG4gICAgZGVsYXkgPSBkZWxheSB8fCAwOyAvLyBXb3JrIG91dCB3aGVuIHRoZSBldmVudCBzaG91bGQgZmlyZVxuXG4gICAgY29uc3QgdGltZSA9IEFuaW1hdG9yLnRpbWVyKCkubm93KCkgKyBkZWxheTsgLy8gQWRkIHRoZSB0aW1lb3V0IHRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlXG5cbiAgICBjb25zdCBub2RlID0gQW5pbWF0b3IudGltZW91dHMucHVzaCh7XG4gICAgICBydW46IGZuLFxuICAgICAgdGltZTogdGltZVxuICAgIH0pOyAvLyBSZXF1ZXN0IGFub3RoZXIgYW5pbWF0aW9uIGZyYW1lIGlmIHdlIG5lZWQgb25lXG5cbiAgICBpZiAoQW5pbWF0b3IubmV4dERyYXcgPT09IG51bGwpIHtcbiAgICAgIEFuaW1hdG9yLm5leHREcmF3ID0gZ2xvYmFscy53aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKEFuaW1hdG9yLl9kcmF3KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcblxuICBpbW1lZGlhdGUoZm4pIHtcbiAgICAvLyBBZGQgdGhlIGltbWVkaWF0ZSBmbiB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxuICAgIGNvbnN0IG5vZGUgPSBBbmltYXRvci5pbW1lZGlhdGVzLnB1c2goZm4pOyAvLyBSZXF1ZXN0IGFub3RoZXIgYW5pbWF0aW9uIGZyYW1lIGlmIHdlIG5lZWQgb25lXG5cbiAgICBpZiAoQW5pbWF0b3IubmV4dERyYXcgPT09IG51bGwpIHtcbiAgICAgIEFuaW1hdG9yLm5leHREcmF3ID0gZ2xvYmFscy53aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKEFuaW1hdG9yLl9kcmF3KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcblxuICBjYW5jZWxGcmFtZShub2RlKSB7XG4gICAgbm9kZSAhPSBudWxsICYmIEFuaW1hdG9yLmZyYW1lcy5yZW1vdmUobm9kZSk7XG4gIH0sXG5cbiAgY2xlYXJUaW1lb3V0KG5vZGUpIHtcbiAgICBub2RlICE9IG51bGwgJiYgQW5pbWF0b3IudGltZW91dHMucmVtb3ZlKG5vZGUpO1xuICB9LFxuXG4gIGNhbmNlbEltbWVkaWF0ZShub2RlKSB7XG4gICAgbm9kZSAhPSBudWxsICYmIEFuaW1hdG9yLmltbWVkaWF0ZXMucmVtb3ZlKG5vZGUpO1xuICB9LFxuXG4gIF9kcmF3KG5vdykge1xuICAgIC8vIFJ1biBhbGwgdGhlIHRpbWVvdXRzIHdlIGNhbiBydW4sIGlmIHRoZXkgYXJlIG5vdCByZWFkeSB5ZXQsIGFkZCB0aGVtXG4gICAgLy8gdG8gdGhlIGVuZCBvZiB0aGUgcXVldWUgaW1tZWRpYXRlbHkhIChiYWQgdGltZW91dHMhISEgW3NhcmNhc21dKVxuICAgIGxldCBuZXh0VGltZW91dCA9IG51bGw7XG4gICAgY29uc3QgbGFzdFRpbWVvdXQgPSBBbmltYXRvci50aW1lb3V0cy5sYXN0KCk7XG5cbiAgICB3aGlsZSAobmV4dFRpbWVvdXQgPSBBbmltYXRvci50aW1lb3V0cy5zaGlmdCgpKSB7XG4gICAgICAvLyBSdW4gdGhlIHRpbWVvdXQgaWYgaXRzIHRpbWUsIG9yIHB1c2ggaXQgdG8gdGhlIGVuZFxuICAgICAgaWYgKG5vdyA+PSBuZXh0VGltZW91dC50aW1lKSB7XG4gICAgICAgIG5leHRUaW1lb3V0LnJ1bigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQW5pbWF0b3IudGltZW91dHMucHVzaChuZXh0VGltZW91dCk7XG4gICAgICB9IC8vIElmIHdlIGhpdCB0aGUgbGFzdCBpdGVtLCB3ZSBzaG91bGQgc3RvcCBzaGlmdGluZyBvdXQgbW9yZSBpdGVtc1xuXG5cbiAgICAgIGlmIChuZXh0VGltZW91dCA9PT0gbGFzdFRpbWVvdXQpIGJyZWFrO1xuICAgIH0gLy8gUnVuIGFsbCBvZiB0aGUgYW5pbWF0aW9uIGZyYW1lc1xuXG5cbiAgICBsZXQgbmV4dEZyYW1lID0gbnVsbDtcbiAgICBjb25zdCBsYXN0RnJhbWUgPSBBbmltYXRvci5mcmFtZXMubGFzdCgpO1xuXG4gICAgd2hpbGUgKG5leHRGcmFtZSAhPT0gbGFzdEZyYW1lICYmIChuZXh0RnJhbWUgPSBBbmltYXRvci5mcmFtZXMuc2hpZnQoKSkpIHtcbiAgICAgIG5leHRGcmFtZS5ydW4obm93KTtcbiAgICB9XG5cbiAgICBsZXQgbmV4dEltbWVkaWF0ZSA9IG51bGw7XG5cbiAgICB3aGlsZSAobmV4dEltbWVkaWF0ZSA9IEFuaW1hdG9yLmltbWVkaWF0ZXMuc2hpZnQoKSkge1xuICAgICAgbmV4dEltbWVkaWF0ZSgpO1xuICAgIH0gLy8gSWYgd2UgaGF2ZSByZW1haW5pbmcgdGltZW91dHMgb3IgZnJhbWVzLCBkcmF3IHVudGlsIHdlIGRvbid0IGFueW1vcmVcblxuXG4gICAgQW5pbWF0b3IubmV4dERyYXcgPSBBbmltYXRvci50aW1lb3V0cy5maXJzdCgpIHx8IEFuaW1hdG9yLmZyYW1lcy5maXJzdCgpID8gZ2xvYmFscy53aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKEFuaW1hdG9yLl9kcmF3KSA6IG51bGw7XG4gIH1cblxufTtcblxuY29uc3QgbWFrZVNjaGVkdWxlID0gZnVuY3Rpb24gKHJ1bm5lckluZm8pIHtcbiAgY29uc3Qgc3RhcnQgPSBydW5uZXJJbmZvLnN0YXJ0O1xuICBjb25zdCBkdXJhdGlvbiA9IHJ1bm5lckluZm8ucnVubmVyLmR1cmF0aW9uKCk7XG4gIGNvbnN0IGVuZCA9IHN0YXJ0ICsgZHVyYXRpb247XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICBlbmQ6IGVuZCxcbiAgICBydW5uZXI6IHJ1bm5lckluZm8ucnVubmVyXG4gIH07XG59O1xuXG5jb25zdCBkZWZhdWx0U291cmNlID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCB3ID0gZ2xvYmFscy53aW5kb3c7XG4gIHJldHVybiAody5wZXJmb3JtYW5jZSB8fCB3LkRhdGUpLm5vdygpO1xufTtcblxuY2xhc3MgVGltZWxpbmUgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gIC8vIENvbnN0cnVjdCBhIG5ldyB0aW1lbGluZSBvbiB0aGUgZ2l2ZW4gZWxlbWVudFxuICBjb25zdHJ1Y3Rvcih0aW1lU291cmNlID0gZGVmYXVsdFNvdXJjZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fdGltZVNvdXJjZSA9IHRpbWVTb3VyY2U7IC8vIFN0b3JlIHRoZSB0aW1pbmcgdmFyaWFibGVzXG5cbiAgICB0aGlzLl9zdGFydFRpbWUgPSAwO1xuICAgIHRoaXMuX3NwZWVkID0gMS4wOyAvLyBEZXRlcm1pbmVzIGhvdyBsb25nIGEgcnVubmVyIGlzIGhvbGQgaW4gbWVtb3J5LiBDYW4gYmUgYSBkdCBvciB0cnVlL2ZhbHNlXG5cbiAgICB0aGlzLl9wZXJzaXN0ID0gMDsgLy8gS2VlcCB0cmFjayBvZiB0aGUgcnVubmluZyBhbmltYXRpb25zIGFuZCB0aGVpciBzdGFydGluZyBwYXJhbWV0ZXJzXG5cbiAgICB0aGlzLl9uZXh0RnJhbWUgPSBudWxsO1xuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgdGhpcy5fcnVubmVycyA9IFtdO1xuICAgIHRoaXMuX3J1bm5lcklkcyA9IFtdO1xuICAgIHRoaXMuX2xhc3RSdW5uZXJJZCA9IC0xO1xuICAgIHRoaXMuX3RpbWUgPSAwO1xuICAgIHRoaXMuX2xhc3RTb3VyY2VUaW1lID0gMDtcbiAgICB0aGlzLl9sYXN0U3RlcFRpbWUgPSAwOyAvLyBNYWtlIHN1cmUgdGhhdCBzdGVwIGlzIGFsd2F5cyBjYWxsZWQgaW4gY2xhc3MgY29udGV4dFxuXG4gICAgdGhpcy5fc3RlcCA9IHRoaXMuX3N0ZXBGbi5iaW5kKHRoaXMsIGZhbHNlKTtcbiAgICB0aGlzLl9zdGVwSW1tZWRpYXRlID0gdGhpcy5fc3RlcEZuLmJpbmQodGhpcywgdHJ1ZSk7XG4gIH1cblxuICBhY3RpdmUoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fbmV4dEZyYW1lO1xuICB9XG5cbiAgZmluaXNoKCkge1xuICAgIC8vIEdvIHRvIGVuZCBhbmQgcGF1c2VcbiAgICB0aGlzLnRpbWUodGhpcy5nZXRFbmRUaW1lT2ZUaW1lbGluZSgpICsgMSk7XG4gICAgcmV0dXJuIHRoaXMucGF1c2UoKTtcbiAgfSAvLyBDYWxjdWxhdGVzIHRoZSBlbmQgb2YgdGhlIHRpbWVsaW5lXG5cblxuICBnZXRFbmRUaW1lKCkge1xuICAgIGNvbnN0IGxhc3RSdW5uZXJJbmZvID0gdGhpcy5nZXRMYXN0UnVubmVySW5mbygpO1xuICAgIGNvbnN0IGxhc3REdXJhdGlvbiA9IGxhc3RSdW5uZXJJbmZvID8gbGFzdFJ1bm5lckluZm8ucnVubmVyLmR1cmF0aW9uKCkgOiAwO1xuICAgIGNvbnN0IGxhc3RTdGFydFRpbWUgPSBsYXN0UnVubmVySW5mbyA/IGxhc3RSdW5uZXJJbmZvLnN0YXJ0IDogdGhpcy5fdGltZTtcbiAgICByZXR1cm4gbGFzdFN0YXJ0VGltZSArIGxhc3REdXJhdGlvbjtcbiAgfVxuXG4gIGdldEVuZFRpbWVPZlRpbWVsaW5lKCkge1xuICAgIGNvbnN0IGVuZFRpbWVzID0gdGhpcy5fcnVubmVycy5tYXAoaSA9PiBpLnN0YXJ0ICsgaS5ydW5uZXIuZHVyYXRpb24oKSk7XG5cbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgLi4uZW5kVGltZXMpO1xuICB9XG5cbiAgZ2V0TGFzdFJ1bm5lckluZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UnVubmVySW5mb0J5SWQodGhpcy5fbGFzdFJ1bm5lcklkKTtcbiAgfVxuXG4gIGdldFJ1bm5lckluZm9CeUlkKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3J1bm5lcnNbdGhpcy5fcnVubmVySWRzLmluZGV4T2YoaWQpXSB8fCBudWxsO1xuICB9XG5cbiAgcGF1c2UoKSB7XG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5fY29udGludWUoKTtcbiAgfVxuXG4gIHBlcnNpc3QoZHRPckZvcmV2ZXIpIHtcbiAgICBpZiAoZHRPckZvcmV2ZXIgPT0gbnVsbCkgcmV0dXJuIHRoaXMuX3BlcnNpc3Q7XG4gICAgdGhpcy5fcGVyc2lzdCA9IGR0T3JGb3JldmVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcGxheSgpIHtcbiAgICAvLyBOb3cgbWFrZSBzdXJlIHdlIGFyZSBub3QgcGF1c2VkIGFuZCBjb250aW51ZSB0aGUgYW5pbWF0aW9uXG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVGltZSgpLl9jb250aW51ZSgpO1xuICB9XG5cbiAgcmV2ZXJzZSh5ZXMpIHtcbiAgICBjb25zdCBjdXJyZW50U3BlZWQgPSB0aGlzLnNwZWVkKCk7XG4gICAgaWYgKHllcyA9PSBudWxsKSByZXR1cm4gdGhpcy5zcGVlZCgtY3VycmVudFNwZWVkKTtcbiAgICBjb25zdCBwb3NpdGl2ZSA9IE1hdGguYWJzKGN1cnJlbnRTcGVlZCk7XG4gICAgcmV0dXJuIHRoaXMuc3BlZWQoeWVzID8gLXBvc2l0aXZlIDogcG9zaXRpdmUpO1xuICB9IC8vIHNjaGVkdWxlcyBhIHJ1bm5lciBvbiB0aGUgdGltZWxpbmVcblxuXG4gIHNjaGVkdWxlKHJ1bm5lciwgZGVsYXksIHdoZW4pIHtcbiAgICBpZiAocnVubmVyID09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5uZXJzLm1hcChtYWtlU2NoZWR1bGUpO1xuICAgIH0gLy8gVGhlIHN0YXJ0IHRpbWUgZm9yIHRoZSBuZXh0IGFuaW1hdGlvbiBjYW4gZWl0aGVyIGJlIGdpdmVuIGV4cGxpY2l0bHksXG4gICAgLy8gZGVyaXZlZCBmcm9tIHRoZSBjdXJyZW50IHRpbWVsaW5lIHRpbWUgb3IgaXQgY2FuIGJlIHJlbGF0aXZlIHRvIHRoZVxuICAgIC8vIGxhc3Qgc3RhcnQgdGltZSB0byBjaGFpbiBhbmltYXRpb25zIGRpcmVjdGx5XG5cblxuICAgIGxldCBhYnNvbHV0ZVN0YXJ0VGltZSA9IDA7XG4gICAgY29uc3QgZW5kVGltZSA9IHRoaXMuZ2V0RW5kVGltZSgpO1xuICAgIGRlbGF5ID0gZGVsYXkgfHwgMDsgLy8gV29yayBvdXQgd2hlbiB0byBzdGFydCB0aGUgYW5pbWF0aW9uXG5cbiAgICBpZiAod2hlbiA9PSBudWxsIHx8IHdoZW4gPT09ICdsYXN0JyB8fCB3aGVuID09PSAnYWZ0ZXInKSB7XG4gICAgICAvLyBUYWtlIHRoZSBsYXN0IHRpbWUgYW5kIGluY3JlbWVudFxuICAgICAgYWJzb2x1dGVTdGFydFRpbWUgPSBlbmRUaW1lO1xuICAgIH0gZWxzZSBpZiAod2hlbiA9PT0gJ2Fic29sdXRlJyB8fCB3aGVuID09PSAnc3RhcnQnKSB7XG4gICAgICBhYnNvbHV0ZVN0YXJ0VGltZSA9IGRlbGF5O1xuICAgICAgZGVsYXkgPSAwO1xuICAgIH0gZWxzZSBpZiAod2hlbiA9PT0gJ25vdycpIHtcbiAgICAgIGFic29sdXRlU3RhcnRUaW1lID0gdGhpcy5fdGltZTtcbiAgICB9IGVsc2UgaWYgKHdoZW4gPT09ICdyZWxhdGl2ZScpIHtcbiAgICAgIGNvbnN0IHJ1bm5lckluZm8gPSB0aGlzLmdldFJ1bm5lckluZm9CeUlkKHJ1bm5lci5pZCk7XG5cbiAgICAgIGlmIChydW5uZXJJbmZvKSB7XG4gICAgICAgIGFic29sdXRlU3RhcnRUaW1lID0gcnVubmVySW5mby5zdGFydCArIGRlbGF5O1xuICAgICAgICBkZWxheSA9IDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh3aGVuID09PSAnd2l0aC1sYXN0Jykge1xuICAgICAgY29uc3QgbGFzdFJ1bm5lckluZm8gPSB0aGlzLmdldExhc3RSdW5uZXJJbmZvKCk7XG4gICAgICBjb25zdCBsYXN0U3RhcnRUaW1lID0gbGFzdFJ1bm5lckluZm8gPyBsYXN0UnVubmVySW5mby5zdGFydCA6IHRoaXMuX3RpbWU7XG4gICAgICBhYnNvbHV0ZVN0YXJ0VGltZSA9IGxhc3RTdGFydFRpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSBmb3IgdGhlIFwid2hlblwiIHBhcmFtZXRlcicpO1xuICAgIH0gLy8gTWFuYWdlIHJ1bm5lclxuXG5cbiAgICBydW5uZXIudW5zY2hlZHVsZSgpO1xuICAgIHJ1bm5lci50aW1lbGluZSh0aGlzKTtcbiAgICBjb25zdCBwZXJzaXN0ID0gcnVubmVyLnBlcnNpc3QoKTtcbiAgICBjb25zdCBydW5uZXJJbmZvID0ge1xuICAgICAgcGVyc2lzdDogcGVyc2lzdCA9PT0gbnVsbCA/IHRoaXMuX3BlcnNpc3QgOiBwZXJzaXN0LFxuICAgICAgc3RhcnQ6IGFic29sdXRlU3RhcnRUaW1lICsgZGVsYXksXG4gICAgICBydW5uZXJcbiAgICB9O1xuICAgIHRoaXMuX2xhc3RSdW5uZXJJZCA9IHJ1bm5lci5pZDtcblxuICAgIHRoaXMuX3J1bm5lcnMucHVzaChydW5uZXJJbmZvKTtcblxuICAgIHRoaXMuX3J1bm5lcnMuc29ydCgoYSwgYikgPT4gYS5zdGFydCAtIGIuc3RhcnQpO1xuXG4gICAgdGhpcy5fcnVubmVySWRzID0gdGhpcy5fcnVubmVycy5tYXAoaW5mbyA9PiBpbmZvLnJ1bm5lci5pZCk7XG5cbiAgICB0aGlzLnVwZGF0ZVRpbWUoKS5fY29udGludWUoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2VlayhkdCkge1xuICAgIHJldHVybiB0aGlzLnRpbWUodGhpcy5fdGltZSArIGR0KTtcbiAgfVxuXG4gIHNvdXJjZShmbikge1xuICAgIGlmIChmbiA9PSBudWxsKSByZXR1cm4gdGhpcy5fdGltZVNvdXJjZTtcbiAgICB0aGlzLl90aW1lU291cmNlID0gZm47XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzcGVlZChzcGVlZCkge1xuICAgIGlmIChzcGVlZCA9PSBudWxsKSByZXR1cm4gdGhpcy5fc3BlZWQ7XG4gICAgdGhpcy5fc3BlZWQgPSBzcGVlZDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgLy8gR28gdG8gc3RhcnQgYW5kIHBhdXNlXG4gICAgdGhpcy50aW1lKDApO1xuICAgIHJldHVybiB0aGlzLnBhdXNlKCk7XG4gIH1cblxuICB0aW1lKHRpbWUpIHtcbiAgICBpZiAodGltZSA9PSBudWxsKSByZXR1cm4gdGhpcy5fdGltZTtcbiAgICB0aGlzLl90aW1lID0gdGltZTtcbiAgICByZXR1cm4gdGhpcy5fY29udGludWUodHJ1ZSk7XG4gIH0gLy8gUmVtb3ZlIHRoZSBydW5uZXIgZnJvbSB0aGlzIHRpbWVsaW5lXG5cblxuICB1bnNjaGVkdWxlKHJ1bm5lcikge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fcnVubmVySWRzLmluZGV4T2YocnVubmVyLmlkKTtcblxuICAgIGlmIChpbmRleCA8IDApIHJldHVybiB0aGlzO1xuXG4gICAgdGhpcy5fcnVubmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgdGhpcy5fcnVubmVySWRzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICBydW5uZXIudGltZWxpbmUobnVsbCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gTWFrZXMgc3VyZSwgdGhhdCBhZnRlciBwYXVzaW5nIHRoZSB0aW1lIGRvZXNuJ3QganVtcFxuXG5cbiAgdXBkYXRlVGltZSgpIHtcbiAgICBpZiAoIXRoaXMuYWN0aXZlKCkpIHtcbiAgICAgIHRoaXMuX2xhc3RTb3VyY2VUaW1lID0gdGhpcy5fdGltZVNvdXJjZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIENoZWNrcyBpZiB3ZSBhcmUgcnVubmluZyBhbmQgY29udGludWVzIHRoZSBhbmltYXRpb25cblxuXG4gIF9jb250aW51ZShpbW1lZGlhdGVTdGVwID0gZmFsc2UpIHtcbiAgICBBbmltYXRvci5jYW5jZWxGcmFtZSh0aGlzLl9uZXh0RnJhbWUpO1xuICAgIHRoaXMuX25leHRGcmFtZSA9IG51bGw7XG4gICAgaWYgKGltbWVkaWF0ZVN0ZXApIHJldHVybiB0aGlzLl9zdGVwSW1tZWRpYXRlKCk7XG4gICAgaWYgKHRoaXMuX3BhdXNlZCkgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy5fbmV4dEZyYW1lID0gQW5pbWF0b3IuZnJhbWUodGhpcy5fc3RlcCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBfc3RlcEZuKGltbWVkaWF0ZVN0ZXAgPSBmYWxzZSkge1xuICAgIC8vIEdldCB0aGUgdGltZSBkZWx0YSBmcm9tIHRoZSBsYXN0IHRpbWUgYW5kIHVwZGF0ZSB0aGUgdGltZVxuICAgIGNvbnN0IHRpbWUgPSB0aGlzLl90aW1lU291cmNlKCk7XG5cbiAgICBsZXQgZHRTb3VyY2UgPSB0aW1lIC0gdGhpcy5fbGFzdFNvdXJjZVRpbWU7XG4gICAgaWYgKGltbWVkaWF0ZVN0ZXApIGR0U291cmNlID0gMDtcbiAgICBjb25zdCBkdFRpbWUgPSB0aGlzLl9zcGVlZCAqIGR0U291cmNlICsgKHRoaXMuX3RpbWUgLSB0aGlzLl9sYXN0U3RlcFRpbWUpO1xuICAgIHRoaXMuX2xhc3RTb3VyY2VUaW1lID0gdGltZTsgLy8gT25seSB1cGRhdGUgdGhlIHRpbWUgaWYgd2UgdXNlIHRoZSB0aW1lU291cmNlLlxuICAgIC8vIE90aGVyd2lzZSB1c2UgdGhlIGN1cnJlbnQgdGltZVxuXG4gICAgaWYgKCFpbW1lZGlhdGVTdGVwKSB7XG4gICAgICAvLyBVcGRhdGUgdGhlIHRpbWVcbiAgICAgIHRoaXMuX3RpbWUgKz0gZHRUaW1lO1xuICAgICAgdGhpcy5fdGltZSA9IHRoaXMuX3RpbWUgPCAwID8gMCA6IHRoaXMuX3RpbWU7XG4gICAgfVxuXG4gICAgdGhpcy5fbGFzdFN0ZXBUaW1lID0gdGhpcy5fdGltZTtcbiAgICB0aGlzLmZpcmUoJ3RpbWUnLCB0aGlzLl90aW1lKTsgLy8gVGhpcyBpcyBmb3IgdGhlIGNhc2UgdGhhdCB0aGUgdGltZWxpbmUgd2FzIHNlZWtlZCBzbyB0aGF0IHRoZSB0aW1lXG4gICAgLy8gaXMgbm93IGJlZm9yZSB0aGUgc3RhcnRUaW1lIG9mIHRoZSBydW5uZXIuIFRoYXQgaXMgd2h5IHdlIG5lZWQgdG8gc2V0XG4gICAgLy8gdGhlIHJ1bm5lciB0byBwb3NpdGlvbiAwXG4gICAgLy8gRklYTUU6XG4gICAgLy8gSG93ZXZlciwgcmVzZXR0aW5nIGluIGluc2VydGlvbiBvcmRlciBsZWFkcyB0byBidWdzLiBDb25zaWRlcmluZyB0aGUgY2FzZSxcbiAgICAvLyB3aGVyZSAyIHJ1bm5lcnMgY2hhbmdlIHRoZSBzYW1lIGF0dHJpYnV0ZSBidXQgaW4gZGlmZmVyZW50IHRpbWVzLFxuICAgIC8vIHJlc2V0dGluZyBib3RoIG9mIHRoZW0gd2lsbCBsZWFkIHRvIHRoZSBjYXNlIHdoZXJlIHRoZSBsYXRlciBkZWZpbmVkXG4gICAgLy8gcnVubmVyIGFsd2F5cyB3aW5zIHRoZSByZXNldCBldmVuIGlmIHRoZSBvdGhlciBydW5uZXIgc3RhcnRlZCBlYXJsaWVyXG4gICAgLy8gYW5kIHRoZXJlZm9yZSBzaG91bGQgd2luIHRoZSBhdHRyaWJ1dGUgYmF0dGxlXG4gICAgLy8gdGhpcyBjYW4gYmUgc29sdmVkIGJ5IHJlc2V0dGluZyB0aGVtIGJhY2t3YXJkc1xuXG4gICAgZm9yIChsZXQgayA9IHRoaXMuX3J1bm5lcnMubGVuZ3RoOyBrLS07KSB7XG4gICAgICAvLyBHZXQgYW5kIHJ1biB0aGUgY3VycmVudCBydW5uZXIgYW5kIGlnbm9yZSBpdCBpZiBpdHMgaW5hY3RpdmVcbiAgICAgIGNvbnN0IHJ1bm5lckluZm8gPSB0aGlzLl9ydW5uZXJzW2tdO1xuICAgICAgY29uc3QgcnVubmVyID0gcnVubmVySW5mby5ydW5uZXI7IC8vIE1ha2Ugc3VyZSB0aGF0IHdlIGdpdmUgdGhlIGFjdHVhbCBkaWZmZXJlbmNlXG4gICAgICAvLyBiZXR3ZWVuIHJ1bm5lciBzdGFydCB0aW1lIGFuZCBub3dcblxuICAgICAgY29uc3QgZHRUb1N0YXJ0ID0gdGhpcy5fdGltZSAtIHJ1bm5lckluZm8uc3RhcnQ7IC8vIERvbnQgcnVuIHJ1bm5lciBpZiBub3Qgc3RhcnRlZCB5ZXRcbiAgICAgIC8vIGFuZCB0cnkgdG8gcmVzZXQgaXRcblxuICAgICAgaWYgKGR0VG9TdGFydCA8PSAwKSB7XG4gICAgICAgIHJ1bm5lci5yZXNldCgpO1xuICAgICAgfVxuICAgIH0gLy8gUnVuIGFsbCBvZiB0aGUgcnVubmVycyBkaXJlY3RseVxuXG5cbiAgICBsZXQgcnVubmVyc0xlZnQgPSBmYWxzZTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9ydW5uZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAvLyBHZXQgYW5kIHJ1biB0aGUgY3VycmVudCBydW5uZXIgYW5kIGlnbm9yZSBpdCBpZiBpdHMgaW5hY3RpdmVcbiAgICAgIGNvbnN0IHJ1bm5lckluZm8gPSB0aGlzLl9ydW5uZXJzW2ldO1xuICAgICAgY29uc3QgcnVubmVyID0gcnVubmVySW5mby5ydW5uZXI7XG4gICAgICBsZXQgZHQgPSBkdFRpbWU7IC8vIE1ha2Ugc3VyZSB0aGF0IHdlIGdpdmUgdGhlIGFjdHVhbCBkaWZmZXJlbmNlXG4gICAgICAvLyBiZXR3ZWVuIHJ1bm5lciBzdGFydCB0aW1lIGFuZCBub3dcblxuICAgICAgY29uc3QgZHRUb1N0YXJ0ID0gdGhpcy5fdGltZSAtIHJ1bm5lckluZm8uc3RhcnQ7IC8vIERvbnQgcnVuIHJ1bm5lciBpZiBub3Qgc3RhcnRlZCB5ZXRcblxuICAgICAgaWYgKGR0VG9TdGFydCA8PSAwKSB7XG4gICAgICAgIHJ1bm5lcnNMZWZ0ID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKGR0VG9TdGFydCA8IGR0KSB7XG4gICAgICAgIC8vIEFkanVzdCBkdCB0byBtYWtlIHN1cmUgdGhhdCBhbmltYXRpb24gaXMgb24gcG9pbnRcbiAgICAgICAgZHQgPSBkdFRvU3RhcnQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghcnVubmVyLmFjdGl2ZSgpKSBjb250aW51ZTsgLy8gSWYgdGhpcyBydW5uZXIgaXMgc3RpbGwgZ29pbmcsIHNpZ25hbCB0aGF0IHdlIG5lZWQgYW5vdGhlciBhbmltYXRpb25cbiAgICAgIC8vIGZyYW1lLCBvdGhlcndpc2UsIHJlbW92ZSB0aGUgY29tcGxldGVkIHJ1bm5lclxuXG4gICAgICBjb25zdCBmaW5pc2hlZCA9IHJ1bm5lci5zdGVwKGR0KS5kb25lO1xuXG4gICAgICBpZiAoIWZpbmlzaGVkKSB7XG4gICAgICAgIHJ1bm5lcnNMZWZ0ID0gdHJ1ZTsgLy8gY29udGludWVcbiAgICAgIH0gZWxzZSBpZiAocnVubmVySW5mby5wZXJzaXN0ICE9PSB0cnVlKSB7XG4gICAgICAgIC8vIHJ1bm5lciBpcyBmaW5pc2hlZC4gQW5kIHJ1bm5lciBtaWdodCBnZXQgcmVtb3ZlZFxuICAgICAgICBjb25zdCBlbmRUaW1lID0gcnVubmVyLmR1cmF0aW9uKCkgLSBydW5uZXIudGltZSgpICsgdGhpcy5fdGltZTtcblxuICAgICAgICBpZiAoZW5kVGltZSArIHJ1bm5lckluZm8ucGVyc2lzdCA8IHRoaXMuX3RpbWUpIHtcbiAgICAgICAgICAvLyBEZWxldGUgcnVubmVyIGFuZCBjb3JyZWN0IGluZGV4XG4gICAgICAgICAgcnVubmVyLnVuc2NoZWR1bGUoKTtcbiAgICAgICAgICAtLWk7XG4gICAgICAgICAgLS1sZW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIEJhc2ljYWxseTogd2UgY29udGludWUgd2hlbiB0aGVyZSBhcmUgcnVubmVycyByaWdodCBmcm9tIHVzIGluIHRpbWVcbiAgICAvLyB3aGVuIC0tPiwgYW5kIHdoZW4gcnVubmVycyBhcmUgbGVmdCBmcm9tIHVzIHdoZW4gPC0tXG5cblxuICAgIGlmIChydW5uZXJzTGVmdCAmJiAhKHRoaXMuX3NwZWVkIDwgMCAmJiB0aGlzLl90aW1lID09PSAwKSB8fCB0aGlzLl9ydW5uZXJJZHMubGVuZ3RoICYmIHRoaXMuX3NwZWVkIDwgMCAmJiB0aGlzLl90aW1lID4gMCkge1xuICAgICAgdGhpcy5fY29udGludWUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgdGhpcy5maXJlKCdmaW5pc2hlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbn1cbnJlZ2lzdGVyTWV0aG9kcyh7XG4gIEVsZW1lbnQ6IHtcbiAgICB0aW1lbGluZTogZnVuY3Rpb24gKHRpbWVsaW5lKSB7XG4gICAgICBpZiAodGltZWxpbmUgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl90aW1lbGluZSA9IHRoaXMuX3RpbWVsaW5lIHx8IG5ldyBUaW1lbGluZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdGltZWxpbmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl90aW1lbGluZSA9IHRpbWVsaW5lO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuXG5jbGFzcyBSdW5uZXIgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpOyAvLyBTdG9yZSBhIHVuaXF1ZSBpZCBvbiB0aGUgcnVubmVyLCBzbyB0aGF0IHdlIGNhbiBpZGVudGlmeSBpdCBsYXRlclxuXG4gICAgdGhpcy5pZCA9IFJ1bm5lci5pZCsrOyAvLyBFbnN1cmUgYSBkZWZhdWx0IHZhbHVlXG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyA9PSBudWxsID8gdGltZWxpbmUuZHVyYXRpb24gOiBvcHRpb25zOyAvLyBFbnN1cmUgdGhhdCB3ZSBnZXQgYSBjb250cm9sbGVyXG5cbiAgICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgPyBuZXcgQ29udHJvbGxlcihvcHRpb25zKSA6IG9wdGlvbnM7IC8vIERlY2xhcmUgYWxsIG9mIHRoZSB2YXJpYWJsZXNcblxuICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX3RpbWVsaW5lID0gbnVsbDtcbiAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9xdWV1ZSA9IFtdOyAvLyBXb3JrIG91dCB0aGUgc3RlcHBlciBhbmQgdGhlIGR1cmF0aW9uXG5cbiAgICB0aGlzLl9kdXJhdGlvbiA9IHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJyAmJiBvcHRpb25zO1xuICAgIHRoaXMuX2lzRGVjbGFyYXRpdmUgPSBvcHRpb25zIGluc3RhbmNlb2YgQ29udHJvbGxlcjtcbiAgICB0aGlzLl9zdGVwcGVyID0gdGhpcy5faXNEZWNsYXJhdGl2ZSA/IG9wdGlvbnMgOiBuZXcgRWFzZSgpOyAvLyBXZSBjb3B5IHRoZSBjdXJyZW50IHZhbHVlcyBmcm9tIHRoZSB0aW1lbGluZSBiZWNhdXNlIHRoZXkgY2FuIGNoYW5nZVxuXG4gICAgdGhpcy5faGlzdG9yeSA9IHt9OyAvLyBTdG9yZSB0aGUgc3RhdGUgb2YgdGhlIHJ1bm5lclxuXG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLl90aW1lID0gMDtcbiAgICB0aGlzLl9sYXN0VGltZSA9IDA7IC8vIEF0IGNyZWF0aW9uLCB0aGUgcnVubmVyIGlzIGluIHJlc2V0IHN0YXRlXG5cbiAgICB0aGlzLl9yZXNldGVkID0gdHJ1ZTsgLy8gU2F2ZSB0cmFuc2Zvcm1zIGFwcGxpZWQgdG8gdGhpcyBydW5uZXJcblxuICAgIHRoaXMudHJhbnNmb3JtcyA9IG5ldyBNYXRyaXgoKTtcbiAgICB0aGlzLnRyYW5zZm9ybUlkID0gMTsgLy8gTG9vcGluZyB2YXJpYWJsZXNcblxuICAgIHRoaXMuX2hhdmVSZXZlcnNlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JldmVyc2UgPSBmYWxzZTtcbiAgICB0aGlzLl9sb29wc0RvbmUgPSAwO1xuICAgIHRoaXMuX3N3aW5nID0gZmFsc2U7XG4gICAgdGhpcy5fd2FpdCA9IDA7XG4gICAgdGhpcy5fdGltZXMgPSAxO1xuICAgIHRoaXMuX2ZyYW1lSWQgPSBudWxsOyAvLyBTdG9yZXMgaG93IGxvbmcgYSBydW5uZXIgaXMgc3RvcmVkIGFmdGVyIGJlaW5nIGRvbmVcblxuICAgIHRoaXMuX3BlcnNpc3QgPSB0aGlzLl9pc0RlY2xhcmF0aXZlID8gdHJ1ZSA6IG51bGw7XG4gIH1cblxuICBzdGF0aWMgc2FuaXRpc2UoZHVyYXRpb24sIGRlbGF5LCB3aGVuKSB7XG4gICAgLy8gSW5pdGlhbGlzZSB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG4gICAgbGV0IHRpbWVzID0gMTtcbiAgICBsZXQgc3dpbmcgPSBmYWxzZTtcbiAgICBsZXQgd2FpdCA9IDA7XG4gICAgZHVyYXRpb24gPSBkdXJhdGlvbiB8fCB0aW1lbGluZS5kdXJhdGlvbjtcbiAgICBkZWxheSA9IGRlbGF5IHx8IHRpbWVsaW5lLmRlbGF5O1xuICAgIHdoZW4gPSB3aGVuIHx8ICdsYXN0JzsgLy8gSWYgd2UgaGF2ZSBhbiBvYmplY3QsIHVucGFjayB0aGUgdmFsdWVzXG5cbiAgICBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0JyAmJiAhKGR1cmF0aW9uIGluc3RhbmNlb2YgU3RlcHBlcikpIHtcbiAgICAgIGRlbGF5ID0gZHVyYXRpb24uZGVsYXkgfHwgZGVsYXk7XG4gICAgICB3aGVuID0gZHVyYXRpb24ud2hlbiB8fCB3aGVuO1xuICAgICAgc3dpbmcgPSBkdXJhdGlvbi5zd2luZyB8fCBzd2luZztcbiAgICAgIHRpbWVzID0gZHVyYXRpb24udGltZXMgfHwgdGltZXM7XG4gICAgICB3YWl0ID0gZHVyYXRpb24ud2FpdCB8fCB3YWl0O1xuICAgICAgZHVyYXRpb24gPSBkdXJhdGlvbi5kdXJhdGlvbiB8fCB0aW1lbGluZS5kdXJhdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgZGVsYXk6IGRlbGF5LFxuICAgICAgc3dpbmc6IHN3aW5nLFxuICAgICAgdGltZXM6IHRpbWVzLFxuICAgICAgd2FpdDogd2FpdCxcbiAgICAgIHdoZW46IHdoZW5cbiAgICB9O1xuICB9XG5cbiAgYWN0aXZlKGVuYWJsZWQpIHtcbiAgICBpZiAoZW5hYmxlZCA9PSBudWxsKSByZXR1cm4gdGhpcy5lbmFibGVkO1xuICAgIHRoaXMuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLypcbiAgUHJpdmF0ZSBNZXRob2RzXG4gID09PT09PT09PT09PT09PVxuICBNZXRob2RzIHRoYXQgc2hvdWxkbid0IGJlIHVzZWQgZXh0ZXJuYWxseVxuICAqL1xuXG5cbiAgYWRkVHJhbnNmb3JtKHRyYW5zZm9ybSwgaW5kZXgpIHtcbiAgICB0aGlzLnRyYW5zZm9ybXMubG11bHRpcGx5Tyh0cmFuc2Zvcm0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgYWZ0ZXIoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5vbignZmluaXNoZWQnLCBmbik7XG4gIH1cblxuICBhbmltYXRlKGR1cmF0aW9uLCBkZWxheSwgd2hlbikge1xuICAgIGNvbnN0IG8gPSBSdW5uZXIuc2FuaXRpc2UoZHVyYXRpb24sIGRlbGF5LCB3aGVuKTtcbiAgICBjb25zdCBydW5uZXIgPSBuZXcgUnVubmVyKG8uZHVyYXRpb24pO1xuICAgIGlmICh0aGlzLl90aW1lbGluZSkgcnVubmVyLnRpbWVsaW5lKHRoaXMuX3RpbWVsaW5lKTtcbiAgICBpZiAodGhpcy5fZWxlbWVudCkgcnVubmVyLmVsZW1lbnQodGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHJ1bm5lci5sb29wKG8pLnNjaGVkdWxlKG8uZGVsYXksIG8ud2hlbik7XG4gIH1cblxuICBjbGVhclRyYW5zZm9ybSgpIHtcbiAgICB0aGlzLnRyYW5zZm9ybXMgPSBuZXcgTWF0cml4KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gVE9ETzogS2VlcCB0cmFjayBvZiBhbGwgdHJhbnNmb3JtYXRpb25zIHNvIHRoYXQgZGVsZXRpb24gaXMgZmFzdGVyXG5cblxuICBjbGVhclRyYW5zZm9ybXNGcm9tUXVldWUoKSB7XG4gICAgaWYgKCF0aGlzLmRvbmUgfHwgIXRoaXMuX3RpbWVsaW5lIHx8ICF0aGlzLl90aW1lbGluZS5fcnVubmVySWRzLmluY2x1ZGVzKHRoaXMuaWQpKSB7XG4gICAgICB0aGlzLl9xdWV1ZSA9IHRoaXMuX3F1ZXVlLmZpbHRlcihpdGVtID0+IHtcbiAgICAgICAgcmV0dXJuICFpdGVtLmlzVHJhbnNmb3JtO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZGVsYXkoZGVsYXkpIHtcbiAgICByZXR1cm4gdGhpcy5hbmltYXRlKDAsIGRlbGF5KTtcbiAgfVxuXG4gIGR1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl90aW1lcyAqICh0aGlzLl93YWl0ICsgdGhpcy5fZHVyYXRpb24pIC0gdGhpcy5fd2FpdDtcbiAgfVxuXG4gIGR1cmluZyhmbikge1xuICAgIHJldHVybiB0aGlzLnF1ZXVlKG51bGwsIGZuKTtcbiAgfVxuXG4gIGVhc2UoZm4pIHtcbiAgICB0aGlzLl9zdGVwcGVyID0gbmV3IEVhc2UoZm4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qXG4gIFJ1bm5lciBEZWZpbml0aW9uc1xuICA9PT09PT09PT09PT09PT09PT1cbiAgVGhlc2UgbWV0aG9kcyBoZWxwIHVzIGRlZmluZSB0aGUgcnVudGltZSBiZWhhdmlvdXIgb2YgdGhlIFJ1bm5lciBvciB0aGV5XG4gIGhlbHAgdXMgbWFrZSBuZXcgcnVubmVycyBmcm9tIHRoZSBjdXJyZW50IHJ1bm5lclxuICAqL1xuXG5cbiAgZWxlbWVudChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICBlbGVtZW50Ll9wcmVwYXJlUnVubmVyKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZpbmlzaCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGVwKEluZmluaXR5KTtcbiAgfVxuXG4gIGxvb3AodGltZXMsIHN3aW5nLCB3YWl0KSB7XG4gICAgLy8gRGVhbCB3aXRoIHRoZSB1c2VyIHBhc3NpbmcgaW4gYW4gb2JqZWN0XG4gICAgaWYgKHR5cGVvZiB0aW1lcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHN3aW5nID0gdGltZXMuc3dpbmc7XG4gICAgICB3YWl0ID0gdGltZXMud2FpdDtcbiAgICAgIHRpbWVzID0gdGltZXMudGltZXM7XG4gICAgfSAvLyBTYW5pdGlzZSB0aGUgdmFsdWVzIGFuZCBzdG9yZSB0aGVtXG5cblxuICAgIHRoaXMuX3RpbWVzID0gdGltZXMgfHwgSW5maW5pdHk7XG4gICAgdGhpcy5fc3dpbmcgPSBzd2luZyB8fCBmYWxzZTtcbiAgICB0aGlzLl93YWl0ID0gd2FpdCB8fCAwOyAvLyBBbGxvdyB0cnVlIHRvIGJlIHBhc3NlZFxuXG4gICAgaWYgKHRoaXMuX3RpbWVzID09PSB0cnVlKSB7XG4gICAgICB0aGlzLl90aW1lcyA9IEluZmluaXR5O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbG9vcHMocCkge1xuICAgIGNvbnN0IGxvb3BEdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uICsgdGhpcy5fd2FpdDtcblxuICAgIGlmIChwID09IG51bGwpIHtcbiAgICAgIGNvbnN0IGxvb3BzRG9uZSA9IE1hdGguZmxvb3IodGhpcy5fdGltZSAvIGxvb3BEdXJhdGlvbik7XG4gICAgICBjb25zdCByZWxhdGl2ZVRpbWUgPSB0aGlzLl90aW1lIC0gbG9vcHNEb25lICogbG9vcER1cmF0aW9uO1xuICAgICAgY29uc3QgcG9zaXRpb24gPSByZWxhdGl2ZVRpbWUgLyB0aGlzLl9kdXJhdGlvbjtcbiAgICAgIHJldHVybiBNYXRoLm1pbihsb29wc0RvbmUgKyBwb3NpdGlvbiwgdGhpcy5fdGltZXMpO1xuICAgIH1cblxuICAgIGNvbnN0IHdob2xlID0gTWF0aC5mbG9vcihwKTtcbiAgICBjb25zdCBwYXJ0aWFsID0gcCAlIDE7XG4gICAgY29uc3QgdGltZSA9IGxvb3BEdXJhdGlvbiAqIHdob2xlICsgdGhpcy5fZHVyYXRpb24gKiBwYXJ0aWFsO1xuICAgIHJldHVybiB0aGlzLnRpbWUodGltZSk7XG4gIH1cblxuICBwZXJzaXN0KGR0T3JGb3JldmVyKSB7XG4gICAgaWYgKGR0T3JGb3JldmVyID09IG51bGwpIHJldHVybiB0aGlzLl9wZXJzaXN0O1xuICAgIHRoaXMuX3BlcnNpc3QgPSBkdE9yRm9yZXZlcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHBvc2l0aW9uKHApIHtcbiAgICAvLyBHZXQgYWxsIG9mIHRoZSB2YXJpYWJsZXMgd2UgbmVlZFxuICAgIGNvbnN0IHggPSB0aGlzLl90aW1lO1xuICAgIGNvbnN0IGQgPSB0aGlzLl9kdXJhdGlvbjtcbiAgICBjb25zdCB3ID0gdGhpcy5fd2FpdDtcbiAgICBjb25zdCB0ID0gdGhpcy5fdGltZXM7XG4gICAgY29uc3QgcyA9IHRoaXMuX3N3aW5nO1xuICAgIGNvbnN0IHIgPSB0aGlzLl9yZXZlcnNlO1xuICAgIGxldCBwb3NpdGlvbjtcblxuICAgIGlmIChwID09IG51bGwpIHtcbiAgICAgIC8qXG4gICAgICBUaGlzIGZ1bmN0aW9uIGNvbnZlcnRzIGEgdGltZSB0byBhIHBvc2l0aW9uIGluIHRoZSByYW5nZSBbMCwgMV1cbiAgICAgIFRoZSBmdWxsIGV4cGxhbmF0aW9uIGNhbiBiZSBmb3VuZCBpbiB0aGlzIGRlc21vcyBkZW1vbnN0cmF0aW9uXG4gICAgICAgIGh0dHBzOi8vd3d3LmRlc21vcy5jb20vY2FsY3VsYXRvci91NGZiYXZnY2hlXG4gICAgICBUaGUgbG9naWMgaXMgc2xpZ2h0bHkgc2ltcGxpZmllZCBoZXJlIGJlY2F1c2Ugd2UgY2FuIHVzZSBib29sZWFuc1xuICAgICAgKi9cbiAgICAgIC8vIEZpZ3VyZSBvdXQgdGhlIHZhbHVlIHdpdGhvdXQgdGhpbmtpbmcgYWJvdXQgdGhlIHN0YXJ0IG9yIGVuZCB0aW1lXG4gICAgICBjb25zdCBmID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgY29uc3Qgc3dpbmdpbmcgPSBzICogTWF0aC5mbG9vcih4ICUgKDIgKiAodyArIGQpKSAvICh3ICsgZCkpO1xuICAgICAgICBjb25zdCBiYWNrd2FyZHMgPSBzd2luZ2luZyAmJiAhciB8fCAhc3dpbmdpbmcgJiYgcjtcbiAgICAgICAgY29uc3QgdW5jbGlwZWQgPSBNYXRoLnBvdygtMSwgYmFja3dhcmRzKSAqICh4ICUgKHcgKyBkKSkgLyBkICsgYmFja3dhcmRzO1xuICAgICAgICBjb25zdCBjbGlwcGVkID0gTWF0aC5tYXgoTWF0aC5taW4odW5jbGlwZWQsIDEpLCAwKTtcbiAgICAgICAgcmV0dXJuIGNsaXBwZWQ7XG4gICAgICB9OyAvLyBGaWd1cmUgb3V0IHRoZSB2YWx1ZSBieSBpbmNvcnBvcmF0aW5nIHRoZSBzdGFydCB0aW1lXG5cblxuICAgICAgY29uc3QgZW5kVGltZSA9IHQgKiAodyArIGQpIC0gdztcbiAgICAgIHBvc2l0aW9uID0geCA8PSAwID8gTWF0aC5yb3VuZChmKDFlLTUpKSA6IHggPCBlbmRUaW1lID8gZih4KSA6IE1hdGgucm91bmQoZihlbmRUaW1lIC0gMWUtNSkpO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH0gLy8gV29yayBvdXQgdGhlIGxvb3BzIGRvbmUgYW5kIGFkZCB0aGUgcG9zaXRpb24gdG8gdGhlIGxvb3BzIGRvbmVcblxuXG4gICAgY29uc3QgbG9vcHNEb25lID0gTWF0aC5mbG9vcih0aGlzLmxvb3BzKCkpO1xuICAgIGNvbnN0IHN3aW5nRm9yd2FyZCA9IHMgJiYgbG9vcHNEb25lICUgMiA9PT0gMDtcbiAgICBjb25zdCBmb3J3YXJkcyA9IHN3aW5nRm9yd2FyZCAmJiAhciB8fCByICYmIHN3aW5nRm9yd2FyZDtcbiAgICBwb3NpdGlvbiA9IGxvb3BzRG9uZSArIChmb3J3YXJkcyA/IHAgOiAxIC0gcCk7XG4gICAgcmV0dXJuIHRoaXMubG9vcHMocG9zaXRpb24pO1xuICB9XG5cbiAgcHJvZ3Jlc3MocCkge1xuICAgIGlmIChwID09IG51bGwpIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbigxLCB0aGlzLl90aW1lIC8gdGhpcy5kdXJhdGlvbigpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50aW1lKHAgKiB0aGlzLmR1cmF0aW9uKCkpO1xuICB9XG4gIC8qXG4gIEJhc2ljIEZ1bmN0aW9uYWxpdHlcbiAgPT09PT09PT09PT09PT09PT09PVxuICBUaGVzZSBtZXRob2RzIGFsbG93IHVzIHRvIGF0dGFjaCBiYXNpYyBmdW5jdGlvbnMgdG8gdGhlIHJ1bm5lciBkaXJlY3RseVxuICAqL1xuXG5cbiAgcXVldWUoaW5pdEZuLCBydW5GbiwgcmV0YXJnZXRGbiwgaXNUcmFuc2Zvcm0pIHtcbiAgICB0aGlzLl9xdWV1ZS5wdXNoKHtcbiAgICAgIGluaXRpYWxpc2VyOiBpbml0Rm4gfHwgbm9vcCxcbiAgICAgIHJ1bm5lcjogcnVuRm4gfHwgbm9vcCxcbiAgICAgIHJldGFyZ2V0OiByZXRhcmdldEZuLFxuICAgICAgaXNUcmFuc2Zvcm06IGlzVHJhbnNmb3JtLFxuICAgICAgaW5pdGlhbGlzZWQ6IGZhbHNlLFxuICAgICAgZmluaXNoZWQ6IGZhbHNlXG4gICAgfSk7XG5cbiAgICBjb25zdCB0aW1lbGluZSA9IHRoaXMudGltZWxpbmUoKTtcbiAgICB0aW1lbGluZSAmJiB0aGlzLnRpbWVsaW5lKCkuX2NvbnRpbnVlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZXNldCgpIHtcbiAgICBpZiAodGhpcy5fcmVzZXRlZCkgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy50aW1lKDApO1xuICAgIHRoaXMuX3Jlc2V0ZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmV2ZXJzZShyZXZlcnNlKSB7XG4gICAgdGhpcy5fcmV2ZXJzZSA9IHJldmVyc2UgPT0gbnVsbCA/ICF0aGlzLl9yZXZlcnNlIDogcmV2ZXJzZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNjaGVkdWxlKHRpbWVsaW5lLCBkZWxheSwgd2hlbikge1xuICAgIC8vIFRoZSB1c2VyIGRvZXNuJ3QgbmVlZCB0byBwYXNzIGEgdGltZWxpbmUgaWYgd2UgYWxyZWFkeSBoYXZlIG9uZVxuICAgIGlmICghKHRpbWVsaW5lIGluc3RhbmNlb2YgVGltZWxpbmUpKSB7XG4gICAgICB3aGVuID0gZGVsYXk7XG4gICAgICBkZWxheSA9IHRpbWVsaW5lO1xuICAgICAgdGltZWxpbmUgPSB0aGlzLnRpbWVsaW5lKCk7XG4gICAgfSAvLyBJZiB0aGVyZSBpcyBubyB0aW1lbGluZSwgeWVsbCBhdCB0aGUgdXNlci4uLlxuXG5cbiAgICBpZiAoIXRpbWVsaW5lKSB7XG4gICAgICB0aHJvdyBFcnJvcignUnVubmVyIGNhbm5vdCBiZSBzY2hlZHVsZWQgd2l0aG91dCB0aW1lbGluZScpO1xuICAgIH0gLy8gU2NoZWR1bGUgdGhlIHJ1bm5lciBvbiB0aGUgdGltZWxpbmUgcHJvdmlkZWRcblxuXG4gICAgdGltZWxpbmUuc2NoZWR1bGUodGhpcywgZGVsYXksIHdoZW4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc3RlcChkdCkge1xuICAgIC8vIElmIHdlIGFyZSBpbmFjdGl2ZSwgdGhpcyBzdGVwcGVyIGp1c3QgZ2V0cyBza2lwcGVkXG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpIHJldHVybiB0aGlzOyAvLyBVcGRhdGUgdGhlIHRpbWUgYW5kIGdldCB0aGUgbmV3IHBvc2l0aW9uXG5cbiAgICBkdCA9IGR0ID09IG51bGwgPyAxNiA6IGR0O1xuICAgIHRoaXMuX3RpbWUgKz0gZHQ7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uKCk7IC8vIEZpZ3VyZSBvdXQgaWYgd2UgbmVlZCB0byBydW4gdGhlIHN0ZXBwZXIgaW4gdGhpcyBmcmFtZVxuXG4gICAgY29uc3QgcnVubmluZyA9IHRoaXMuX2xhc3RQb3NpdGlvbiAhPT0gcG9zaXRpb24gJiYgdGhpcy5fdGltZSA+PSAwO1xuICAgIHRoaXMuX2xhc3RQb3NpdGlvbiA9IHBvc2l0aW9uOyAvLyBGaWd1cmUgb3V0IGlmIHdlIGp1c3Qgc3RhcnRlZFxuXG4gICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uKCk7XG4gICAgY29uc3QganVzdFN0YXJ0ZWQgPSB0aGlzLl9sYXN0VGltZSA8PSAwICYmIHRoaXMuX3RpbWUgPiAwO1xuICAgIGNvbnN0IGp1c3RGaW5pc2hlZCA9IHRoaXMuX2xhc3RUaW1lIDwgZHVyYXRpb24gJiYgdGhpcy5fdGltZSA+PSBkdXJhdGlvbjtcbiAgICB0aGlzLl9sYXN0VGltZSA9IHRoaXMuX3RpbWU7XG5cbiAgICBpZiAoanVzdFN0YXJ0ZWQpIHtcbiAgICAgIHRoaXMuZmlyZSgnc3RhcnQnLCB0aGlzKTtcbiAgICB9IC8vIFdvcmsgb3V0IGlmIHRoZSBydW5uZXIgaXMgZmluaXNoZWQgc2V0IHRoZSBkb25lIGZsYWcgaGVyZSBzbyBhbmltYXRpb25zXG4gICAgLy8ga25vdywgdGhhdCB0aGV5IGFyZSBydW5uaW5nIGluIHRoZSBsYXN0IHN0ZXAgKHRoaXMgaXMgZ29vZCBmb3JcbiAgICAvLyB0cmFuc2Zvcm1hdGlvbnMgd2hpY2ggY2FuIGJlIG1lcmdlZClcblxuXG4gICAgY29uc3QgZGVjbGFyYXRpdmUgPSB0aGlzLl9pc0RlY2xhcmF0aXZlO1xuICAgIHRoaXMuZG9uZSA9ICFkZWNsYXJhdGl2ZSAmJiAhanVzdEZpbmlzaGVkICYmIHRoaXMuX3RpbWUgPj0gZHVyYXRpb247IC8vIFJ1bm5lciBpcyBydW5uaW5nLiBTbyBpdHMgbm90IGluIHJlc2V0IHN0YXRlIGFueW1vcmVcblxuICAgIHRoaXMuX3Jlc2V0ZWQgPSBmYWxzZTtcbiAgICBsZXQgY29udmVyZ2VkID0gZmFsc2U7IC8vIENhbGwgaW5pdGlhbGlzZSBhbmQgdGhlIHJ1biBmdW5jdGlvblxuXG4gICAgaWYgKHJ1bm5pbmcgfHwgZGVjbGFyYXRpdmUpIHtcbiAgICAgIHRoaXMuX2luaXRpYWxpc2UocnVubmluZyk7IC8vIGNsZWFyIHRoZSB0cmFuc2Zvcm1zIG9uIHRoaXMgcnVubmVyIHNvIHRoZXkgZG9udCBnZXQgYWRkZWQgYWdhaW4gYW5kIGFnYWluXG5cblxuICAgICAgdGhpcy50cmFuc2Zvcm1zID0gbmV3IE1hdHJpeCgpO1xuICAgICAgY29udmVyZ2VkID0gdGhpcy5fcnVuKGRlY2xhcmF0aXZlID8gZHQgOiBwb3NpdGlvbik7XG4gICAgICB0aGlzLmZpcmUoJ3N0ZXAnLCB0aGlzKTtcbiAgICB9IC8vIGNvcnJlY3QgdGhlIGRvbmUgZmxhZyBoZXJlXG4gICAgLy8gZGVjbGFyYXRpdmUgYW5pbWF0aW9ucyBpdHNlbGYga25vdyB3aGVuIHRoZXkgY29udmVyZ2VkXG5cblxuICAgIHRoaXMuZG9uZSA9IHRoaXMuZG9uZSB8fCBjb252ZXJnZWQgJiYgZGVjbGFyYXRpdmU7XG5cbiAgICBpZiAoanVzdEZpbmlzaGVkKSB7XG4gICAgICB0aGlzLmZpcmUoJ2ZpbmlzaGVkJywgdGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLypcbiAgUnVubmVyIGFuaW1hdGlvbiBtZXRob2RzXG4gID09PT09PT09PT09PT09PT09PT09PT09PVxuICBDb250cm9sIGhvdyB0aGUgYW5pbWF0aW9uIHBsYXlzXG4gICovXG5cblxuICB0aW1lKHRpbWUpIHtcbiAgICBpZiAodGltZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdGltZTtcbiAgICB9XG5cbiAgICBjb25zdCBkdCA9IHRpbWUgLSB0aGlzLl90aW1lO1xuICAgIHRoaXMuc3RlcChkdCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0aW1lbGluZSh0aW1lbGluZSkge1xuICAgIC8vIGNoZWNrIGV4cGxpY2l0bHkgZm9yIHVuZGVmaW5lZCBzbyB3ZSBjYW4gc2V0IHRoZSB0aW1lbGluZSB0byBudWxsXG4gICAgaWYgKHR5cGVvZiB0aW1lbGluZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiB0aGlzLl90aW1lbGluZTtcbiAgICB0aGlzLl90aW1lbGluZSA9IHRpbWVsaW5lO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdW5zY2hlZHVsZSgpIHtcbiAgICBjb25zdCB0aW1lbGluZSA9IHRoaXMudGltZWxpbmUoKTtcbiAgICB0aW1lbGluZSAmJiB0aW1lbGluZS51bnNjaGVkdWxlKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIFJ1biBlYWNoIGluaXRpYWxpc2UgZnVuY3Rpb24gaW4gdGhlIHJ1bm5lciBpZiByZXF1aXJlZFxuXG5cbiAgX2luaXRpYWxpc2UocnVubmluZykge1xuICAgIC8vIElmIHdlIGFyZW4ndCBydW5uaW5nLCB3ZSBzaG91bGRuJ3QgaW5pdGlhbGlzZSB3aGVuIG5vdCBkZWNsYXJhdGl2ZVxuICAgIGlmICghcnVubmluZyAmJiAhdGhpcy5faXNEZWNsYXJhdGl2ZSkgcmV0dXJuOyAvLyBMb29wIHRocm91Z2ggYWxsIG9mIHRoZSBpbml0aWFsaXNlcnNcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGluaXRpYWxpc2VyXG4gICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5fcXVldWVbaV07IC8vIERldGVybWluZSB3aGV0aGVyIHdlIG5lZWQgdG8gaW5pdGlhbGlzZVxuXG4gICAgICBjb25zdCBuZWVkc0l0ID0gdGhpcy5faXNEZWNsYXJhdGl2ZSB8fCAhY3VycmVudC5pbml0aWFsaXNlZCAmJiBydW5uaW5nO1xuICAgICAgcnVubmluZyA9ICFjdXJyZW50LmZpbmlzaGVkOyAvLyBDYWxsIHRoZSBpbml0aWFsaXNlciBpZiB3ZSBuZWVkIHRvXG5cbiAgICAgIGlmIChuZWVkc0l0ICYmIHJ1bm5pbmcpIHtcbiAgICAgICAgY3VycmVudC5pbml0aWFsaXNlci5jYWxsKHRoaXMpO1xuICAgICAgICBjdXJyZW50LmluaXRpYWxpc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gU2F2ZSBhIG1vcnBoZXIgdG8gdGhlIG1vcnBoZXIgbGlzdCBzbyB0aGF0IHdlIGNhbiByZXRhcmdldCBpdCBsYXRlclxuXG5cbiAgX3JlbWVtYmVyTW9ycGhlcihtZXRob2QsIG1vcnBoZXIpIHtcbiAgICB0aGlzLl9oaXN0b3J5W21ldGhvZF0gPSB7XG4gICAgICBtb3JwaGVyOiBtb3JwaGVyLFxuICAgICAgY2FsbGVyOiB0aGlzLl9xdWV1ZVt0aGlzLl9xdWV1ZS5sZW5ndGggLSAxXVxuICAgIH07IC8vIFdlIGhhdmUgdG8gcmVzdW1lIHRoZSB0aW1lbGluZSBpbiBjYXNlIGEgY29udHJvbGxlclxuICAgIC8vIGlzIGFscmVhZHkgZG9uZSB3aXRob3V0IGJlaW5nIGV2ZXIgcnVuXG4gICAgLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gZS5nLiB0aGlzIGlzIGRvbmU6XG4gICAgLy8gICAgYW5pbSA9IGVsLmFuaW1hdGUobmV3IFNWRy5TcHJpbmcpXG4gICAgLy8gYW5kIGxhdGVyXG4gICAgLy8gICAgYW5pbS5tb3ZlKC4uLilcblxuICAgIGlmICh0aGlzLl9pc0RlY2xhcmF0aXZlKSB7XG4gICAgICBjb25zdCB0aW1lbGluZSA9IHRoaXMudGltZWxpbmUoKTtcbiAgICAgIHRpbWVsaW5lICYmIHRpbWVsaW5lLnBsYXkoKTtcbiAgICB9XG4gIH0gLy8gVHJ5IHRvIHNldCB0aGUgdGFyZ2V0IGZvciBhIG1vcnBoZXIgaWYgdGhlIG1vcnBoZXIgZXhpc3RzLCBvdGhlcndpc2VcbiAgLy8gUnVuIGVhY2ggcnVuIGZ1bmN0aW9uIGZvciB0aGUgcG9zaXRpb24gb3IgZHQgZ2l2ZW5cblxuXG4gIF9ydW4ocG9zaXRpb25PckR0KSB7XG4gICAgLy8gUnVuIGFsbCBvZiB0aGUgX3F1ZXVlIGRpcmVjdGx5XG4gICAgbGV0IGFsbGZpbmlzaGVkID0gdHJ1ZTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGZ1bmN0aW9uIHRvIHJ1blxuICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuX3F1ZXVlW2ldOyAvLyBSdW4gdGhlIGZ1bmN0aW9uIGlmIGl0cyBub3QgZmluaXNoZWQsIHdlIGtlZXAgdHJhY2sgb2YgdGhlIGZpbmlzaGVkXG4gICAgICAvLyBmbGFnIGZvciB0aGUgc2FrZSBvZiBkZWNsYXJhdGl2ZSBfcXVldWVcblxuICAgICAgY29uc3QgY29udmVyZ2VkID0gY3VycmVudC5ydW5uZXIuY2FsbCh0aGlzLCBwb3NpdGlvbk9yRHQpO1xuICAgICAgY3VycmVudC5maW5pc2hlZCA9IGN1cnJlbnQuZmluaXNoZWQgfHwgY29udmVyZ2VkID09PSB0cnVlO1xuICAgICAgYWxsZmluaXNoZWQgPSBhbGxmaW5pc2hlZCAmJiBjdXJyZW50LmZpbmlzaGVkO1xuICAgIH0gLy8gV2UgcmVwb3J0IHdoZW4gYWxsIG9mIHRoZSBjb25zdHJ1Y3RvcnMgYXJlIGZpbmlzaGVkXG5cblxuICAgIHJldHVybiBhbGxmaW5pc2hlZDtcbiAgfSAvLyBkbyBub3RoaW5nIGFuZCByZXR1cm4gZmFsc2VcblxuXG4gIF90cnlSZXRhcmdldChtZXRob2QsIHRhcmdldCwgZXh0cmEpIHtcbiAgICBpZiAodGhpcy5faGlzdG9yeVttZXRob2RdKSB7XG4gICAgICAvLyBpZiB0aGUgbGFzdCBtZXRob2Qgd2Fzbid0IGV2ZW4gaW5pdGlhbGlzZWQsIHRocm93IGl0IGF3YXlcbiAgICAgIGlmICghdGhpcy5faGlzdG9yeVttZXRob2RdLmNhbGxlci5pbml0aWFsaXNlZCkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX3F1ZXVlLmluZGV4T2YodGhpcy5faGlzdG9yeVttZXRob2RdLmNhbGxlcik7XG5cbiAgICAgICAgdGhpcy5fcXVldWUuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIGZvciB0aGUgY2FzZSBvZiB0cmFuc2Zvcm1hdGlvbnMsIHdlIHVzZSB0aGUgc3BlY2lhbCByZXRhcmdldCBmdW5jdGlvblxuICAgICAgLy8gd2hpY2ggaGFzIGFjY2VzcyB0byB0aGUgb3V0ZXIgc2NvcGVcblxuXG4gICAgICBpZiAodGhpcy5faGlzdG9yeVttZXRob2RdLmNhbGxlci5yZXRhcmdldCkge1xuICAgICAgICB0aGlzLl9oaXN0b3J5W21ldGhvZF0uY2FsbGVyLnJldGFyZ2V0LmNhbGwodGhpcywgdGFyZ2V0LCBleHRyYSk7IC8vIGZvciBldmVyeXRoaW5nIGVsc2UgYSBzaW1wbGUgbW9ycGhlciBjaGFuZ2UgaXMgc3VmZmljaWVudFxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9oaXN0b3J5W21ldGhvZF0ubW9ycGhlci50byh0YXJnZXQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9oaXN0b3J5W21ldGhvZF0uY2FsbGVyLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICBjb25zdCB0aW1lbGluZSA9IHRoaXMudGltZWxpbmUoKTtcbiAgICAgIHRpbWVsaW5lICYmIHRpbWVsaW5lLnBsYXkoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG59XG5SdW5uZXIuaWQgPSAwO1xuY2xhc3MgRmFrZVJ1bm5lciB7XG4gIGNvbnN0cnVjdG9yKHRyYW5zZm9ybXMgPSBuZXcgTWF0cml4KCksIGlkID0gLTEsIGRvbmUgPSB0cnVlKSB7XG4gICAgdGhpcy50cmFuc2Zvcm1zID0gdHJhbnNmb3JtcztcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5kb25lID0gZG9uZTtcbiAgfVxuXG4gIGNsZWFyVHJhbnNmb3Jtc0Zyb21RdWV1ZSgpIHt9XG5cbn1cbmV4dGVuZChbUnVubmVyLCBGYWtlUnVubmVyXSwge1xuICBtZXJnZVdpdGgocnVubmVyKSB7XG4gICAgcmV0dXJuIG5ldyBGYWtlUnVubmVyKHJ1bm5lci50cmFuc2Zvcm1zLmxtdWx0aXBseSh0aGlzLnRyYW5zZm9ybXMpLCBydW5uZXIuaWQpO1xuICB9XG5cbn0pOyAvLyBGYWtlUnVubmVyLmVtcHR5UnVubmVyID0gbmV3IEZha2VSdW5uZXIoKVxuXG5jb25zdCBsbXVsdGlwbHkgPSAobGFzdCwgY3VycikgPT4gbGFzdC5sbXVsdGlwbHlPKGN1cnIpO1xuXG5jb25zdCBnZXRSdW5uZXJUcmFuc2Zvcm0gPSBydW5uZXIgPT4gcnVubmVyLnRyYW5zZm9ybXM7XG5cbmZ1bmN0aW9uIG1lcmdlVHJhbnNmb3JtcygpIHtcbiAgLy8gRmluZCB0aGUgbWF0cml4IHRvIGFwcGx5IHRvIHRoZSBlbGVtZW50IGFuZCBhcHBseSBpdFxuICBjb25zdCBydW5uZXJzID0gdGhpcy5fdHJhbnNmb3JtYXRpb25SdW5uZXJzLnJ1bm5lcnM7XG4gIGNvbnN0IG5ldFRyYW5zZm9ybSA9IHJ1bm5lcnMubWFwKGdldFJ1bm5lclRyYW5zZm9ybSkucmVkdWNlKGxtdWx0aXBseSwgbmV3IE1hdHJpeCgpKTtcbiAgdGhpcy50cmFuc2Zvcm0obmV0VHJhbnNmb3JtKTtcblxuICB0aGlzLl90cmFuc2Zvcm1hdGlvblJ1bm5lcnMubWVyZ2UoKTtcblxuICBpZiAodGhpcy5fdHJhbnNmb3JtYXRpb25SdW5uZXJzLmxlbmd0aCgpID09PSAxKSB7XG4gICAgdGhpcy5fZnJhbWVJZCA9IG51bGw7XG4gIH1cbn1cblxuY2xhc3MgUnVubmVyQXJyYXkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnJ1bm5lcnMgPSBbXTtcbiAgICB0aGlzLmlkcyA9IFtdO1xuICB9XG5cbiAgYWRkKHJ1bm5lcikge1xuICAgIGlmICh0aGlzLnJ1bm5lcnMuaW5jbHVkZXMocnVubmVyKSkgcmV0dXJuO1xuICAgIGNvbnN0IGlkID0gcnVubmVyLmlkICsgMTtcbiAgICB0aGlzLnJ1bm5lcnMucHVzaChydW5uZXIpO1xuICAgIHRoaXMuaWRzLnB1c2goaWQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY2xlYXJCZWZvcmUoaWQpIHtcbiAgICBjb25zdCBkZWxldGVDbnQgPSB0aGlzLmlkcy5pbmRleE9mKGlkICsgMSkgfHwgMTtcbiAgICB0aGlzLmlkcy5zcGxpY2UoMCwgZGVsZXRlQ250LCAwKTtcbiAgICB0aGlzLnJ1bm5lcnMuc3BsaWNlKDAsIGRlbGV0ZUNudCwgbmV3IEZha2VSdW5uZXIoKSkuZm9yRWFjaChyID0+IHIuY2xlYXJUcmFuc2Zvcm1zRnJvbVF1ZXVlKCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZWRpdChpZCwgbmV3UnVubmVyKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmlkcy5pbmRleE9mKGlkICsgMSk7XG4gICAgdGhpcy5pZHMuc3BsaWNlKGluZGV4LCAxLCBpZCArIDEpO1xuICAgIHRoaXMucnVubmVycy5zcGxpY2UoaW5kZXgsIDEsIG5ld1J1bm5lcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXRCeUlEKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMucnVubmVyc1t0aGlzLmlkcy5pbmRleE9mKGlkICsgMSldO1xuICB9XG5cbiAgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmlkcy5sZW5ndGg7XG4gIH1cblxuICBtZXJnZSgpIHtcbiAgICBsZXQgbGFzdFJ1bm5lciA9IG51bGw7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucnVubmVycy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgcnVubmVyID0gdGhpcy5ydW5uZXJzW2ldO1xuICAgICAgY29uc3QgY29uZGl0aW9uID0gbGFzdFJ1bm5lciAmJiBydW5uZXIuZG9uZSAmJiBsYXN0UnVubmVyLmRvbmUgLy8gZG9uJ3QgbWVyZ2UgcnVubmVyIHdoZW4gcGVyc2lzdGVkIG9uIHRpbWVsaW5lXG4gICAgICAmJiAoIXJ1bm5lci5fdGltZWxpbmUgfHwgIXJ1bm5lci5fdGltZWxpbmUuX3J1bm5lcklkcy5pbmNsdWRlcyhydW5uZXIuaWQpKSAmJiAoIWxhc3RSdW5uZXIuX3RpbWVsaW5lIHx8ICFsYXN0UnVubmVyLl90aW1lbGluZS5fcnVubmVySWRzLmluY2x1ZGVzKGxhc3RSdW5uZXIuaWQpKTtcblxuICAgICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgICAvLyB0aGUgKzEgaGFwcGVucyBpbiB0aGUgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5yZW1vdmUocnVubmVyLmlkKTtcbiAgICAgICAgY29uc3QgbmV3UnVubmVyID0gcnVubmVyLm1lcmdlV2l0aChsYXN0UnVubmVyKTtcbiAgICAgICAgdGhpcy5lZGl0KGxhc3RSdW5uZXIuaWQsIG5ld1J1bm5lcik7XG4gICAgICAgIGxhc3RSdW5uZXIgPSBuZXdSdW5uZXI7XG4gICAgICAgIC0taTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3RSdW5uZXIgPSBydW5uZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZW1vdmUoaWQpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuaWRzLmluZGV4T2YoaWQgKyAxKTtcbiAgICB0aGlzLmlkcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHRoaXMucnVubmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbn1cbnJlZ2lzdGVyTWV0aG9kcyh7XG4gIEVsZW1lbnQ6IHtcbiAgICBhbmltYXRlKGR1cmF0aW9uLCBkZWxheSwgd2hlbikge1xuICAgICAgY29uc3QgbyA9IFJ1bm5lci5zYW5pdGlzZShkdXJhdGlvbiwgZGVsYXksIHdoZW4pO1xuICAgICAgY29uc3QgdGltZWxpbmUgPSB0aGlzLnRpbWVsaW5lKCk7XG4gICAgICByZXR1cm4gbmV3IFJ1bm5lcihvLmR1cmF0aW9uKS5sb29wKG8pLmVsZW1lbnQodGhpcykudGltZWxpbmUodGltZWxpbmUucGxheSgpKS5zY2hlZHVsZShvLmRlbGF5LCBvLndoZW4pO1xuICAgIH0sXG5cbiAgICBkZWxheShieSwgd2hlbikge1xuICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSgwLCBieSwgd2hlbik7XG4gICAgfSxcblxuICAgIC8vIHRoaXMgZnVuY3Rpb24gc2VhcmNoZXMgZm9yIGFsbCBydW5uZXJzIG9uIHRoZSBlbGVtZW50IGFuZCBkZWxldGVzIHRoZSBvbmVzXG4gICAgLy8gd2hpY2ggcnVuIGJlZm9yZSB0aGUgY3VycmVudCBvbmUuIFRoaXMgaXMgYmVjYXVzZSBhYnNvbHV0ZSB0cmFuc2Zvcm1hdGlvbnNcbiAgICAvLyBvdmVyd3JpdGUgYW55dGhpbmcgYW55d2F5IHNvIHRoZXJlIGlzIG5vIG5lZWQgdG8gd2FzdGUgdGltZSBjb21wdXRpbmdcbiAgICAvLyBvdGhlciBydW5uZXJzXG4gICAgX2NsZWFyVHJhbnNmb3JtUnVubmVyc0JlZm9yZShjdXJyZW50UnVubmVyKSB7XG4gICAgICB0aGlzLl90cmFuc2Zvcm1hdGlvblJ1bm5lcnMuY2xlYXJCZWZvcmUoY3VycmVudFJ1bm5lci5pZCk7XG4gICAgfSxcblxuICAgIF9jdXJyZW50VHJhbnNmb3JtKGN1cnJlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm1hdGlvblJ1bm5lcnMucnVubmVycyAvLyB3ZSBuZWVkIHRoZSBlcXVhbCBzaWduIGhlcmUgdG8gbWFrZSBzdXJlLCB0aGF0IGFsc28gdHJhbnNmb3JtYXRpb25zXG4gICAgICAvLyBvbiB0aGUgc2FtZSBydW5uZXIgd2hpY2ggZXhlY3V0ZSBiZWZvcmUgdGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gYXJlXG4gICAgICAvLyB0YWtlbiBpbnRvIGFjY291bnRcbiAgICAgIC5maWx0ZXIocnVubmVyID0+IHJ1bm5lci5pZCA8PSBjdXJyZW50LmlkKS5tYXAoZ2V0UnVubmVyVHJhbnNmb3JtKS5yZWR1Y2UobG11bHRpcGx5LCBuZXcgTWF0cml4KCkpO1xuICAgIH0sXG5cbiAgICBfYWRkUnVubmVyKHJ1bm5lcikge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtYXRpb25SdW5uZXJzLmFkZChydW5uZXIpOyAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcnVubmVyIG1lcmdlIGlzIGV4ZWN1dGVkIGF0IHRoZSB2ZXJ5IGVuZCBvZlxuICAgICAgLy8gYWxsIEFuaW1hdG9yIGZ1bmN0aW9ucy4gVGhhdCBpcyB3aHkgd2UgdXNlIGltbWVkaWF0ZSBoZXJlIHRvIGV4ZWN1dGVcbiAgICAgIC8vIHRoZSBtZXJnZSByaWdodCBhZnRlciBhbGwgZnJhbWVzIGFyZSBydW5cblxuXG4gICAgICBBbmltYXRvci5jYW5jZWxJbW1lZGlhdGUodGhpcy5fZnJhbWVJZCk7XG4gICAgICB0aGlzLl9mcmFtZUlkID0gQW5pbWF0b3IuaW1tZWRpYXRlKG1lcmdlVHJhbnNmb3Jtcy5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgX3ByZXBhcmVSdW5uZXIoKSB7XG4gICAgICBpZiAodGhpcy5fZnJhbWVJZCA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybWF0aW9uUnVubmVycyA9IG5ldyBSdW5uZXJBcnJheSgpLmFkZChuZXcgRmFrZVJ1bm5lcihuZXcgTWF0cml4KHRoaXMpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cbn0pOyAvLyBXaWxsIG91dHB1dCB0aGUgZWxlbWVudHMgZnJvbSBhcnJheSBBIHRoYXQgYXJlIG5vdCBpbiB0aGUgYXJyYXkgQlxuXG5jb25zdCBkaWZmZXJlbmNlID0gKGEsIGIpID0+IGEuZmlsdGVyKHggPT4gIWIuaW5jbHVkZXMoeCkpO1xuXG5leHRlbmQoUnVubmVyLCB7XG4gIGF0dHIoYSwgdikge1xuICAgIHJldHVybiB0aGlzLnN0eWxlQXR0cignYXR0cicsIGEsIHYpO1xuICB9LFxuXG4gIC8vIEFkZCBhbmltYXRhYmxlIHN0eWxlc1xuICBjc3Mocywgdikge1xuICAgIHJldHVybiB0aGlzLnN0eWxlQXR0cignY3NzJywgcywgdik7XG4gIH0sXG5cbiAgc3R5bGVBdHRyKHR5cGUsIG5hbWVPckF0dHJzLCB2YWwpIHtcbiAgICBpZiAodHlwZW9mIG5hbWVPckF0dHJzID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRoaXMuc3R5bGVBdHRyKHR5cGUsIHtcbiAgICAgICAgW25hbWVPckF0dHJzXTogdmFsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBsZXQgYXR0cnMgPSBuYW1lT3JBdHRycztcbiAgICBpZiAodGhpcy5fdHJ5UmV0YXJnZXQodHlwZSwgYXR0cnMpKSByZXR1cm4gdGhpcztcbiAgICBsZXQgbW9ycGhlciA9IG5ldyBNb3JwaGFibGUodGhpcy5fc3RlcHBlcikudG8oYXR0cnMpO1xuICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMoYXR0cnMpO1xuICAgIHRoaXMucXVldWUoZnVuY3Rpb24gKCkge1xuICAgICAgbW9ycGhlciA9IG1vcnBoZXIuZnJvbSh0aGlzLmVsZW1lbnQoKVt0eXBlXShrZXlzKSk7XG4gICAgfSwgZnVuY3Rpb24gKHBvcykge1xuICAgICAgdGhpcy5lbGVtZW50KClbdHlwZV0obW9ycGhlci5hdChwb3MpLnZhbHVlT2YoKSk7XG4gICAgICByZXR1cm4gbW9ycGhlci5kb25lKCk7XG4gICAgfSwgZnVuY3Rpb24gKG5ld1RvQXR0cnMpIHtcbiAgICAgIC8vIENoZWNrIGlmIGFueSBuZXcga2V5cyB3ZXJlIGFkZGVkXG4gICAgICBjb25zdCBuZXdLZXlzID0gT2JqZWN0LmtleXMobmV3VG9BdHRycyk7XG4gICAgICBjb25zdCBkaWZmZXJlbmNlcyA9IGRpZmZlcmVuY2UobmV3S2V5cywga2V5cyk7IC8vIElmIHRoZWlyIGFyZSBuZXcga2V5cywgaW5pdGlhbGl6ZSB0aGVtIGFuZCBhZGQgdGhlbSB0byBtb3JwaGVyXG5cbiAgICAgIGlmIChkaWZmZXJlbmNlcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gR2V0IHRoZSB2YWx1ZXNcbiAgICAgICAgY29uc3QgYWRkZWRGcm9tQXR0cnMgPSB0aGlzLmVsZW1lbnQoKVt0eXBlXShkaWZmZXJlbmNlcyk7IC8vIEdldCB0aGUgYWxyZWFkeSBpbml0aWFsaXplZCB2YWx1ZXNcblxuICAgICAgICBjb25zdCBvbGRGcm9tQXR0cnMgPSBuZXcgT2JqZWN0QmFnKG1vcnBoZXIuZnJvbSgpKS52YWx1ZU9mKCk7IC8vIE1lcmdlIG9sZCBhbmQgbmV3XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihvbGRGcm9tQXR0cnMsIGFkZGVkRnJvbUF0dHJzKTtcbiAgICAgICAgbW9ycGhlci5mcm9tKG9sZEZyb21BdHRycyk7XG4gICAgICB9IC8vIEdldCB0aGUgb2JqZWN0IGZyb20gdGhlIG1vcnBoZXJcblxuXG4gICAgICBjb25zdCBvbGRUb0F0dHJzID0gbmV3IE9iamVjdEJhZyhtb3JwaGVyLnRvKCkpLnZhbHVlT2YoKTsgLy8gTWVyZ2UgaW4gbmV3IGF0dHJpYnV0ZXNcblxuICAgICAgT2JqZWN0LmFzc2lnbihvbGRUb0F0dHJzLCBuZXdUb0F0dHJzKTsgLy8gQ2hhbmdlIG1vcnBoZXIgdGFyZ2V0XG5cbiAgICAgIG1vcnBoZXIudG8ob2xkVG9BdHRycyk7IC8vIE1ha2Ugc3VyZSB0aGF0IHdlIHNhdmUgdGhlIHdvcmsgd2UgZGlkIHNvIHdlIGRvbid0IG5lZWQgaXQgdG8gZG8gYWdhaW5cblxuICAgICAga2V5cyA9IG5ld0tleXM7XG4gICAgICBhdHRycyA9IG5ld1RvQXR0cnM7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9yZW1lbWJlck1vcnBoZXIodHlwZSwgbW9ycGhlcik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICB6b29tKGxldmVsLCBwb2ludCkge1xuICAgIGlmICh0aGlzLl90cnlSZXRhcmdldCgnem9vbScsIGxldmVsLCBwb2ludCkpIHJldHVybiB0aGlzO1xuICAgIGxldCBtb3JwaGVyID0gbmV3IE1vcnBoYWJsZSh0aGlzLl9zdGVwcGVyKS50byhuZXcgU1ZHTnVtYmVyKGxldmVsKSk7XG4gICAgdGhpcy5xdWV1ZShmdW5jdGlvbiAoKSB7XG4gICAgICBtb3JwaGVyID0gbW9ycGhlci5mcm9tKHRoaXMuZWxlbWVudCgpLnpvb20oKSk7XG4gICAgfSwgZnVuY3Rpb24gKHBvcykge1xuICAgICAgdGhpcy5lbGVtZW50KCkuem9vbShtb3JwaGVyLmF0KHBvcyksIHBvaW50KTtcbiAgICAgIHJldHVybiBtb3JwaGVyLmRvbmUoKTtcbiAgICB9LCBmdW5jdGlvbiAobmV3TGV2ZWwsIG5ld1BvaW50KSB7XG4gICAgICBwb2ludCA9IG5ld1BvaW50O1xuICAgICAgbW9ycGhlci50byhuZXdMZXZlbCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9yZW1lbWJlck1vcnBoZXIoJ3pvb20nLCBtb3JwaGVyKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiogYWJzb2x1dGUgdHJhbnNmb3JtYXRpb25zXG4gICAqKi9cbiAgLy9cbiAgLy8gTSB2IC0tLS0tfC0tLS0tKEQgTSB2ID0gRiB2KS0tLS0tLXwtLS0tLT4gIFQgdlxuICAvL1xuICAvLyAxLiBkZWZpbmUgdGhlIGZpbmFsIHN0YXRlIChUKSBhbmQgZGVjb21wb3NlIGl0IChvbmNlKVxuICAvLyAgICB0ID0gW3R4LCB0eSwgdGhlLCBsYW0sIHN5LCBzeF1cbiAgLy8gMi4gb24gZXZlcnkgZnJhbWU6IHB1bGwgdGhlIGN1cnJlbnQgc3RhdGUgb2YgYWxsIHByZXZpb3VzIHRyYW5zZm9ybXNcbiAgLy8gICAgKE0gLSBtIGNhbiBjaGFuZ2UpXG4gIC8vICAgYW5kIHRoZW4gd3JpdGUgdGhpcyBhcyBtID0gW3R4MCwgdHkwLCB0aGUwLCBsYW0wLCBzeTAsIHN4MF1cbiAgLy8gMy4gRmluZCB0aGUgaW50ZXJwb2xhdGVkIG1hdHJpeCBGKHBvcykgPSBtICsgcG9zICogKHQgLSBtKVxuICAvLyAgIC0gTm90ZSBGKDApID0gTVxuICAvLyAgIC0gTm90ZSBGKDEpID0gVFxuICAvLyA0LiBOb3cgeW91IGdldCB0aGUgZGVsdGEgbWF0cml4IGFzIGEgcmVzdWx0OiBEID0gRiAqIGludihNKVxuICB0cmFuc2Zvcm0odHJhbnNmb3JtcywgcmVsYXRpdmUsIGFmZmluZSkge1xuICAgIC8vIElmIHdlIGhhdmUgYSBkZWNsYXJhdGl2ZSBmdW5jdGlvbiwgd2Ugc2hvdWxkIHJldGFyZ2V0IGl0IGlmIHBvc3NpYmxlXG4gICAgcmVsYXRpdmUgPSB0cmFuc2Zvcm1zLnJlbGF0aXZlIHx8IHJlbGF0aXZlO1xuXG4gICAgaWYgKHRoaXMuX2lzRGVjbGFyYXRpdmUgJiYgIXJlbGF0aXZlICYmIHRoaXMuX3RyeVJldGFyZ2V0KCd0cmFuc2Zvcm0nLCB0cmFuc2Zvcm1zKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSAvLyBQYXJzZSB0aGUgcGFyYW1ldGVyc1xuXG5cbiAgICBjb25zdCBpc01hdHJpeCA9IE1hdHJpeC5pc01hdHJpeExpa2UodHJhbnNmb3Jtcyk7XG4gICAgYWZmaW5lID0gdHJhbnNmb3Jtcy5hZmZpbmUgIT0gbnVsbCA/IHRyYW5zZm9ybXMuYWZmaW5lIDogYWZmaW5lICE9IG51bGwgPyBhZmZpbmUgOiAhaXNNYXRyaXg7IC8vIENyZWF0ZSBhIG1vcnBoZXIgYW5kIHNldCBpdHMgdHlwZVxuXG4gICAgY29uc3QgbW9ycGhlciA9IG5ldyBNb3JwaGFibGUodGhpcy5fc3RlcHBlcikudHlwZShhZmZpbmUgPyBUcmFuc2Zvcm1CYWcgOiBNYXRyaXgpO1xuICAgIGxldCBvcmlnaW47XG4gICAgbGV0IGVsZW1lbnQ7XG4gICAgbGV0IGN1cnJlbnQ7XG4gICAgbGV0IGN1cnJlbnRBbmdsZTtcbiAgICBsZXQgc3RhcnRUcmFuc2Zvcm07XG5cbiAgICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSBlbGVtZW50IGFuZCBvcmlnaW4gaXMgZGVmaW5lZFxuICAgICAgZWxlbWVudCA9IGVsZW1lbnQgfHwgdGhpcy5lbGVtZW50KCk7XG4gICAgICBvcmlnaW4gPSBvcmlnaW4gfHwgZ2V0T3JpZ2luKHRyYW5zZm9ybXMsIGVsZW1lbnQpO1xuICAgICAgc3RhcnRUcmFuc2Zvcm0gPSBuZXcgTWF0cml4KHJlbGF0aXZlID8gdW5kZWZpbmVkIDogZWxlbWVudCk7IC8vIGFkZCB0aGUgcnVubmVyIHRvIHRoZSBlbGVtZW50IHNvIGl0IGNhbiBtZXJnZSB0cmFuc2Zvcm1hdGlvbnNcblxuICAgICAgZWxlbWVudC5fYWRkUnVubmVyKHRoaXMpOyAvLyBEZWFjdGl2YXRlIGFsbCB0cmFuc2Zvcm1zIHRoYXQgaGF2ZSBydW4gc28gZmFyIGlmIHdlIGFyZSBhYnNvbHV0ZVxuXG5cbiAgICAgIGlmICghcmVsYXRpdmUpIHtcbiAgICAgICAgZWxlbWVudC5fY2xlYXJUcmFuc2Zvcm1SdW5uZXJzQmVmb3JlKHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bihwb3MpIHtcbiAgICAgIC8vIGNsZWFyIGFsbCBvdGhlciB0cmFuc2Zvcm1zIGJlZm9yZSB0aGlzIGluIGNhc2Ugc29tZXRoaW5nIGlzIHNhdmVkXG4gICAgICAvLyBvbiB0aGlzIHJ1bm5lci4gV2UgYXJlIGFic29sdXRlLiBXZSBkb250IG5lZWQgdGhlc2UhXG4gICAgICBpZiAoIXJlbGF0aXZlKSB0aGlzLmNsZWFyVHJhbnNmb3JtKCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSBuZXcgUG9pbnQob3JpZ2luKS50cmFuc2Zvcm0oZWxlbWVudC5fY3VycmVudFRyYW5zZm9ybSh0aGlzKSk7XG4gICAgICBsZXQgdGFyZ2V0ID0gbmV3IE1hdHJpeCh7IC4uLnRyYW5zZm9ybXMsXG4gICAgICAgIG9yaWdpbjogW3gsIHldXG4gICAgICB9KTtcbiAgICAgIGxldCBzdGFydCA9IHRoaXMuX2lzRGVjbGFyYXRpdmUgJiYgY3VycmVudCA/IGN1cnJlbnQgOiBzdGFydFRyYW5zZm9ybTtcblxuICAgICAgaWYgKGFmZmluZSkge1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXQuZGVjb21wb3NlKHgsIHkpO1xuICAgICAgICBzdGFydCA9IHN0YXJ0LmRlY29tcG9zZSh4LCB5KTsgLy8gR2V0IHRoZSBjdXJyZW50IGFuZCB0YXJnZXQgYW5nbGUgYXMgaXQgd2FzIHNldFxuXG4gICAgICAgIGNvbnN0IHJUYXJnZXQgPSB0YXJnZXQucm90YXRlO1xuICAgICAgICBjb25zdCByQ3VycmVudCA9IHN0YXJ0LnJvdGF0ZTsgLy8gRmlndXJlIG91dCB0aGUgc2hvcnRlc3QgcGF0aCB0byByb3RhdGUgZGlyZWN0bHlcblxuICAgICAgICBjb25zdCBwb3NzaWJpbGl0aWVzID0gW3JUYXJnZXQgLSAzNjAsIHJUYXJnZXQsIHJUYXJnZXQgKyAzNjBdO1xuICAgICAgICBjb25zdCBkaXN0YW5jZXMgPSBwb3NzaWJpbGl0aWVzLm1hcChhID0+IE1hdGguYWJzKGEgLSByQ3VycmVudCkpO1xuICAgICAgICBjb25zdCBzaG9ydGVzdCA9IE1hdGgubWluKC4uLmRpc3RhbmNlcyk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZGlzdGFuY2VzLmluZGV4T2Yoc2hvcnRlc3QpO1xuICAgICAgICB0YXJnZXQucm90YXRlID0gcG9zc2liaWxpdGllc1tpbmRleF07XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWxhdGl2ZSkge1xuICAgICAgICAvLyB3ZSBoYXZlIHRvIGJlIGNhcmVmdWwgaGVyZSBub3QgdG8gb3ZlcndyaXRlIHRoZSByb3RhdGlvblxuICAgICAgICAvLyB3aXRoIHRoZSByb3RhdGUgbWV0aG9kIG9mIE1hdHJpeFxuICAgICAgICBpZiAoIWlzTWF0cml4KSB7XG4gICAgICAgICAgdGFyZ2V0LnJvdGF0ZSA9IHRyYW5zZm9ybXMucm90YXRlIHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faXNEZWNsYXJhdGl2ZSAmJiBjdXJyZW50QW5nbGUpIHtcbiAgICAgICAgICBzdGFydC5yb3RhdGUgPSBjdXJyZW50QW5nbGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbW9ycGhlci5mcm9tKHN0YXJ0KTtcbiAgICAgIG1vcnBoZXIudG8odGFyZ2V0KTtcbiAgICAgIGNvbnN0IGFmZmluZVBhcmFtZXRlcnMgPSBtb3JwaGVyLmF0KHBvcyk7XG4gICAgICBjdXJyZW50QW5nbGUgPSBhZmZpbmVQYXJhbWV0ZXJzLnJvdGF0ZTtcbiAgICAgIGN1cnJlbnQgPSBuZXcgTWF0cml4KGFmZmluZVBhcmFtZXRlcnMpO1xuICAgICAgdGhpcy5hZGRUcmFuc2Zvcm0oY3VycmVudCk7XG5cbiAgICAgIGVsZW1lbnQuX2FkZFJ1bm5lcih0aGlzKTtcblxuICAgICAgcmV0dXJuIG1vcnBoZXIuZG9uZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJldGFyZ2V0KG5ld1RyYW5zZm9ybXMpIHtcbiAgICAgIC8vIG9ubHkgZ2V0IGEgbmV3IG9yaWdpbiBpZiBpdCBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IGNhbGxcbiAgICAgIGlmICgobmV3VHJhbnNmb3Jtcy5vcmlnaW4gfHwgJ2NlbnRlcicpLnRvU3RyaW5nKCkgIT09ICh0cmFuc2Zvcm1zLm9yaWdpbiB8fCAnY2VudGVyJykudG9TdHJpbmcoKSkge1xuICAgICAgICBvcmlnaW4gPSBnZXRPcmlnaW4obmV3VHJhbnNmb3JtcywgZWxlbWVudCk7XG4gICAgICB9IC8vIG92ZXJ3cml0ZSB0aGUgb2xkIHRyYW5zZm9ybWF0aW9ucyB3aXRoIHRoZSBuZXcgb25lc1xuXG5cbiAgICAgIHRyYW5zZm9ybXMgPSB7IC4uLm5ld1RyYW5zZm9ybXMsXG4gICAgICAgIG9yaWdpblxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLnF1ZXVlKHNldHVwLCBydW4sIHJldGFyZ2V0LCB0cnVlKTtcbiAgICB0aGlzLl9pc0RlY2xhcmF0aXZlICYmIHRoaXMuX3JlbWVtYmVyTW9ycGhlcigndHJhbnNmb3JtJywgbW9ycGhlcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gQW5pbWF0YWJsZSB4LWF4aXNcbiAgeCh4LCByZWxhdGl2ZSkge1xuICAgIHJldHVybiB0aGlzLl9xdWV1ZU51bWJlcigneCcsIHgpO1xuICB9LFxuXG4gIC8vIEFuaW1hdGFibGUgeS1heGlzXG4gIHkoeSkge1xuICAgIHJldHVybiB0aGlzLl9xdWV1ZU51bWJlcigneScsIHkpO1xuICB9LFxuXG4gIGR4KHggPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1ZXVlTnVtYmVyRGVsdGEoJ3gnLCB4KTtcbiAgfSxcblxuICBkeSh5ID0gMCkge1xuICAgIHJldHVybiB0aGlzLl9xdWV1ZU51bWJlckRlbHRhKCd5JywgeSk7XG4gIH0sXG5cbiAgZG1vdmUoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmR4KHgpLmR5KHkpO1xuICB9LFxuXG4gIF9xdWV1ZU51bWJlckRlbHRhKG1ldGhvZCwgdG8pIHtcbiAgICB0byA9IG5ldyBTVkdOdW1iZXIodG8pOyAvLyBUcnkgdG8gY2hhbmdlIHRoZSB0YXJnZXQgaWYgd2UgaGF2ZSB0aGlzIG1ldGhvZCBhbHJlYWR5IHJlZ2lzdGVyZWRcblxuICAgIGlmICh0aGlzLl90cnlSZXRhcmdldChtZXRob2QsIHRvKSkgcmV0dXJuIHRoaXM7IC8vIE1ha2UgYSBtb3JwaGVyIGFuZCBxdWV1ZSB0aGUgYW5pbWF0aW9uXG5cbiAgICBjb25zdCBtb3JwaGVyID0gbmV3IE1vcnBoYWJsZSh0aGlzLl9zdGVwcGVyKS50byh0byk7XG4gICAgbGV0IGZyb20gPSBudWxsO1xuICAgIHRoaXMucXVldWUoZnVuY3Rpb24gKCkge1xuICAgICAgZnJvbSA9IHRoaXMuZWxlbWVudCgpW21ldGhvZF0oKTtcbiAgICAgIG1vcnBoZXIuZnJvbShmcm9tKTtcbiAgICAgIG1vcnBoZXIudG8oZnJvbSArIHRvKTtcbiAgICB9LCBmdW5jdGlvbiAocG9zKSB7XG4gICAgICB0aGlzLmVsZW1lbnQoKVttZXRob2RdKG1vcnBoZXIuYXQocG9zKSk7XG4gICAgICByZXR1cm4gbW9ycGhlci5kb25lKCk7XG4gICAgfSwgZnVuY3Rpb24gKG5ld1RvKSB7XG4gICAgICBtb3JwaGVyLnRvKGZyb20gKyBuZXcgU1ZHTnVtYmVyKG5ld1RvKSk7XG4gICAgfSk7IC8vIFJlZ2lzdGVyIHRoZSBtb3JwaGVyIHNvIHRoYXQgaWYgaXQgaXMgY2hhbmdlZCBhZ2Fpbiwgd2UgY2FuIHJldGFyZ2V0IGl0XG5cbiAgICB0aGlzLl9yZW1lbWJlck1vcnBoZXIobWV0aG9kLCBtb3JwaGVyKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9xdWV1ZU9iamVjdChtZXRob2QsIHRvKSB7XG4gICAgLy8gVHJ5IHRvIGNoYW5nZSB0aGUgdGFyZ2V0IGlmIHdlIGhhdmUgdGhpcyBtZXRob2QgYWxyZWFkeSByZWdpc3RlcmVkXG4gICAgaWYgKHRoaXMuX3RyeVJldGFyZ2V0KG1ldGhvZCwgdG8pKSByZXR1cm4gdGhpczsgLy8gTWFrZSBhIG1vcnBoZXIgYW5kIHF1ZXVlIHRoZSBhbmltYXRpb25cblxuICAgIGNvbnN0IG1vcnBoZXIgPSBuZXcgTW9ycGhhYmxlKHRoaXMuX3N0ZXBwZXIpLnRvKHRvKTtcbiAgICB0aGlzLnF1ZXVlKGZ1bmN0aW9uICgpIHtcbiAgICAgIG1vcnBoZXIuZnJvbSh0aGlzLmVsZW1lbnQoKVttZXRob2RdKCkpO1xuICAgIH0sIGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgIHRoaXMuZWxlbWVudCgpW21ldGhvZF0obW9ycGhlci5hdChwb3MpKTtcbiAgICAgIHJldHVybiBtb3JwaGVyLmRvbmUoKTtcbiAgICB9KTsgLy8gUmVnaXN0ZXIgdGhlIG1vcnBoZXIgc28gdGhhdCBpZiBpdCBpcyBjaGFuZ2VkIGFnYWluLCB3ZSBjYW4gcmV0YXJnZXQgaXRcblxuICAgIHRoaXMuX3JlbWVtYmVyTW9ycGhlcihtZXRob2QsIG1vcnBoZXIpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX3F1ZXVlTnVtYmVyKG1ldGhvZCwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcXVldWVPYmplY3QobWV0aG9kLCBuZXcgU1ZHTnVtYmVyKHZhbHVlKSk7XG4gIH0sXG5cbiAgLy8gQW5pbWF0YWJsZSBjZW50ZXIgeC1heGlzXG4gIGN4KHgpIHtcbiAgICByZXR1cm4gdGhpcy5fcXVldWVOdW1iZXIoJ2N4JywgeCk7XG4gIH0sXG5cbiAgLy8gQW5pbWF0YWJsZSBjZW50ZXIgeS1heGlzXG4gIGN5KHkpIHtcbiAgICByZXR1cm4gdGhpcy5fcXVldWVOdW1iZXIoJ2N5JywgeSk7XG4gIH0sXG5cbiAgLy8gQWRkIGFuaW1hdGFibGUgbW92ZVxuICBtb3ZlKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy54KHgpLnkoeSk7XG4gIH0sXG5cbiAgLy8gQWRkIGFuaW1hdGFibGUgY2VudGVyXG4gIGNlbnRlcih4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuY3goeCkuY3koeSk7XG4gIH0sXG5cbiAgLy8gQWRkIGFuaW1hdGFibGUgc2l6ZVxuICBzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAvLyBhbmltYXRlIGJib3ggYmFzZWQgc2l6ZSBmb3IgYWxsIG90aGVyIGVsZW1lbnRzXG4gICAgbGV0IGJveDtcblxuICAgIGlmICghd2lkdGggfHwgIWhlaWdodCkge1xuICAgICAgYm94ID0gdGhpcy5fZWxlbWVudC5iYm94KCk7XG4gICAgfVxuXG4gICAgaWYgKCF3aWR0aCkge1xuICAgICAgd2lkdGggPSBib3gud2lkdGggLyBib3guaGVpZ2h0ICogaGVpZ2h0O1xuICAgIH1cblxuICAgIGlmICghaGVpZ2h0KSB7XG4gICAgICBoZWlnaHQgPSBib3guaGVpZ2h0IC8gYm94LndpZHRoICogd2lkdGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMud2lkdGgod2lkdGgpLmhlaWdodChoZWlnaHQpO1xuICB9LFxuXG4gIC8vIEFkZCBhbmltYXRhYmxlIHdpZHRoXG4gIHdpZHRoKHdpZHRoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1ZXVlTnVtYmVyKCd3aWR0aCcsIHdpZHRoKTtcbiAgfSxcblxuICAvLyBBZGQgYW5pbWF0YWJsZSBoZWlnaHRcbiAgaGVpZ2h0KGhlaWdodCkge1xuICAgIHJldHVybiB0aGlzLl9xdWV1ZU51bWJlcignaGVpZ2h0JywgaGVpZ2h0KTtcbiAgfSxcblxuICAvLyBBZGQgYW5pbWF0YWJsZSBwbG90XG4gIHBsb3QoYSwgYiwgYywgZCkge1xuICAgIC8vIExpbmVzIGNhbiBiZSBwbG90dGVkIHdpdGggNCBhcmd1bWVudHNcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgcmV0dXJuIHRoaXMucGxvdChbYSwgYiwgYywgZF0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl90cnlSZXRhcmdldCgncGxvdCcsIGEpKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBtb3JwaGVyID0gbmV3IE1vcnBoYWJsZSh0aGlzLl9zdGVwcGVyKS50eXBlKHRoaXMuX2VsZW1lbnQuTW9ycGhBcnJheSkudG8oYSk7XG4gICAgdGhpcy5xdWV1ZShmdW5jdGlvbiAoKSB7XG4gICAgICBtb3JwaGVyLmZyb20odGhpcy5fZWxlbWVudC5hcnJheSgpKTtcbiAgICB9LCBmdW5jdGlvbiAocG9zKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LnBsb3QobW9ycGhlci5hdChwb3MpKTtcblxuICAgICAgcmV0dXJuIG1vcnBoZXIuZG9uZSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fcmVtZW1iZXJNb3JwaGVyKCdwbG90JywgbW9ycGhlcik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvLyBBZGQgbGVhZGluZyBtZXRob2RcbiAgbGVhZGluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9xdWV1ZU51bWJlcignbGVhZGluZycsIHZhbHVlKTtcbiAgfSxcblxuICAvLyBBZGQgYW5pbWF0YWJsZSB2aWV3Ym94XG4gIHZpZXdib3goeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHJldHVybiB0aGlzLl9xdWV1ZU9iamVjdCgndmlld2JveCcsIG5ldyBCb3goeCwgeSwgd2lkdGgsIGhlaWdodCkpO1xuICB9LFxuXG4gIHVwZGF0ZShvKSB7XG4gICAgaWYgKHR5cGVvZiBvICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKHtcbiAgICAgICAgb2Zmc2V0OiBhcmd1bWVudHNbMF0sXG4gICAgICAgIGNvbG9yOiBhcmd1bWVudHNbMV0sXG4gICAgICAgIG9wYWNpdHk6IGFyZ3VtZW50c1syXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG8ub3BhY2l0eSAhPSBudWxsKSB0aGlzLmF0dHIoJ3N0b3Atb3BhY2l0eScsIG8ub3BhY2l0eSk7XG4gICAgaWYgKG8uY29sb3IgIT0gbnVsbCkgdGhpcy5hdHRyKCdzdG9wLWNvbG9yJywgby5jb2xvcik7XG4gICAgaWYgKG8ub2Zmc2V0ICE9IG51bGwpIHRoaXMuYXR0cignb2Zmc2V0Jywgby5vZmZzZXQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbn0pO1xuZXh0ZW5kKFJ1bm5lciwge1xuICByeCxcbiAgcnksXG4gIGZyb20sXG4gIHRvXG59KTtcbnJlZ2lzdGVyKFJ1bm5lciwgJ1J1bm5lcicpO1xuXG5jbGFzcyBTdmcgZXh0ZW5kcyBDb250YWluZXIge1xuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ3N2ZycsIG5vZGUpLCBhdHRycyk7XG4gICAgdGhpcy5uYW1lc3BhY2UoKTtcbiAgfSAvLyBDcmVhdGVzIGFuZCByZXR1cm5zIGRlZnMgZWxlbWVudFxuXG5cbiAgZGVmcygpIHtcbiAgICBpZiAoIXRoaXMuaXNSb290KCkpIHJldHVybiB0aGlzLnJvb3QoKS5kZWZzKCk7XG4gICAgcmV0dXJuIGFkb3B0KHRoaXMubm9kZS5xdWVyeVNlbGVjdG9yKCdkZWZzJykpIHx8IHRoaXMucHV0KG5ldyBEZWZzKCkpO1xuICB9XG5cbiAgaXNSb290KCkge1xuICAgIHJldHVybiAhdGhpcy5ub2RlLnBhcmVudE5vZGUgfHwgISh0aGlzLm5vZGUucGFyZW50Tm9kZSBpbnN0YW5jZW9mIGdsb2JhbHMud2luZG93LlNWR0VsZW1lbnQpICYmIHRoaXMubm9kZS5wYXJlbnROb2RlLm5vZGVOYW1lICE9PSAnI2RvY3VtZW50LWZyYWdtZW50JztcbiAgfSAvLyBBZGQgbmFtZXNwYWNlc1xuXG5cbiAgbmFtZXNwYWNlKCkge1xuICAgIGlmICghdGhpcy5pc1Jvb3QoKSkgcmV0dXJuIHRoaXMucm9vdCgpLm5hbWVzcGFjZSgpO1xuICAgIHJldHVybiB0aGlzLmF0dHIoe1xuICAgICAgeG1sbnM6IHN2ZyxcbiAgICAgIHZlcnNpb246ICcxLjEnXG4gICAgfSkuYXR0cigneG1sbnM6eGxpbmsnLCB4bGluaywgeG1sbnMpLmF0dHIoJ3htbG5zOnN2Z2pzJywgc3ZnanMsIHhtbG5zKTtcbiAgfVxuXG4gIHJlbW92ZU5hbWVzcGFjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKHtcbiAgICAgIHhtbG5zOiBudWxsLFxuICAgICAgdmVyc2lvbjogbnVsbFxuICAgIH0pLmF0dHIoJ3htbG5zOnhsaW5rJywgbnVsbCwgeG1sbnMpLmF0dHIoJ3htbG5zOnN2Z2pzJywgbnVsbCwgeG1sbnMpO1xuICB9IC8vIENoZWNrIGlmIHRoaXMgaXMgYSByb290IHN2Z1xuICAvLyBJZiBub3QsIGNhbGwgcm9vdCgpIGZyb20gdGhpcyBlbGVtZW50XG5cblxuICByb290KCkge1xuICAgIGlmICh0aGlzLmlzUm9vdCgpKSByZXR1cm4gdGhpcztcbiAgICByZXR1cm4gc3VwZXIucm9vdCgpO1xuICB9XG5cbn1cbnJlZ2lzdGVyTWV0aG9kcyh7XG4gIENvbnRhaW5lcjoge1xuICAgIC8vIENyZWF0ZSBuZXN0ZWQgc3ZnIGRvY3VtZW50XG4gICAgbmVzdGVkOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFN2ZygpKTtcbiAgICB9KVxuICB9XG59KTtcbnJlZ2lzdGVyKFN2ZywgJ1N2ZycsIHRydWUpO1xuXG5jbGFzcyBTeW1ib2wgZXh0ZW5kcyBDb250YWluZXIge1xuICAvLyBJbml0aWFsaXplIG5vZGVcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMgPSBub2RlKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KCdzeW1ib2wnLCBub2RlKSwgYXR0cnMpO1xuICB9XG5cbn1cbnJlZ2lzdGVyTWV0aG9kcyh7XG4gIENvbnRhaW5lcjoge1xuICAgIHN5bWJvbDogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTeW1ib2woKSk7XG4gICAgfSlcbiAgfVxufSk7XG5yZWdpc3RlcihTeW1ib2wsICdTeW1ib2wnKTtcblxuZnVuY3Rpb24gcGxhaW4odGV4dCkge1xuICAvLyBjbGVhciBpZiBidWlsZCBtb2RlIGlzIGRpc2FibGVkXG4gIGlmICh0aGlzLl9idWlsZCA9PT0gZmFsc2UpIHtcbiAgICB0aGlzLmNsZWFyKCk7XG4gIH0gLy8gY3JlYXRlIHRleHQgbm9kZVxuXG5cbiAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKGdsb2JhbHMuZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCkpO1xuICByZXR1cm4gdGhpcztcbn0gLy8gR2V0IGxlbmd0aCBvZiB0ZXh0IGVsZW1lbnRcblxuZnVuY3Rpb24gbGVuZ3RoKCkge1xuICByZXR1cm4gdGhpcy5ub2RlLmdldENvbXB1dGVkVGV4dExlbmd0aCgpO1xufSAvLyBNb3ZlIG92ZXIgeC1heGlzXG4vLyBUZXh0IGlzIG1vdmVkIGJ5IGl0cyBib3VuZGluZyBib3hcbi8vIHRleHQtYW5jaG9yIGRvZXMgTk9UIG1hdHRlclxuXG5mdW5jdGlvbiB4JDEoeCwgYm94ID0gdGhpcy5iYm94KCkpIHtcbiAgaWYgKHggPT0gbnVsbCkge1xuICAgIHJldHVybiBib3gueDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmF0dHIoJ3gnLCB0aGlzLmF0dHIoJ3gnKSArIHggLSBib3gueCk7XG59IC8vIE1vdmUgb3ZlciB5LWF4aXNcblxuZnVuY3Rpb24geSQxKHksIGJveCA9IHRoaXMuYmJveCgpKSB7XG4gIGlmICh5ID09IG51bGwpIHtcbiAgICByZXR1cm4gYm94Lnk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5hdHRyKCd5JywgdGhpcy5hdHRyKCd5JykgKyB5IC0gYm94LnkpO1xufVxuZnVuY3Rpb24gbW92ZSQxKHgsIHksIGJveCA9IHRoaXMuYmJveCgpKSB7XG4gIHJldHVybiB0aGlzLngoeCwgYm94KS55KHksIGJveCk7XG59IC8vIE1vdmUgY2VudGVyIG92ZXIgeC1heGlzXG5cbmZ1bmN0aW9uIGN4KHgsIGJveCA9IHRoaXMuYmJveCgpKSB7XG4gIGlmICh4ID09IG51bGwpIHtcbiAgICByZXR1cm4gYm94LmN4O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXR0cigneCcsIHRoaXMuYXR0cigneCcpICsgeCAtIGJveC5jeCk7XG59IC8vIE1vdmUgY2VudGVyIG92ZXIgeS1heGlzXG5cbmZ1bmN0aW9uIGN5KHksIGJveCA9IHRoaXMuYmJveCgpKSB7XG4gIGlmICh5ID09IG51bGwpIHtcbiAgICByZXR1cm4gYm94LmN5O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXR0cigneScsIHRoaXMuYXR0cigneScpICsgeSAtIGJveC5jeSk7XG59XG5mdW5jdGlvbiBjZW50ZXIoeCwgeSwgYm94ID0gdGhpcy5iYm94KCkpIHtcbiAgcmV0dXJuIHRoaXMuY3goeCwgYm94KS5jeSh5LCBib3gpO1xufVxuZnVuY3Rpb24gYXgoeCkge1xuICByZXR1cm4gdGhpcy5hdHRyKCd4JywgeCk7XG59XG5mdW5jdGlvbiBheSh5KSB7XG4gIHJldHVybiB0aGlzLmF0dHIoJ3knLCB5KTtcbn1cbmZ1bmN0aW9uIGFtb3ZlKHgsIHkpIHtcbiAgcmV0dXJuIHRoaXMuYXgoeCkuYXkoeSk7XG59IC8vIEVuYWJsZSAvIGRpc2FibGUgYnVpbGQgbW9kZVxuXG5mdW5jdGlvbiBidWlsZChidWlsZCkge1xuICB0aGlzLl9idWlsZCA9ICEhYnVpbGQ7XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgdGV4dGFibGUgPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgcGxhaW46IHBsYWluLFxuICBsZW5ndGg6IGxlbmd0aCxcbiAgeDogeCQxLFxuICB5OiB5JDEsXG4gIG1vdmU6IG1vdmUkMSxcbiAgY3g6IGN4LFxuICBjeTogY3ksXG4gIGNlbnRlcjogY2VudGVyLFxuICBheDogYXgsXG4gIGF5OiBheSxcbiAgYW1vdmU6IGFtb3ZlLFxuICBidWlsZDogYnVpbGRcbn07XG5cbmNsYXNzIFRleHQgZXh0ZW5kcyBTaGFwZSB7XG4gIC8vIEluaXRpYWxpemUgbm9kZVxuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ3RleHQnLCBub2RlKSwgYXR0cnMpO1xuICAgIHRoaXMuZG9tLmxlYWRpbmcgPSBuZXcgU1ZHTnVtYmVyKDEuMyk7IC8vIHN0b3JlIGxlYWRpbmcgdmFsdWUgZm9yIHJlYnVpbGRpbmdcblxuICAgIHRoaXMuX3JlYnVpbGQgPSB0cnVlOyAvLyBlbmFibGUgYXV0b21hdGljIHVwZGF0aW5nIG9mIGR5IHZhbHVlc1xuXG4gICAgdGhpcy5fYnVpbGQgPSBmYWxzZTsgLy8gZGlzYWJsZSBidWlsZCBtb2RlIGZvciBhZGRpbmcgbXVsdGlwbGUgbGluZXNcbiAgfSAvLyBTZXQgLyBnZXQgbGVhZGluZ1xuXG5cbiAgbGVhZGluZyh2YWx1ZSkge1xuICAgIC8vIGFjdCBhcyBnZXR0ZXJcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuZG9tLmxlYWRpbmc7XG4gICAgfSAvLyBhY3QgYXMgc2V0dGVyXG5cblxuICAgIHRoaXMuZG9tLmxlYWRpbmcgPSBuZXcgU1ZHTnVtYmVyKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5yZWJ1aWxkKCk7XG4gIH0gLy8gUmVidWlsZCBhcHBlYXJhbmNlIHR5cGVcblxuXG4gIHJlYnVpbGQocmVidWlsZCkge1xuICAgIC8vIHN0b3JlIG5ldyByZWJ1aWxkIGZsYWcgaWYgZ2l2ZW5cbiAgICBpZiAodHlwZW9mIHJlYnVpbGQgPT09ICdib29sZWFuJykge1xuICAgICAgdGhpcy5fcmVidWlsZCA9IHJlYnVpbGQ7XG4gICAgfSAvLyBkZWZpbmUgcG9zaXRpb24gb2YgYWxsIGxpbmVzXG5cblxuICAgIGlmICh0aGlzLl9yZWJ1aWxkKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIGxldCBibGFua0xpbmVPZmZzZXQgPSAwO1xuICAgICAgY29uc3QgbGVhZGluZyA9IHRoaXMuZG9tLmxlYWRpbmc7XG4gICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgY29uc3QgZm9udFNpemUgPSBnbG9iYWxzLndpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMubm9kZSkuZ2V0UHJvcGVydHlWYWx1ZSgnZm9udC1zaXplJyk7XG4gICAgICAgIGNvbnN0IGR5ID0gbGVhZGluZyAqIG5ldyBTVkdOdW1iZXIoZm9udFNpemUpO1xuXG4gICAgICAgIGlmICh0aGlzLmRvbS5uZXdMaW5lZCkge1xuICAgICAgICAgIHRoaXMuYXR0cigneCcsIHNlbGYuYXR0cigneCcpKTtcblxuICAgICAgICAgIGlmICh0aGlzLnRleHQoKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIGJsYW5rTGluZU9mZnNldCArPSBkeTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hdHRyKCdkeScsIGkgPyBkeSArIGJsYW5rTGluZU9mZnNldCA6IDApO1xuICAgICAgICAgICAgYmxhbmtMaW5lT2Zmc2V0ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5maXJlKCdyZWJ1aWxkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gb3ZlcndyaXRlIG1ldGhvZCBmcm9tIHBhcmVudCB0byBzZXQgZGF0YSBwcm9wZXJseVxuXG5cbiAgc2V0RGF0YShvKSB7XG4gICAgdGhpcy5kb20gPSBvO1xuICAgIHRoaXMuZG9tLmxlYWRpbmcgPSBuZXcgU1ZHTnVtYmVyKG8ubGVhZGluZyB8fCAxLjMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIFNldCB0aGUgdGV4dCBjb250ZW50XG5cblxuICB0ZXh0KHRleHQpIHtcbiAgICAvLyBhY3QgYXMgZ2V0dGVyXG4gICAgaWYgKHRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLm5vZGUuY2hpbGROb2RlcztcbiAgICAgIGxldCBmaXJzdExpbmUgPSAwO1xuICAgICAgdGV4dCA9ICcnO1xuXG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgLy8gc2tpcCB0ZXh0UGF0aHMgLSB0aGV5IGFyZSBubyBsaW5lc1xuICAgICAgICBpZiAoY2hpbGRyZW5baV0ubm9kZU5hbWUgPT09ICd0ZXh0UGF0aCcpIHtcbiAgICAgICAgICBpZiAoaSA9PT0gMCkgZmlyc3RMaW5lID0gMTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBhZGQgbmV3bGluZSBpZiBpdHMgbm90IHRoZSBmaXJzdCBjaGlsZCBhbmQgbmV3TGluZWQgaXMgc2V0IHRvIHRydWVcblxuXG4gICAgICAgIGlmIChpICE9PSBmaXJzdExpbmUgJiYgY2hpbGRyZW5baV0ubm9kZVR5cGUgIT09IDMgJiYgYWRvcHQoY2hpbGRyZW5baV0pLmRvbS5uZXdMaW5lZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRleHQgKz0gJ1xcbic7XG4gICAgICAgIH0gLy8gYWRkIGNvbnRlbnQgb2YgdGhpcyBub2RlXG5cblxuICAgICAgICB0ZXh0ICs9IGNoaWxkcmVuW2ldLnRleHRDb250ZW50O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9IC8vIHJlbW92ZSBleGlzdGluZyBjb250ZW50XG5cblxuICAgIHRoaXMuY2xlYXIoKS5idWlsZCh0cnVlKTtcblxuICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gY2FsbCBibG9ja1xuICAgICAgdGV4dC5jYWxsKHRoaXMsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzdG9yZSB0ZXh0IGFuZCBtYWtlIHN1cmUgdGV4dCBpcyBub3QgYmxhbmtcbiAgICAgIHRleHQgPSAodGV4dCArICcnKS5zcGxpdCgnXFxuJyk7IC8vIGJ1aWxkIG5ldyBsaW5lc1xuXG4gICAgICBmb3IgKGxldCBqID0gMCwgamwgPSB0ZXh0Lmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcbiAgICAgICAgdGhpcy5uZXdMaW5lKHRleHRbal0pO1xuICAgICAgfVxuICAgIH0gLy8gZGlzYWJsZSBidWlsZCBtb2RlIGFuZCByZWJ1aWxkIGxpbmVzXG5cblxuICAgIHJldHVybiB0aGlzLmJ1aWxkKGZhbHNlKS5yZWJ1aWxkKCk7XG4gIH1cblxufVxuZXh0ZW5kKFRleHQsIHRleHRhYmxlKTtcbnJlZ2lzdGVyTWV0aG9kcyh7XG4gIENvbnRhaW5lcjoge1xuICAgIC8vIENyZWF0ZSB0ZXh0IGVsZW1lbnRcbiAgICB0ZXh0OiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAodGV4dCA9ICcnKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFRleHQoKSkudGV4dCh0ZXh0KTtcbiAgICB9KSxcbiAgICAvLyBDcmVhdGUgcGxhaW4gdGV4dCBlbGVtZW50XG4gICAgcGxhaW46IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICh0ZXh0ID0gJycpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgVGV4dCgpKS5wbGFpbih0ZXh0KTtcbiAgICB9KVxuICB9XG59KTtcbnJlZ2lzdGVyKFRleHQsICdUZXh0Jyk7XG5cbmNsYXNzIFRzcGFuIGV4dGVuZHMgU2hhcGUge1xuICAvLyBJbml0aWFsaXplIG5vZGVcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMgPSBub2RlKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KCd0c3BhbicsIG5vZGUpLCBhdHRycyk7XG4gICAgdGhpcy5fYnVpbGQgPSBmYWxzZTsgLy8gZGlzYWJsZSBidWlsZCBtb2RlIGZvciBhZGRpbmcgbXVsdGlwbGUgbGluZXNcbiAgfSAvLyBTaG9ydGN1dCBkeFxuXG5cbiAgZHgoZHgpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdkeCcsIGR4KTtcbiAgfSAvLyBTaG9ydGN1dCBkeVxuXG5cbiAgZHkoZHkpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdkeScsIGR5KTtcbiAgfSAvLyBDcmVhdGUgbmV3IGxpbmVcblxuXG4gIG5ld0xpbmUoKSB7XG4gICAgLy8gbWFyayBuZXcgbGluZVxuICAgIHRoaXMuZG9tLm5ld0xpbmVkID0gdHJ1ZTsgLy8gZmV0Y2ggcGFyZW50XG5cbiAgICBjb25zdCB0ZXh0ID0gdGhpcy5wYXJlbnQoKTsgLy8gZWFybHkgcmV0dXJuIGluIGNhc2Ugd2UgYXJlIG5vdCBpbiBhIHRleHQgZWxlbWVudFxuXG4gICAgaWYgKCEodGV4dCBpbnN0YW5jZW9mIFRleHQpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb25zdCBpID0gdGV4dC5pbmRleCh0aGlzKTtcbiAgICBjb25zdCBmb250U2l6ZSA9IGdsb2JhbHMud2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5ub2RlKS5nZXRQcm9wZXJ0eVZhbHVlKCdmb250LXNpemUnKTtcbiAgICBjb25zdCBkeSA9IHRleHQuZG9tLmxlYWRpbmcgKiBuZXcgU1ZHTnVtYmVyKGZvbnRTaXplKTsgLy8gYXBwbHkgbmV3IHBvc2l0aW9uXG5cbiAgICByZXR1cm4gdGhpcy5keShpID8gZHkgOiAwKS5hdHRyKCd4JywgdGV4dC54KCkpO1xuICB9IC8vIFNldCB0ZXh0IGNvbnRlbnRcblxuXG4gIHRleHQodGV4dCkge1xuICAgIGlmICh0ZXh0ID09IG51bGwpIHJldHVybiB0aGlzLm5vZGUudGV4dENvbnRlbnQgKyAodGhpcy5kb20ubmV3TGluZWQgPyAnXFxuJyA6ICcnKTtcblxuICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5jbGVhcigpLmJ1aWxkKHRydWUpO1xuICAgICAgdGV4dC5jYWxsKHRoaXMsIHRoaXMpO1xuICAgICAgdGhpcy5idWlsZChmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGxhaW4odGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxufVxuZXh0ZW5kKFRzcGFuLCB0ZXh0YWJsZSk7XG5yZWdpc3Rlck1ldGhvZHMoe1xuICBUc3Bhbjoge1xuICAgIHRzcGFuOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAodGV4dCA9ICcnKSB7XG4gICAgICBjb25zdCB0c3BhbiA9IG5ldyBUc3BhbigpOyAvLyBjbGVhciBpZiBidWlsZCBtb2RlIGlzIGRpc2FibGVkXG5cbiAgICAgIGlmICghdGhpcy5fYnVpbGQpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgfSAvLyBhZGQgbmV3IHRzcGFuXG5cblxuICAgICAgcmV0dXJuIHRoaXMucHV0KHRzcGFuKS50ZXh0KHRleHQpO1xuICAgIH0pXG4gIH0sXG4gIFRleHQ6IHtcbiAgICBuZXdMaW5lOiBmdW5jdGlvbiAodGV4dCA9ICcnKSB7XG4gICAgICByZXR1cm4gdGhpcy50c3Bhbih0ZXh0KS5uZXdMaW5lKCk7XG4gICAgfVxuICB9XG59KTtcbnJlZ2lzdGVyKFRzcGFuLCAnVHNwYW4nKTtcblxuY2xhc3MgQ2lyY2xlIGV4dGVuZHMgU2hhcGUge1xuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ2NpcmNsZScsIG5vZGUpLCBhdHRycyk7XG4gIH1cblxuICByYWRpdXMocikge1xuICAgIHJldHVybiB0aGlzLmF0dHIoJ3InLCByKTtcbiAgfSAvLyBSYWRpdXMgeCB2YWx1ZVxuXG5cbiAgcngocngpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdyJywgcngpO1xuICB9IC8vIEFsaWFzIHJhZGl1cyB4IHZhbHVlXG5cblxuICByeShyeSkge1xuICAgIHJldHVybiB0aGlzLnJ4KHJ5KTtcbiAgfVxuXG4gIHNpemUoc2l6ZSkge1xuICAgIHJldHVybiB0aGlzLnJhZGl1cyhuZXcgU1ZHTnVtYmVyKHNpemUpLmRpdmlkZSgyKSk7XG4gIH1cblxufVxuZXh0ZW5kKENpcmNsZSwge1xuICB4OiB4JDMsXG4gIHk6IHkkMyxcbiAgY3g6IGN4JDEsXG4gIGN5OiBjeSQxLFxuICB3aWR0aDogd2lkdGgkMixcbiAgaGVpZ2h0OiBoZWlnaHQkMlxufSk7XG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICAvLyBDcmVhdGUgY2lyY2xlIGVsZW1lbnRcbiAgICBjaXJjbGU6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uIChzaXplID0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBDaXJjbGUoKSkuc2l6ZShzaXplKS5tb3ZlKDAsIDApO1xuICAgIH0pXG4gIH1cbn0pO1xucmVnaXN0ZXIoQ2lyY2xlLCAnQ2lyY2xlJyk7XG5cbmNsYXNzIENsaXBQYXRoIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMgPSBub2RlKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KCdjbGlwUGF0aCcsIG5vZGUpLCBhdHRycyk7XG4gIH0gLy8gVW5jbGlwIGFsbCBjbGlwcGVkIGVsZW1lbnRzIGFuZCByZW1vdmUgaXRzZWxmXG5cblxuICByZW1vdmUoKSB7XG4gICAgLy8gdW5jbGlwIGFsbCB0YXJnZXRzXG4gICAgdGhpcy50YXJnZXRzKCkuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIGVsLnVuY2xpcCgpO1xuICAgIH0pOyAvLyByZW1vdmUgY2xpcFBhdGggZnJvbSBwYXJlbnRcblxuICAgIHJldHVybiBzdXBlci5yZW1vdmUoKTtcbiAgfVxuXG4gIHRhcmdldHMoKSB7XG4gICAgcmV0dXJuIGJhc2VGaW5kKCdzdmcgW2NsaXAtcGF0aCo9JyArIHRoaXMuaWQoKSArICddJyk7XG4gIH1cblxufVxucmVnaXN0ZXJNZXRob2RzKHtcbiAgQ29udGFpbmVyOiB7XG4gICAgLy8gQ3JlYXRlIGNsaXBwaW5nIGVsZW1lbnRcbiAgICBjbGlwOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWZzKCkucHV0KG5ldyBDbGlwUGF0aCgpKTtcbiAgICB9KVxuICB9LFxuICBFbGVtZW50OiB7XG4gICAgLy8gRGlzdHJpYnV0ZSBjbGlwUGF0aCB0byBzdmcgZWxlbWVudFxuICAgIGNsaXBwZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2UoJ2NsaXAtcGF0aCcpO1xuICAgIH0sXG5cbiAgICBjbGlwV2l0aChlbGVtZW50KSB7XG4gICAgICAvLyB1c2UgZ2l2ZW4gY2xpcCBvciBjcmVhdGUgYSBuZXcgb25lXG4gICAgICBjb25zdCBjbGlwcGVyID0gZWxlbWVudCBpbnN0YW5jZW9mIENsaXBQYXRoID8gZWxlbWVudCA6IHRoaXMucGFyZW50KCkuY2xpcCgpLmFkZChlbGVtZW50KTsgLy8gYXBwbHkgbWFza1xuXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdjbGlwLXBhdGgnLCAndXJsKCMnICsgY2xpcHBlci5pZCgpICsgJyknKTtcbiAgICB9LFxuXG4gICAgLy8gVW5jbGlwIGVsZW1lbnRcbiAgICB1bmNsaXAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdjbGlwLXBhdGgnLCBudWxsKTtcbiAgICB9XG5cbiAgfVxufSk7XG5yZWdpc3RlcihDbGlwUGF0aCwgJ0NsaXBQYXRoJyk7XG5cbmNsYXNzIEZvcmVpZ25PYmplY3QgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMgPSBub2RlKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KCdmb3JlaWduT2JqZWN0Jywgbm9kZSksIGF0dHJzKTtcbiAgfVxuXG59XG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICBmb3JlaWduT2JqZWN0OiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBGb3JlaWduT2JqZWN0KCkpLnNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfSlcbiAgfVxufSk7XG5yZWdpc3RlcihGb3JlaWduT2JqZWN0LCAnRm9yZWlnbk9iamVjdCcpO1xuXG5mdW5jdGlvbiBkbW92ZShkeCwgZHkpIHtcbiAgdGhpcy5jaGlsZHJlbigpLmZvckVhY2goKGNoaWxkLCBpKSA9PiB7XG4gICAgbGV0IGJib3g7IC8vIFdlIGhhdmUgdG8gd3JhcCB0aGlzIGZvciBlbGVtZW50cyB0aGF0IGRvbnQgaGF2ZSBhIGJib3hcbiAgICAvLyBlLmcuIHRpdGxlIGFuZCBvdGhlciBkZXNjcmlwdGl2ZSBlbGVtZW50c1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCB0aGUgY2hpbGRzIGJib3hcbiAgICAgIGJib3ggPSBjaGlsZC5iYm94KCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gR2V0IGNoaWxkcyBtYXRyaXhcblxuXG4gICAgY29uc3QgbSA9IG5ldyBNYXRyaXgoY2hpbGQpOyAvLyBUcmFuc2xhdGUgY2hpbGRzIG1hdHJpeCBieSBhbW91bnQgYW5kXG4gICAgLy8gdHJhbnNmb3JtIGl0IGJhY2sgaW50byBwYXJlbnRzIHNwYWNlXG5cbiAgICBjb25zdCBtYXRyaXggPSBtLnRyYW5zbGF0ZShkeCwgZHkpLnRyYW5zZm9ybShtLmludmVyc2UoKSk7IC8vIENhbGN1bGF0ZSBuZXcgeCBhbmQgeSBmcm9tIG9sZCBib3hcblxuICAgIGNvbnN0IHAgPSBuZXcgUG9pbnQoYmJveC54LCBiYm94LnkpLnRyYW5zZm9ybShtYXRyaXgpOyAvLyBNb3ZlIGVsZW1lbnRcblxuICAgIGNoaWxkLm1vdmUocC54LCBwLnkpO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBkeChkeCkge1xuICByZXR1cm4gdGhpcy5kbW92ZShkeCwgMCk7XG59XG5mdW5jdGlvbiBkeShkeSkge1xuICByZXR1cm4gdGhpcy5kbW92ZSgwLCBkeSk7XG59XG5mdW5jdGlvbiBoZWlnaHQoaGVpZ2h0LCBib3ggPSB0aGlzLmJib3goKSkge1xuICBpZiAoaGVpZ2h0ID09IG51bGwpIHJldHVybiBib3guaGVpZ2h0O1xuICByZXR1cm4gdGhpcy5zaXplKGJveC53aWR0aCwgaGVpZ2h0LCBib3gpO1xufVxuZnVuY3Rpb24gbW92ZSh4ID0gMCwgeSA9IDAsIGJveCA9IHRoaXMuYmJveCgpKSB7XG4gIGNvbnN0IGR4ID0geCAtIGJveC54O1xuICBjb25zdCBkeSA9IHkgLSBib3gueTtcbiAgcmV0dXJuIHRoaXMuZG1vdmUoZHgsIGR5KTtcbn1cbmZ1bmN0aW9uIHNpemUod2lkdGgsIGhlaWdodCwgYm94ID0gdGhpcy5iYm94KCkpIHtcbiAgY29uc3QgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodCwgYm94KTtcbiAgY29uc3Qgc2NhbGVYID0gcC53aWR0aCAvIGJveC53aWR0aDtcbiAgY29uc3Qgc2NhbGVZID0gcC5oZWlnaHQgLyBib3guaGVpZ2h0O1xuICB0aGlzLmNoaWxkcmVuKCkuZm9yRWFjaCgoY2hpbGQsIGkpID0+IHtcbiAgICBjb25zdCBvID0gbmV3IFBvaW50KGJveCkudHJhbnNmb3JtKG5ldyBNYXRyaXgoY2hpbGQpLmludmVyc2UoKSk7XG4gICAgY2hpbGQuc2NhbGUoc2NhbGVYLCBzY2FsZVksIG8ueCwgby55KTtcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gd2lkdGgod2lkdGgsIGJveCA9IHRoaXMuYmJveCgpKSB7XG4gIGlmICh3aWR0aCA9PSBudWxsKSByZXR1cm4gYm94LndpZHRoO1xuICByZXR1cm4gdGhpcy5zaXplKHdpZHRoLCBib3guaGVpZ2h0LCBib3gpO1xufVxuZnVuY3Rpb24geCh4LCBib3ggPSB0aGlzLmJib3goKSkge1xuICBpZiAoeCA9PSBudWxsKSByZXR1cm4gYm94Lng7XG4gIHJldHVybiB0aGlzLm1vdmUoeCwgYm94LnksIGJveCk7XG59XG5mdW5jdGlvbiB5KHksIGJveCA9IHRoaXMuYmJveCgpKSB7XG4gIGlmICh5ID09IG51bGwpIHJldHVybiBib3gueTtcbiAgcmV0dXJuIHRoaXMubW92ZShib3gueCwgeSwgYm94KTtcbn1cblxudmFyIGNvbnRhaW5lckdlb21ldHJ5ID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIGRtb3ZlOiBkbW92ZSxcbiAgZHg6IGR4LFxuICBkeTogZHksXG4gIGhlaWdodDogaGVpZ2h0LFxuICBtb3ZlOiBtb3ZlLFxuICBzaXplOiBzaXplLFxuICB3aWR0aDogd2lkdGgsXG4gIHg6IHgsXG4gIHk6IHlcbn07XG5cbmNsYXNzIEcgZXh0ZW5kcyBDb250YWluZXIge1xuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ2cnLCBub2RlKSwgYXR0cnMpO1xuICB9XG5cbn1cbmV4dGVuZChHLCBjb250YWluZXJHZW9tZXRyeSk7XG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICAvLyBDcmVhdGUgYSBncm91cCBlbGVtZW50XG4gICAgZ3JvdXA6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgRygpKTtcbiAgICB9KVxuICB9XG59KTtcbnJlZ2lzdGVyKEcsICdHJyk7XG5cbmNsYXNzIEEgZXh0ZW5kcyBDb250YWluZXIge1xuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ2EnLCBub2RlKSwgYXR0cnMpO1xuICB9IC8vIExpbmsgdGFyZ2V0IGF0dHJpYnV0ZVxuXG5cbiAgdGFyZ2V0KHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLmF0dHIoJ3RhcmdldCcsIHRhcmdldCk7XG4gIH0gLy8gTGluayB1cmxcblxuXG4gIHRvKHVybCkge1xuICAgIHJldHVybiB0aGlzLmF0dHIoJ2hyZWYnLCB1cmwsIHhsaW5rKTtcbiAgfVxuXG59XG5leHRlbmQoQSwgY29udGFpbmVyR2VvbWV0cnkpO1xucmVnaXN0ZXJNZXRob2RzKHtcbiAgQ29udGFpbmVyOiB7XG4gICAgLy8gQ3JlYXRlIGEgaHlwZXJsaW5rIGVsZW1lbnRcbiAgICBsaW5rOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAodXJsKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IEEoKSkudG8odXJsKTtcbiAgICB9KVxuICB9LFxuICBFbGVtZW50OiB7XG4gICAgdW5saW5rKCkge1xuICAgICAgY29uc3QgbGluayA9IHRoaXMubGlua2VyKCk7XG4gICAgICBpZiAoIWxpbmspIHJldHVybiB0aGlzO1xuICAgICAgY29uc3QgcGFyZW50ID0gbGluay5wYXJlbnQoKTtcblxuICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGluZGV4ID0gcGFyZW50LmluZGV4KGxpbmspO1xuICAgICAgcGFyZW50LmFkZCh0aGlzLCBpbmRleCk7XG4gICAgICBsaW5rLnJlbW92ZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGxpbmtUbyh1cmwpIHtcbiAgICAgIC8vIHJldXNlIG9sZCBsaW5rIGlmIHBvc3NpYmxlXG4gICAgICBsZXQgbGluayA9IHRoaXMubGlua2VyKCk7XG5cbiAgICAgIGlmICghbGluaykge1xuICAgICAgICBsaW5rID0gbmV3IEEoKTtcbiAgICAgICAgdGhpcy53cmFwKGxpbmspO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHVybCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB1cmwuY2FsbChsaW5rLCBsaW5rKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmsudG8odXJsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGxpbmtlcigpIHtcbiAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLnBhcmVudCgpO1xuXG4gICAgICBpZiAobGluayAmJiBsaW5rLm5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG4gICAgICAgIHJldHVybiBsaW5rO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgfVxufSk7XG5yZWdpc3RlcihBLCAnQScpO1xuXG5jbGFzcyBNYXNrIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygnbWFzaycsIG5vZGUpLCBhdHRycyk7XG4gIH0gLy8gVW5tYXNrIGFsbCBtYXNrZWQgZWxlbWVudHMgYW5kIHJlbW92ZSBpdHNlbGZcblxuXG4gIHJlbW92ZSgpIHtcbiAgICAvLyB1bm1hc2sgYWxsIHRhcmdldHNcbiAgICB0aGlzLnRhcmdldHMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgZWwudW5tYXNrKCk7XG4gICAgfSk7IC8vIHJlbW92ZSBtYXNrIGZyb20gcGFyZW50XG5cbiAgICByZXR1cm4gc3VwZXIucmVtb3ZlKCk7XG4gIH1cblxuICB0YXJnZXRzKCkge1xuICAgIHJldHVybiBiYXNlRmluZCgnc3ZnIFttYXNrKj0nICsgdGhpcy5pZCgpICsgJ10nKTtcbiAgfVxuXG59XG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICBtYXNrOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWZzKCkucHV0KG5ldyBNYXNrKCkpO1xuICAgIH0pXG4gIH0sXG4gIEVsZW1lbnQ6IHtcbiAgICAvLyBEaXN0cmlidXRlIG1hc2sgdG8gc3ZnIGVsZW1lbnRcbiAgICBtYXNrZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2UoJ21hc2snKTtcbiAgICB9LFxuXG4gICAgbWFza1dpdGgoZWxlbWVudCkge1xuICAgICAgLy8gdXNlIGdpdmVuIG1hc2sgb3IgY3JlYXRlIGEgbmV3IG9uZVxuICAgICAgY29uc3QgbWFza2VyID0gZWxlbWVudCBpbnN0YW5jZW9mIE1hc2sgPyBlbGVtZW50IDogdGhpcy5wYXJlbnQoKS5tYXNrKCkuYWRkKGVsZW1lbnQpOyAvLyBhcHBseSBtYXNrXG5cbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ21hc2snLCAndXJsKCMnICsgbWFza2VyLmlkKCkgKyAnKScpO1xuICAgIH0sXG5cbiAgICAvLyBVbm1hc2sgZWxlbWVudFxuICAgIHVubWFzaygpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ21hc2snLCBudWxsKTtcbiAgICB9XG5cbiAgfVxufSk7XG5yZWdpc3RlcihNYXNrLCAnTWFzaycpO1xuXG5jbGFzcyBTdG9wIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygnc3RvcCcsIG5vZGUpLCBhdHRycyk7XG4gIH0gLy8gYWRkIGNvbG9yIHN0b3BzXG5cblxuICB1cGRhdGUobykge1xuICAgIGlmICh0eXBlb2YgbyA9PT0gJ251bWJlcicgfHwgbyBpbnN0YW5jZW9mIFNWR051bWJlcikge1xuICAgICAgbyA9IHtcbiAgICAgICAgb2Zmc2V0OiBhcmd1bWVudHNbMF0sXG4gICAgICAgIGNvbG9yOiBhcmd1bWVudHNbMV0sXG4gICAgICAgIG9wYWNpdHk6IGFyZ3VtZW50c1syXVxuICAgICAgfTtcbiAgICB9IC8vIHNldCBhdHRyaWJ1dGVzXG5cblxuICAgIGlmIChvLm9wYWNpdHkgIT0gbnVsbCkgdGhpcy5hdHRyKCdzdG9wLW9wYWNpdHknLCBvLm9wYWNpdHkpO1xuICAgIGlmIChvLmNvbG9yICE9IG51bGwpIHRoaXMuYXR0cignc3RvcC1jb2xvcicsIG8uY29sb3IpO1xuICAgIGlmIChvLm9mZnNldCAhPSBudWxsKSB0aGlzLmF0dHIoJ29mZnNldCcsIG5ldyBTVkdOdW1iZXIoby5vZmZzZXQpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59XG5yZWdpc3Rlck1ldGhvZHMoe1xuICBHcmFkaWVudDoge1xuICAgIC8vIEFkZCBhIGNvbG9yIHN0b3BcbiAgICBzdG9wOiBmdW5jdGlvbiAob2Zmc2V0LCBjb2xvciwgb3BhY2l0eSkge1xuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTdG9wKCkpLnVwZGF0ZShvZmZzZXQsIGNvbG9yLCBvcGFjaXR5KTtcbiAgICB9XG4gIH1cbn0pO1xucmVnaXN0ZXIoU3RvcCwgJ1N0b3AnKTtcblxuZnVuY3Rpb24gY3NzUnVsZShzZWxlY3RvciwgcnVsZSkge1xuICBpZiAoIXNlbGVjdG9yKSByZXR1cm4gJyc7XG4gIGlmICghcnVsZSkgcmV0dXJuIHNlbGVjdG9yO1xuICBsZXQgcmV0ID0gc2VsZWN0b3IgKyAneyc7XG5cbiAgZm9yIChjb25zdCBpIGluIHJ1bGUpIHtcbiAgICByZXQgKz0gdW5DYW1lbENhc2UoaSkgKyAnOicgKyBydWxlW2ldICsgJzsnO1xuICB9XG5cbiAgcmV0ICs9ICd9JztcbiAgcmV0dXJuIHJldDtcbn1cblxuY2xhc3MgU3R5bGUgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMgPSBub2RlKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KCdzdHlsZScsIG5vZGUpLCBhdHRycyk7XG4gIH1cblxuICBhZGRUZXh0KHcgPSAnJykge1xuICAgIHRoaXMubm9kZS50ZXh0Q29udGVudCArPSB3O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZm9udChuYW1lLCBzcmMsIHBhcmFtcyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZSgnQGZvbnQtZmFjZScsIHtcbiAgICAgIGZvbnRGYW1pbHk6IG5hbWUsXG4gICAgICBzcmM6IHNyYyxcbiAgICAgIC4uLnBhcmFtc1xuICAgIH0pO1xuICB9XG5cbiAgcnVsZShzZWxlY3Rvciwgb2JqKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkVGV4dChjc3NSdWxlKHNlbGVjdG9yLCBvYmopKTtcbiAgfVxuXG59XG5yZWdpc3Rlck1ldGhvZHMoJ0RvbScsIHtcbiAgc3R5bGUoc2VsZWN0b3IsIG9iaikge1xuICAgIHJldHVybiB0aGlzLnB1dChuZXcgU3R5bGUoKSkucnVsZShzZWxlY3Rvciwgb2JqKTtcbiAgfSxcblxuICBmb250ZmFjZShuYW1lLCBzcmMsIHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLnB1dChuZXcgU3R5bGUoKSkuZm9udChuYW1lLCBzcmMsIHBhcmFtcyk7XG4gIH1cblxufSk7XG5yZWdpc3RlcihTdHlsZSwgJ1N0eWxlJyk7XG5cbmNsYXNzIFRleHRQYXRoIGV4dGVuZHMgVGV4dCB7XG4gIC8vIEluaXRpYWxpemUgbm9kZVxuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ3RleHRQYXRoJywgbm9kZSksIGF0dHJzKTtcbiAgfSAvLyByZXR1cm4gdGhlIGFycmF5IG9mIHRoZSBwYXRoIHRyYWNrIGVsZW1lbnRcblxuXG4gIGFycmF5KCkge1xuICAgIGNvbnN0IHRyYWNrID0gdGhpcy50cmFjaygpO1xuICAgIHJldHVybiB0cmFjayA/IHRyYWNrLmFycmF5KCkgOiBudWxsO1xuICB9IC8vIFBsb3QgcGF0aCBpZiBhbnlcblxuXG4gIHBsb3QoZCkge1xuICAgIGNvbnN0IHRyYWNrID0gdGhpcy50cmFjaygpO1xuICAgIGxldCBwYXRoQXJyYXkgPSBudWxsO1xuXG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICBwYXRoQXJyYXkgPSB0cmFjay5wbG90KGQpO1xuICAgIH1cblxuICAgIHJldHVybiBkID09IG51bGwgPyBwYXRoQXJyYXkgOiB0aGlzO1xuICB9IC8vIEdldCB0aGUgcGF0aCBlbGVtZW50XG5cblxuICB0cmFjaygpIHtcbiAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2UoJ2hyZWYnKTtcbiAgfVxuXG59XG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICB0ZXh0UGF0aDogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHRleHQsIHBhdGgpIHtcbiAgICAgIC8vIENvbnZlcnQgdGV4dCB0byBpbnN0YW5jZSBpZiBuZWVkZWRcbiAgICAgIGlmICghKHRleHQgaW5zdGFuY2VvZiBUZXh0KSkge1xuICAgICAgICB0ZXh0ID0gdGhpcy50ZXh0KHRleHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGV4dC5wYXRoKHBhdGgpO1xuICAgIH0pXG4gIH0sXG4gIFRleHQ6IHtcbiAgICAvLyBDcmVhdGUgcGF0aCBmb3IgdGV4dCB0byBydW4gb25cbiAgICBwYXRoOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAodHJhY2ssIGltcG9ydE5vZGVzID0gdHJ1ZSkge1xuICAgICAgY29uc3QgdGV4dFBhdGggPSBuZXcgVGV4dFBhdGgoKTsgLy8gaWYgdHJhY2sgaXMgYSBwYXRoLCByZXVzZSBpdFxuXG4gICAgICBpZiAoISh0cmFjayBpbnN0YW5jZW9mIFBhdGgpKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBwYXRoIGVsZW1lbnRcbiAgICAgICAgdHJhY2sgPSB0aGlzLmRlZnMoKS5wYXRoKHRyYWNrKTtcbiAgICAgIH0gLy8gbGluayB0ZXh0UGF0aCB0byBwYXRoIGFuZCBhZGQgY29udGVudFxuXG5cbiAgICAgIHRleHRQYXRoLmF0dHIoJ2hyZWYnLCAnIycgKyB0cmFjaywgeGxpbmspOyAvLyBUcmFuc3BsYW50IGFsbCBub2RlcyBmcm9tIHRleHQgdG8gdGV4dFBhdGhcblxuICAgICAgbGV0IG5vZGU7XG5cbiAgICAgIGlmIChpbXBvcnROb2Rlcykge1xuICAgICAgICB3aGlsZSAobm9kZSA9IHRoaXMubm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgdGV4dFBhdGgubm9kZS5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBhZGQgdGV4dFBhdGggZWxlbWVudCBhcyBjaGlsZCBub2RlIGFuZCByZXR1cm4gdGV4dFBhdGhcblxuXG4gICAgICByZXR1cm4gdGhpcy5wdXQodGV4dFBhdGgpO1xuICAgIH0pLFxuXG4gICAgLy8gR2V0IHRoZSB0ZXh0UGF0aCBjaGlsZHJlblxuICAgIHRleHRQYXRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluZE9uZSgndGV4dFBhdGgnKTtcbiAgICB9XG5cbiAgfSxcbiAgUGF0aDoge1xuICAgIC8vIGNyZWF0ZXMgYSB0ZXh0UGF0aCBmcm9tIHRoaXMgcGF0aFxuICAgIHRleHQ6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAvLyBDb252ZXJ0IHRleHQgdG8gaW5zdGFuY2UgaWYgbmVlZGVkXG4gICAgICBpZiAoISh0ZXh0IGluc3RhbmNlb2YgVGV4dCkpIHtcbiAgICAgICAgdGV4dCA9IG5ldyBUZXh0KCkuYWRkVG8odGhpcy5wYXJlbnQoKSkudGV4dCh0ZXh0KTtcbiAgICAgIH0gLy8gQ3JlYXRlIHRleHRQYXRoIGZyb20gdGV4dCBhbmQgcGF0aCBhbmQgcmV0dXJuXG5cblxuICAgICAgcmV0dXJuIHRleHQucGF0aCh0aGlzKTtcbiAgICB9KSxcblxuICAgIHRhcmdldHMoKSB7XG4gICAgICByZXR1cm4gYmFzZUZpbmQoJ3N2ZyB0ZXh0UGF0aCcpLmZpbHRlcihub2RlID0+IHtcbiAgICAgICAgcmV0dXJuIChub2RlLmF0dHIoJ2hyZWYnKSB8fCAnJykuaW5jbHVkZXModGhpcy5pZCgpKTtcbiAgICAgIH0pOyAvLyBEb2VzIG5vdCB3b3JrIGluIElFMTEuIFVzZSB3aGVuIElFIHN1cHBvcnQgaXMgZHJvcHBlZFxuICAgICAgLy8gcmV0dXJuIGJhc2VGaW5kKCdzdmcgdGV4dFBhdGhbKnxocmVmKj0nICsgdGhpcy5pZCgpICsgJ10nKVxuICAgIH1cblxuICB9XG59KTtcblRleHRQYXRoLnByb3RvdHlwZS5Nb3JwaEFycmF5ID0gUGF0aEFycmF5O1xucmVnaXN0ZXIoVGV4dFBhdGgsICdUZXh0UGF0aCcpO1xuXG5jbGFzcyBVc2UgZXh0ZW5kcyBTaGFwZSB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygndXNlJywgbm9kZSksIGF0dHJzKTtcbiAgfSAvLyBVc2UgZWxlbWVudCBhcyBhIHJlZmVyZW5jZVxuXG5cbiAgdXNlKGVsZW1lbnQsIGZpbGUpIHtcbiAgICAvLyBTZXQgbGluZWQgZWxlbWVudFxuICAgIHJldHVybiB0aGlzLmF0dHIoJ2hyZWYnLCAoZmlsZSB8fCAnJykgKyAnIycgKyBlbGVtZW50LCB4bGluayk7XG4gIH1cblxufVxucmVnaXN0ZXJNZXRob2RzKHtcbiAgQ29udGFpbmVyOiB7XG4gICAgLy8gQ3JlYXRlIGEgdXNlIGVsZW1lbnRcbiAgICB1c2U6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uIChlbGVtZW50LCBmaWxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFVzZSgpKS51c2UoZWxlbWVudCwgZmlsZSk7XG4gICAgfSlcbiAgfVxufSk7XG5yZWdpc3RlcihVc2UsICdVc2UnKTtcblxuLyogT3B0aW9uYWwgTW9kdWxlcyAqL1xuY29uc3QgU1ZHID0gbWFrZUluc3RhbmNlO1xuZXh0ZW5kKFtTdmcsIFN5bWJvbCwgSW1hZ2UsIFBhdHRlcm4sIE1hcmtlcl0sIGdldE1ldGhvZHNGb3IoJ3ZpZXdib3gnKSk7XG5leHRlbmQoW0xpbmUsIFBvbHlsaW5lLCBQb2x5Z29uLCBQYXRoXSwgZ2V0TWV0aG9kc0ZvcignbWFya2VyJykpO1xuZXh0ZW5kKFRleHQsIGdldE1ldGhvZHNGb3IoJ1RleHQnKSk7XG5leHRlbmQoUGF0aCwgZ2V0TWV0aG9kc0ZvcignUGF0aCcpKTtcbmV4dGVuZChEZWZzLCBnZXRNZXRob2RzRm9yKCdEZWZzJykpO1xuZXh0ZW5kKFtUZXh0LCBUc3Bhbl0sIGdldE1ldGhvZHNGb3IoJ1RzcGFuJykpO1xuZXh0ZW5kKFtSZWN0LCBFbGxpcHNlLCBHcmFkaWVudCwgUnVubmVyXSwgZ2V0TWV0aG9kc0ZvcigncmFkaXVzJykpO1xuZXh0ZW5kKEV2ZW50VGFyZ2V0LCBnZXRNZXRob2RzRm9yKCdFdmVudFRhcmdldCcpKTtcbmV4dGVuZChEb20sIGdldE1ldGhvZHNGb3IoJ0RvbScpKTtcbmV4dGVuZChFbGVtZW50LCBnZXRNZXRob2RzRm9yKCdFbGVtZW50JykpO1xuZXh0ZW5kKFNoYXBlLCBnZXRNZXRob2RzRm9yKCdTaGFwZScpKTtcbmV4dGVuZChbQ29udGFpbmVyLCBGcmFnbWVudF0sIGdldE1ldGhvZHNGb3IoJ0NvbnRhaW5lcicpKTtcbmV4dGVuZChHcmFkaWVudCwgZ2V0TWV0aG9kc0ZvcignR3JhZGllbnQnKSk7XG5leHRlbmQoUnVubmVyLCBnZXRNZXRob2RzRm9yKCdSdW5uZXInKSk7XG5MaXN0LmV4dGVuZChnZXRNZXRob2ROYW1lcygpKTtcbnJlZ2lzdGVyTW9ycGhhYmxlVHlwZShbU1ZHTnVtYmVyLCBDb2xvciwgQm94LCBNYXRyaXgsIFNWR0FycmF5LCBQb2ludEFycmF5LCBQYXRoQXJyYXksIFBvaW50XSk7XG5tYWtlTW9ycGhhYmxlKCk7XG5cbmV4cG9ydCB7IEEsIEFuaW1hdG9yLCBTVkdBcnJheSBhcyBBcnJheSwgQm94LCBDaXJjbGUsIENsaXBQYXRoLCBDb2xvciwgQ29udGFpbmVyLCBDb250cm9sbGVyLCBEZWZzLCBEb20sIEVhc2UsIEVsZW1lbnQsIEVsbGlwc2UsIEV2ZW50VGFyZ2V0LCBGb3JlaWduT2JqZWN0LCBGcmFnbWVudCwgRywgR3JhZGllbnQsIEltYWdlLCBMaW5lLCBMaXN0LCBNYXJrZXIsIE1hc2ssIE1hdHJpeCwgTW9ycGhhYmxlLCBOb25Nb3JwaGFibGUsIFNWR051bWJlciBhcyBOdW1iZXIsIE9iamVjdEJhZywgUElELCBQYXRoLCBQYXRoQXJyYXksIFBhdHRlcm4sIFBvaW50LCBQb2ludEFycmF5LCBQb2x5Z29uLCBQb2x5bGluZSwgUXVldWUsIFJlY3QsIFJ1bm5lciwgU1ZHLCBTaGFwZSwgU3ByaW5nLCBTdG9wLCBTdHlsZSwgU3ZnLCBTeW1ib2wsIFRleHQsIFRleHRQYXRoLCBUaW1lbGluZSwgVHJhbnNmb3JtQmFnLCBUc3BhbiwgVXNlLCBhZG9wdCwgYXNzaWduTmV3SWQsIGNsZWFyRXZlbnRzLCBjcmVhdGUsIGRlZmF1bHRzLCBkaXNwYXRjaCwgZWFzaW5nLCBlaWQsIGV4dGVuZCwgYmFzZUZpbmQgYXMgZmluZCwgZ2V0Q2xhc3MsIGdldEV2ZW50VGFyZ2V0LCBnZXRFdmVudHMsIGdldFdpbmRvdywgbWFrZUluc3RhbmNlLCBtYWtlTW9ycGhhYmxlLCBtb2NrQWRvcHQsIG5hbWVzcGFjZXMsIG5vZGVPck5ldywgb2ZmLCBvbiwgcGFyc2VyLCByZWdleCwgcmVnaXN0ZXIsIHJlZ2lzdGVyTW9ycGhhYmxlVHlwZSwgcmVnaXN0ZXJXaW5kb3csIHJlc3RvcmVXaW5kb3csIHJvb3QsIHNhdmVXaW5kb3csIHV0aWxzLCB3aW5kb3dFdmVudHMsIHdpdGhXaW5kb3csIHdyYXBXaXRoQXR0ckNoZWNrIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdmcuZXNtLmpzLm1hcFxuIiwiLyoqXG4gKiBkYXQtZ3VpIEphdmFTY3JpcHQgQ29udHJvbGxlciBMaWJyYXJ5XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZGF0YWFydHMvZGF0Lmd1aVxuICpcbiAqIENvcHlyaWdodCAyMDExIERhdGEgQXJ0cyBUZWFtLCBHb29nbGUgQ3JlYXRpdmUgTGFiXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG5cbmZ1bmN0aW9uIF9fXyRpbnNlcnRTdHlsZShjc3MpIHtcbiAgaWYgKCFjc3MpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblxuICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9jc3MnKTtcbiAgc3R5bGUuaW5uZXJIVE1MID0gY3NzO1xuICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcblxuICByZXR1cm4gY3NzO1xufVxuXG5mdW5jdGlvbiBjb2xvclRvU3RyaW5nIChjb2xvciwgZm9yY2VDU1NIZXgpIHtcbiAgdmFyIGNvbG9yRm9ybWF0ID0gY29sb3IuX19zdGF0ZS5jb252ZXJzaW9uTmFtZS50b1N0cmluZygpO1xuICB2YXIgciA9IE1hdGgucm91bmQoY29sb3Iucik7XG4gIHZhciBnID0gTWF0aC5yb3VuZChjb2xvci5nKTtcbiAgdmFyIGIgPSBNYXRoLnJvdW5kKGNvbG9yLmIpO1xuICB2YXIgYSA9IGNvbG9yLmE7XG4gIHZhciBoID0gTWF0aC5yb3VuZChjb2xvci5oKTtcbiAgdmFyIHMgPSBjb2xvci5zLnRvRml4ZWQoMSk7XG4gIHZhciB2ID0gY29sb3Iudi50b0ZpeGVkKDEpO1xuICBpZiAoZm9yY2VDU1NIZXggfHwgY29sb3JGb3JtYXQgPT09ICdUSFJFRV9DSEFSX0hFWCcgfHwgY29sb3JGb3JtYXQgPT09ICdTSVhfQ0hBUl9IRVgnKSB7XG4gICAgdmFyIHN0ciA9IGNvbG9yLmhleC50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPCA2KSB7XG4gICAgICBzdHIgPSAnMCcgKyBzdHI7XG4gICAgfVxuICAgIHJldHVybiAnIycgKyBzdHI7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdDU1NfUkdCJykge1xuICAgIHJldHVybiAncmdiKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnKSc7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdDU1NfUkdCQScpIHtcbiAgICByZXR1cm4gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdIRVgnKSB7XG4gICAgcmV0dXJuICcweCcgKyBjb2xvci5oZXgudG9TdHJpbmcoMTYpO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnUkdCX0FSUkFZJykge1xuICAgIHJldHVybiAnWycgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnXSc7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdSR0JBX0FSUkFZJykge1xuICAgIHJldHVybiAnWycgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJ10nO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnUkdCX09CSicpIHtcbiAgICByZXR1cm4gJ3tyOicgKyByICsgJyxnOicgKyBnICsgJyxiOicgKyBiICsgJ30nO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnUkdCQV9PQkonKSB7XG4gICAgcmV0dXJuICd7cjonICsgciArICcsZzonICsgZyArICcsYjonICsgYiArICcsYTonICsgYSArICd9JztcbiAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ0hTVl9PQkonKSB7XG4gICAgcmV0dXJuICd7aDonICsgaCArICcsczonICsgcyArICcsdjonICsgdiArICd9JztcbiAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ0hTVkFfT0JKJykge1xuICAgIHJldHVybiAne2g6JyArIGggKyAnLHM6JyArIHMgKyAnLHY6JyArIHYgKyAnLGE6JyArIGEgKyAnfSc7XG4gIH1cbiAgcmV0dXJuICd1bmtub3duIGZvcm1hdCc7XG59XG5cbnZhciBBUlJfRUFDSCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xudmFyIEFSUl9TTElDRSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBDb21tb24gPSB7XG4gIEJSRUFLOiB7fSxcbiAgZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQodGFyZ2V0KSB7XG4gICAgdGhpcy5lYWNoKEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHZhciBrZXlzID0gdGhpcy5pc09iamVjdChvYmopID8gT2JqZWN0LmtleXMob2JqKSA6IFtdO1xuICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVW5kZWZpbmVkKG9ialtrZXldKSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSxcbiAgZGVmYXVsdHM6IGZ1bmN0aW9uIGRlZmF1bHRzKHRhcmdldCkge1xuICAgIHRoaXMuZWFjaChBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICB2YXIga2V5cyA9IHRoaXMuaXNPYmplY3Qob2JqKSA/IE9iamVjdC5rZXlzKG9iaikgOiBbXTtcbiAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLmlzVW5kZWZpbmVkKHRhcmdldFtrZXldKSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSxcbiAgY29tcG9zZTogZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgICB2YXIgdG9DYWxsID0gQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgZm9yICh2YXIgaSA9IHRvQ2FsbC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBhcmdzID0gW3RvQ2FsbFtpXS5hcHBseSh0aGlzLCBhcmdzKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJnc1swXTtcbiAgICB9O1xuICB9LFxuICBlYWNoOiBmdW5jdGlvbiBlYWNoKG9iaiwgaXRyLCBzY29wZSkge1xuICAgIGlmICghb2JqKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChBUlJfRUFDSCAmJiBvYmouZm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gQVJSX0VBQ0gpIHtcbiAgICAgIG9iai5mb3JFYWNoKGl0ciwgc2NvcGUpO1xuICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gb2JqLmxlbmd0aCArIDApIHtcbiAgICAgIHZhciBrZXkgPSB2b2lkIDA7XG4gICAgICB2YXIgbCA9IHZvaWQgMDtcbiAgICAgIGZvciAoa2V5ID0gMCwgbCA9IG9iai5sZW5ndGg7IGtleSA8IGw7IGtleSsrKSB7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqICYmIGl0ci5jYWxsKHNjb3BlLCBvYmpba2V5XSwga2V5KSA9PT0gdGhpcy5CUkVBSykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBfa2V5IGluIG9iaikge1xuICAgICAgICBpZiAoaXRyLmNhbGwoc2NvcGUsIG9ialtfa2V5XSwgX2tleSkgPT09IHRoaXMuQlJFQUspIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGRlZmVyOiBmdW5jdGlvbiBkZWZlcihmbmMpIHtcbiAgICBzZXRUaW1lb3V0KGZuYywgMCk7XG4gIH0sXG4gIGRlYm91bmNlOiBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB0aHJlc2hvbGQsIGNhbGxJbW1lZGlhdGVseSkge1xuICAgIHZhciB0aW1lb3V0ID0gdm9pZCAwO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb2JqID0gdGhpcztcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgZnVuY3Rpb24gZGVsYXllZCgpIHtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIGlmICghY2FsbEltbWVkaWF0ZWx5KSBmdW5jLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgICB9XG4gICAgICB2YXIgY2FsbE5vdyA9IGNhbGxJbW1lZGlhdGVseSB8fCAhdGltZW91dDtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHRocmVzaG9sZCk7XG4gICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICBmdW5jLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgdG9BcnJheTogZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgICBpZiAob2JqLnRvQXJyYXkpIHJldHVybiBvYmoudG9BcnJheSgpO1xuICAgIHJldHVybiBBUlJfU0xJQ0UuY2FsbChvYmopO1xuICB9LFxuICBpc1VuZGVmaW5lZDogZnVuY3Rpb24gaXNVbmRlZmluZWQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uIGlzTnVsbChvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBudWxsO1xuICB9LFxuICBpc05hTjogZnVuY3Rpb24gKF9pc05hTikge1xuICAgIGZ1bmN0aW9uIGlzTmFOKF94KSB7XG4gICAgICByZXR1cm4gX2lzTmFOLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGlzTmFOLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pc05hTi50b1N0cmluZygpO1xuICAgIH07XG4gICAgcmV0dXJuIGlzTmFOO1xuICB9KGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gaXNOYU4ob2JqKTtcbiAgfSksXG4gIGlzQXJyYXk6IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmouY29uc3RydWN0b3IgPT09IEFycmF5O1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaik7XG4gIH0sXG4gIGlzTnVtYmVyOiBmdW5jdGlvbiBpc051bWJlcihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBvYmogKyAwO1xuICB9LFxuICBpc1N0cmluZzogZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gb2JqICsgJyc7XG4gIH0sXG4gIGlzQm9vbGVhbjogZnVuY3Rpb24gaXNCb29sZWFuKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gdHJ1ZTtcbiAgfSxcbiAgaXNGdW5jdGlvbjogZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRnVuY3Rpb247XG4gIH1cbn07XG5cbnZhciBJTlRFUlBSRVRBVElPTlMgPSBbXG57XG4gIGxpdG11czogQ29tbW9uLmlzU3RyaW5nLFxuICBjb252ZXJzaW9uczoge1xuICAgIFRIUkVFX0NIQVJfSEVYOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL14jKFtBLUYwLTldKShbQS1GMC05XSkoW0EtRjAtOV0pJC9pKTtcbiAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgaGV4OiBwYXJzZUludCgnMHgnICsgdGVzdFsxXS50b1N0cmluZygpICsgdGVzdFsxXS50b1N0cmluZygpICsgdGVzdFsyXS50b1N0cmluZygpICsgdGVzdFsyXS50b1N0cmluZygpICsgdGVzdFszXS50b1N0cmluZygpICsgdGVzdFszXS50b1N0cmluZygpLCAwKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBjb2xvclRvU3RyaW5nXG4gICAgfSxcbiAgICBTSVhfQ0hBUl9IRVg6IHtcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcbiAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXiMoW0EtRjAtOV17Nn0pJC9pKTtcbiAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgaGV4OiBwYXJzZUludCgnMHgnICsgdGVzdFsxXS50b1N0cmluZygpLCAwKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBjb2xvclRvU3RyaW5nXG4gICAgfSxcbiAgICBDU1NfUkdCOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL15yZ2JcXChcXHMqKFxcUyspXFxzKixcXHMqKFxcUyspXFxzKixcXHMqKFxcUyspXFxzKlxcKS8pO1xuICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICByOiBwYXJzZUZsb2F0KHRlc3RbMV0pLFxuICAgICAgICAgIGc6IHBhcnNlRmxvYXQodGVzdFsyXSksXG4gICAgICAgICAgYjogcGFyc2VGbG9hdCh0ZXN0WzNdKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBjb2xvclRvU3RyaW5nXG4gICAgfSxcbiAgICBDU1NfUkdCQToge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9ecmdiYVxcKFxccyooXFxTKylcXHMqLFxccyooXFxTKylcXHMqLFxccyooXFxTKylcXHMqLFxccyooXFxTKylcXHMqXFwpLyk7XG4gICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgIHI6IHBhcnNlRmxvYXQodGVzdFsxXSksXG4gICAgICAgICAgZzogcGFyc2VGbG9hdCh0ZXN0WzJdKSxcbiAgICAgICAgICBiOiBwYXJzZUZsb2F0KHRlc3RbM10pLFxuICAgICAgICAgIGE6IHBhcnNlRmxvYXQodGVzdFs0XSlcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogY29sb3JUb1N0cmluZ1xuICAgIH1cbiAgfVxufSxcbntcbiAgbGl0bXVzOiBDb21tb24uaXNOdW1iZXIsXG4gIGNvbnZlcnNpb25zOiB7XG4gICAgSEVYOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3BhY2U6ICdIRVgnLFxuICAgICAgICAgIGhleDogb3JpZ2luYWwsXG4gICAgICAgICAgY29udmVyc2lvbk5hbWU6ICdIRVgnXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBjb2xvci5oZXg7XG4gICAgICB9XG4gICAgfVxuICB9XG59LFxue1xuICBsaXRtdXM6IENvbW1vbi5pc0FycmF5LFxuICBjb252ZXJzaW9uczoge1xuICAgIFJHQl9BUlJBWToge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICBpZiAob3JpZ2luYWwubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgIHI6IG9yaWdpbmFsWzBdLFxuICAgICAgICAgIGc6IG9yaWdpbmFsWzFdLFxuICAgICAgICAgIGI6IG9yaWdpbmFsWzJdXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBbY29sb3IuciwgY29sb3IuZywgY29sb3IuYl07XG4gICAgICB9XG4gICAgfSxcbiAgICBSR0JBX0FSUkFZOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIGlmIChvcmlnaW5hbC5sZW5ndGggIT09IDQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgcjogb3JpZ2luYWxbMF0sXG4gICAgICAgICAgZzogb3JpZ2luYWxbMV0sXG4gICAgICAgICAgYjogb3JpZ2luYWxbMl0sXG4gICAgICAgICAgYTogb3JpZ2luYWxbM11cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIFtjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iLCBjb2xvci5hXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sXG57XG4gIGxpdG11czogQ29tbW9uLmlzT2JqZWN0LFxuICBjb252ZXJzaW9uczoge1xuICAgIFJHQkFfT0JKOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIGlmIChDb21tb24uaXNOdW1iZXIob3JpZ2luYWwucikgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmcpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5iKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgcjogb3JpZ2luYWwucixcbiAgICAgICAgICAgIGc6IG9yaWdpbmFsLmcsXG4gICAgICAgICAgICBiOiBvcmlnaW5hbC5iLFxuICAgICAgICAgICAgYTogb3JpZ2luYWwuYVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShjb2xvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHI6IGNvbG9yLnIsXG4gICAgICAgICAgZzogY29sb3IuZyxcbiAgICAgICAgICBiOiBjb2xvci5iLFxuICAgICAgICAgIGE6IGNvbG9yLmFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFJHQl9PQko6IHtcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcbiAgICAgICAgaWYgKENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5yKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwuZykgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmIpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgIHI6IG9yaWdpbmFsLnIsXG4gICAgICAgICAgICBnOiBvcmlnaW5hbC5nLFxuICAgICAgICAgICAgYjogb3JpZ2luYWwuYlxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShjb2xvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHI6IGNvbG9yLnIsXG4gICAgICAgICAgZzogY29sb3IuZyxcbiAgICAgICAgICBiOiBjb2xvci5iXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICBIU1ZBX09CSjoge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmgpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5zKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwudikgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmEpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNwYWNlOiAnSFNWJyxcbiAgICAgICAgICAgIGg6IG9yaWdpbmFsLmgsXG4gICAgICAgICAgICBzOiBvcmlnaW5hbC5zLFxuICAgICAgICAgICAgdjogb3JpZ2luYWwudixcbiAgICAgICAgICAgIGE6IG9yaWdpbmFsLmFcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoOiBjb2xvci5oLFxuICAgICAgICAgIHM6IGNvbG9yLnMsXG4gICAgICAgICAgdjogY29sb3IudixcbiAgICAgICAgICBhOiBjb2xvci5hXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICBIU1ZfT0JKOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIGlmIChDb21tb24uaXNOdW1iZXIob3JpZ2luYWwuaCkgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnMpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC52KSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzcGFjZTogJ0hTVicsXG4gICAgICAgICAgICBoOiBvcmlnaW5hbC5oLFxuICAgICAgICAgICAgczogb3JpZ2luYWwucyxcbiAgICAgICAgICAgIHY6IG9yaWdpbmFsLnZcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoOiBjb2xvci5oLFxuICAgICAgICAgIHM6IGNvbG9yLnMsXG4gICAgICAgICAgdjogY29sb3IudlxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufV07XG52YXIgcmVzdWx0ID0gdm9pZCAwO1xudmFyIHRvUmV0dXJuID0gdm9pZCAwO1xudmFyIGludGVycHJldCA9IGZ1bmN0aW9uIGludGVycHJldCgpIHtcbiAgdG9SZXR1cm4gPSBmYWxzZTtcbiAgdmFyIG9yaWdpbmFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBDb21tb24udG9BcnJheShhcmd1bWVudHMpIDogYXJndW1lbnRzWzBdO1xuICBDb21tb24uZWFjaChJTlRFUlBSRVRBVElPTlMsIGZ1bmN0aW9uIChmYW1pbHkpIHtcbiAgICBpZiAoZmFtaWx5LmxpdG11cyhvcmlnaW5hbCkpIHtcbiAgICAgIENvbW1vbi5lYWNoKGZhbWlseS5jb252ZXJzaW9ucywgZnVuY3Rpb24gKGNvbnZlcnNpb24sIGNvbnZlcnNpb25OYW1lKSB7XG4gICAgICAgIHJlc3VsdCA9IGNvbnZlcnNpb24ucmVhZChvcmlnaW5hbCk7XG4gICAgICAgIGlmICh0b1JldHVybiA9PT0gZmFsc2UgJiYgcmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgIHRvUmV0dXJuID0gcmVzdWx0O1xuICAgICAgICAgIHJlc3VsdC5jb252ZXJzaW9uTmFtZSA9IGNvbnZlcnNpb25OYW1lO1xuICAgICAgICAgIHJlc3VsdC5jb252ZXJzaW9uID0gY29udmVyc2lvbjtcbiAgICAgICAgICByZXR1cm4gQ29tbW9uLkJSRUFLO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBDb21tb24uQlJFQUs7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRvUmV0dXJuO1xufTtcblxudmFyIHRtcENvbXBvbmVudCA9IHZvaWQgMDtcbnZhciBDb2xvck1hdGggPSB7XG4gIGhzdl90b19yZ2I6IGZ1bmN0aW9uIGhzdl90b19yZ2IoaCwgcywgdikge1xuICAgIHZhciBoaSA9IE1hdGguZmxvb3IoaCAvIDYwKSAlIDY7XG4gICAgdmFyIGYgPSBoIC8gNjAgLSBNYXRoLmZsb29yKGggLyA2MCk7XG4gICAgdmFyIHAgPSB2ICogKDEuMCAtIHMpO1xuICAgIHZhciBxID0gdiAqICgxLjAgLSBmICogcyk7XG4gICAgdmFyIHQgPSB2ICogKDEuMCAtICgxLjAgLSBmKSAqIHMpO1xuICAgIHZhciBjID0gW1t2LCB0LCBwXSwgW3EsIHYsIHBdLCBbcCwgdiwgdF0sIFtwLCBxLCB2XSwgW3QsIHAsIHZdLCBbdiwgcCwgcV1dW2hpXTtcbiAgICByZXR1cm4ge1xuICAgICAgcjogY1swXSAqIDI1NSxcbiAgICAgIGc6IGNbMV0gKiAyNTUsXG4gICAgICBiOiBjWzJdICogMjU1XG4gICAgfTtcbiAgfSxcbiAgcmdiX3RvX2hzdjogZnVuY3Rpb24gcmdiX3RvX2hzdihyLCBnLCBiKSB7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgICB2YXIgZGVsdGEgPSBtYXggLSBtaW47XG4gICAgdmFyIGggPSB2b2lkIDA7XG4gICAgdmFyIHMgPSB2b2lkIDA7XG4gICAgaWYgKG1heCAhPT0gMCkge1xuICAgICAgcyA9IGRlbHRhIC8gbWF4O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoOiBOYU4sXG4gICAgICAgIHM6IDAsXG4gICAgICAgIHY6IDBcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChyID09PSBtYXgpIHtcbiAgICAgIGggPSAoZyAtIGIpIC8gZGVsdGE7XG4gICAgfSBlbHNlIGlmIChnID09PSBtYXgpIHtcbiAgICAgIGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBoID0gNCArIChyIC0gZykgLyBkZWx0YTtcbiAgICB9XG4gICAgaCAvPSA2O1xuICAgIGlmIChoIDwgMCkge1xuICAgICAgaCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaDogaCAqIDM2MCxcbiAgICAgIHM6IHMsXG4gICAgICB2OiBtYXggLyAyNTVcbiAgICB9O1xuICB9LFxuICByZ2JfdG9faGV4OiBmdW5jdGlvbiByZ2JfdG9faGV4KHIsIGcsIGIpIHtcbiAgICB2YXIgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoMCwgMiwgcik7XG4gICAgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoaGV4LCAxLCBnKTtcbiAgICBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudChoZXgsIDAsIGIpO1xuICAgIHJldHVybiBoZXg7XG4gIH0sXG4gIGNvbXBvbmVudF9mcm9tX2hleDogZnVuY3Rpb24gY29tcG9uZW50X2Zyb21faGV4KGhleCwgY29tcG9uZW50SW5kZXgpIHtcbiAgICByZXR1cm4gaGV4ID4+IGNvbXBvbmVudEluZGV4ICogOCAmIDB4RkY7XG4gIH0sXG4gIGhleF93aXRoX2NvbXBvbmVudDogZnVuY3Rpb24gaGV4X3dpdGhfY29tcG9uZW50KGhleCwgY29tcG9uZW50SW5kZXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIDw8ICh0bXBDb21wb25lbnQgPSBjb21wb25lbnRJbmRleCAqIDgpIHwgaGV4ICYgfigweEZGIDw8IHRtcENvbXBvbmVudCk7XG4gIH1cbn07XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cblxuXG5cblxuXG5cbnZhciBnZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcblxuICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykge1xuICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBnZXR0ZXIgPSBkZXNjLmdldDtcblxuICAgIGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpO1xuICB9XG59O1xuXG52YXIgaW5oZXJpdHMgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG52YXIgQ29sb3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbG9yKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENvbG9yKTtcbiAgICB0aGlzLl9fc3RhdGUgPSBpbnRlcnByZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodGhpcy5fX3N0YXRlID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gaW50ZXJwcmV0IGNvbG9yIGFyZ3VtZW50cycpO1xuICAgIH1cbiAgICB0aGlzLl9fc3RhdGUuYSA9IHRoaXMuX19zdGF0ZS5hIHx8IDE7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoQ29sb3IsIFt7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBjb2xvclRvU3RyaW5nKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSGV4U3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9IZXhTdHJpbmcoKSB7XG4gICAgICByZXR1cm4gY29sb3JUb1N0cmluZyh0aGlzLCB0cnVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b09yaWdpbmFsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9PcmlnaW5hbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGUuY29udmVyc2lvbi53cml0ZSh0aGlzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENvbG9yO1xufSgpO1xuZnVuY3Rpb24gZGVmaW5lUkdCQ29tcG9uZW50KHRhcmdldCwgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb21wb25lbnQsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgPT09ICdSR0InKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcbiAgICAgIH1cbiAgICAgIENvbG9yLnJlY2FsY3VsYXRlUkdCKHRoaXMsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpO1xuICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xuICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSAhPT0gJ1JHQicpIHtcbiAgICAgICAgQ29sb3IucmVjYWxjdWxhdGVSR0IodGhpcywgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCk7XG4gICAgICAgIHRoaXMuX19zdGF0ZS5zcGFjZSA9ICdSR0InO1xuICAgICAgfVxuICAgICAgdGhpcy5fX3N0YXRlW2NvbXBvbmVudF0gPSB2O1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBkZWZpbmVIU1ZDb21wb25lbnQodGFyZ2V0LCBjb21wb25lbnQpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29tcG9uZW50LCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlID09PSAnSFNWJykge1xuICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG4gICAgICB9XG4gICAgICBDb2xvci5yZWNhbGN1bGF0ZUhTVih0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcbiAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdIU1YnKSB7XG4gICAgICAgIENvbG9yLnJlY2FsY3VsYXRlSFNWKHRoaXMpO1xuICAgICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnSFNWJztcbiAgICAgIH1cbiAgICAgIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdID0gdjtcbiAgICB9XG4gIH0pO1xufVxuQ29sb3IucmVjYWxjdWxhdGVSR0IgPSBmdW5jdGlvbiAoY29sb3IsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpIHtcbiAgaWYgKGNvbG9yLl9fc3RhdGUuc3BhY2UgPT09ICdIRVgnKSB7XG4gICAgY29sb3IuX19zdGF0ZVtjb21wb25lbnRdID0gQ29sb3JNYXRoLmNvbXBvbmVudF9mcm9tX2hleChjb2xvci5fX3N0YXRlLmhleCwgY29tcG9uZW50SGV4SW5kZXgpO1xuICB9IGVsc2UgaWYgKGNvbG9yLl9fc3RhdGUuc3BhY2UgPT09ICdIU1YnKSB7XG4gICAgQ29tbW9uLmV4dGVuZChjb2xvci5fX3N0YXRlLCBDb2xvck1hdGguaHN2X3RvX3JnYihjb2xvci5fX3N0YXRlLmgsIGNvbG9yLl9fc3RhdGUucywgY29sb3IuX19zdGF0ZS52KSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3JydXB0ZWQgY29sb3Igc3RhdGUnKTtcbiAgfVxufTtcbkNvbG9yLnJlY2FsY3VsYXRlSFNWID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gIHZhciByZXN1bHQgPSBDb2xvck1hdGgucmdiX3RvX2hzdihjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTtcbiAgQ29tbW9uLmV4dGVuZChjb2xvci5fX3N0YXRlLCB7XG4gICAgczogcmVzdWx0LnMsXG4gICAgdjogcmVzdWx0LnZcbiAgfSk7XG4gIGlmICghQ29tbW9uLmlzTmFOKHJlc3VsdC5oKSkge1xuICAgIGNvbG9yLl9fc3RhdGUuaCA9IHJlc3VsdC5oO1xuICB9IGVsc2UgaWYgKENvbW1vbi5pc1VuZGVmaW5lZChjb2xvci5fX3N0YXRlLmgpKSB7XG4gICAgY29sb3IuX19zdGF0ZS5oID0gMDtcbiAgfVxufTtcbkNvbG9yLkNPTVBPTkVOVFMgPSBbJ3InLCAnZycsICdiJywgJ2gnLCAncycsICd2JywgJ2hleCcsICdhJ107XG5kZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAncicsIDIpO1xuZGVmaW5lUkdCQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ2cnLCAxKTtcbmRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdiJywgMCk7XG5kZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnaCcpO1xuZGVmaW5lSFNWQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ3MnKTtcbmRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICd2Jyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3IucHJvdG90eXBlLCAnYScsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5hO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSh2KSB7XG4gICAgdGhpcy5fX3N0YXRlLmEgPSB2O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xvci5wcm90b3R5cGUsICdoZXgnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdIRVgnKSB7XG4gICAgICB0aGlzLl9fc3RhdGUuaGV4ID0gQ29sb3JNYXRoLnJnYl90b19oZXgodGhpcy5yLCB0aGlzLmcsIHRoaXMuYik7XG4gICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnSEVYJztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5oZXg7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcbiAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnSEVYJztcbiAgICB0aGlzLl9fc3RhdGUuaGV4ID0gdjtcbiAgfVxufSk7XG5cbnZhciBDb250cm9sbGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDb250cm9sbGVyKTtcbiAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG4gICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIHRoaXMuX19vbkNoYW5nZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UgPSB1bmRlZmluZWQ7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoQ29udHJvbGxlciwgW3tcbiAgICBrZXk6ICdvbkNoYW5nZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ2hhbmdlKGZuYykge1xuICAgICAgdGhpcy5fX29uQ2hhbmdlID0gZm5jO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25GaW5pc2hDaGFuZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkZpbmlzaENoYW5nZShmbmMpIHtcbiAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZSA9IGZuYztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUobmV3VmFsdWUpIHtcbiAgICAgIHRoaXMub2JqZWN0W3RoaXMucHJvcGVydHldID0gbmV3VmFsdWU7XG4gICAgICBpZiAodGhpcy5fX29uQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX19vbkNoYW5nZS5jYWxsKHRoaXMsIG5ld1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9iamVjdFt0aGlzLnByb3BlcnR5XTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVEaXNwbGF5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2lzTW9kaWZpZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc01vZGlmaWVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbFZhbHVlICE9PSB0aGlzLmdldFZhbHVlKCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDb250cm9sbGVyO1xufSgpO1xuXG52YXIgRVZFTlRfTUFQID0ge1xuICBIVE1MRXZlbnRzOiBbJ2NoYW5nZSddLFxuICBNb3VzZUV2ZW50czogWydjbGljaycsICdtb3VzZW1vdmUnLCAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnbW91c2VvdmVyJ10sXG4gIEtleWJvYXJkRXZlbnRzOiBbJ2tleWRvd24nXVxufTtcbnZhciBFVkVOVF9NQVBfSU5WID0ge307XG5Db21tb24uZWFjaChFVkVOVF9NQVAsIGZ1bmN0aW9uICh2LCBrKSB7XG4gIENvbW1vbi5lYWNoKHYsIGZ1bmN0aW9uIChlKSB7XG4gICAgRVZFTlRfTUFQX0lOVltlXSA9IGs7XG4gIH0pO1xufSk7XG52YXIgQ1NTX1ZBTFVFX1BJWEVMUyA9IC8oXFxkKyhcXC5cXGQrKT8pcHgvO1xuZnVuY3Rpb24gY3NzVmFsdWVUb1BpeGVscyh2YWwpIHtcbiAgaWYgKHZhbCA9PT0gJzAnIHx8IENvbW1vbi5pc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIG1hdGNoID0gdmFsLm1hdGNoKENTU19WQUxVRV9QSVhFTFMpO1xuICBpZiAoIUNvbW1vbi5pc051bGwobWF0Y2gpKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB9XG4gIHJldHVybiAwO1xufVxudmFyIGRvbSA9IHtcbiAgbWFrZVNlbGVjdGFibGU6IGZ1bmN0aW9uIG1ha2VTZWxlY3RhYmxlKGVsZW0sIHNlbGVjdGFibGUpIHtcbiAgICBpZiAoZWxlbSA9PT0gdW5kZWZpbmVkIHx8IGVsZW0uc3R5bGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgIGVsZW0ub25zZWxlY3RzdGFydCA9IHNlbGVjdGFibGUgPyBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSA6IGZ1bmN0aW9uICgpIHt9O1xuICAgIGVsZW0uc3R5bGUuTW96VXNlclNlbGVjdCA9IHNlbGVjdGFibGUgPyAnYXV0bycgOiAnbm9uZSc7XG4gICAgZWxlbS5zdHlsZS5LaHRtbFVzZXJTZWxlY3QgPSBzZWxlY3RhYmxlID8gJ2F1dG8nIDogJ25vbmUnO1xuICAgIGVsZW0udW5zZWxlY3RhYmxlID0gc2VsZWN0YWJsZSA/ICdvbicgOiAnb2ZmJztcbiAgfSxcbiAgbWFrZUZ1bGxzY3JlZW46IGZ1bmN0aW9uIG1ha2VGdWxsc2NyZWVuKGVsZW0sIGhvciwgdmVydCkge1xuICAgIHZhciB2ZXJ0aWNhbCA9IHZlcnQ7XG4gICAgdmFyIGhvcml6b250YWwgPSBob3I7XG4gICAgaWYgKENvbW1vbi5pc1VuZGVmaW5lZChob3Jpem9udGFsKSkge1xuICAgICAgaG9yaXpvbnRhbCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChDb21tb24uaXNVbmRlZmluZWQodmVydGljYWwpKSB7XG4gICAgICB2ZXJ0aWNhbCA9IHRydWU7XG4gICAgfVxuICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICBlbGVtLnN0eWxlLmxlZnQgPSAwO1xuICAgICAgZWxlbS5zdHlsZS5yaWdodCA9IDA7XG4gICAgfVxuICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgZWxlbS5zdHlsZS50b3AgPSAwO1xuICAgICAgZWxlbS5zdHlsZS5ib3R0b20gPSAwO1xuICAgIH1cbiAgfSxcbiAgZmFrZUV2ZW50OiBmdW5jdGlvbiBmYWtlRXZlbnQoZWxlbSwgZXZlbnRUeXBlLCBwYXJzLCBhdXgpIHtcbiAgICB2YXIgcGFyYW1zID0gcGFycyB8fCB7fTtcbiAgICB2YXIgY2xhc3NOYW1lID0gRVZFTlRfTUFQX0lOVltldmVudFR5cGVdO1xuICAgIGlmICghY2xhc3NOYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50IHR5cGUgJyArIGV2ZW50VHlwZSArICcgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG4gICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KGNsYXNzTmFtZSk7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIGNhc2UgJ01vdXNlRXZlbnRzJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBjbGllbnRYID0gcGFyYW1zLnggfHwgcGFyYW1zLmNsaWVudFggfHwgMDtcbiAgICAgICAgICB2YXIgY2xpZW50WSA9IHBhcmFtcy55IHx8IHBhcmFtcy5jbGllbnRZIHx8IDA7XG4gICAgICAgICAgZXZ0LmluaXRNb3VzZUV2ZW50KGV2ZW50VHlwZSwgcGFyYW1zLmJ1YmJsZXMgfHwgZmFsc2UsIHBhcmFtcy5jYW5jZWxhYmxlIHx8IHRydWUsIHdpbmRvdywgcGFyYW1zLmNsaWNrQ291bnQgfHwgMSwgMCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIGNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WSxcbiAgICAgICAgICBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ0tleWJvYXJkRXZlbnRzJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpbml0ID0gZXZ0LmluaXRLZXlib2FyZEV2ZW50IHx8IGV2dC5pbml0S2V5RXZlbnQ7XG4gICAgICAgICAgQ29tbW9uLmRlZmF1bHRzKHBhcmFtcywge1xuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGN0cmxLZXk6IGZhbHNlLFxuICAgICAgICAgICAgYWx0S2V5OiBmYWxzZSxcbiAgICAgICAgICAgIHNoaWZ0S2V5OiBmYWxzZSxcbiAgICAgICAgICAgIG1ldGFLZXk6IGZhbHNlLFxuICAgICAgICAgICAga2V5Q29kZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2hhckNvZGU6IHVuZGVmaW5lZFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGluaXQoZXZlbnRUeXBlLCBwYXJhbXMuYnViYmxlcyB8fCBmYWxzZSwgcGFyYW1zLmNhbmNlbGFibGUsIHdpbmRvdywgcGFyYW1zLmN0cmxLZXksIHBhcmFtcy5hbHRLZXksIHBhcmFtcy5zaGlmdEtleSwgcGFyYW1zLm1ldGFLZXksIHBhcmFtcy5rZXlDb2RlLCBwYXJhbXMuY2hhckNvZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgZXZ0LmluaXRFdmVudChldmVudFR5cGUsIHBhcmFtcy5idWJibGVzIHx8IGZhbHNlLCBwYXJhbXMuY2FuY2VsYWJsZSB8fCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBDb21tb24uZGVmYXVsdHMoZXZ0LCBhdXgpO1xuICAgIGVsZW0uZGlzcGF0Y2hFdmVudChldnQpO1xuICB9LFxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKGVsZW0sIGV2ZW50LCBmdW5jLCBuZXdCb29sKSB7XG4gICAgdmFyIGJvb2wgPSBuZXdCb29sIHx8IGZhbHNlO1xuICAgIGlmIChlbGVtLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuYywgYm9vbCk7XG4gICAgfSBlbHNlIGlmIChlbGVtLmF0dGFjaEV2ZW50KSB7XG4gICAgICBlbGVtLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgZnVuYyk7XG4gICAgfVxuICAgIHJldHVybiBkb207XG4gIH0sXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKGVsZW0sIGV2ZW50LCBmdW5jLCBuZXdCb29sKSB7XG4gICAgdmFyIGJvb2wgPSBuZXdCb29sIHx8IGZhbHNlO1xuICAgIGlmIChlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuYywgYm9vbCk7XG4gICAgfSBlbHNlIGlmIChlbGVtLmRldGFjaEV2ZW50KSB7XG4gICAgICBlbGVtLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgZnVuYyk7XG4gICAgfVxuICAgIHJldHVybiBkb207XG4gIH0sXG4gIGFkZENsYXNzOiBmdW5jdGlvbiBhZGRDbGFzcyhlbGVtLCBjbGFzc05hbWUpIHtcbiAgICBpZiAoZWxlbS5jbGFzc05hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgfSBlbHNlIGlmIChlbGVtLmNsYXNzTmFtZSAhPT0gY2xhc3NOYW1lKSB7XG4gICAgICB2YXIgY2xhc3NlcyA9IGVsZW0uY2xhc3NOYW1lLnNwbGl0KC8gKy8pO1xuICAgICAgaWYgKGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpID09PSAtMSkge1xuICAgICAgICBjbGFzc2VzLnB1c2goY2xhc3NOYW1lKTtcbiAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKS5yZXBsYWNlKC9eXFxzKy8sICcnKS5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRvbTtcbiAgfSxcbiAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW0sIGNsYXNzTmFtZSkge1xuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgIGlmIChlbGVtLmNsYXNzTmFtZSA9PT0gY2xhc3NOYW1lKSB7XG4gICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBlbGVtLmNsYXNzTmFtZS5zcGxpdCgvICsvKTtcbiAgICAgICAgdmFyIGluZGV4ID0gY2xhc3Nlcy5pbmRleE9mKGNsYXNzTmFtZSk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBjbGFzc2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtLmNsYXNzTmFtZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGRvbTtcbiAgfSxcbiAgaGFzQ2xhc3M6IGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW0sIGNsYXNzTmFtZSkge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKCcoPzpefFxcXFxzKyknICsgY2xhc3NOYW1lICsgJyg/OlxcXFxzK3wkKScpLnRlc3QoZWxlbS5jbGFzc05hbWUpIHx8IGZhbHNlO1xuICB9LFxuICBnZXRXaWR0aDogZnVuY3Rpb24gZ2V0V2lkdGgoZWxlbSkge1xuICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbSk7XG4gICAgcmV0dXJuIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2JvcmRlci1sZWZ0LXdpZHRoJ10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnYm9yZGVyLXJpZ2h0LXdpZHRoJ10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy1sZWZ0J10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy1yaWdodCddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGUud2lkdGgpO1xuICB9LFxuICBnZXRIZWlnaHQ6IGZ1bmN0aW9uIGdldEhlaWdodChlbGVtKSB7XG4gICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKTtcbiAgICByZXR1cm4gY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnYm9yZGVyLXRvcC13aWR0aCddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2JvcmRlci1ib3R0b20td2lkdGgnXSkgKyBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydwYWRkaW5nLXRvcCddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ3BhZGRpbmctYm90dG9tJ10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZS5oZWlnaHQpO1xuICB9LFxuICBnZXRPZmZzZXQ6IGZ1bmN0aW9uIGdldE9mZnNldChlbCkge1xuICAgIHZhciBlbGVtID0gZWw7XG4gICAgdmFyIG9mZnNldCA9IHsgbGVmdDogMCwgdG9wOiAwIH07XG4gICAgaWYgKGVsZW0ub2Zmc2V0UGFyZW50KSB7XG4gICAgICBkbyB7XG4gICAgICAgIG9mZnNldC5sZWZ0ICs9IGVsZW0ub2Zmc2V0TGVmdDtcbiAgICAgICAgb2Zmc2V0LnRvcCArPSBlbGVtLm9mZnNldFRvcDtcbiAgICAgICAgZWxlbSA9IGVsZW0ub2Zmc2V0UGFyZW50O1xuICAgICAgfSB3aGlsZSAoZWxlbSk7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH0sXG4gIGlzQWN0aXZlOiBmdW5jdGlvbiBpc0FjdGl2ZShlbGVtKSB7XG4gICAgcmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYpO1xuICB9XG59O1xuXG52YXIgQm9vbGVhbkNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0NvbnRyb2xsZXIpIHtcbiAgaW5oZXJpdHMoQm9vbGVhbkNvbnRyb2xsZXIsIF9Db250cm9sbGVyKTtcbiAgZnVuY3Rpb24gQm9vbGVhbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEJvb2xlYW5Db250cm9sbGVyKTtcbiAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQm9vbGVhbkNvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCb29sZWFuQ29udHJvbGxlcikpLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSkpO1xuICAgIHZhciBfdGhpcyA9IF90aGlzMjtcbiAgICBfdGhpczIuX19wcmV2ID0gX3RoaXMyLmdldFZhbHVlKCk7XG4gICAgX3RoaXMyLl9fY2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIF90aGlzMi5fX2NoZWNrYm94LnNldEF0dHJpYnV0ZSgndHlwZScsICdjaGVja2JveCcpO1xuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICAgICAgX3RoaXMuc2V0VmFsdWUoIV90aGlzLl9fcHJldik7XG4gICAgfVxuICAgIGRvbS5iaW5kKF90aGlzMi5fX2NoZWNrYm94LCAnY2hhbmdlJywgb25DaGFuZ2UsIGZhbHNlKTtcbiAgICBfdGhpczIuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczIuX19jaGVja2JveCk7XG4gICAgX3RoaXMyLnVwZGF0ZURpc3BsYXkoKTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIGNyZWF0ZUNsYXNzKEJvb2xlYW5Db250cm9sbGVyLCBbe1xuICAgIGtleTogJ3NldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUodikge1xuICAgICAgdmFyIHRvUmV0dXJuID0gZ2V0KEJvb2xlYW5Db250cm9sbGVyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJvb2xlYW5Db250cm9sbGVyLnByb3RvdHlwZSksICdzZXRWYWx1ZScsIHRoaXMpLmNhbGwodGhpcywgdik7XG4gICAgICBpZiAodGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKHRoaXMsIHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9fcHJldiA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgIHJldHVybiB0b1JldHVybjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVEaXNwbGF5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICAgIGlmICh0aGlzLmdldFZhbHVlKCkgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fX2NoZWNrYm94LnNldEF0dHJpYnV0ZSgnY2hlY2tlZCcsICdjaGVja2VkJyk7XG4gICAgICAgIHRoaXMuX19jaGVja2JveC5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fX3ByZXYgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fX2NoZWNrYm94LmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fX3ByZXYgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXQoQm9vbGVhbkNvbnRyb2xsZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQm9vbGVhbkNvbnRyb2xsZXIucHJvdG90eXBlKSwgJ3VwZGF0ZURpc3BsYXknLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQm9vbGVhbkNvbnRyb2xsZXI7XG59KENvbnRyb2xsZXIpO1xuXG52YXIgT3B0aW9uQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhPcHRpb25Db250cm9sbGVyLCBfQ29udHJvbGxlcik7XG4gIGZ1bmN0aW9uIE9wdGlvbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSwgb3B0cykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE9wdGlvbkNvbnRyb2xsZXIpO1xuICAgIHZhciBfdGhpczIgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChPcHRpb25Db250cm9sbGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT3B0aW9uQ29udHJvbGxlcikpLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSkpO1xuICAgIHZhciBvcHRpb25zID0gb3B0cztcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG4gICAgX3RoaXMyLl9fc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG4gICAgaWYgKENvbW1vbi5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICB2YXIgbWFwID0ge307XG4gICAgICBDb21tb24uZWFjaChvcHRpb25zLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICBtYXBbZWxlbWVudF0gPSBlbGVtZW50O1xuICAgICAgfSk7XG4gICAgICBvcHRpb25zID0gbWFwO1xuICAgIH1cbiAgICBDb21tb24uZWFjaChvcHRpb25zLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgdmFyIG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgb3B0LmlubmVySFRNTCA9IGtleTtcbiAgICAgIG9wdC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgdmFsdWUpO1xuICAgICAgX3RoaXMuX19zZWxlY3QuYXBwZW5kQ2hpbGQob3B0KTtcbiAgICB9KTtcbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX3NlbGVjdCwgJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkZXNpcmVkVmFsdWUgPSB0aGlzLm9wdGlvbnNbdGhpcy5zZWxlY3RlZEluZGV4XS52YWx1ZTtcbiAgICAgIF90aGlzLnNldFZhbHVlKGRlc2lyZWRWYWx1ZSk7XG4gICAgfSk7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fc2VsZWN0KTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIGNyZWF0ZUNsYXNzKE9wdGlvbkNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAnc2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSh2KSB7XG4gICAgICB2YXIgdG9SZXR1cm4gPSBnZXQoT3B0aW9uQ29udHJvbGxlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihPcHRpb25Db250cm9sbGVyLnByb3RvdHlwZSksICdzZXRWYWx1ZScsIHRoaXMpLmNhbGwodGhpcywgdik7XG4gICAgICBpZiAodGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKHRoaXMsIHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9SZXR1cm47XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlRGlzcGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICBpZiAoZG9tLmlzQWN0aXZlKHRoaXMuX19zZWxlY3QpKSByZXR1cm4gdGhpcztcbiAgICAgIHRoaXMuX19zZWxlY3QudmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgICByZXR1cm4gZ2V0KE9wdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT3B0aW9uQ29udHJvbGxlci5wcm90b3R5cGUpLCAndXBkYXRlRGlzcGxheScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBPcHRpb25Db250cm9sbGVyO1xufShDb250cm9sbGVyKTtcblxudmFyIFN0cmluZ0NvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0NvbnRyb2xsZXIpIHtcbiAgaW5oZXJpdHMoU3RyaW5nQ29udHJvbGxlciwgX0NvbnRyb2xsZXIpO1xuICBmdW5jdGlvbiBTdHJpbmdDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTdHJpbmdDb250cm9sbGVyKTtcbiAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU3RyaW5nQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFN0cmluZ0NvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpKTtcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5fX2lucHV0LnZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25CbHVyKCkge1xuICAgICAgaWYgKF90aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgX3RoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKF90aGlzLCBfdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX3RoaXMyLl9faW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIF90aGlzMi5fX2lucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0Jyk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdrZXl1cCcsIG9uQ2hhbmdlKTtcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ2JsdXInLCBvbkJsdXIpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgICB0aGlzLmJsdXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX2lucHV0KTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIGNyZWF0ZUNsYXNzKFN0cmluZ0NvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAndXBkYXRlRGlzcGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICBpZiAoIWRvbS5pc0FjdGl2ZSh0aGlzLl9faW5wdXQpKSB7XG4gICAgICAgIHRoaXMuX19pbnB1dC52YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXQoU3RyaW5nQ29udHJvbGxlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTdHJpbmdDb250cm9sbGVyLnByb3RvdHlwZSksICd1cGRhdGVEaXNwbGF5JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFN0cmluZ0NvbnRyb2xsZXI7XG59KENvbnRyb2xsZXIpO1xuXG5mdW5jdGlvbiBudW1EZWNpbWFscyh4KSB7XG4gIHZhciBfeCA9IHgudG9TdHJpbmcoKTtcbiAgaWYgKF94LmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgcmV0dXJuIF94Lmxlbmd0aCAtIF94LmluZGV4T2YoJy4nKSAtIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG52YXIgTnVtYmVyQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhOdW1iZXJDb250cm9sbGVyLCBfQ29udHJvbGxlcik7XG4gIGZ1bmN0aW9uIE51bWJlckNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTnVtYmVyQ29udHJvbGxlcik7XG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTnVtYmVyQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE51bWJlckNvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpKTtcbiAgICB2YXIgX3BhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBfdGhpcy5fX21pbiA9IF9wYXJhbXMubWluO1xuICAgIF90aGlzLl9fbWF4ID0gX3BhcmFtcy5tYXg7XG4gICAgX3RoaXMuX19zdGVwID0gX3BhcmFtcy5zdGVwO1xuICAgIGlmIChDb21tb24uaXNVbmRlZmluZWQoX3RoaXMuX19zdGVwKSkge1xuICAgICAgaWYgKF90aGlzLmluaXRpYWxWYWx1ZSA9PT0gMCkge1xuICAgICAgICBfdGhpcy5fX2ltcGxpZWRTdGVwID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLl9faW1wbGllZFN0ZXAgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihNYXRoLmxvZyhNYXRoLmFicyhfdGhpcy5pbml0aWFsVmFsdWUpKSAvIE1hdGguTE4xMCkpIC8gMTA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzLl9faW1wbGllZFN0ZXAgPSBfdGhpcy5fX3N0ZXA7XG4gICAgfVxuICAgIF90aGlzLl9fcHJlY2lzaW9uID0gbnVtRGVjaW1hbHMoX3RoaXMuX19pbXBsaWVkU3RlcCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIGNyZWF0ZUNsYXNzKE51bWJlckNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAnc2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSh2KSB7XG4gICAgICB2YXIgX3YgPSB2O1xuICAgICAgaWYgKHRoaXMuX19taW4gIT09IHVuZGVmaW5lZCAmJiBfdiA8IHRoaXMuX19taW4pIHtcbiAgICAgICAgX3YgPSB0aGlzLl9fbWluO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9fbWF4ICE9PSB1bmRlZmluZWQgJiYgX3YgPiB0aGlzLl9fbWF4KSB7XG4gICAgICAgIF92ID0gdGhpcy5fX21heDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fc3RlcCAhPT0gdW5kZWZpbmVkICYmIF92ICUgdGhpcy5fX3N0ZXAgIT09IDApIHtcbiAgICAgICAgX3YgPSBNYXRoLnJvdW5kKF92IC8gdGhpcy5fX3N0ZXApICogdGhpcy5fX3N0ZXA7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0KE51bWJlckNvbnRyb2xsZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTnVtYmVyQ29udHJvbGxlci5wcm90b3R5cGUpLCAnc2V0VmFsdWUnLCB0aGlzKS5jYWxsKHRoaXMsIF92KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtaW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtaW4obWluVmFsdWUpIHtcbiAgICAgIHRoaXMuX19taW4gPSBtaW5WYWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ21heCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1heChtYXhWYWx1ZSkge1xuICAgICAgdGhpcy5fX21heCA9IG1heFZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3RlcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0ZXAoc3RlcFZhbHVlKSB7XG4gICAgICB0aGlzLl9fc3RlcCA9IHN0ZXBWYWx1ZTtcbiAgICAgIHRoaXMuX19pbXBsaWVkU3RlcCA9IHN0ZXBWYWx1ZTtcbiAgICAgIHRoaXMuX19wcmVjaXNpb24gPSBudW1EZWNpbWFscyhzdGVwVmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOdW1iZXJDb250cm9sbGVyO1xufShDb250cm9sbGVyKTtcblxuZnVuY3Rpb24gcm91bmRUb0RlY2ltYWwodmFsdWUsIGRlY2ltYWxzKSB7XG4gIHZhciB0ZW5UbyA9IE1hdGgucG93KDEwLCBkZWNpbWFscyk7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogdGVuVG8pIC8gdGVuVG87XG59XG52YXIgTnVtYmVyQ29udHJvbGxlckJveCA9IGZ1bmN0aW9uIChfTnVtYmVyQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhOdW1iZXJDb250cm9sbGVyQm94LCBfTnVtYmVyQ29udHJvbGxlcik7XG4gIGZ1bmN0aW9uIE51bWJlckNvbnRyb2xsZXJCb3gob2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTnVtYmVyQ29udHJvbGxlckJveCk7XG4gICAgdmFyIF90aGlzMiA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKE51bWJlckNvbnRyb2xsZXJCb3guX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihOdW1iZXJDb250cm9sbGVyQm94KSkuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5LCBwYXJhbXMpKTtcbiAgICBfdGhpczIuX190cnVuY2F0aW9uU3VzcGVuZGVkID0gZmFsc2U7XG4gICAgdmFyIF90aGlzID0gX3RoaXMyO1xuICAgIHZhciBwcmV2WSA9IHZvaWQgMDtcbiAgICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgIHZhciBhdHRlbXB0ZWQgPSBwYXJzZUZsb2F0KF90aGlzLl9faW5wdXQudmFsdWUpO1xuICAgICAgaWYgKCFDb21tb24uaXNOYU4oYXR0ZW1wdGVkKSkge1xuICAgICAgICBfdGhpcy5zZXRWYWx1ZShhdHRlbXB0ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbkZpbmlzaCgpIHtcbiAgICAgIGlmIChfdGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChfdGhpcywgX3RoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQmx1cigpIHtcbiAgICAgIG9uRmluaXNoKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VEcmFnKGUpIHtcbiAgICAgIHZhciBkaWZmID0gcHJldlkgLSBlLmNsaWVudFk7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5nZXRWYWx1ZSgpICsgZGlmZiAqIF90aGlzLl9faW1wbGllZFN0ZXApO1xuICAgICAgcHJldlkgPSBlLmNsaWVudFk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VVcCgpIHtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgIG9uRmluaXNoKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIG9uTW91c2VEcmFnKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgICAgcHJldlkgPSBlLmNsaWVudFk7XG4gICAgfVxuICAgIF90aGlzMi5fX2lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBfdGhpczIuX19pbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAnY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAnYmx1cicsIG9uQmx1cik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdtb3VzZWRvd24nLCBvbk1vdXNlRG93bik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdrZXlkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgIF90aGlzLl9fdHJ1bmNhdGlvblN1c3BlbmRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgICBfdGhpcy5fX3RydW5jYXRpb25TdXNwZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgb25GaW5pc2goKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX2lucHV0KTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIGNyZWF0ZUNsYXNzKE51bWJlckNvbnRyb2xsZXJCb3gsIFt7XG4gICAga2V5OiAndXBkYXRlRGlzcGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICB0aGlzLl9faW5wdXQudmFsdWUgPSB0aGlzLl9fdHJ1bmNhdGlvblN1c3BlbmRlZCA/IHRoaXMuZ2V0VmFsdWUoKSA6IHJvdW5kVG9EZWNpbWFsKHRoaXMuZ2V0VmFsdWUoKSwgdGhpcy5fX3ByZWNpc2lvbik7XG4gICAgICByZXR1cm4gZ2V0KE51bWJlckNvbnRyb2xsZXJCb3gucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTnVtYmVyQ29udHJvbGxlckJveC5wcm90b3R5cGUpLCAndXBkYXRlRGlzcGxheScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOdW1iZXJDb250cm9sbGVyQm94O1xufShOdW1iZXJDb250cm9sbGVyKTtcblxuZnVuY3Rpb24gbWFwKHYsIGkxLCBpMiwgbzEsIG8yKSB7XG4gIHJldHVybiBvMSArIChvMiAtIG8xKSAqICgodiAtIGkxKSAvIChpMiAtIGkxKSk7XG59XG52YXIgTnVtYmVyQ29udHJvbGxlclNsaWRlciA9IGZ1bmN0aW9uIChfTnVtYmVyQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhOdW1iZXJDb250cm9sbGVyU2xpZGVyLCBfTnVtYmVyQ29udHJvbGxlcik7XG4gIGZ1bmN0aW9uIE51bWJlckNvbnRyb2xsZXJTbGlkZXIob2JqZWN0LCBwcm9wZXJ0eSwgbWluLCBtYXgsIHN0ZXApIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBOdW1iZXJDb250cm9sbGVyU2xpZGVyKTtcbiAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTnVtYmVyQ29udHJvbGxlclNsaWRlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE51bWJlckNvbnRyb2xsZXJTbGlkZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHksIHsgbWluOiBtaW4sIG1heDogbWF4LCBzdGVwOiBzdGVwIH0pKTtcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG4gICAgX3RoaXMyLl9fYmFja2dyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIF90aGlzMi5fX2ZvcmVncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkb20uYmluZChfdGhpczIuX19iYWNrZ3JvdW5kLCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24pO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2JhY2tncm91bmQsICd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0KTtcbiAgICBkb20uYWRkQ2xhc3MoX3RoaXMyLl9fYmFja2dyb3VuZCwgJ3NsaWRlcicpO1xuICAgIGRvbS5hZGRDbGFzcyhfdGhpczIuX19mb3JlZ3JvdW5kLCAnc2xpZGVyLWZnJyk7XG4gICAgZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xuICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBvbk1vdXNlRHJhZyk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgIG9uTW91c2VEcmFnKGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1vdXNlRHJhZyhlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB2YXIgYmdSZWN0ID0gX3RoaXMuX19iYWNrZ3JvdW5kLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgX3RoaXMuc2V0VmFsdWUobWFwKGUuY2xpZW50WCwgYmdSZWN0LmxlZnQsIGJnUmVjdC5yaWdodCwgX3RoaXMuX19taW4sIF90aGlzLl9fbWF4KSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VVcCgpIHtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgIGlmIChfdGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChfdGhpcywgX3RoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uVG91Y2hTdGFydChlKSB7XG4gICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaGVuZCcsIG9uVG91Y2hFbmQpO1xuICAgICAgb25Ub3VjaE1vdmUoZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uVG91Y2hNb3ZlKGUpIHtcbiAgICAgIHZhciBjbGllbnRYID0gZS50b3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICB2YXIgYmdSZWN0ID0gX3RoaXMuX19iYWNrZ3JvdW5kLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgX3RoaXMuc2V0VmFsdWUobWFwKGNsaWVudFgsIGJnUmVjdC5sZWZ0LCBiZ1JlY3QucmlnaHQsIF90aGlzLl9fbWluLCBfdGhpcy5fX21heCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvblRvdWNoRW5kKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCk7XG4gICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuICAgIF90aGlzMi5fX2JhY2tncm91bmQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fZm9yZWdyb3VuZCk7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fYmFja2dyb3VuZCk7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuICBjcmVhdGVDbGFzcyhOdW1iZXJDb250cm9sbGVyU2xpZGVyLCBbe1xuICAgIGtleTogJ3VwZGF0ZURpc3BsYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgICAgdmFyIHBjdCA9ICh0aGlzLmdldFZhbHVlKCkgLSB0aGlzLl9fbWluKSAvICh0aGlzLl9fbWF4IC0gdGhpcy5fX21pbik7XG4gICAgICB0aGlzLl9fZm9yZWdyb3VuZC5zdHlsZS53aWR0aCA9IHBjdCAqIDEwMCArICclJztcbiAgICAgIHJldHVybiBnZXQoTnVtYmVyQ29udHJvbGxlclNsaWRlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihOdW1iZXJDb250cm9sbGVyU2xpZGVyLnByb3RvdHlwZSksICd1cGRhdGVEaXNwbGF5JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE51bWJlckNvbnRyb2xsZXJTbGlkZXI7XG59KE51bWJlckNvbnRyb2xsZXIpO1xuXG52YXIgRnVuY3Rpb25Db250cm9sbGVyID0gZnVuY3Rpb24gKF9Db250cm9sbGVyKSB7XG4gIGluaGVyaXRzKEZ1bmN0aW9uQ29udHJvbGxlciwgX0NvbnRyb2xsZXIpO1xuICBmdW5jdGlvbiBGdW5jdGlvbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSwgdGV4dCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEZ1bmN0aW9uQ29udHJvbGxlcik7XG4gICAgdmFyIF90aGlzMiA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEZ1bmN0aW9uQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEZ1bmN0aW9uQ29udHJvbGxlcikpLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSkpO1xuICAgIHZhciBfdGhpcyA9IF90aGlzMjtcbiAgICBfdGhpczIuX19idXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBfdGhpczIuX19idXR0b24uaW5uZXJIVE1MID0gdGV4dCA9PT0gdW5kZWZpbmVkID8gJ0ZpcmUnIDogdGV4dDtcbiAgICBkb20uYmluZChfdGhpczIuX19idXR0b24sICdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBfdGhpcy5maXJlKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgZG9tLmFkZENsYXNzKF90aGlzMi5fX2J1dHRvbiwgJ2J1dHRvbicpO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX2J1dHRvbik7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuICBjcmVhdGVDbGFzcyhGdW5jdGlvbkNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAnZmlyZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpcmUoKSB7XG4gICAgICBpZiAodGhpcy5fX29uQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX19vbkNoYW5nZS5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5nZXRWYWx1ZSgpLmNhbGwodGhpcy5vYmplY3QpO1xuICAgICAgaWYgKHRoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbCh0aGlzLCB0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRnVuY3Rpb25Db250cm9sbGVyO1xufShDb250cm9sbGVyKTtcblxudmFyIENvbG9yQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhDb2xvckNvbnRyb2xsZXIsIF9Db250cm9sbGVyKTtcbiAgZnVuY3Rpb24gQ29sb3JDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDb2xvckNvbnRyb2xsZXIpO1xuICAgIHZhciBfdGhpczIgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDb2xvckNvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDb2xvckNvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpKTtcbiAgICBfdGhpczIuX19jb2xvciA9IG5ldyBDb2xvcihfdGhpczIuZ2V0VmFsdWUoKSk7XG4gICAgX3RoaXMyLl9fdGVtcCA9IG5ldyBDb2xvcigwKTtcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkb20ubWFrZVNlbGVjdGFibGUoX3RoaXMyLmRvbUVsZW1lbnQsIGZhbHNlKTtcbiAgICBfdGhpczIuX19zZWxlY3RvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIF90aGlzMi5fX3NlbGVjdG9yLmNsYXNzTmFtZSA9ICdzZWxlY3Rvcic7XG4gICAgX3RoaXMyLl9fc2F0dXJhdGlvbl9maWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIF90aGlzMi5fX3NhdHVyYXRpb25fZmllbGQuY2xhc3NOYW1lID0gJ3NhdHVyYXRpb24tZmllbGQnO1xuICAgIF90aGlzMi5fX2ZpZWxkX2tub2IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBfdGhpczIuX19maWVsZF9rbm9iLmNsYXNzTmFtZSA9ICdmaWVsZC1rbm9iJztcbiAgICBfdGhpczIuX19maWVsZF9rbm9iX2JvcmRlciA9ICcycHggc29saWQgJztcbiAgICBfdGhpczIuX19odWVfa25vYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIF90aGlzMi5fX2h1ZV9rbm9iLmNsYXNzTmFtZSA9ICdodWUta25vYic7XG4gICAgX3RoaXMyLl9faHVlX2ZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgX3RoaXMyLl9faHVlX2ZpZWxkLmNsYXNzTmFtZSA9ICdodWUtZmllbGQnO1xuICAgIF90aGlzMi5fX2lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBfdGhpczIuX19pbnB1dC50eXBlID0gJ3RleHQnO1xuICAgIF90aGlzMi5fX2lucHV0X3RleHRTaGFkb3cgPSAnMCAxcHggMXB4ICc7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdrZXlkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgIG9uQmx1ci5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAnYmx1cicsIG9uQmx1cik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fc2VsZWN0b3IsICdtb3VzZWRvd24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICBkb20uYWRkQ2xhc3ModGhpcywgJ2RyYWcnKS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcyhfdGhpcy5fX3NlbGVjdG9yLCAnZHJhZycpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fc2VsZWN0b3IsICd0b3VjaHN0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgZG9tLmFkZENsYXNzKHRoaXMsICdkcmFnJykuYmluZCh3aW5kb3csICd0b3VjaGVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9tLnJlbW92ZUNsYXNzKF90aGlzLl9fc2VsZWN0b3IsICdkcmFnJyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgdmFsdWVGaWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIENvbW1vbi5leHRlbmQoX3RoaXMyLl9fc2VsZWN0b3Iuc3R5bGUsIHtcbiAgICAgIHdpZHRoOiAnMTIycHgnLFxuICAgICAgaGVpZ2h0OiAnMTAycHgnLFxuICAgICAgcGFkZGluZzogJzNweCcsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMjIyJyxcbiAgICAgIGJveFNoYWRvdzogJzBweCAxcHggM3B4IHJnYmEoMCwwLDAsMC4zKSdcbiAgICB9KTtcbiAgICBDb21tb24uZXh0ZW5kKF90aGlzMi5fX2ZpZWxkX2tub2Iuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgd2lkdGg6ICcxMnB4JyxcbiAgICAgIGhlaWdodDogJzEycHgnLFxuICAgICAgYm9yZGVyOiBfdGhpczIuX19maWVsZF9rbm9iX2JvcmRlciArIChfdGhpczIuX19jb2xvci52IDwgMC41ID8gJyNmZmYnIDogJyMwMDAnKSxcbiAgICAgIGJveFNoYWRvdzogJzBweCAxcHggM3B4IHJnYmEoMCwwLDAsMC41KScsXG4gICAgICBib3JkZXJSYWRpdXM6ICcxMnB4JyxcbiAgICAgIHpJbmRleDogMVxuICAgIH0pO1xuICAgIENvbW1vbi5leHRlbmQoX3RoaXMyLl9faHVlX2tub2Iuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgd2lkdGg6ICcxNXB4JyxcbiAgICAgIGhlaWdodDogJzJweCcsXG4gICAgICBib3JkZXJSaWdodDogJzRweCBzb2xpZCAjZmZmJyxcbiAgICAgIHpJbmRleDogMVxuICAgIH0pO1xuICAgIENvbW1vbi5leHRlbmQoX3RoaXMyLl9fc2F0dXJhdGlvbl9maWVsZC5zdHlsZSwge1xuICAgICAgd2lkdGg6ICcxMDBweCcsXG4gICAgICBoZWlnaHQ6ICcxMDBweCcsXG4gICAgICBib3JkZXI6ICcxcHggc29saWQgIzU1NScsXG4gICAgICBtYXJnaW5SaWdodDogJzNweCcsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgfSk7XG4gICAgQ29tbW9uLmV4dGVuZCh2YWx1ZUZpZWxkLnN0eWxlLCB7XG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICBiYWNrZ3JvdW5kOiAnbm9uZSdcbiAgICB9KTtcbiAgICBsaW5lYXJHcmFkaWVudCh2YWx1ZUZpZWxkLCAndG9wJywgJ3JnYmEoMCwwLDAsMCknLCAnIzAwMCcpO1xuICAgIENvbW1vbi5leHRlbmQoX3RoaXMyLl9faHVlX2ZpZWxkLnN0eWxlLCB7XG4gICAgICB3aWR0aDogJzE1cHgnLFxuICAgICAgaGVpZ2h0OiAnMTAwcHgnLFxuICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkICM1NTUnLFxuICAgICAgY3Vyc29yOiAnbnMtcmVzaXplJyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgdG9wOiAnM3B4JyxcbiAgICAgIHJpZ2h0OiAnM3B4J1xuICAgIH0pO1xuICAgIGh1ZUdyYWRpZW50KF90aGlzMi5fX2h1ZV9maWVsZCk7XG4gICAgQ29tbW9uLmV4dGVuZChfdGhpczIuX19pbnB1dC5zdHlsZSwge1xuICAgICAgb3V0bGluZTogJ25vbmUnLFxuICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICBib3JkZXI6IDAsXG4gICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG4gICAgICB0ZXh0U2hhZG93OiBfdGhpczIuX19pbnB1dF90ZXh0U2hhZG93ICsgJ3JnYmEoMCwwLDAsMC43KSdcbiAgICB9KTtcbiAgICBkb20uYmluZChfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkLCAnbW91c2Vkb3duJywgZmllbGREb3duKTtcbiAgICBkb20uYmluZChfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkLCAndG91Y2hzdGFydCcsIGZpZWxkRG93bik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fZmllbGRfa25vYiwgJ21vdXNlZG93bicsIGZpZWxkRG93bik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fZmllbGRfa25vYiwgJ3RvdWNoc3RhcnQnLCBmaWVsZERvd24pO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2h1ZV9maWVsZCwgJ21vdXNlZG93bicsIGZpZWxkRG93bkgpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2h1ZV9maWVsZCwgJ3RvdWNoc3RhcnQnLCBmaWVsZERvd25IKTtcbiAgICBmdW5jdGlvbiBmaWVsZERvd24oZSkge1xuICAgICAgc2V0U1YoZSk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRTVik7XG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaG1vdmUnLCBzZXRTVik7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgZmllbGRVcFNWKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgZmllbGRVcFNWKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmllbGREb3duSChlKSB7XG4gICAgICBzZXRIKGUpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgc2V0SCk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaG1vdmUnLCBzZXRIKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBmaWVsZFVwSCk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaGVuZCcsIGZpZWxkVXBIKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmllbGRVcFNWKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRTVik7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3RvdWNobW92ZScsIHNldFNWKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIGZpZWxkVXBTVik7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgZmllbGRVcFNWKTtcbiAgICAgIG9uRmluaXNoKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpZWxkVXBIKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRIKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAndG91Y2htb3ZlJywgc2V0SCk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBmaWVsZFVwSCk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgZmllbGRVcEgpO1xuICAgICAgb25GaW5pc2goKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25CbHVyKCkge1xuICAgICAgdmFyIGkgPSBpbnRlcnByZXQodGhpcy52YWx1ZSk7XG4gICAgICBpZiAoaSAhPT0gZmFsc2UpIHtcbiAgICAgICAgX3RoaXMuX19jb2xvci5fX3N0YXRlID0gaTtcbiAgICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuX19jb2xvci50b09yaWdpbmFsKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IF90aGlzLl9fY29sb3IudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25GaW5pc2goKSB7XG4gICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLl9fY29sb3IudG9PcmlnaW5hbCgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX3RoaXMyLl9fc2F0dXJhdGlvbl9maWVsZC5hcHBlbmRDaGlsZCh2YWx1ZUZpZWxkKTtcbiAgICBfdGhpczIuX19zZWxlY3Rvci5hcHBlbmRDaGlsZChfdGhpczIuX19maWVsZF9rbm9iKTtcbiAgICBfdGhpczIuX19zZWxlY3Rvci5hcHBlbmRDaGlsZChfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkKTtcbiAgICBfdGhpczIuX19zZWxlY3Rvci5hcHBlbmRDaGlsZChfdGhpczIuX19odWVfZmllbGQpO1xuICAgIF90aGlzMi5fX2h1ZV9maWVsZC5hcHBlbmRDaGlsZChfdGhpczIuX19odWVfa25vYik7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9faW5wdXQpO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX3NlbGVjdG9yKTtcbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuICAgIGZ1bmN0aW9uIHNldFNWKGUpIHtcbiAgICAgIGlmIChlLnR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gLTEpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgdmFyIGZpZWxkUmVjdCA9IF90aGlzLl9fc2F0dXJhdGlvbl9maWVsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBfcmVmID0gZS50b3VjaGVzICYmIGUudG91Y2hlc1swXSB8fCBlLFxuICAgICAgICAgIGNsaWVudFggPSBfcmVmLmNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WSA9IF9yZWYuY2xpZW50WTtcbiAgICAgIHZhciBzID0gKGNsaWVudFggLSBmaWVsZFJlY3QubGVmdCkgLyAoZmllbGRSZWN0LnJpZ2h0IC0gZmllbGRSZWN0LmxlZnQpO1xuICAgICAgdmFyIHYgPSAxIC0gKGNsaWVudFkgLSBmaWVsZFJlY3QudG9wKSAvIChmaWVsZFJlY3QuYm90dG9tIC0gZmllbGRSZWN0LnRvcCk7XG4gICAgICBpZiAodiA+IDEpIHtcbiAgICAgICAgdiA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHYgPCAwKSB7XG4gICAgICAgIHYgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHMgPiAxKSB7XG4gICAgICAgIHMgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzIDwgMCkge1xuICAgICAgICBzID0gMDtcbiAgICAgIH1cbiAgICAgIF90aGlzLl9fY29sb3IudiA9IHY7XG4gICAgICBfdGhpcy5fX2NvbG9yLnMgPSBzO1xuICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuX19jb2xvci50b09yaWdpbmFsKCkpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRIKGUpIHtcbiAgICAgIGlmIChlLnR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gLTEpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgdmFyIGZpZWxkUmVjdCA9IF90aGlzLl9faHVlX2ZpZWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIF9yZWYyID0gZS50b3VjaGVzICYmIGUudG91Y2hlc1swXSB8fCBlLFxuICAgICAgICAgIGNsaWVudFkgPSBfcmVmMi5jbGllbnRZO1xuICAgICAgdmFyIGggPSAxIC0gKGNsaWVudFkgLSBmaWVsZFJlY3QudG9wKSAvIChmaWVsZFJlY3QuYm90dG9tIC0gZmllbGRSZWN0LnRvcCk7XG4gICAgICBpZiAoaCA+IDEpIHtcbiAgICAgICAgaCA9IDE7XG4gICAgICB9IGVsc2UgaWYgKGggPCAwKSB7XG4gICAgICAgIGggPSAwO1xuICAgICAgfVxuICAgICAgX3RoaXMuX19jb2xvci5oID0gaCAqIDM2MDtcbiAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLl9fY29sb3IudG9PcmlnaW5hbCgpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuICBjcmVhdGVDbGFzcyhDb2xvckNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAndXBkYXRlRGlzcGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICB2YXIgaSA9IGludGVycHJldCh0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgaWYgKGkgIT09IGZhbHNlKSB7XG4gICAgICAgIHZhciBtaXNtYXRjaCA9IGZhbHNlO1xuICAgICAgICBDb21tb24uZWFjaChDb2xvci5DT01QT05FTlRTLCBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgaWYgKCFDb21tb24uaXNVbmRlZmluZWQoaVtjb21wb25lbnRdKSAmJiAhQ29tbW9uLmlzVW5kZWZpbmVkKHRoaXMuX19jb2xvci5fX3N0YXRlW2NvbXBvbmVudF0pICYmIGlbY29tcG9uZW50XSAhPT0gdGhpcy5fX2NvbG9yLl9fc3RhdGVbY29tcG9uZW50XSkge1xuICAgICAgICAgICAgbWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGlmIChtaXNtYXRjaCkge1xuICAgICAgICAgIENvbW1vbi5leHRlbmQodGhpcy5fX2NvbG9yLl9fc3RhdGUsIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBDb21tb24uZXh0ZW5kKHRoaXMuX190ZW1wLl9fc3RhdGUsIHRoaXMuX19jb2xvci5fX3N0YXRlKTtcbiAgICAgIHRoaXMuX190ZW1wLmEgPSAxO1xuICAgICAgdmFyIGZsaXAgPSB0aGlzLl9fY29sb3IudiA8IDAuNSB8fCB0aGlzLl9fY29sb3IucyA+IDAuNSA/IDI1NSA6IDA7XG4gICAgICB2YXIgX2ZsaXAgPSAyNTUgLSBmbGlwO1xuICAgICAgQ29tbW9uLmV4dGVuZCh0aGlzLl9fZmllbGRfa25vYi5zdHlsZSwge1xuICAgICAgICBtYXJnaW5MZWZ0OiAxMDAgKiB0aGlzLl9fY29sb3IucyAtIDcgKyAncHgnLFxuICAgICAgICBtYXJnaW5Ub3A6IDEwMCAqICgxIC0gdGhpcy5fX2NvbG9yLnYpIC0gNyArICdweCcsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5fX3RlbXAudG9IZXhTdHJpbmcoKSxcbiAgICAgICAgYm9yZGVyOiB0aGlzLl9fZmllbGRfa25vYl9ib3JkZXIgKyAncmdiKCcgKyBmbGlwICsgJywnICsgZmxpcCArICcsJyArIGZsaXAgKyAnKSdcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fX2h1ZV9rbm9iLnN0eWxlLm1hcmdpblRvcCA9ICgxIC0gdGhpcy5fX2NvbG9yLmggLyAzNjApICogMTAwICsgJ3B4JztcbiAgICAgIHRoaXMuX190ZW1wLnMgPSAxO1xuICAgICAgdGhpcy5fX3RlbXAudiA9IDE7XG4gICAgICBsaW5lYXJHcmFkaWVudCh0aGlzLl9fc2F0dXJhdGlvbl9maWVsZCwgJ2xlZnQnLCAnI2ZmZicsIHRoaXMuX190ZW1wLnRvSGV4U3RyaW5nKCkpO1xuICAgICAgdGhpcy5fX2lucHV0LnZhbHVlID0gdGhpcy5fX2NvbG9yLnRvU3RyaW5nKCk7XG4gICAgICBDb21tb24uZXh0ZW5kKHRoaXMuX19pbnB1dC5zdHlsZSwge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuX19jb2xvci50b0hleFN0cmluZygpLFxuICAgICAgICBjb2xvcjogJ3JnYignICsgZmxpcCArICcsJyArIGZsaXAgKyAnLCcgKyBmbGlwICsgJyknLFxuICAgICAgICB0ZXh0U2hhZG93OiB0aGlzLl9faW5wdXRfdGV4dFNoYWRvdyArICdyZ2JhKCcgKyBfZmxpcCArICcsJyArIF9mbGlwICsgJywnICsgX2ZsaXAgKyAnLC43KSdcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ29sb3JDb250cm9sbGVyO1xufShDb250cm9sbGVyKTtcbnZhciB2ZW5kb3JzID0gWyctbW96LScsICctby0nLCAnLXdlYmtpdC0nLCAnLW1zLScsICcnXTtcbmZ1bmN0aW9uIGxpbmVhckdyYWRpZW50KGVsZW0sIHgsIGEsIGIpIHtcbiAgZWxlbS5zdHlsZS5iYWNrZ3JvdW5kID0gJyc7XG4gIENvbW1vbi5lYWNoKHZlbmRvcnMsIGZ1bmN0aW9uICh2ZW5kb3IpIHtcbiAgICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6ICcgKyB2ZW5kb3IgKyAnbGluZWFyLWdyYWRpZW50KCcgKyB4ICsgJywgJyArIGEgKyAnIDAlLCAnICsgYiArICcgMTAwJSk7ICc7XG4gIH0pO1xufVxuZnVuY3Rpb24gaHVlR3JhZGllbnQoZWxlbSkge1xuICBlbGVtLnN0eWxlLmJhY2tncm91bmQgPSAnJztcbiAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtbW96LWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCAjZmYwMGZmIDE3JSwgIzAwMDBmZiAzNCUsICMwMGZmZmYgNTAlLCAjMDBmZjAwIDY3JSwgI2ZmZmYwMCA4NCUsICNmZjAwMDAgMTAwJSk7JztcbiAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCNmZjAwZmYgMTclLCMwMDAwZmYgMzQlLCMwMGZmZmYgNTAlLCMwMGZmMDAgNjclLCNmZmZmMDAgODQlLCNmZjAwMDAgMTAwJSk7JztcbiAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtby1saW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOyc7XG4gIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogLW1zLWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCNmZjAwZmYgMTclLCMwMDAwZmYgMzQlLCMwMGZmZmYgNTAlLCMwMGZmMDAgNjclLCNmZmZmMDAgODQlLCNmZjAwMDAgMTAwJSk7JztcbiAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOyc7XG59XG5cbnZhciBjc3MgPSB7XG4gIGxvYWQ6IGZ1bmN0aW9uIGxvYWQodXJsLCBpbmRvYykge1xuICAgIHZhciBkb2MgPSBpbmRvYyB8fCBkb2N1bWVudDtcbiAgICB2YXIgbGluayA9IGRvYy5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgbGluay50eXBlID0gJ3RleHQvY3NzJztcbiAgICBsaW5rLnJlbCA9ICdzdHlsZXNoZWV0JztcbiAgICBsaW5rLmhyZWYgPSB1cmw7XG4gICAgZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQobGluayk7XG4gIH0sXG4gIGluamVjdDogZnVuY3Rpb24gaW5qZWN0KGNzc0NvbnRlbnQsIGluZG9jKSB7XG4gICAgdmFyIGRvYyA9IGluZG9jIHx8IGRvY3VtZW50O1xuICAgIHZhciBpbmplY3RlZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgaW5qZWN0ZWQudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgaW5qZWN0ZWQuaW5uZXJIVE1MID0gY3NzQ29udGVudDtcbiAgICB2YXIgaGVhZCA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgIHRyeSB7XG4gICAgICBoZWFkLmFwcGVuZENoaWxkKGluamVjdGVkKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxuICB9XG59O1xuXG52YXIgc2F2ZURpYWxvZ0NvbnRlbnRzID0gXCI8ZGl2IGlkPVxcXCJkZy1zYXZlXFxcIiBjbGFzcz1cXFwiZGcgZGlhbG9ndWVcXFwiPlxcblxcbiAgSGVyZSdzIHRoZSBuZXcgbG9hZCBwYXJhbWV0ZXIgZm9yIHlvdXIgPGNvZGU+R1VJPC9jb2RlPidzIGNvbnN0cnVjdG9yOlxcblxcbiAgPHRleHRhcmVhIGlkPVxcXCJkZy1uZXctY29uc3RydWN0b3JcXFwiPjwvdGV4dGFyZWE+XFxuXFxuICA8ZGl2IGlkPVxcXCJkZy1zYXZlLWxvY2FsbHlcXFwiPlxcblxcbiAgICA8aW5wdXQgaWQ9XFxcImRnLWxvY2FsLXN0b3JhZ2VcXFwiIHR5cGU9XFxcImNoZWNrYm94XFxcIi8+IEF1dG9tYXRpY2FsbHkgc2F2ZVxcbiAgICB2YWx1ZXMgdG8gPGNvZGU+bG9jYWxTdG9yYWdlPC9jb2RlPiBvbiBleGl0LlxcblxcbiAgICA8ZGl2IGlkPVxcXCJkZy1sb2NhbC1leHBsYWluXFxcIj5UaGUgdmFsdWVzIHNhdmVkIHRvIDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4gd2lsbFxcbiAgICAgIG92ZXJyaWRlIHRob3NlIHBhc3NlZCB0byA8Y29kZT5kYXQuR1VJPC9jb2RlPidzIGNvbnN0cnVjdG9yLiBUaGlzIG1ha2VzIGl0XFxuICAgICAgZWFzaWVyIHRvIHdvcmsgaW5jcmVtZW50YWxseSwgYnV0IDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4gaXMgZnJhZ2lsZSxcXG4gICAgICBhbmQgeW91ciBmcmllbmRzIG1heSBub3Qgc2VlIHRoZSBzYW1lIHZhbHVlcyB5b3UgZG8uXFxuXFxuICAgIDwvZGl2PlxcblxcbiAgPC9kaXY+XFxuXFxuPC9kaXY+XCI7XG5cbnZhciBDb250cm9sbGVyRmFjdG9yeSA9IGZ1bmN0aW9uIENvbnRyb2xsZXJGYWN0b3J5KG9iamVjdCwgcHJvcGVydHkpIHtcbiAgdmFyIGluaXRpYWxWYWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gIGlmIChDb21tb24uaXNBcnJheShhcmd1bWVudHNbMl0pIHx8IENvbW1vbi5pc09iamVjdChhcmd1bWVudHNbMl0pKSB7XG4gICAgcmV0dXJuIG5ldyBPcHRpb25Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHksIGFyZ3VtZW50c1syXSk7XG4gIH1cbiAgaWYgKENvbW1vbi5pc051bWJlcihpbml0aWFsVmFsdWUpKSB7XG4gICAgaWYgKENvbW1vbi5pc051bWJlcihhcmd1bWVudHNbMl0pICYmIENvbW1vbi5pc051bWJlcihhcmd1bWVudHNbM10pKSB7XG4gICAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKGFyZ3VtZW50c1s0XSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJDb250cm9sbGVyU2xpZGVyKG9iamVjdCwgcHJvcGVydHksIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdLCBhcmd1bWVudHNbNF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBOdW1iZXJDb250cm9sbGVyU2xpZGVyKG9iamVjdCwgcHJvcGVydHksIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKTtcbiAgICB9XG4gICAgaWYgKENvbW1vbi5pc051bWJlcihhcmd1bWVudHNbNF0pKSB7XG4gICAgICByZXR1cm4gbmV3IE51bWJlckNvbnRyb2xsZXJCb3gob2JqZWN0LCBwcm9wZXJ0eSwgeyBtaW46IGFyZ3VtZW50c1syXSwgbWF4OiBhcmd1bWVudHNbM10sIHN0ZXA6IGFyZ3VtZW50c1s0XSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBOdW1iZXJDb250cm9sbGVyQm94KG9iamVjdCwgcHJvcGVydHksIHsgbWluOiBhcmd1bWVudHNbMl0sIG1heDogYXJndW1lbnRzWzNdIH0pO1xuICB9XG4gIGlmIChDb21tb24uaXNTdHJpbmcoaW5pdGlhbFZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgU3RyaW5nQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KTtcbiAgfVxuICBpZiAoQ29tbW9uLmlzRnVuY3Rpb24oaW5pdGlhbFZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb25Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHksICcnKTtcbiAgfVxuICBpZiAoQ29tbW9uLmlzQm9vbGVhbihpbml0aWFsVmFsdWUpKSB7XG4gICAgcmV0dXJuIG5ldyBCb29sZWFuQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbmZ1bmN0aW9uIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjaykge1xuICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xufVxudmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSQxID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHJlcXVlc3RBbmltYXRpb25GcmFtZTtcblxudmFyIENlbnRlcmVkRGl2ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDZW50ZXJlZERpdigpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDZW50ZXJlZERpdik7XG4gICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIENvbW1vbi5leHRlbmQodGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZSwge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwLjgpJyxcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgICB6SW5kZXg6ICcxMDAwJyxcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICBXZWJraXRUcmFuc2l0aW9uOiAnb3BhY2l0eSAwLjJzIGxpbmVhcicsXG4gICAgICB0cmFuc2l0aW9uOiAnb3BhY2l0eSAwLjJzIGxpbmVhcidcbiAgICB9KTtcbiAgICBkb20ubWFrZUZ1bGxzY3JlZW4odGhpcy5iYWNrZ3JvdW5kRWxlbWVudCk7XG4gICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgQ29tbW9uLmV4dGVuZCh0aGlzLmRvbUVsZW1lbnQuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgZGlzcGxheTogJ25vbmUnLFxuICAgICAgekluZGV4OiAnMTAwMScsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgV2Via2l0VHJhbnNpdGlvbjogJy13ZWJraXQtdHJhbnNmb3JtIDAuMnMgZWFzZS1vdXQsIG9wYWNpdHkgMC4ycyBsaW5lYXInLFxuICAgICAgdHJhbnNpdGlvbjogJ3RyYW5zZm9ybSAwLjJzIGVhc2Utb3V0LCBvcGFjaXR5IDAuMnMgbGluZWFyJ1xuICAgIH0pO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5iYWNrZ3JvdW5kRWxlbWVudCk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmRvbUVsZW1lbnQpO1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgZG9tLmJpbmQodGhpcy5iYWNrZ3JvdW5kRWxlbWVudCwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuaGlkZSgpO1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZUNsYXNzKENlbnRlcmVkRGl2LCBbe1xuICAgIGtleTogJ3Nob3cnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHRoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEuMSknO1xuICAgICAgdGhpcy5sYXlvdXQoKTtcbiAgICAgIENvbW1vbi5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICBfdGhpcy5kb21FbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICBfdGhpcy5kb21FbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdzY2FsZSgxKSc7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdoaWRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgaGlkZSA9IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICAgIF90aGlzLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgX3RoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgZG9tLnVuYmluZChfdGhpcy5kb21FbGVtZW50LCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xuICAgICAgICBkb20udW5iaW5kKF90aGlzLmRvbUVsZW1lbnQsICd0cmFuc2l0aW9uZW5kJywgaGlkZSk7XG4gICAgICAgIGRvbS51bmJpbmQoX3RoaXMuZG9tRWxlbWVudCwgJ29UcmFuc2l0aW9uRW5kJywgaGlkZSk7XG4gICAgICB9O1xuICAgICAgZG9tLmJpbmQodGhpcy5kb21FbGVtZW50LCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xuICAgICAgZG9tLmJpbmQodGhpcy5kb21FbGVtZW50LCAndHJhbnNpdGlvbmVuZCcsIGhpZGUpO1xuICAgICAgZG9tLmJpbmQodGhpcy5kb21FbGVtZW50LCAnb1RyYW5zaXRpb25FbmQnLCBoaWRlKTtcbiAgICAgIHRoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEuMSknO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xheW91dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxheW91dCgpIHtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5sZWZ0ID0gd2luZG93LmlubmVyV2lkdGggLyAyIC0gZG9tLmdldFdpZHRoKHRoaXMuZG9tRWxlbWVudCkgLyAyICsgJ3B4JztcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS50b3AgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyAyIC0gZG9tLmdldEhlaWdodCh0aGlzLmRvbUVsZW1lbnQpIC8gMiArICdweCc7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDZW50ZXJlZERpdjtcbn0oKTtcblxudmFyIHN0eWxlU2hlZXQgPSBfX18kaW5zZXJ0U3R5bGUoXCIuZGcgdWx7bGlzdC1zdHlsZTpub25lO21hcmdpbjowO3BhZGRpbmc6MDt3aWR0aDoxMDAlO2NsZWFyOmJvdGh9LmRnLmFje3Bvc2l0aW9uOmZpeGVkO3RvcDowO2xlZnQ6MDtyaWdodDowO2hlaWdodDowO3otaW5kZXg6MH0uZGc6bm90KC5hYykgLm1haW57b3ZlcmZsb3c6aGlkZGVufS5kZy5tYWluey13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7LW8tdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7LW1vei10cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGxpbmVhcjt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGxpbmVhcn0uZGcubWFpbi50YWxsZXItdGhhbi13aW5kb3d7b3ZlcmZsb3cteTphdXRvfS5kZy5tYWluLnRhbGxlci10aGFuLXdpbmRvdyAuY2xvc2UtYnV0dG9ue29wYWNpdHk6MTttYXJnaW4tdG9wOi0xcHg7Ym9yZGVyLXRvcDoxcHggc29saWQgIzJjMmMyY30uZGcubWFpbiB1bC5jbG9zZWQgLmNsb3NlLWJ1dHRvbntvcGFjaXR5OjEgIWltcG9ydGFudH0uZGcubWFpbjpob3ZlciAuY2xvc2UtYnV0dG9uLC5kZy5tYWluIC5jbG9zZS1idXR0b24uZHJhZ3tvcGFjaXR5OjF9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbnstd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSAuMXMgbGluZWFyOy1vLXRyYW5zaXRpb246b3BhY2l0eSAuMXMgbGluZWFyOy1tb3otdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7Ym9yZGVyOjA7bGluZS1oZWlnaHQ6MTlweDtoZWlnaHQ6MjBweDtjdXJzb3I6cG9pbnRlcjt0ZXh0LWFsaWduOmNlbnRlcjtiYWNrZ3JvdW5kLWNvbG9yOiMwMDB9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbi5jbG9zZS10b3B7cG9zaXRpb246cmVsYXRpdmV9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbi5jbG9zZS1ib3R0b217cG9zaXRpb246YWJzb2x1dGV9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMxMTF9LmRnLmF7ZmxvYXQ6cmlnaHQ7bWFyZ2luLXJpZ2h0OjE1cHg7b3ZlcmZsb3cteTp2aXNpYmxlfS5kZy5hLmhhcy1zYXZlPnVsLmNsb3NlLXRvcHttYXJnaW4tdG9wOjB9LmRnLmEuaGFzLXNhdmU+dWwuY2xvc2UtYm90dG9te21hcmdpbi10b3A6MjdweH0uZGcuYS5oYXMtc2F2ZT51bC5jbG9zZWR7bWFyZ2luLXRvcDowfS5kZy5hIC5zYXZlLXJvd3t0b3A6MDt6LWluZGV4OjEwMDJ9LmRnLmEgLnNhdmUtcm93LmNsb3NlLXRvcHtwb3NpdGlvbjpyZWxhdGl2ZX0uZGcuYSAuc2F2ZS1yb3cuY2xvc2UtYm90dG9te3Bvc2l0aW9uOmZpeGVkfS5kZyBsaXstd2Via2l0LXRyYW5zaXRpb246aGVpZ2h0IC4xcyBlYXNlLW91dDstby10cmFuc2l0aW9uOmhlaWdodCAuMXMgZWFzZS1vdXQ7LW1vei10cmFuc2l0aW9uOmhlaWdodCAuMXMgZWFzZS1vdXQ7dHJhbnNpdGlvbjpoZWlnaHQgLjFzIGVhc2Utb3V0Oy13ZWJraXQtdHJhbnNpdGlvbjpvdmVyZmxvdyAuMXMgbGluZWFyOy1vLXRyYW5zaXRpb246b3ZlcmZsb3cgLjFzIGxpbmVhcjstbW96LXRyYW5zaXRpb246b3ZlcmZsb3cgLjFzIGxpbmVhcjt0cmFuc2l0aW9uOm92ZXJmbG93IC4xcyBsaW5lYXJ9LmRnIGxpOm5vdCguZm9sZGVyKXtjdXJzb3I6YXV0bztoZWlnaHQ6MjdweDtsaW5lLWhlaWdodDoyN3B4O3BhZGRpbmc6MCA0cHggMCA1cHh9LmRnIGxpLmZvbGRlcntwYWRkaW5nOjA7Ym9yZGVyLWxlZnQ6NHB4IHNvbGlkIHJnYmEoMCwwLDAsMCl9LmRnIGxpLnRpdGxle2N1cnNvcjpwb2ludGVyO21hcmdpbi1sZWZ0Oi00cHh9LmRnIC5jbG9zZWQgbGk6bm90KC50aXRsZSksLmRnIC5jbG9zZWQgdWwgbGksLmRnIC5jbG9zZWQgdWwgbGk+KntoZWlnaHQ6MDtvdmVyZmxvdzpoaWRkZW47Ym9yZGVyOjB9LmRnIC5jcntjbGVhcjpib3RoO3BhZGRpbmctbGVmdDozcHg7aGVpZ2h0OjI3cHg7b3ZlcmZsb3c6aGlkZGVufS5kZyAucHJvcGVydHktbmFtZXtjdXJzb3I6ZGVmYXVsdDtmbG9hdDpsZWZ0O2NsZWFyOmxlZnQ7d2lkdGg6NDAlO292ZXJmbG93OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzfS5kZyAuY3IuZnVuY3Rpb24gLnByb3BlcnR5LW5hbWV7d2lkdGg6MTAwJX0uZGcgLmN7ZmxvYXQ6bGVmdDt3aWR0aDo2MCU7cG9zaXRpb246cmVsYXRpdmV9LmRnIC5jIGlucHV0W3R5cGU9dGV4dF17Ym9yZGVyOjA7bWFyZ2luLXRvcDo0cHg7cGFkZGluZzozcHg7d2lkdGg6MTAwJTtmbG9hdDpyaWdodH0uZGcgLmhhcy1zbGlkZXIgaW5wdXRbdHlwZT10ZXh0XXt3aWR0aDozMCU7bWFyZ2luLWxlZnQ6MH0uZGcgLnNsaWRlcntmbG9hdDpsZWZ0O3dpZHRoOjY2JTttYXJnaW4tbGVmdDotNXB4O21hcmdpbi1yaWdodDowO2hlaWdodDoxOXB4O21hcmdpbi10b3A6NHB4fS5kZyAuc2xpZGVyLWZne2hlaWdodDoxMDAlfS5kZyAuYyBpbnB1dFt0eXBlPWNoZWNrYm94XXttYXJnaW4tdG9wOjdweH0uZGcgLmMgc2VsZWN0e21hcmdpbi10b3A6NXB4fS5kZyAuY3IuZnVuY3Rpb24sLmRnIC5jci5mdW5jdGlvbiAucHJvcGVydHktbmFtZSwuZGcgLmNyLmZ1bmN0aW9uICosLmRnIC5jci5ib29sZWFuLC5kZyAuY3IuYm9vbGVhbiAqe2N1cnNvcjpwb2ludGVyfS5kZyAuY3IuY29sb3J7b3ZlcmZsb3c6dmlzaWJsZX0uZGcgLnNlbGVjdG9ye2Rpc3BsYXk6bm9uZTtwb3NpdGlvbjphYnNvbHV0ZTttYXJnaW4tbGVmdDotOXB4O21hcmdpbi10b3A6MjNweDt6LWluZGV4OjEwfS5kZyAuYzpob3ZlciAuc2VsZWN0b3IsLmRnIC5zZWxlY3Rvci5kcmFne2Rpc3BsYXk6YmxvY2t9LmRnIGxpLnNhdmUtcm93e3BhZGRpbmc6MH0uZGcgbGkuc2F2ZS1yb3cgLmJ1dHRvbntkaXNwbGF5OmlubGluZS1ibG9jaztwYWRkaW5nOjBweCA2cHh9LmRnLmRpYWxvZ3Vle2JhY2tncm91bmQtY29sb3I6IzIyMjt3aWR0aDo0NjBweDtwYWRkaW5nOjE1cHg7Zm9udC1zaXplOjEzcHg7bGluZS1oZWlnaHQ6MTVweH0jZGctbmV3LWNvbnN0cnVjdG9ye3BhZGRpbmc6MTBweDtjb2xvcjojMjIyO2ZvbnQtZmFtaWx5Ok1vbmFjbywgbW9ub3NwYWNlO2ZvbnQtc2l6ZToxMHB4O2JvcmRlcjowO3Jlc2l6ZTpub25lO2JveC1zaGFkb3c6aW5zZXQgMXB4IDFweCAxcHggIzg4ODt3b3JkLXdyYXA6YnJlYWstd29yZDttYXJnaW46MTJweCAwO2Rpc3BsYXk6YmxvY2s7d2lkdGg6NDQwcHg7b3ZlcmZsb3cteTpzY3JvbGw7aGVpZ2h0OjEwMHB4O3Bvc2l0aW9uOnJlbGF0aXZlfSNkZy1sb2NhbC1leHBsYWlue2Rpc3BsYXk6bm9uZTtmb250LXNpemU6MTFweDtsaW5lLWhlaWdodDoxN3B4O2JvcmRlci1yYWRpdXM6M3B4O2JhY2tncm91bmQtY29sb3I6IzMzMztwYWRkaW5nOjhweDttYXJnaW4tdG9wOjEwcHh9I2RnLWxvY2FsLWV4cGxhaW4gY29kZXtmb250LXNpemU6MTBweH0jZGF0LWd1aS1zYXZlLWxvY2FsbHl7ZGlzcGxheTpub25lfS5kZ3tjb2xvcjojZWVlO2ZvbnQ6MTFweCAnTHVjaWRhIEdyYW5kZScsIHNhbnMtc2VyaWY7dGV4dC1zaGFkb3c6MCAtMXB4IDAgIzExMX0uZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXJ7d2lkdGg6NXB4O2JhY2tncm91bmQ6IzFhMWExYX0uZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXItY29ybmVye2hlaWdodDowO2Rpc3BsYXk6bm9uZX0uZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWJ7Ym9yZGVyLXJhZGl1czo1cHg7YmFja2dyb3VuZDojNjc2NzY3fS5kZyBsaTpub3QoLmZvbGRlcil7YmFja2dyb3VuZDojMWExYTFhO2JvcmRlci1ib3R0b206MXB4IHNvbGlkICMyYzJjMmN9LmRnIGxpLnNhdmUtcm93e2xpbmUtaGVpZ2h0OjI1cHg7YmFja2dyb3VuZDojZGFkNWNiO2JvcmRlcjowfS5kZyBsaS5zYXZlLXJvdyBzZWxlY3R7bWFyZ2luLWxlZnQ6NXB4O3dpZHRoOjEwOHB4fS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9ue21hcmdpbi1sZWZ0OjVweDttYXJnaW4tdG9wOjFweDtib3JkZXItcmFkaXVzOjJweDtmb250LXNpemU6OXB4O2xpbmUtaGVpZ2h0OjdweDtwYWRkaW5nOjRweCA0cHggNXB4IDRweDtiYWNrZ3JvdW5kOiNjNWJkYWQ7Y29sb3I6I2ZmZjt0ZXh0LXNoYWRvdzowIDFweCAwICNiMGE1OGY7Ym94LXNoYWRvdzowIC0xcHggMCAjYjBhNThmO2N1cnNvcjpwb2ludGVyfS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9uLmdlYXJze2JhY2tncm91bmQ6I2M1YmRhZCB1cmwoZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBc0FBQUFOQ0FZQUFBQi85WlE3QUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUFRSkpSRUZVZU5waVlLQVUvUC8vUHdHSUMvQXBDQUJpQlNBVytJOEFDbEFjZ0t4UTRUOWhvTUFFVXJ4eDJRU0dONitlZ0RYKy92V1Q0ZTdOODJBTVlvUEF4L2V2d1dvWW9TWWJBQ1gyczdLeEN4emNzZXpEaDNldkZvREVCWVRFRXF5Y2dnV0F6QTlBdVVTUVFnZVlQYTlmUHY2L1lXbS9BY3g1SVBiN3R5L2Z3K1FaYmx3Njd2RHM4UjBZSHlRaGdPYngreUFKa0JxbUc1ZFBQRGgxYVBPR1IvZXVnVzBHNHZsSW9USWZ5RmNBK1Fla2hoSEpoUGRReGJpQUlndU1CVFFaclBENzEwOE02cm9XWURGUWlJQUF2NkFvdy8xYkZ3WGdpcytmMkxVQXlud29JYU5jejhYTngzRGw3TUVKVURHUXB4OWd0UThZQ3VlQitEMjZPRUNBQVFEYWR0N2U0NkQ0MlFBQUFBQkpSVTVFcmtKZ2dnPT0pIDJweCAxcHggbm8tcmVwZWF0O2hlaWdodDo3cHg7d2lkdGg6OHB4fS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2JhYjE5ZTtib3gtc2hhZG93OjAgLTFweCAwICNiMGE1OGZ9LmRnIGxpLmZvbGRlcntib3JkZXItYm90dG9tOjB9LmRnIGxpLnRpdGxle3BhZGRpbmctbGVmdDoxNnB4O2JhY2tncm91bmQ6IzAwMCB1cmwoZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQlFBRkFKRUFBUC8vLy9QejgvLy8vLy8vL3lINUJBRUFBQUlBTEFBQUFBQUZBQVVBQUFJSWxJK2hLZ0Z4b0NnQU93PT0pIDZweCAxMHB4IG5vLXJlcGVhdDtjdXJzb3I6cG9pbnRlcjtib3JkZXItYm90dG9tOjFweCBzb2xpZCByZ2JhKDI1NSwyNTUsMjU1LDAuMil9LmRnIC5jbG9zZWQgbGkudGl0bGV7YmFja2dyb3VuZC1pbWFnZTp1cmwoZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQlFBRkFKRUFBUC8vLy9QejgvLy8vLy8vL3lINUJBRUFBQUlBTEFBQUFBQUZBQVVBQUFJSWxHSVdxTUNiV0FFQU93PT0pfS5kZyAuY3IuYm9vbGVhbntib3JkZXItbGVmdDozcHggc29saWQgIzgwNjc4N30uZGcgLmNyLmNvbG9ye2JvcmRlci1sZWZ0OjNweCBzb2xpZH0uZGcgLmNyLmZ1bmN0aW9ue2JvcmRlci1sZWZ0OjNweCBzb2xpZCAjZTYxZDVmfS5kZyAuY3IubnVtYmVye2JvcmRlci1sZWZ0OjNweCBzb2xpZCAjMkZBMUQ2fS5kZyAuY3IubnVtYmVyIGlucHV0W3R5cGU9dGV4dF17Y29sb3I6IzJGQTFENn0uZGcgLmNyLnN0cmluZ3tib3JkZXItbGVmdDozcHggc29saWQgIzFlZDM2Zn0uZGcgLmNyLnN0cmluZyBpbnB1dFt0eXBlPXRleHRde2NvbG9yOiMxZWQzNmZ9LmRnIC5jci5mdW5jdGlvbjpob3ZlciwuZGcgLmNyLmJvb2xlYW46aG92ZXJ7YmFja2dyb3VuZDojMTExfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRde2JhY2tncm91bmQ6IzMwMzAzMDtvdXRsaW5lOm5vbmV9LmRnIC5jIGlucHV0W3R5cGU9dGV4dF06aG92ZXJ7YmFja2dyb3VuZDojM2MzYzNjfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRdOmZvY3Vze2JhY2tncm91bmQ6IzQ5NDk0OTtjb2xvcjojZmZmfS5kZyAuYyAuc2xpZGVye2JhY2tncm91bmQ6IzMwMzAzMDtjdXJzb3I6ZXctcmVzaXplfS5kZyAuYyAuc2xpZGVyLWZne2JhY2tncm91bmQ6IzJGQTFENjttYXgtd2lkdGg6MTAwJX0uZGcgLmMgLnNsaWRlcjpob3ZlcntiYWNrZ3JvdW5kOiMzYzNjM2N9LmRnIC5jIC5zbGlkZXI6aG92ZXIgLnNsaWRlci1mZ3tiYWNrZ3JvdW5kOiM0NGFiZGF9XFxuXCIpO1xuXG5jc3MuaW5qZWN0KHN0eWxlU2hlZXQpO1xudmFyIENTU19OQU1FU1BBQ0UgPSAnZGcnO1xudmFyIEhJREVfS0VZX0NPREUgPSA3MjtcbnZhciBDTE9TRV9CVVRUT05fSEVJR0hUID0gMjA7XG52YXIgREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FID0gJ0RlZmF1bHQnO1xudmFyIFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UgPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSgpO1xudmFyIFNBVkVfRElBTE9HVUUgPSB2b2lkIDA7XG52YXIgYXV0b1BsYWNlVmlyZ2luID0gdHJ1ZTtcbnZhciBhdXRvUGxhY2VDb250YWluZXIgPSB2b2lkIDA7XG52YXIgaGlkZSA9IGZhbHNlO1xudmFyIGhpZGVhYmxlR3VpcyA9IFtdO1xudmFyIEdVSSA9IGZ1bmN0aW9uIEdVSShwYXJzKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIHZhciBwYXJhbXMgPSBwYXJzIHx8IHt9O1xuICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5fX3VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcbiAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX191bCk7XG4gIGRvbS5hZGRDbGFzcyh0aGlzLmRvbUVsZW1lbnQsIENTU19OQU1FU1BBQ0UpO1xuICB0aGlzLl9fZm9sZGVycyA9IHt9O1xuICB0aGlzLl9fY29udHJvbGxlcnMgPSBbXTtcbiAgdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzID0gW107XG4gIHRoaXMuX19yZW1lbWJlcmVkT2JqZWN0SW5kZWNlc1RvQ29udHJvbGxlcnMgPSBbXTtcbiAgdGhpcy5fX2xpc3RlbmluZyA9IFtdO1xuICBwYXJhbXMgPSBDb21tb24uZGVmYXVsdHMocGFyYW1zLCB7XG4gICAgY2xvc2VPblRvcDogZmFsc2UsXG4gICAgYXV0b1BsYWNlOiB0cnVlLFxuICAgIHdpZHRoOiBHVUkuREVGQVVMVF9XSURUSFxuICB9KTtcbiAgcGFyYW1zID0gQ29tbW9uLmRlZmF1bHRzKHBhcmFtcywge1xuICAgIHJlc2l6YWJsZTogcGFyYW1zLmF1dG9QbGFjZSxcbiAgICBoaWRlYWJsZTogcGFyYW1zLmF1dG9QbGFjZVxuICB9KTtcbiAgaWYgKCFDb21tb24uaXNVbmRlZmluZWQocGFyYW1zLmxvYWQpKSB7XG4gICAgaWYgKHBhcmFtcy5wcmVzZXQpIHtcbiAgICAgIHBhcmFtcy5sb2FkLnByZXNldCA9IHBhcmFtcy5wcmVzZXQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhcmFtcy5sb2FkID0geyBwcmVzZXQ6IERFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRSB9O1xuICB9XG4gIGlmIChDb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkgJiYgcGFyYW1zLmhpZGVhYmxlKSB7XG4gICAgaGlkZWFibGVHdWlzLnB1c2godGhpcyk7XG4gIH1cbiAgcGFyYW1zLnJlc2l6YWJsZSA9IENvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMucGFyZW50KSAmJiBwYXJhbXMucmVzaXphYmxlO1xuICBpZiAocGFyYW1zLmF1dG9QbGFjZSAmJiBDb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnNjcm9sbGFibGUpKSB7XG4gICAgcGFyYW1zLnNjcm9sbGFibGUgPSB0cnVlO1xuICB9XG4gIHZhciB1c2VMb2NhbFN0b3JhZ2UgPSBTVVBQT1JUU19MT0NBTF9TVE9SQUdFICYmIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2godGhpcywgJ2lzTG9jYWwnKSkgPT09ICd0cnVlJztcbiAgdmFyIHNhdmVUb0xvY2FsU3RvcmFnZSA9IHZvaWQgMDtcbiAgdmFyIHRpdGxlUm93ID0gdm9pZCAwO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLFxuICB7XG4gICAgcGFyZW50OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5wYXJlbnQ7XG4gICAgICB9XG4gICAgfSxcbiAgICBzY3JvbGxhYmxlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5zY3JvbGxhYmxlO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXV0b1BsYWNlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5hdXRvUGxhY2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbG9zZU9uVG9wOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5jbG9zZU9uVG9wO1xuICAgICAgfVxuICAgIH0sXG4gICAgcHJlc2V0OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgaWYgKF90aGlzLnBhcmVudCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRSb290KCkucHJlc2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXMubG9hZC5wcmVzZXQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xuICAgICAgICBpZiAoX3RoaXMucGFyZW50KSB7XG4gICAgICAgICAgX3RoaXMuZ2V0Um9vdCgpLnByZXNldCA9IHY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyYW1zLmxvYWQucHJlc2V0ID0gdjtcbiAgICAgICAgfVxuICAgICAgICBzZXRQcmVzZXRTZWxlY3RJbmRleCh0aGlzKTtcbiAgICAgICAgX3RoaXMucmV2ZXJ0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB3aWR0aDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMud2lkdGg7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xuICAgICAgICBwYXJhbXMud2lkdGggPSB2O1xuICAgICAgICBzZXRXaWR0aChfdGhpcywgdik7XG4gICAgICB9XG4gICAgfSxcbiAgICBuYW1lOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5uYW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcbiAgICAgICAgcGFyYW1zLm5hbWUgPSB2O1xuICAgICAgICBpZiAodGl0bGVSb3cpIHtcbiAgICAgICAgICB0aXRsZVJvdy5pbm5lckhUTUwgPSBwYXJhbXMubmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY2xvc2VkOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5jbG9zZWQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xuICAgICAgICBwYXJhbXMuY2xvc2VkID0gdjtcbiAgICAgICAgaWYgKHBhcmFtcy5jbG9zZWQpIHtcbiAgICAgICAgICBkb20uYWRkQ2xhc3MoX3RoaXMuX191bCwgR1VJLkNMQVNTX0NMT1NFRCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKF90aGlzLl9fdWwsIEdVSS5DTEFTU19DTE9TRUQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25SZXNpemUoKTtcbiAgICAgICAgaWYgKF90aGlzLl9fY2xvc2VCdXR0b24pIHtcbiAgICAgICAgICBfdGhpcy5fX2Nsb3NlQnV0dG9uLmlubmVySFRNTCA9IHYgPyBHVUkuVEVYVF9PUEVOIDogR1VJLlRFWFRfQ0xPU0VEO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBsb2FkOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5sb2FkO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlTG9jYWxTdG9yYWdlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHVzZUxvY2FsU3RvcmFnZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShib29sKSB7XG4gICAgICAgIGlmIChTVVBQT1JUU19MT0NBTF9TVE9SQUdFKSB7XG4gICAgICAgICAgdXNlTG9jYWxTdG9yYWdlID0gYm9vbDtcbiAgICAgICAgICBpZiAoYm9vbCkge1xuICAgICAgICAgICAgZG9tLmJpbmQod2luZG93LCAndW5sb2FkJywgc2F2ZVRvTG9jYWxTdG9yYWdlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9tLnVuYmluZCh3aW5kb3csICd1bmxvYWQnLCBzYXZlVG9Mb2NhbFN0b3JhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKF90aGlzLCAnaXNMb2NhbCcpLCBib29sKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGlmIChDb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkpIHtcbiAgICB0aGlzLmNsb3NlZCA9IHBhcmFtcy5jbG9zZWQgfHwgZmFsc2U7XG4gICAgZG9tLmFkZENsYXNzKHRoaXMuZG9tRWxlbWVudCwgR1VJLkNMQVNTX01BSU4pO1xuICAgIGRvbS5tYWtlU2VsZWN0YWJsZSh0aGlzLmRvbUVsZW1lbnQsIGZhbHNlKTtcbiAgICBpZiAoU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSkge1xuICAgICAgaWYgKHVzZUxvY2FsU3RvcmFnZSkge1xuICAgICAgICBfdGhpcy51c2VMb2NhbFN0b3JhZ2UgPSB0cnVlO1xuICAgICAgICB2YXIgc2F2ZWRHdWkgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKHRoaXMsICdndWknKSk7XG4gICAgICAgIGlmIChzYXZlZEd1aSkge1xuICAgICAgICAgIHBhcmFtcy5sb2FkID0gSlNPTi5wYXJzZShzYXZlZEd1aSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fX2Nsb3NlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fX2Nsb3NlQnV0dG9uLmlubmVySFRNTCA9IEdVSS5URVhUX0NMT1NFRDtcbiAgICBkb20uYWRkQ2xhc3ModGhpcy5fX2Nsb3NlQnV0dG9uLCBHVUkuQ0xBU1NfQ0xPU0VfQlVUVE9OKTtcbiAgICBpZiAocGFyYW1zLmNsb3NlT25Ub3ApIHtcbiAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLl9fY2xvc2VCdXR0b24sIEdVSS5DTEFTU19DTE9TRV9UT1ApO1xuICAgICAgdGhpcy5kb21FbGVtZW50Lmluc2VydEJlZm9yZSh0aGlzLl9fY2xvc2VCdXR0b24sIHRoaXMuZG9tRWxlbWVudC5jaGlsZE5vZGVzWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9tLmFkZENsYXNzKHRoaXMuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0NMT1NFX0JPVFRPTSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX2Nsb3NlQnV0dG9uKTtcbiAgICB9XG4gICAgZG9tLmJpbmQodGhpcy5fX2Nsb3NlQnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5jbG9zZWQgPSAhX3RoaXMuY2xvc2VkO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChwYXJhbXMuY2xvc2VkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhcmFtcy5jbG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgdGl0bGVSb3dOYW1lID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocGFyYW1zLm5hbWUpO1xuICAgIGRvbS5hZGRDbGFzcyh0aXRsZVJvd05hbWUsICdjb250cm9sbGVyLW5hbWUnKTtcbiAgICB0aXRsZVJvdyA9IGFkZFJvdyhfdGhpcywgdGl0bGVSb3dOYW1lKTtcbiAgICB2YXIgb25DbGlja1RpdGxlID0gZnVuY3Rpb24gb25DbGlja1RpdGxlKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIF90aGlzLmNsb3NlZCA9ICFfdGhpcy5jbG9zZWQ7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBkb20uYWRkQ2xhc3ModGhpcy5fX3VsLCBHVUkuQ0xBU1NfQ0xPU0VEKTtcbiAgICBkb20uYWRkQ2xhc3ModGl0bGVSb3csICd0aXRsZScpO1xuICAgIGRvbS5iaW5kKHRpdGxlUm93LCAnY2xpY2snLCBvbkNsaWNrVGl0bGUpO1xuICAgIGlmICghcGFyYW1zLmNsb3NlZCkge1xuICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKHBhcmFtcy5hdXRvUGxhY2UpIHtcbiAgICBpZiAoQ29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpKSB7XG4gICAgICBpZiAoYXV0b1BsYWNlVmlyZ2luKSB7XG4gICAgICAgIGF1dG9QbGFjZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBkb20uYWRkQ2xhc3MoYXV0b1BsYWNlQ29udGFpbmVyLCBDU1NfTkFNRVNQQUNFKTtcbiAgICAgICAgZG9tLmFkZENsYXNzKGF1dG9QbGFjZUNvbnRhaW5lciwgR1VJLkNMQVNTX0FVVE9fUExBQ0VfQ09OVEFJTkVSKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhdXRvUGxhY2VDb250YWluZXIpO1xuICAgICAgICBhdXRvUGxhY2VWaXJnaW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGF1dG9QbGFjZUNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbUVsZW1lbnQpO1xuICAgICAgZG9tLmFkZENsYXNzKHRoaXMuZG9tRWxlbWVudCwgR1VJLkNMQVNTX0FVVE9fUExBQ0UpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICBzZXRXaWR0aChfdGhpcywgcGFyYW1zLndpZHRoKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5fX3Jlc2l6ZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMub25SZXNpemVEZWJvdW5jZWQoKTtcbiAgfTtcbiAgZG9tLmJpbmQod2luZG93LCAncmVzaXplJywgdGhpcy5fX3Jlc2l6ZUhhbmRsZXIpO1xuICBkb20uYmluZCh0aGlzLl9fdWwsICd3ZWJraXRUcmFuc2l0aW9uRW5kJywgdGhpcy5fX3Jlc2l6ZUhhbmRsZXIpO1xuICBkb20uYmluZCh0aGlzLl9fdWwsICd0cmFuc2l0aW9uZW5kJywgdGhpcy5fX3Jlc2l6ZUhhbmRsZXIpO1xuICBkb20uYmluZCh0aGlzLl9fdWwsICdvVHJhbnNpdGlvbkVuZCcsIHRoaXMuX19yZXNpemVIYW5kbGVyKTtcbiAgdGhpcy5vblJlc2l6ZSgpO1xuICBpZiAocGFyYW1zLnJlc2l6YWJsZSkge1xuICAgIGFkZFJlc2l6ZUhhbmRsZSh0aGlzKTtcbiAgfVxuICBzYXZlVG9Mb2NhbFN0b3JhZ2UgPSBmdW5jdGlvbiBzYXZlVG9Mb2NhbFN0b3JhZ2UoKSB7XG4gICAgaWYgKFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UgJiYgbG9jYWxTdG9yYWdlLmdldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaChfdGhpcywgJ2lzTG9jYWwnKSkgPT09ICd0cnVlJykge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaChfdGhpcywgJ2d1aScpLCBKU09OLnN0cmluZ2lmeShfdGhpcy5nZXRTYXZlT2JqZWN0KCkpKTtcbiAgICB9XG4gIH07XG4gIHRoaXMuc2F2ZVRvTG9jYWxTdG9yYWdlSWZQb3NzaWJsZSA9IHNhdmVUb0xvY2FsU3RvcmFnZTtcbiAgZnVuY3Rpb24gcmVzZXRXaWR0aCgpIHtcbiAgICB2YXIgcm9vdCA9IF90aGlzLmdldFJvb3QoKTtcbiAgICByb290LndpZHRoICs9IDE7XG4gICAgQ29tbW9uLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJvb3Qud2lkdGggLT0gMTtcbiAgICB9KTtcbiAgfVxuICBpZiAoIXBhcmFtcy5wYXJlbnQpIHtcbiAgICByZXNldFdpZHRoKCk7XG4gIH1cbn07XG5HVUkudG9nZ2xlSGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgaGlkZSA9ICFoaWRlO1xuICBDb21tb24uZWFjaChoaWRlYWJsZUd1aXMsIGZ1bmN0aW9uIChndWkpIHtcbiAgICBndWkuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gaGlkZSA/ICdub25lJyA6ICcnO1xuICB9KTtcbn07XG5HVUkuQ0xBU1NfQVVUT19QTEFDRSA9ICdhJztcbkdVSS5DTEFTU19BVVRPX1BMQUNFX0NPTlRBSU5FUiA9ICdhYyc7XG5HVUkuQ0xBU1NfTUFJTiA9ICdtYWluJztcbkdVSS5DTEFTU19DT05UUk9MTEVSX1JPVyA9ICdjcic7XG5HVUkuQ0xBU1NfVE9PX1RBTEwgPSAndGFsbGVyLXRoYW4td2luZG93JztcbkdVSS5DTEFTU19DTE9TRUQgPSAnY2xvc2VkJztcbkdVSS5DTEFTU19DTE9TRV9CVVRUT04gPSAnY2xvc2UtYnV0dG9uJztcbkdVSS5DTEFTU19DTE9TRV9UT1AgPSAnY2xvc2UtdG9wJztcbkdVSS5DTEFTU19DTE9TRV9CT1RUT00gPSAnY2xvc2UtYm90dG9tJztcbkdVSS5DTEFTU19EUkFHID0gJ2RyYWcnO1xuR1VJLkRFRkFVTFRfV0lEVEggPSAyNDU7XG5HVUkuVEVYVF9DTE9TRUQgPSAnQ2xvc2UgQ29udHJvbHMnO1xuR1VJLlRFWFRfT1BFTiA9ICdPcGVuIENvbnRyb2xzJztcbkdVSS5fa2V5ZG93bkhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudC50eXBlICE9PSAndGV4dCcgJiYgKGUud2hpY2ggPT09IEhJREVfS0VZX0NPREUgfHwgZS5rZXlDb2RlID09PSBISURFX0tFWV9DT0RFKSkge1xuICAgIEdVSS50b2dnbGVIaWRlKCk7XG4gIH1cbn07XG5kb20uYmluZCh3aW5kb3csICdrZXlkb3duJywgR1VJLl9rZXlkb3duSGFuZGxlciwgZmFsc2UpO1xuQ29tbW9uLmV4dGVuZChHVUkucHJvdG90eXBlLFxue1xuICBhZGQ6IGZ1bmN0aW9uIGFkZChvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIF9hZGQodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSwge1xuICAgICAgZmFjdG9yeUFyZ3M6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMilcbiAgICB9KTtcbiAgfSxcbiAgYWRkQ29sb3I6IGZ1bmN0aW9uIGFkZENvbG9yKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICByZXR1cm4gX2FkZCh0aGlzLCBvYmplY3QsIHByb3BlcnR5LCB7XG4gICAgICBjb2xvcjogdHJ1ZVxuICAgIH0pO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShjb250cm9sbGVyKSB7XG4gICAgdGhpcy5fX3VsLnJlbW92ZUNoaWxkKGNvbnRyb2xsZXIuX19saSk7XG4gICAgdGhpcy5fX2NvbnRyb2xsZXJzLnNwbGljZSh0aGlzLl9fY29udHJvbGxlcnMuaW5kZXhPZihjb250cm9sbGVyKSwgMSk7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBDb21tb24uZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMub25SZXNpemUoKTtcbiAgICB9KTtcbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT25seSB0aGUgcm9vdCBHVUkgc2hvdWxkIGJlIHJlbW92ZWQgd2l0aCAuZGVzdHJveSgpLiAnICsgJ0ZvciBzdWJmb2xkZXJzLCB1c2UgZ3VpLnJlbW92ZUZvbGRlcihmb2xkZXIpIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmF1dG9QbGFjZSkge1xuICAgICAgYXV0b1BsYWNlQ29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuZG9tRWxlbWVudCk7XG4gICAgfVxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgQ29tbW9uLmVhY2godGhpcy5fX2ZvbGRlcnMsIGZ1bmN0aW9uIChzdWJmb2xkZXIpIHtcbiAgICAgIF90aGlzLnJlbW92ZUZvbGRlcihzdWJmb2xkZXIpO1xuICAgIH0pO1xuICAgIGRvbS51bmJpbmQod2luZG93LCAna2V5ZG93bicsIEdVSS5fa2V5ZG93bkhhbmRsZXIsIGZhbHNlKTtcbiAgICByZW1vdmVMaXN0ZW5lcnModGhpcyk7XG4gIH0sXG4gIGFkZEZvbGRlcjogZnVuY3Rpb24gYWRkRm9sZGVyKG5hbWUpIHtcbiAgICBpZiAodGhpcy5fX2ZvbGRlcnNbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgYWxyZWFkeSBoYXZlIGEgZm9sZGVyIGluIHRoaXMgR1VJIGJ5IHRoZScgKyAnIG5hbWUgXCInICsgbmFtZSArICdcIicpO1xuICAgIH1cbiAgICB2YXIgbmV3R3VpUGFyYW1zID0geyBuYW1lOiBuYW1lLCBwYXJlbnQ6IHRoaXMgfTtcbiAgICBuZXdHdWlQYXJhbXMuYXV0b1BsYWNlID0gdGhpcy5hdXRvUGxhY2U7XG4gICAgaWYgKHRoaXMubG9hZCAmJlxuICAgIHRoaXMubG9hZC5mb2xkZXJzICYmXG4gICAgdGhpcy5sb2FkLmZvbGRlcnNbbmFtZV0pIHtcbiAgICAgIG5ld0d1aVBhcmFtcy5jbG9zZWQgPSB0aGlzLmxvYWQuZm9sZGVyc1tuYW1lXS5jbG9zZWQ7XG4gICAgICBuZXdHdWlQYXJhbXMubG9hZCA9IHRoaXMubG9hZC5mb2xkZXJzW25hbWVdO1xuICAgIH1cbiAgICB2YXIgZ3VpID0gbmV3IEdVSShuZXdHdWlQYXJhbXMpO1xuICAgIHRoaXMuX19mb2xkZXJzW25hbWVdID0gZ3VpO1xuICAgIHZhciBsaSA9IGFkZFJvdyh0aGlzLCBndWkuZG9tRWxlbWVudCk7XG4gICAgZG9tLmFkZENsYXNzKGxpLCAnZm9sZGVyJyk7XG4gICAgcmV0dXJuIGd1aTtcbiAgfSxcbiAgcmVtb3ZlRm9sZGVyOiBmdW5jdGlvbiByZW1vdmVGb2xkZXIoZm9sZGVyKSB7XG4gICAgdGhpcy5fX3VsLnJlbW92ZUNoaWxkKGZvbGRlci5kb21FbGVtZW50LnBhcmVudEVsZW1lbnQpO1xuICAgIGRlbGV0ZSB0aGlzLl9fZm9sZGVyc1tmb2xkZXIubmFtZV07XG4gICAgaWYgKHRoaXMubG9hZCAmJlxuICAgIHRoaXMubG9hZC5mb2xkZXJzICYmXG4gICAgdGhpcy5sb2FkLmZvbGRlcnNbZm9sZGVyLm5hbWVdKSB7XG4gICAgICBkZWxldGUgdGhpcy5sb2FkLmZvbGRlcnNbZm9sZGVyLm5hbWVdO1xuICAgIH1cbiAgICByZW1vdmVMaXN0ZW5lcnMoZm9sZGVyKTtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIENvbW1vbi5lYWNoKGZvbGRlci5fX2ZvbGRlcnMsIGZ1bmN0aW9uIChzdWJmb2xkZXIpIHtcbiAgICAgIGZvbGRlci5yZW1vdmVGb2xkZXIoc3ViZm9sZGVyKTtcbiAgICB9KTtcbiAgICBDb21tb24uZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMub25SZXNpemUoKTtcbiAgICB9KTtcbiAgfSxcbiAgb3BlbjogZnVuY3Rpb24gb3BlbigpIHtcbiAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICB9LFxuICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICB9LFxuICBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9LFxuICBzaG93OiBmdW5jdGlvbiBzaG93KCkge1xuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gIH0sXG4gIG9uUmVzaXplOiBmdW5jdGlvbiBvblJlc2l6ZSgpIHtcbiAgICB2YXIgcm9vdCA9IHRoaXMuZ2V0Um9vdCgpO1xuICAgIGlmIChyb290LnNjcm9sbGFibGUpIHtcbiAgICAgIHZhciB0b3AgPSBkb20uZ2V0T2Zmc2V0KHJvb3QuX191bCkudG9wO1xuICAgICAgdmFyIGggPSAwO1xuICAgICAgQ29tbW9uLmVhY2gocm9vdC5fX3VsLmNoaWxkTm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmICghKHJvb3QuYXV0b1BsYWNlICYmIG5vZGUgPT09IHJvb3QuX19zYXZlX3JvdykpIHtcbiAgICAgICAgICBoICs9IGRvbS5nZXRIZWlnaHQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHdpbmRvdy5pbm5lckhlaWdodCAtIHRvcCAtIENMT1NFX0JVVFRPTl9IRUlHSFQgPCBoKSB7XG4gICAgICAgIGRvbS5hZGRDbGFzcyhyb290LmRvbUVsZW1lbnQsIEdVSS5DTEFTU19UT09fVEFMTCk7XG4gICAgICAgIHJvb3QuX191bC5zdHlsZS5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSB0b3AgLSBDTE9TRV9CVVRUT05fSEVJR0hUICsgJ3B4JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcyhyb290LmRvbUVsZW1lbnQsIEdVSS5DTEFTU19UT09fVEFMTCk7XG4gICAgICAgIHJvb3QuX191bC5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyb290Ll9fcmVzaXplX2hhbmRsZSkge1xuICAgICAgQ29tbW9uLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcm9vdC5fX3Jlc2l6ZV9oYW5kbGUuc3R5bGUuaGVpZ2h0ID0gcm9vdC5fX3VsLm9mZnNldEhlaWdodCArICdweCc7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHJvb3QuX19jbG9zZUJ1dHRvbikge1xuICAgICAgcm9vdC5fX2Nsb3NlQnV0dG9uLnN0eWxlLndpZHRoID0gcm9vdC53aWR0aCArICdweCc7XG4gICAgfVxuICB9LFxuICBvblJlc2l6ZURlYm91bmNlZDogQ29tbW9uLmRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm9uUmVzaXplKCk7XG4gIH0sIDUwKSxcbiAgcmVtZW1iZXI6IGZ1bmN0aW9uIHJlbWVtYmVyKCkge1xuICAgIGlmIChDb21tb24uaXNVbmRlZmluZWQoU0FWRV9ESUFMT0dVRSkpIHtcbiAgICAgIFNBVkVfRElBTE9HVUUgPSBuZXcgQ2VudGVyZWREaXYoKTtcbiAgICAgIFNBVkVfRElBTE9HVUUuZG9tRWxlbWVudC5pbm5lckhUTUwgPSBzYXZlRGlhbG9nQ29udGVudHM7XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2FuIG9ubHkgY2FsbCByZW1lbWJlciBvbiBhIHRvcCBsZXZlbCBHVUkuJyk7XG4gICAgfVxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgQ29tbW9uLmVhY2goQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSwgZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKF90aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGFkZFNhdmVNZW51KF90aGlzKTtcbiAgICAgIH1cbiAgICAgIGlmIChfdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzLmluZGV4T2Yob2JqZWN0KSA9PT0gLTEpIHtcbiAgICAgICAgX3RoaXMuX19yZW1lbWJlcmVkT2JqZWN0cy5wdXNoKG9iamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuYXV0b1BsYWNlKSB7XG4gICAgICBzZXRXaWR0aCh0aGlzLCB0aGlzLndpZHRoKTtcbiAgICB9XG4gIH0sXG4gIGdldFJvb3Q6IGZ1bmN0aW9uIGdldFJvb3QoKSB7XG4gICAgdmFyIGd1aSA9IHRoaXM7XG4gICAgd2hpbGUgKGd1aS5wYXJlbnQpIHtcbiAgICAgIGd1aSA9IGd1aS5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBndWk7XG4gIH0sXG4gIGdldFNhdmVPYmplY3Q6IGZ1bmN0aW9uIGdldFNhdmVPYmplY3QoKSB7XG4gICAgdmFyIHRvUmV0dXJuID0gdGhpcy5sb2FkO1xuICAgIHRvUmV0dXJuLmNsb3NlZCA9IHRoaXMuY2xvc2VkO1xuICAgIGlmICh0aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgdG9SZXR1cm4ucHJlc2V0ID0gdGhpcy5wcmVzZXQ7XG4gICAgICBpZiAoIXRvUmV0dXJuLnJlbWVtYmVyZWQpIHtcbiAgICAgICAgdG9SZXR1cm4ucmVtZW1iZXJlZCA9IHt9O1xuICAgICAgfVxuICAgICAgdG9SZXR1cm4ucmVtZW1iZXJlZFt0aGlzLnByZXNldF0gPSBnZXRDdXJyZW50UHJlc2V0KHRoaXMpO1xuICAgIH1cbiAgICB0b1JldHVybi5mb2xkZXJzID0ge307XG4gICAgQ29tbW9uLmVhY2godGhpcy5fX2ZvbGRlcnMsIGZ1bmN0aW9uIChlbGVtZW50LCBrZXkpIHtcbiAgICAgIHRvUmV0dXJuLmZvbGRlcnNba2V5XSA9IGVsZW1lbnQuZ2V0U2F2ZU9iamVjdCgpO1xuICAgIH0pO1xuICAgIHJldHVybiB0b1JldHVybjtcbiAgfSxcbiAgc2F2ZTogZnVuY3Rpb24gc2F2ZSgpIHtcbiAgICBpZiAoIXRoaXMubG9hZC5yZW1lbWJlcmVkKSB7XG4gICAgICB0aGlzLmxvYWQucmVtZW1iZXJlZCA9IHt9O1xuICAgIH1cbiAgICB0aGlzLmxvYWQucmVtZW1iZXJlZFt0aGlzLnByZXNldF0gPSBnZXRDdXJyZW50UHJlc2V0KHRoaXMpO1xuICAgIG1hcmtQcmVzZXRNb2RpZmllZCh0aGlzLCBmYWxzZSk7XG4gICAgdGhpcy5zYXZlVG9Mb2NhbFN0b3JhZ2VJZlBvc3NpYmxlKCk7XG4gIH0sXG4gIHNhdmVBczogZnVuY3Rpb24gc2F2ZUFzKHByZXNldE5hbWUpIHtcbiAgICBpZiAoIXRoaXMubG9hZC5yZW1lbWJlcmVkKSB7XG4gICAgICB0aGlzLmxvYWQucmVtZW1iZXJlZCA9IHt9O1xuICAgICAgdGhpcy5sb2FkLnJlbWVtYmVyZWRbREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FXSA9IGdldEN1cnJlbnRQcmVzZXQodGhpcywgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkW3ByZXNldE5hbWVdID0gZ2V0Q3VycmVudFByZXNldCh0aGlzKTtcbiAgICB0aGlzLnByZXNldCA9IHByZXNldE5hbWU7XG4gICAgYWRkUHJlc2V0T3B0aW9uKHRoaXMsIHByZXNldE5hbWUsIHRydWUpO1xuICAgIHRoaXMuc2F2ZVRvTG9jYWxTdG9yYWdlSWZQb3NzaWJsZSgpO1xuICB9LFxuICByZXZlcnQ6IGZ1bmN0aW9uIHJldmVydChndWkpIHtcbiAgICBDb21tb24uZWFjaCh0aGlzLl9fY29udHJvbGxlcnMsIGZ1bmN0aW9uIChjb250cm9sbGVyKSB7XG4gICAgICBpZiAoIXRoaXMuZ2V0Um9vdCgpLmxvYWQucmVtZW1iZXJlZCkge1xuICAgICAgICBjb250cm9sbGVyLnNldFZhbHVlKGNvbnRyb2xsZXIuaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlY2FsbFNhdmVkVmFsdWUoZ3VpIHx8IHRoaXMuZ2V0Um9vdCgpLCBjb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb250cm9sbGVyLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgY29udHJvbGxlci5fX29uRmluaXNoQ2hhbmdlLmNhbGwoY29udHJvbGxlciwgY29udHJvbGxlci5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICBDb21tb24uZWFjaCh0aGlzLl9fZm9sZGVycywgZnVuY3Rpb24gKGZvbGRlcikge1xuICAgICAgZm9sZGVyLnJldmVydChmb2xkZXIpO1xuICAgIH0pO1xuICAgIGlmICghZ3VpKSB7XG4gICAgICBtYXJrUHJlc2V0TW9kaWZpZWQodGhpcy5nZXRSb290KCksIGZhbHNlKTtcbiAgICB9XG4gIH0sXG4gIGxpc3RlbjogZnVuY3Rpb24gbGlzdGVuKGNvbnRyb2xsZXIpIHtcbiAgICB2YXIgaW5pdCA9IHRoaXMuX19saXN0ZW5pbmcubGVuZ3RoID09PSAwO1xuICAgIHRoaXMuX19saXN0ZW5pbmcucHVzaChjb250cm9sbGVyKTtcbiAgICBpZiAoaW5pdCkge1xuICAgICAgdXBkYXRlRGlzcGxheXModGhpcy5fX2xpc3RlbmluZyk7XG4gICAgfVxuICB9LFxuICB1cGRhdGVEaXNwbGF5OiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgIENvbW1vbi5lYWNoKHRoaXMuX19jb250cm9sbGVycywgZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIudXBkYXRlRGlzcGxheSgpO1xuICAgIH0pO1xuICAgIENvbW1vbi5lYWNoKHRoaXMuX19mb2xkZXJzLCBmdW5jdGlvbiAoZm9sZGVyKSB7XG4gICAgICBmb2xkZXIudXBkYXRlRGlzcGxheSgpO1xuICAgIH0pO1xuICB9XG59KTtcbmZ1bmN0aW9uIGFkZFJvdyhndWksIG5ld0RvbSwgbGlCZWZvcmUpIHtcbiAgdmFyIGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgaWYgKG5ld0RvbSkge1xuICAgIGxpLmFwcGVuZENoaWxkKG5ld0RvbSk7XG4gIH1cbiAgaWYgKGxpQmVmb3JlKSB7XG4gICAgZ3VpLl9fdWwuaW5zZXJ0QmVmb3JlKGxpLCBsaUJlZm9yZSk7XG4gIH0gZWxzZSB7XG4gICAgZ3VpLl9fdWwuYXBwZW5kQ2hpbGQobGkpO1xuICB9XG4gIGd1aS5vblJlc2l6ZSgpO1xuICByZXR1cm4gbGk7XG59XG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoZ3VpKSB7XG4gIGRvbS51bmJpbmQod2luZG93LCAncmVzaXplJywgZ3VpLl9fcmVzaXplSGFuZGxlcik7XG4gIGlmIChndWkuc2F2ZVRvTG9jYWxTdG9yYWdlSWZQb3NzaWJsZSkge1xuICAgIGRvbS51bmJpbmQod2luZG93LCAndW5sb2FkJywgZ3VpLnNhdmVUb0xvY2FsU3RvcmFnZUlmUG9zc2libGUpO1xuICB9XG59XG5mdW5jdGlvbiBtYXJrUHJlc2V0TW9kaWZpZWQoZ3VpLCBtb2RpZmllZCkge1xuICB2YXIgb3B0ID0gZ3VpLl9fcHJlc2V0X3NlbGVjdFtndWkuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXhdO1xuICBpZiAobW9kaWZpZWQpIHtcbiAgICBvcHQuaW5uZXJIVE1MID0gb3B0LnZhbHVlICsgJyonO1xuICB9IGVsc2Uge1xuICAgIG9wdC5pbm5lckhUTUwgPSBvcHQudmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGF1Z21lbnRDb250cm9sbGVyKGd1aSwgbGksIGNvbnRyb2xsZXIpIHtcbiAgY29udHJvbGxlci5fX2xpID0gbGk7XG4gIGNvbnRyb2xsZXIuX19ndWkgPSBndWk7XG4gIENvbW1vbi5leHRlbmQoY29udHJvbGxlciwge1xuICAgIG9wdGlvbnM6IGZ1bmN0aW9uIG9wdGlvbnMoX29wdGlvbnMpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBjb250cm9sbGVyLl9fbGkubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICBjb250cm9sbGVyLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm4gX2FkZChndWksIGNvbnRyb2xsZXIub2JqZWN0LCBjb250cm9sbGVyLnByb3BlcnR5LCB7XG4gICAgICAgICAgYmVmb3JlOiBuZXh0U2libGluZyxcbiAgICAgICAgICBmYWN0b3J5QXJnczogW0NvbW1vbi50b0FycmF5KGFyZ3VtZW50cyldXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKENvbW1vbi5pc0FycmF5KF9vcHRpb25zKSB8fCBDb21tb24uaXNPYmplY3QoX29wdGlvbnMpKSB7XG4gICAgICAgIHZhciBfbmV4dFNpYmxpbmcgPSBjb250cm9sbGVyLl9fbGkubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICBjb250cm9sbGVyLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm4gX2FkZChndWksIGNvbnRyb2xsZXIub2JqZWN0LCBjb250cm9sbGVyLnByb3BlcnR5LCB7XG4gICAgICAgICAgYmVmb3JlOiBfbmV4dFNpYmxpbmcsXG4gICAgICAgICAgZmFjdG9yeUFyZ3M6IFtfb3B0aW9uc11cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBuYW1lOiBmdW5jdGlvbiBuYW1lKF9uYW1lKSB7XG4gICAgICBjb250cm9sbGVyLl9fbGkuZmlyc3RFbGVtZW50Q2hpbGQuZmlyc3RFbGVtZW50Q2hpbGQuaW5uZXJIVE1MID0gX25hbWU7XG4gICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICB9LFxuICAgIGxpc3RlbjogZnVuY3Rpb24gbGlzdGVuKCkge1xuICAgICAgY29udHJvbGxlci5fX2d1aS5saXN0ZW4oY29udHJvbGxlcik7XG4gICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgY29udHJvbGxlci5fX2d1aS5yZW1vdmUoY29udHJvbGxlcik7XG4gICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICB9XG4gIH0pO1xuICBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIE51bWJlckNvbnRyb2xsZXJTbGlkZXIpIHtcbiAgICB2YXIgYm94ID0gbmV3IE51bWJlckNvbnRyb2xsZXJCb3goY29udHJvbGxlci5vYmplY3QsIGNvbnRyb2xsZXIucHJvcGVydHksIHsgbWluOiBjb250cm9sbGVyLl9fbWluLCBtYXg6IGNvbnRyb2xsZXIuX19tYXgsIHN0ZXA6IGNvbnRyb2xsZXIuX19zdGVwIH0pO1xuICAgIENvbW1vbi5lYWNoKFsndXBkYXRlRGlzcGxheScsICdvbkNoYW5nZScsICdvbkZpbmlzaENoYW5nZScsICdzdGVwJywgJ21pbicsICdtYXgnXSwgZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgdmFyIHBjID0gY29udHJvbGxlclttZXRob2RdO1xuICAgICAgdmFyIHBiID0gYm94W21ldGhvZF07XG4gICAgICBjb250cm9sbGVyW21ldGhvZF0gPSBib3hbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICBwYi5hcHBseShib3gsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gcGMuYXBwbHkoY29udHJvbGxlciwgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIGRvbS5hZGRDbGFzcyhsaSwgJ2hhcy1zbGlkZXInKTtcbiAgICBjb250cm9sbGVyLmRvbUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGJveC5kb21FbGVtZW50LCBjb250cm9sbGVyLmRvbUVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpO1xuICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBOdW1iZXJDb250cm9sbGVyQm94KSB7XG4gICAgdmFyIHIgPSBmdW5jdGlvbiByKHJldHVybmVkKSB7XG4gICAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKGNvbnRyb2xsZXIuX19taW4pICYmIENvbW1vbi5pc051bWJlcihjb250cm9sbGVyLl9fbWF4KSkge1xuICAgICAgICB2YXIgb2xkTmFtZSA9IGNvbnRyb2xsZXIuX19saS5maXJzdEVsZW1lbnRDaGlsZC5maXJzdEVsZW1lbnRDaGlsZC5pbm5lckhUTUw7XG4gICAgICAgIHZhciB3YXNMaXN0ZW5pbmcgPSBjb250cm9sbGVyLl9fZ3VpLl9fbGlzdGVuaW5nLmluZGV4T2YoY29udHJvbGxlcikgPiAtMTtcbiAgICAgICAgY29udHJvbGxlci5yZW1vdmUoKTtcbiAgICAgICAgdmFyIG5ld0NvbnRyb2xsZXIgPSBfYWRkKGd1aSwgY29udHJvbGxlci5vYmplY3QsIGNvbnRyb2xsZXIucHJvcGVydHksIHtcbiAgICAgICAgICBiZWZvcmU6IGNvbnRyb2xsZXIuX19saS5uZXh0RWxlbWVudFNpYmxpbmcsXG4gICAgICAgICAgZmFjdG9yeUFyZ3M6IFtjb250cm9sbGVyLl9fbWluLCBjb250cm9sbGVyLl9fbWF4LCBjb250cm9sbGVyLl9fc3RlcF1cbiAgICAgICAgfSk7XG4gICAgICAgIG5ld0NvbnRyb2xsZXIubmFtZShvbGROYW1lKTtcbiAgICAgICAgaWYgKHdhc0xpc3RlbmluZykgbmV3Q29udHJvbGxlci5saXN0ZW4oKTtcbiAgICAgICAgcmV0dXJuIG5ld0NvbnRyb2xsZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0dXJuZWQ7XG4gICAgfTtcbiAgICBjb250cm9sbGVyLm1pbiA9IENvbW1vbi5jb21wb3NlKHIsIGNvbnRyb2xsZXIubWluKTtcbiAgICBjb250cm9sbGVyLm1heCA9IENvbW1vbi5jb21wb3NlKHIsIGNvbnRyb2xsZXIubWF4KTtcbiAgfSBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgQm9vbGVhbkNvbnRyb2xsZXIpIHtcbiAgICBkb20uYmluZChsaSwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgZG9tLmZha2VFdmVudChjb250cm9sbGVyLl9fY2hlY2tib3gsICdjbGljaycpO1xuICAgIH0pO1xuICAgIGRvbS5iaW5kKGNvbnRyb2xsZXIuX19jaGVja2JveCwgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIEZ1bmN0aW9uQ29udHJvbGxlcikge1xuICAgIGRvbS5iaW5kKGxpLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICBkb20uZmFrZUV2ZW50KGNvbnRyb2xsZXIuX19idXR0b24sICdjbGljaycpO1xuICAgIH0pO1xuICAgIGRvbS5iaW5kKGxpLCAnbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgZG9tLmFkZENsYXNzKGNvbnRyb2xsZXIuX19idXR0b24sICdob3ZlcicpO1xuICAgIH0pO1xuICAgIGRvbS5iaW5kKGxpLCAnbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBkb20ucmVtb3ZlQ2xhc3MoY29udHJvbGxlci5fX2J1dHRvbiwgJ2hvdmVyJyk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIENvbG9yQ29udHJvbGxlcikge1xuICAgIGRvbS5hZGRDbGFzcyhsaSwgJ2NvbG9yJyk7XG4gICAgY29udHJvbGxlci51cGRhdGVEaXNwbGF5ID0gQ29tbW9uLmNvbXBvc2UoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgbGkuc3R5bGUuYm9yZGVyTGVmdENvbG9yID0gY29udHJvbGxlci5fX2NvbG9yLnRvU3RyaW5nKCk7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0sIGNvbnRyb2xsZXIudXBkYXRlRGlzcGxheSk7XG4gICAgY29udHJvbGxlci51cGRhdGVEaXNwbGF5KCk7XG4gIH1cbiAgY29udHJvbGxlci5zZXRWYWx1ZSA9IENvbW1vbi5jb21wb3NlKGZ1bmN0aW9uICh2YWwpIHtcbiAgICBpZiAoZ3VpLmdldFJvb3QoKS5fX3ByZXNldF9zZWxlY3QgJiYgY29udHJvbGxlci5pc01vZGlmaWVkKCkpIHtcbiAgICAgIG1hcmtQcmVzZXRNb2RpZmllZChndWkuZ2V0Um9vdCgpLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfSwgY29udHJvbGxlci5zZXRWYWx1ZSk7XG59XG5mdW5jdGlvbiByZWNhbGxTYXZlZFZhbHVlKGd1aSwgY29udHJvbGxlcikge1xuICB2YXIgcm9vdCA9IGd1aS5nZXRSb290KCk7XG4gIHZhciBtYXRjaGVkSW5kZXggPSByb290Ll9fcmVtZW1iZXJlZE9iamVjdHMuaW5kZXhPZihjb250cm9sbGVyLm9iamVjdCk7XG4gIGlmIChtYXRjaGVkSW5kZXggIT09IC0xKSB7XG4gICAgdmFyIGNvbnRyb2xsZXJNYXAgPSByb290Ll9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzW21hdGNoZWRJbmRleF07XG4gICAgaWYgKGNvbnRyb2xsZXJNYXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udHJvbGxlck1hcCA9IHt9O1xuICAgICAgcm9vdC5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVyc1ttYXRjaGVkSW5kZXhdID0gY29udHJvbGxlck1hcDtcbiAgICB9XG4gICAgY29udHJvbGxlck1hcFtjb250cm9sbGVyLnByb3BlcnR5XSA9IGNvbnRyb2xsZXI7XG4gICAgaWYgKHJvb3QubG9hZCAmJiByb290LmxvYWQucmVtZW1iZXJlZCkge1xuICAgICAgdmFyIHByZXNldE1hcCA9IHJvb3QubG9hZC5yZW1lbWJlcmVkO1xuICAgICAgdmFyIHByZXNldCA9IHZvaWQgMDtcbiAgICAgIGlmIChwcmVzZXRNYXBbZ3VpLnByZXNldF0pIHtcbiAgICAgICAgcHJlc2V0ID0gcHJlc2V0TWFwW2d1aS5wcmVzZXRdO1xuICAgICAgfSBlbHNlIGlmIChwcmVzZXRNYXBbREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FXSkge1xuICAgICAgICBwcmVzZXQgPSBwcmVzZXRNYXBbREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVzZXRbbWF0Y2hlZEluZGV4XSAmJiBwcmVzZXRbbWF0Y2hlZEluZGV4XVtjb250cm9sbGVyLnByb3BlcnR5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHByZXNldFttYXRjaGVkSW5kZXhdW2NvbnRyb2xsZXIucHJvcGVydHldO1xuICAgICAgICBjb250cm9sbGVyLmluaXRpYWxWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBjb250cm9sbGVyLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF9hZGQoZ3VpLCBvYmplY3QsIHByb3BlcnR5LCBwYXJhbXMpIHtcbiAgaWYgKG9iamVjdFtwcm9wZXJ0eV0gPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0IFwiJyArIG9iamVjdCArICdcIiBoYXMgbm8gcHJvcGVydHkgXCInICsgcHJvcGVydHkgKyAnXCInKTtcbiAgfVxuICB2YXIgY29udHJvbGxlciA9IHZvaWQgMDtcbiAgaWYgKHBhcmFtcy5jb2xvcikge1xuICAgIGNvbnRyb2xsZXIgPSBuZXcgQ29sb3JDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpO1xuICB9IGVsc2Uge1xuICAgIHZhciBmYWN0b3J5QXJncyA9IFtvYmplY3QsIHByb3BlcnR5XS5jb25jYXQocGFyYW1zLmZhY3RvcnlBcmdzKTtcbiAgICBjb250cm9sbGVyID0gQ29udHJvbGxlckZhY3RvcnkuYXBwbHkoZ3VpLCBmYWN0b3J5QXJncyk7XG4gIH1cbiAgaWYgKHBhcmFtcy5iZWZvcmUgaW5zdGFuY2VvZiBDb250cm9sbGVyKSB7XG4gICAgcGFyYW1zLmJlZm9yZSA9IHBhcmFtcy5iZWZvcmUuX19saTtcbiAgfVxuICByZWNhbGxTYXZlZFZhbHVlKGd1aSwgY29udHJvbGxlcik7XG4gIGRvbS5hZGRDbGFzcyhjb250cm9sbGVyLmRvbUVsZW1lbnQsICdjJyk7XG4gIHZhciBuYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBkb20uYWRkQ2xhc3MobmFtZSwgJ3Byb3BlcnR5LW5hbWUnKTtcbiAgbmFtZS5pbm5lckhUTUwgPSBjb250cm9sbGVyLnByb3BlcnR5O1xuICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChuYW1lKTtcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRyb2xsZXIuZG9tRWxlbWVudCk7XG4gIHZhciBsaSA9IGFkZFJvdyhndWksIGNvbnRhaW5lciwgcGFyYW1zLmJlZm9yZSk7XG4gIGRvbS5hZGRDbGFzcyhsaSwgR1VJLkNMQVNTX0NPTlRST0xMRVJfUk9XKTtcbiAgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBDb2xvckNvbnRyb2xsZXIpIHtcbiAgICBkb20uYWRkQ2xhc3MobGksICdjb2xvcicpO1xuICB9IGVsc2Uge1xuICAgIGRvbS5hZGRDbGFzcyhsaSwgX3R5cGVvZihjb250cm9sbGVyLmdldFZhbHVlKCkpKTtcbiAgfVxuICBhdWdtZW50Q29udHJvbGxlcihndWksIGxpLCBjb250cm9sbGVyKTtcbiAgZ3VpLl9fY29udHJvbGxlcnMucHVzaChjb250cm9sbGVyKTtcbiAgcmV0dXJuIGNvbnRyb2xsZXI7XG59XG5mdW5jdGlvbiBnZXRMb2NhbFN0b3JhZ2VIYXNoKGd1aSwga2V5KSB7XG4gIHJldHVybiBkb2N1bWVudC5sb2NhdGlvbi5ocmVmICsgJy4nICsga2V5O1xufVxuZnVuY3Rpb24gYWRkUHJlc2V0T3B0aW9uKGd1aSwgbmFtZSwgc2V0U2VsZWN0ZWQpIHtcbiAgdmFyIG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICBvcHQuaW5uZXJIVE1MID0gbmFtZTtcbiAgb3B0LnZhbHVlID0gbmFtZTtcbiAgZ3VpLl9fcHJlc2V0X3NlbGVjdC5hcHBlbmRDaGlsZChvcHQpO1xuICBpZiAoc2V0U2VsZWN0ZWQpIHtcbiAgICBndWkuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXggPSBndWkuX19wcmVzZXRfc2VsZWN0Lmxlbmd0aCAtIDE7XG4gIH1cbn1cbmZ1bmN0aW9uIHNob3dIaWRlRXhwbGFpbihndWksIGV4cGxhaW4pIHtcbiAgZXhwbGFpbi5zdHlsZS5kaXNwbGF5ID0gZ3VpLnVzZUxvY2FsU3RvcmFnZSA/ICdibG9jaycgOiAnbm9uZSc7XG59XG5mdW5jdGlvbiBhZGRTYXZlTWVudShndWkpIHtcbiAgdmFyIGRpdiA9IGd1aS5fX3NhdmVfcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgZG9tLmFkZENsYXNzKGd1aS5kb21FbGVtZW50LCAnaGFzLXNhdmUnKTtcbiAgZ3VpLl9fdWwuaW5zZXJ0QmVmb3JlKGRpdiwgZ3VpLl9fdWwuZmlyc3RDaGlsZCk7XG4gIGRvbS5hZGRDbGFzcyhkaXYsICdzYXZlLXJvdycpO1xuICB2YXIgZ2VhcnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIGdlYXJzLmlubmVySFRNTCA9ICcmbmJzcDsnO1xuICBkb20uYWRkQ2xhc3MoZ2VhcnMsICdidXR0b24gZ2VhcnMnKTtcbiAgdmFyIGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgYnV0dG9uLmlubmVySFRNTCA9ICdTYXZlJztcbiAgZG9tLmFkZENsYXNzKGJ1dHRvbiwgJ2J1dHRvbicpO1xuICBkb20uYWRkQ2xhc3MoYnV0dG9uLCAnc2F2ZScpO1xuICB2YXIgYnV0dG9uMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgYnV0dG9uMi5pbm5lckhUTUwgPSAnTmV3JztcbiAgZG9tLmFkZENsYXNzKGJ1dHRvbjIsICdidXR0b24nKTtcbiAgZG9tLmFkZENsYXNzKGJ1dHRvbjIsICdzYXZlLWFzJyk7XG4gIHZhciBidXR0b24zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBidXR0b24zLmlubmVySFRNTCA9ICdSZXZlcnQnO1xuICBkb20uYWRkQ2xhc3MoYnV0dG9uMywgJ2J1dHRvbicpO1xuICBkb20uYWRkQ2xhc3MoYnV0dG9uMywgJ3JldmVydCcpO1xuICB2YXIgc2VsZWN0ID0gZ3VpLl9fcHJlc2V0X3NlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpO1xuICBpZiAoZ3VpLmxvYWQgJiYgZ3VpLmxvYWQucmVtZW1iZXJlZCkge1xuICAgIENvbW1vbi5lYWNoKGd1aS5sb2FkLnJlbWVtYmVyZWQsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICBhZGRQcmVzZXRPcHRpb24oZ3VpLCBrZXksIGtleSA9PT0gZ3VpLnByZXNldCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgYWRkUHJlc2V0T3B0aW9uKGd1aSwgREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FLCBmYWxzZSk7XG4gIH1cbiAgZG9tLmJpbmQoc2VsZWN0LCAnY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBndWkuX19wcmVzZXRfc2VsZWN0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgZ3VpLl9fcHJlc2V0X3NlbGVjdFtpbmRleF0uaW5uZXJIVE1MID0gZ3VpLl9fcHJlc2V0X3NlbGVjdFtpbmRleF0udmFsdWU7XG4gICAgfVxuICAgIGd1aS5wcmVzZXQgPSB0aGlzLnZhbHVlO1xuICB9KTtcbiAgZGl2LmFwcGVuZENoaWxkKHNlbGVjdCk7XG4gIGRpdi5hcHBlbmRDaGlsZChnZWFycyk7XG4gIGRpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuICBkaXYuYXBwZW5kQ2hpbGQoYnV0dG9uMik7XG4gIGRpdi5hcHBlbmRDaGlsZChidXR0b24zKTtcbiAgaWYgKFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UpIHtcbiAgICB2YXIgZXhwbGFpbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZy1sb2NhbC1leHBsYWluJyk7XG4gICAgdmFyIGxvY2FsU3RvcmFnZUNoZWNrQm94ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RnLWxvY2FsLXN0b3JhZ2UnKTtcbiAgICB2YXIgc2F2ZUxvY2FsbHkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGctc2F2ZS1sb2NhbGx5Jyk7XG4gICAgc2F2ZUxvY2FsbHkuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgaWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2goZ3VpLCAnaXNMb2NhbCcpKSA9PT0gJ3RydWUnKSB7XG4gICAgICBsb2NhbFN0b3JhZ2VDaGVja0JveC5zZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnLCAnY2hlY2tlZCcpO1xuICAgIH1cbiAgICBzaG93SGlkZUV4cGxhaW4oZ3VpLCBleHBsYWluKTtcbiAgICBkb20uYmluZChsb2NhbFN0b3JhZ2VDaGVja0JveCwgJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGd1aS51c2VMb2NhbFN0b3JhZ2UgPSAhZ3VpLnVzZUxvY2FsU3RvcmFnZTtcbiAgICAgIHNob3dIaWRlRXhwbGFpbihndWksIGV4cGxhaW4pO1xuICAgIH0pO1xuICB9XG4gIHZhciBuZXdDb25zdHJ1Y3RvclRleHRBcmVhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RnLW5ldy1jb25zdHJ1Y3RvcicpO1xuICBkb20uYmluZChuZXdDb25zdHJ1Y3RvclRleHRBcmVhLCAna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUubWV0YUtleSAmJiAoZS53aGljaCA9PT0gNjcgfHwgZS5rZXlDb2RlID09PSA2NykpIHtcbiAgICAgIFNBVkVfRElBTE9HVUUuaGlkZSgpO1xuICAgIH1cbiAgfSk7XG4gIGRvbS5iaW5kKGdlYXJzLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgbmV3Q29uc3RydWN0b3JUZXh0QXJlYS5pbm5lckhUTUwgPSBKU09OLnN0cmluZ2lmeShndWkuZ2V0U2F2ZU9iamVjdCgpLCB1bmRlZmluZWQsIDIpO1xuICAgIFNBVkVfRElBTE9HVUUuc2hvdygpO1xuICAgIG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEuZm9jdXMoKTtcbiAgICBuZXdDb25zdHJ1Y3RvclRleHRBcmVhLnNlbGVjdCgpO1xuICB9KTtcbiAgZG9tLmJpbmQoYnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgZ3VpLnNhdmUoKTtcbiAgfSk7XG4gIGRvbS5iaW5kKGJ1dHRvbjIsICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJlc2V0TmFtZSA9IHByb21wdCgnRW50ZXIgYSBuZXcgcHJlc2V0IG5hbWUuJyk7XG4gICAgaWYgKHByZXNldE5hbWUpIHtcbiAgICAgIGd1aS5zYXZlQXMocHJlc2V0TmFtZSk7XG4gICAgfVxuICB9KTtcbiAgZG9tLmJpbmQoYnV0dG9uMywgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgIGd1aS5yZXZlcnQoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGRSZXNpemVIYW5kbGUoZ3VpKSB7XG4gIHZhciBwbW91c2VYID0gdm9pZCAwO1xuICBndWkuX19yZXNpemVfaGFuZGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIENvbW1vbi5leHRlbmQoZ3VpLl9fcmVzaXplX2hhbmRsZS5zdHlsZSwge1xuICAgIHdpZHRoOiAnNnB4JyxcbiAgICBtYXJnaW5MZWZ0OiAnLTNweCcsXG4gICAgaGVpZ2h0OiAnMjAwcHgnLFxuICAgIGN1cnNvcjogJ2V3LXJlc2l6ZScsXG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgfSk7XG4gIGZ1bmN0aW9uIGRyYWcoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBndWkud2lkdGggKz0gcG1vdXNlWCAtIGUuY2xpZW50WDtcbiAgICBndWkub25SZXNpemUoKTtcbiAgICBwbW91c2VYID0gZS5jbGllbnRYO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBkcmFnU3RvcCgpIHtcbiAgICBkb20ucmVtb3ZlQ2xhc3MoZ3VpLl9fY2xvc2VCdXR0b24sIEdVSS5DTEFTU19EUkFHKTtcbiAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIGRyYWcpO1xuICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIGRyYWdTdG9wKTtcbiAgfVxuICBmdW5jdGlvbiBkcmFnU3RhcnQoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBwbW91c2VYID0gZS5jbGllbnRYO1xuICAgIGRvbS5hZGRDbGFzcyhndWkuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0RSQUcpO1xuICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIGRyYWcpO1xuICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBkcmFnU3RvcCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGRvbS5iaW5kKGd1aS5fX3Jlc2l6ZV9oYW5kbGUsICdtb3VzZWRvd24nLCBkcmFnU3RhcnQpO1xuICBkb20uYmluZChndWkuX19jbG9zZUJ1dHRvbiwgJ21vdXNlZG93bicsIGRyYWdTdGFydCk7XG4gIGd1aS5kb21FbGVtZW50Lmluc2VydEJlZm9yZShndWkuX19yZXNpemVfaGFuZGxlLCBndWkuZG9tRWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCk7XG59XG5mdW5jdGlvbiBzZXRXaWR0aChndWksIHcpIHtcbiAgZ3VpLmRvbUVsZW1lbnQuc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgaWYgKGd1aS5fX3NhdmVfcm93ICYmIGd1aS5hdXRvUGxhY2UpIHtcbiAgICBndWkuX19zYXZlX3Jvdy5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICB9XG4gIGlmIChndWkuX19jbG9zZUJ1dHRvbikge1xuICAgIGd1aS5fX2Nsb3NlQnV0dG9uLnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRQcmVzZXQoZ3VpLCB1c2VJbml0aWFsVmFsdWVzKSB7XG4gIHZhciB0b1JldHVybiA9IHt9O1xuICBDb21tb24uZWFjaChndWkuX19yZW1lbWJlcmVkT2JqZWN0cywgZnVuY3Rpb24gKHZhbCwgaW5kZXgpIHtcbiAgICB2YXIgc2F2ZWRWYWx1ZXMgPSB7fTtcbiAgICB2YXIgY29udHJvbGxlck1hcCA9IGd1aS5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVyc1tpbmRleF07XG4gICAgQ29tbW9uLmVhY2goY29udHJvbGxlck1hcCwgZnVuY3Rpb24gKGNvbnRyb2xsZXIsIHByb3BlcnR5KSB7XG4gICAgICBzYXZlZFZhbHVlc1twcm9wZXJ0eV0gPSB1c2VJbml0aWFsVmFsdWVzID8gY29udHJvbGxlci5pbml0aWFsVmFsdWUgOiBjb250cm9sbGVyLmdldFZhbHVlKCk7XG4gICAgfSk7XG4gICAgdG9SZXR1cm5baW5kZXhdID0gc2F2ZWRWYWx1ZXM7XG4gIH0pO1xuICByZXR1cm4gdG9SZXR1cm47XG59XG5mdW5jdGlvbiBzZXRQcmVzZXRTZWxlY3RJbmRleChndWkpIHtcbiAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGd1aS5fX3ByZXNldF9zZWxlY3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgaWYgKGd1aS5fX3ByZXNldF9zZWxlY3RbaW5kZXhdLnZhbHVlID09PSBndWkucHJlc2V0KSB7XG4gICAgICBndWkuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXggPSBpbmRleDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZURpc3BsYXlzKGNvbnRyb2xsZXJBcnJheSkge1xuICBpZiAoY29udHJvbGxlckFycmF5Lmxlbmd0aCAhPT0gMCkge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSQxLmNhbGwod2luZG93LCBmdW5jdGlvbiAoKSB7XG4gICAgICB1cGRhdGVEaXNwbGF5cyhjb250cm9sbGVyQXJyYXkpO1xuICAgIH0pO1xuICB9XG4gIENvbW1vbi5lYWNoKGNvbnRyb2xsZXJBcnJheSwgZnVuY3Rpb24gKGMpIHtcbiAgICBjLnVwZGF0ZURpc3BsYXkoKTtcbiAgfSk7XG59XG5cbnZhciBjb2xvciA9IHtcbiAgQ29sb3I6IENvbG9yLFxuICBtYXRoOiBDb2xvck1hdGgsXG4gIGludGVycHJldDogaW50ZXJwcmV0XG59O1xudmFyIGNvbnRyb2xsZXJzID0ge1xuICBDb250cm9sbGVyOiBDb250cm9sbGVyLFxuICBCb29sZWFuQ29udHJvbGxlcjogQm9vbGVhbkNvbnRyb2xsZXIsXG4gIE9wdGlvbkNvbnRyb2xsZXI6IE9wdGlvbkNvbnRyb2xsZXIsXG4gIFN0cmluZ0NvbnRyb2xsZXI6IFN0cmluZ0NvbnRyb2xsZXIsXG4gIE51bWJlckNvbnRyb2xsZXI6IE51bWJlckNvbnRyb2xsZXIsXG4gIE51bWJlckNvbnRyb2xsZXJCb3g6IE51bWJlckNvbnRyb2xsZXJCb3gsXG4gIE51bWJlckNvbnRyb2xsZXJTbGlkZXI6IE51bWJlckNvbnRyb2xsZXJTbGlkZXIsXG4gIEZ1bmN0aW9uQ29udHJvbGxlcjogRnVuY3Rpb25Db250cm9sbGVyLFxuICBDb2xvckNvbnRyb2xsZXI6IENvbG9yQ29udHJvbGxlclxufTtcbnZhciBkb20kMSA9IHsgZG9tOiBkb20gfTtcbnZhciBndWkgPSB7IEdVSTogR1VJIH07XG52YXIgR1VJJDEgPSBHVUk7XG52YXIgaW5kZXggPSB7XG4gIGNvbG9yOiBjb2xvcixcbiAgY29udHJvbGxlcnM6IGNvbnRyb2xsZXJzLFxuICBkb206IGRvbSQxLFxuICBndWk6IGd1aSxcbiAgR1VJOiBHVUkkMVxufTtcblxuZXhwb3J0IHsgY29sb3IsIGNvbnRyb2xsZXJzLCBkb20kMSBhcyBkb20sIGd1aSwgR1VJJDEgYXMgR1VJIH07XG5leHBvcnQgZGVmYXVsdCBpbmRleDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdC5ndWkubW9kdWxlLmpzLm1hcFxuIiwiKGZ1bmN0aW9uKGEsYil7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXSxiKTtlbHNlIGlmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBleHBvcnRzKWIoKTtlbHNle2IoKSxhLkZpbGVTYXZlcj17ZXhwb3J0czp7fX0uZXhwb3J0c319KSh0aGlzLGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihhLGIpe3JldHVyblwidW5kZWZpbmVkXCI9PXR5cGVvZiBiP2I9e2F1dG9Cb206ITF9Olwib2JqZWN0XCIhPXR5cGVvZiBiJiYoY29uc29sZS53YXJuKFwiRGVwcmVjYXRlZDogRXhwZWN0ZWQgdGhpcmQgYXJndW1lbnQgdG8gYmUgYSBvYmplY3RcIiksYj17YXV0b0JvbTohYn0pLGIuYXV0b0JvbSYmL15cXHMqKD86dGV4dFxcL1xcUyp8YXBwbGljYXRpb25cXC94bWx8XFxTKlxcL1xcUypcXCt4bWwpXFxzKjsuKmNoYXJzZXRcXHMqPVxccyp1dGYtOC9pLnRlc3QoYS50eXBlKT9uZXcgQmxvYihbXCJcXHVGRUZGXCIsYV0se3R5cGU6YS50eXBlfSk6YX1mdW5jdGlvbiBjKGEsYixjKXt2YXIgZD1uZXcgWE1MSHR0cFJlcXVlc3Q7ZC5vcGVuKFwiR0VUXCIsYSksZC5yZXNwb25zZVR5cGU9XCJibG9iXCIsZC5vbmxvYWQ9ZnVuY3Rpb24oKXtnKGQucmVzcG9uc2UsYixjKX0sZC5vbmVycm9yPWZ1bmN0aW9uKCl7Y29uc29sZS5lcnJvcihcImNvdWxkIG5vdCBkb3dubG9hZCBmaWxlXCIpfSxkLnNlbmQoKX1mdW5jdGlvbiBkKGEpe3ZhciBiPW5ldyBYTUxIdHRwUmVxdWVzdDtiLm9wZW4oXCJIRUFEXCIsYSwhMSk7dHJ5e2Iuc2VuZCgpfWNhdGNoKGEpe31yZXR1cm4gMjAwPD1iLnN0YXR1cyYmMjk5Pj1iLnN0YXR1c31mdW5jdGlvbiBlKGEpe3RyeXthLmRpc3BhdGNoRXZlbnQobmV3IE1vdXNlRXZlbnQoXCJjbGlja1wiKSl9Y2F0Y2goYyl7dmFyIGI9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJNb3VzZUV2ZW50c1wiKTtiLmluaXRNb3VzZUV2ZW50KFwiY2xpY2tcIiwhMCwhMCx3aW5kb3csMCwwLDAsODAsMjAsITEsITEsITEsITEsMCxudWxsKSxhLmRpc3BhdGNoRXZlbnQoYil9fXZhciBmPVwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3cmJndpbmRvdy53aW5kb3c9PT13aW5kb3c/d2luZG93Olwib2JqZWN0XCI9PXR5cGVvZiBzZWxmJiZzZWxmLnNlbGY9PT1zZWxmP3NlbGY6XCJvYmplY3RcIj09dHlwZW9mIGdsb2JhbCYmZ2xvYmFsLmdsb2JhbD09PWdsb2JhbD9nbG9iYWw6dm9pZCAwLGE9Zi5uYXZpZ2F0b3ImJi9NYWNpbnRvc2gvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkmJi9BcHBsZVdlYktpdC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSYmIS9TYWZhcmkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCksZz1mLnNhdmVBc3x8KFwib2JqZWN0XCIhPXR5cGVvZiB3aW5kb3d8fHdpbmRvdyE9PWY/ZnVuY3Rpb24oKXt9OlwiZG93bmxvYWRcImluIEhUTUxBbmNob3JFbGVtZW50LnByb3RvdHlwZSYmIWE/ZnVuY3Rpb24oYixnLGgpe3ZhciBpPWYuVVJMfHxmLndlYmtpdFVSTCxqPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO2c9Z3x8Yi5uYW1lfHxcImRvd25sb2FkXCIsai5kb3dubG9hZD1nLGoucmVsPVwibm9vcGVuZXJcIixcInN0cmluZ1wiPT10eXBlb2YgYj8oai5ocmVmPWIsai5vcmlnaW49PT1sb2NhdGlvbi5vcmlnaW4/ZShqKTpkKGouaHJlZik/YyhiLGcsaCk6ZShqLGoudGFyZ2V0PVwiX2JsYW5rXCIpKTooai5ocmVmPWkuY3JlYXRlT2JqZWN0VVJMKGIpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtpLnJldm9rZU9iamVjdFVSTChqLmhyZWYpfSw0RTQpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtlKGopfSwwKSl9OlwibXNTYXZlT3JPcGVuQmxvYlwiaW4gbmF2aWdhdG9yP2Z1bmN0aW9uKGYsZyxoKXtpZihnPWd8fGYubmFtZXx8XCJkb3dubG9hZFwiLFwic3RyaW5nXCIhPXR5cGVvZiBmKW5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKGIoZixoKSxnKTtlbHNlIGlmKGQoZikpYyhmLGcsaCk7ZWxzZXt2YXIgaT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtpLmhyZWY9ZixpLnRhcmdldD1cIl9ibGFua1wiLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtlKGkpfSl9fTpmdW5jdGlvbihiLGQsZSxnKXtpZihnPWd8fG9wZW4oXCJcIixcIl9ibGFua1wiKSxnJiYoZy5kb2N1bWVudC50aXRsZT1nLmRvY3VtZW50LmJvZHkuaW5uZXJUZXh0PVwiZG93bmxvYWRpbmcuLi5cIiksXCJzdHJpbmdcIj09dHlwZW9mIGIpcmV0dXJuIGMoYixkLGUpO3ZhciBoPVwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCI9PT1iLnR5cGUsaT0vY29uc3RydWN0b3IvaS50ZXN0KGYuSFRNTEVsZW1lbnQpfHxmLnNhZmFyaSxqPS9DcmlPU1xcL1tcXGRdKy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtpZigoanx8aCYmaXx8YSkmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBGaWxlUmVhZGVyKXt2YXIgaz1uZXcgRmlsZVJlYWRlcjtrLm9ubG9hZGVuZD1mdW5jdGlvbigpe3ZhciBhPWsucmVzdWx0O2E9aj9hOmEucmVwbGFjZSgvXmRhdGE6W147XSo7LyxcImRhdGE6YXR0YWNobWVudC9maWxlO1wiKSxnP2cubG9jYXRpb24uaHJlZj1hOmxvY2F0aW9uPWEsZz1udWxsfSxrLnJlYWRBc0RhdGFVUkwoYil9ZWxzZXt2YXIgbD1mLlVSTHx8Zi53ZWJraXRVUkwsbT1sLmNyZWF0ZU9iamVjdFVSTChiKTtnP2cubG9jYXRpb249bTpsb2NhdGlvbi5ocmVmPW0sZz1udWxsLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtsLnJldm9rZU9iamVjdFVSTChtKX0sNEU0KX19KTtmLnNhdmVBcz1nLnNhdmVBcz1nLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUmJihtb2R1bGUuZXhwb3J0cz1nKX0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaWxlU2F2ZXIubWluLmpzLm1hcCIsIi8qIGludGVyYWN0LmpzIDEuMTAuMjYgfCBodHRwczovL3Jhdy5naXRodWIuY29tL3RheWUvaW50ZXJhY3QuanMvbWFpbi9MSUNFTlNFICovXG5cbiFmdW5jdGlvbih0LGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPWUoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKGUpOih0PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWxUaGlzP2dsb2JhbFRoaXM6dHx8c2VsZikuaW50ZXJhY3Q9ZSgpfSh0aGlzLChmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHQodCxlKXt2YXIgbj1PYmplY3Qua2V5cyh0KTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgcj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHQpO2UmJihyPXIuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LGUpLmVudW1lcmFibGV9KSkpLG4ucHVzaC5hcHBseShuLHIpfXJldHVybiBufWZ1bmN0aW9uIGUoZSl7Zm9yKHZhciBuPTE7bjxhcmd1bWVudHMubGVuZ3RoO24rKyl7dmFyIHI9bnVsbCE9YXJndW1lbnRzW25dP2FyZ3VtZW50c1tuXTp7fTtuJTI/dChPYmplY3QociksITApLmZvckVhY2goKGZ1bmN0aW9uKHQpe2EoZSx0LHJbdF0pfSkpOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMocikpOnQoT2JqZWN0KHIpKS5mb3JFYWNoKChmdW5jdGlvbih0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iocix0KSl9KSl9cmV0dXJuIGV9ZnVuY3Rpb24gbih0KXtyZXR1cm4gbj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSxuKHQpfWZ1bmN0aW9uIHIodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIGkodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZChyLmtleSkscil9fWZ1bmN0aW9uIG8odCxlLG4pe3JldHVybiBlJiZpKHQucHJvdG90eXBlLGUpLG4mJmkodCxuKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcInByb3RvdHlwZVwiLHt3cml0YWJsZTohMX0pLHR9ZnVuY3Rpb24gYSh0LGUsbil7cmV0dXJuKGU9ZChlKSlpbiB0P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp0W2VdPW4sdH1mdW5jdGlvbiBzKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmbnVsbCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcInByb3RvdHlwZVwiLHt3cml0YWJsZTohMX0pLGUmJmwodCxlKX1mdW5jdGlvbiBjKHQpe3JldHVybiBjPU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpOmZ1bmN0aW9uKHQpe3JldHVybiB0Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpfSxjKHQpfWZ1bmN0aW9uIGwodCxlKXtyZXR1cm4gbD1PYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKTpmdW5jdGlvbih0LGUpe3JldHVybiB0Ll9fcHJvdG9fXz1lLHR9LGwodCxlKX1mdW5jdGlvbiB1KHQpe2lmKHZvaWQgMD09PXQpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiB0fWZ1bmN0aW9uIHAodCl7dmFyIGU9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IVJlZmxlY3QuY29uc3RydWN0KXJldHVybiExO2lmKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbixbXSwoZnVuY3Rpb24oKXt9KSkpLCEwfWNhdGNoKHQpe3JldHVybiExfX0oKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgbixyPWModCk7aWYoZSl7dmFyIGk9Yyh0aGlzKS5jb25zdHJ1Y3RvcjtuPVJlZmxlY3QuY29uc3RydWN0KHIsYXJndW1lbnRzLGkpfWVsc2Ugbj1yLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gZnVuY3Rpb24odCxlKXtpZihlJiYoXCJvYmplY3RcIj09dHlwZW9mIGV8fFwiZnVuY3Rpb25cIj09dHlwZW9mIGUpKXJldHVybiBlO2lmKHZvaWQgMCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO3JldHVybiB1KHQpfSh0aGlzLG4pfX1mdW5jdGlvbiBmKCl7cmV0dXJuIGY9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFJlZmxlY3QmJlJlZmxlY3QuZ2V0P1JlZmxlY3QuZ2V0LmJpbmQoKTpmdW5jdGlvbih0LGUsbil7dmFyIHI9ZnVuY3Rpb24odCxlKXtmb3IoOyFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKSYmbnVsbCE9PSh0PWModCkpOyk7cmV0dXJuIHR9KHQsZSk7aWYocil7dmFyIGk9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLGUpO3JldHVybiBpLmdldD9pLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGg8Mz90Om4pOmkudmFsdWV9fSxmLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1mdW5jdGlvbiBkKHQpe3ZhciBlPWZ1bmN0aW9uKHQsZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHR8fG51bGw9PT10KXJldHVybiB0O3ZhciBuPXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtpZih2b2lkIDAhPT1uKXt2YXIgcj1uLmNhbGwodCxlfHxcImRlZmF1bHRcIik7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHIpcmV0dXJuIHI7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpfXJldHVybihcInN0cmluZ1wiPT09ZT9TdHJpbmc6TnVtYmVyKSh0KX0odCxcInN0cmluZ1wiKTtyZXR1cm5cInN5bWJvbFwiPT10eXBlb2YgZT9lOmUrXCJcIn12YXIgaD1mdW5jdGlvbih0KXtyZXR1cm4hKCF0fHwhdC5XaW5kb3cpJiZ0IGluc3RhbmNlb2YgdC5XaW5kb3d9LHY9dm9pZCAwLGc9dm9pZCAwO2Z1bmN0aW9uIG0odCl7dj10O3ZhciBlPXQuZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIik7ZS5vd25lckRvY3VtZW50IT09dC5kb2N1bWVudCYmXCJmdW5jdGlvblwiPT10eXBlb2YgdC53cmFwJiZ0LndyYXAoZSk9PT1lJiYodD10LndyYXAodCkpLGc9dH1mdW5jdGlvbiB5KHQpe3JldHVybiBoKHQpP3Q6KHQub3duZXJEb2N1bWVudHx8dCkuZGVmYXVsdFZpZXd8fGcud2luZG93fVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdyYmbSh3aW5kb3cpO3ZhciBiPWZ1bmN0aW9uKHQpe3JldHVybiEhdCYmXCJvYmplY3RcIj09PW4odCl9LHg9ZnVuY3Rpb24odCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdH0sdz17d2luZG93OmZ1bmN0aW9uKHQpe3JldHVybiB0PT09Z3x8aCh0KX0sZG9jRnJhZzpmdW5jdGlvbih0KXtyZXR1cm4gYih0KSYmMTE9PT10Lm5vZGVUeXBlfSxvYmplY3Q6YixmdW5jOngsbnVtYmVyOmZ1bmN0aW9uKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0fSxib29sOmZ1bmN0aW9uKHQpe3JldHVyblwiYm9vbGVhblwiPT10eXBlb2YgdH0sc3RyaW5nOmZ1bmN0aW9uKHQpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiB0fSxlbGVtZW50OmZ1bmN0aW9uKHQpe2lmKCF0fHxcIm9iamVjdFwiIT09bih0KSlyZXR1cm4hMTt2YXIgZT15KHQpfHxnO3JldHVybi9vYmplY3R8ZnVuY3Rpb24vLnRlc3QoXCJ1bmRlZmluZWRcIj09dHlwZW9mIEVsZW1lbnQ/XCJ1bmRlZmluZWRcIjpuKEVsZW1lbnQpKT90IGluc3RhbmNlb2YgRWxlbWVudHx8dCBpbnN0YW5jZW9mIGUuRWxlbWVudDoxPT09dC5ub2RlVHlwZSYmXCJzdHJpbmdcIj09dHlwZW9mIHQubm9kZU5hbWV9LHBsYWluT2JqZWN0OmZ1bmN0aW9uKHQpe3JldHVybiBiKHQpJiYhIXQuY29uc3RydWN0b3ImJi9mdW5jdGlvbiBPYmplY3RcXGIvLnRlc3QodC5jb25zdHJ1Y3Rvci50b1N0cmluZygpKX0sYXJyYXk6ZnVuY3Rpb24odCl7cmV0dXJuIGIodCkmJnZvaWQgMCE9PXQubGVuZ3RoJiZ4KHQuc3BsaWNlKX19O2Z1bmN0aW9uIEUodCl7dmFyIGU9dC5pbnRlcmFjdGlvbjtpZihcImRyYWdcIj09PWUucHJlcGFyZWQubmFtZSl7dmFyIG49ZS5wcmVwYXJlZC5heGlzO1wieFwiPT09bj8oZS5jb29yZHMuY3VyLnBhZ2UueT1lLmNvb3Jkcy5zdGFydC5wYWdlLnksZS5jb29yZHMuY3VyLmNsaWVudC55PWUuY29vcmRzLnN0YXJ0LmNsaWVudC55LGUuY29vcmRzLnZlbG9jaXR5LmNsaWVudC55PTAsZS5jb29yZHMudmVsb2NpdHkucGFnZS55PTApOlwieVwiPT09biYmKGUuY29vcmRzLmN1ci5wYWdlLng9ZS5jb29yZHMuc3RhcnQucGFnZS54LGUuY29vcmRzLmN1ci5jbGllbnQueD1lLmNvb3Jkcy5zdGFydC5jbGllbnQueCxlLmNvb3Jkcy52ZWxvY2l0eS5jbGllbnQueD0wLGUuY29vcmRzLnZlbG9jaXR5LnBhZ2UueD0wKX19ZnVuY3Rpb24gVCh0KXt2YXIgZT10LmlFdmVudCxuPXQuaW50ZXJhY3Rpb247aWYoXCJkcmFnXCI9PT1uLnByZXBhcmVkLm5hbWUpe3ZhciByPW4ucHJlcGFyZWQuYXhpcztpZihcInhcIj09PXJ8fFwieVwiPT09cil7dmFyIGk9XCJ4XCI9PT1yP1wieVwiOlwieFwiO2UucGFnZVtpXT1uLmNvb3Jkcy5zdGFydC5wYWdlW2ldLGUuY2xpZW50W2ldPW4uY29vcmRzLnN0YXJ0LmNsaWVudFtpXSxlLmRlbHRhW2ldPTB9fX12YXIgUz17aWQ6XCJhY3Rpb25zL2RyYWdcIixpbnN0YWxsOmZ1bmN0aW9uKHQpe3ZhciBlPXQuYWN0aW9ucyxuPXQuSW50ZXJhY3RhYmxlLHI9dC5kZWZhdWx0cztuLnByb3RvdHlwZS5kcmFnZ2FibGU9Uy5kcmFnZ2FibGUsZS5tYXAuZHJhZz1TLGUubWV0aG9kRGljdC5kcmFnPVwiZHJhZ2dhYmxlXCIsci5hY3Rpb25zLmRyYWc9Uy5kZWZhdWx0c30sbGlzdGVuZXJzOntcImludGVyYWN0aW9uczpiZWZvcmUtYWN0aW9uLW1vdmVcIjpFLFwiaW50ZXJhY3Rpb25zOmFjdGlvbi1yZXN1bWVcIjpFLFwiaW50ZXJhY3Rpb25zOmFjdGlvbi1tb3ZlXCI6VCxcImF1dG8tc3RhcnQ6Y2hlY2tcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uLG49dC5pbnRlcmFjdGFibGUscj10LmJ1dHRvbnMsaT1uLm9wdGlvbnMuZHJhZztpZihpJiZpLmVuYWJsZWQmJighZS5wb2ludGVySXNEb3dufHwhL21vdXNlfHBvaW50ZXIvLnRlc3QoZS5wb2ludGVyVHlwZSl8fDAhPShyJm4ub3B0aW9ucy5kcmFnLm1vdXNlQnV0dG9ucykpKXJldHVybiB0LmFjdGlvbj17bmFtZTpcImRyYWdcIixheGlzOlwic3RhcnRcIj09PWkubG9ja0F4aXM/aS5zdGFydEF4aXM6aS5sb2NrQXhpc30sITF9fSxkcmFnZ2FibGU6ZnVuY3Rpb24odCl7cmV0dXJuIHcub2JqZWN0KHQpPyh0aGlzLm9wdGlvbnMuZHJhZy5lbmFibGVkPSExIT09dC5lbmFibGVkLHRoaXMuc2V0UGVyQWN0aW9uKFwiZHJhZ1wiLHQpLHRoaXMuc2V0T25FdmVudHMoXCJkcmFnXCIsdCksL14oeHl8eHx5fHN0YXJ0KSQvLnRlc3QodC5sb2NrQXhpcykmJih0aGlzLm9wdGlvbnMuZHJhZy5sb2NrQXhpcz10LmxvY2tBeGlzKSwvXih4eXx4fHkpJC8udGVzdCh0LnN0YXJ0QXhpcykmJih0aGlzLm9wdGlvbnMuZHJhZy5zdGFydEF4aXM9dC5zdGFydEF4aXMpLHRoaXMpOncuYm9vbCh0KT8odGhpcy5vcHRpb25zLmRyYWcuZW5hYmxlZD10LHRoaXMpOnRoaXMub3B0aW9ucy5kcmFnfSxiZWZvcmVNb3ZlOkUsbW92ZTpULGRlZmF1bHRzOntzdGFydEF4aXM6XCJ4eVwiLGxvY2tBeGlzOlwieHlcIn0sZ2V0Q3Vyc29yOmZ1bmN0aW9uKCl7cmV0dXJuXCJtb3ZlXCJ9LGZpbHRlckV2ZW50VHlwZTpmdW5jdGlvbih0KXtyZXR1cm4gMD09PXQuc2VhcmNoKFwiZHJhZ1wiKX19LF89UyxQPXtpbml0OmZ1bmN0aW9uKHQpe3ZhciBlPXQ7UC5kb2N1bWVudD1lLmRvY3VtZW50LFAuRG9jdW1lbnRGcmFnbWVudD1lLkRvY3VtZW50RnJhZ21lbnR8fE8sUC5TVkdFbGVtZW50PWUuU1ZHRWxlbWVudHx8TyxQLlNWR1NWR0VsZW1lbnQ9ZS5TVkdTVkdFbGVtZW50fHxPLFAuU1ZHRWxlbWVudEluc3RhbmNlPWUuU1ZHRWxlbWVudEluc3RhbmNlfHxPLFAuRWxlbWVudD1lLkVsZW1lbnR8fE8sUC5IVE1MRWxlbWVudD1lLkhUTUxFbGVtZW50fHxQLkVsZW1lbnQsUC5FdmVudD1lLkV2ZW50LFAuVG91Y2g9ZS5Ub3VjaHx8TyxQLlBvaW50ZXJFdmVudD1lLlBvaW50ZXJFdmVudHx8ZS5NU1BvaW50ZXJFdmVudH0sZG9jdW1lbnQ6bnVsbCxEb2N1bWVudEZyYWdtZW50Om51bGwsU1ZHRWxlbWVudDpudWxsLFNWR1NWR0VsZW1lbnQ6bnVsbCxTVkdFbGVtZW50SW5zdGFuY2U6bnVsbCxFbGVtZW50Om51bGwsSFRNTEVsZW1lbnQ6bnVsbCxFdmVudDpudWxsLFRvdWNoOm51bGwsUG9pbnRlckV2ZW50Om51bGx9O2Z1bmN0aW9uIE8oKXt9dmFyIGs9UDt2YXIgRD17aW5pdDpmdW5jdGlvbih0KXt2YXIgZT1rLkVsZW1lbnQsbj10Lm5hdmlnYXRvcnx8e307RC5zdXBwb3J0c1RvdWNoPVwib250b3VjaHN0YXJ0XCJpbiB0fHx3LmZ1bmModC5Eb2N1bWVudFRvdWNoKSYmay5kb2N1bWVudCBpbnN0YW5jZW9mIHQuRG9jdW1lbnRUb3VjaCxELnN1cHBvcnRzUG9pbnRlckV2ZW50PSExIT09bi5wb2ludGVyRW5hYmxlZCYmISFrLlBvaW50ZXJFdmVudCxELmlzSU9TPS9pUChob25lfG9kfGFkKS8udGVzdChuLnBsYXRmb3JtKSxELmlzSU9TNz0vaVAoaG9uZXxvZHxhZCkvLnRlc3Qobi5wbGF0Zm9ybSkmJi9PUyA3W15cXGRdLy50ZXN0KG4uYXBwVmVyc2lvbiksRC5pc0llOT0vTVNJRSA5Ly50ZXN0KG4udXNlckFnZW50KSxELmlzT3BlcmFNb2JpbGU9XCJPcGVyYVwiPT09bi5hcHBOYW1lJiZELnN1cHBvcnRzVG91Y2gmJi9QcmVzdG8vLnRlc3Qobi51c2VyQWdlbnQpLEQucHJlZml4ZWRNYXRjaGVzU2VsZWN0b3I9XCJtYXRjaGVzXCJpbiBlLnByb3RvdHlwZT9cIm1hdGNoZXNcIjpcIndlYmtpdE1hdGNoZXNTZWxlY3RvclwiaW4gZS5wcm90b3R5cGU/XCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3JcIjpcIm1vek1hdGNoZXNTZWxlY3RvclwiaW4gZS5wcm90b3R5cGU/XCJtb3pNYXRjaGVzU2VsZWN0b3JcIjpcIm9NYXRjaGVzU2VsZWN0b3JcImluIGUucHJvdG90eXBlP1wib01hdGNoZXNTZWxlY3RvclwiOlwibXNNYXRjaGVzU2VsZWN0b3JcIixELnBFdmVudFR5cGVzPUQuc3VwcG9ydHNQb2ludGVyRXZlbnQ/ay5Qb2ludGVyRXZlbnQ9PT10Lk1TUG9pbnRlckV2ZW50P3t1cDpcIk1TUG9pbnRlclVwXCIsZG93bjpcIk1TUG9pbnRlckRvd25cIixvdmVyOlwibW91c2VvdmVyXCIsb3V0OlwibW91c2VvdXRcIixtb3ZlOlwiTVNQb2ludGVyTW92ZVwiLGNhbmNlbDpcIk1TUG9pbnRlckNhbmNlbFwifTp7dXA6XCJwb2ludGVydXBcIixkb3duOlwicG9pbnRlcmRvd25cIixvdmVyOlwicG9pbnRlcm92ZXJcIixvdXQ6XCJwb2ludGVyb3V0XCIsbW92ZTpcInBvaW50ZXJtb3ZlXCIsY2FuY2VsOlwicG9pbnRlcmNhbmNlbFwifTpudWxsLEQud2hlZWxFdmVudD1rLmRvY3VtZW50JiZcIm9ubW91c2V3aGVlbFwiaW4gay5kb2N1bWVudD9cIm1vdXNld2hlZWxcIjpcIndoZWVsXCJ9LHN1cHBvcnRzVG91Y2g6bnVsbCxzdXBwb3J0c1BvaW50ZXJFdmVudDpudWxsLGlzSU9TNzpudWxsLGlzSU9TOm51bGwsaXNJZTk6bnVsbCxpc09wZXJhTW9iaWxlOm51bGwscHJlZml4ZWRNYXRjaGVzU2VsZWN0b3I6bnVsbCxwRXZlbnRUeXBlczpudWxsLHdoZWVsRXZlbnQ6bnVsbH07dmFyIEk9RDtmdW5jdGlvbiBNKHQsZSl7aWYodC5jb250YWlucylyZXR1cm4gdC5jb250YWlucyhlKTtmb3IoO2U7KXtpZihlPT09dClyZXR1cm4hMDtlPWUucGFyZW50Tm9kZX1yZXR1cm4hMX1mdW5jdGlvbiB6KHQsZSl7Zm9yKDt3LmVsZW1lbnQodCk7KXtpZihSKHQsZSkpcmV0dXJuIHQ7dD1BKHQpfXJldHVybiBudWxsfWZ1bmN0aW9uIEEodCl7dmFyIGU9dC5wYXJlbnROb2RlO2lmKHcuZG9jRnJhZyhlKSl7Zm9yKDsoZT1lLmhvc3QpJiZ3LmRvY0ZyYWcoZSk7KTtyZXR1cm4gZX1yZXR1cm4gZX1mdW5jdGlvbiBSKHQsZSl7cmV0dXJuIGchPT12JiYoZT1lLnJlcGxhY2UoL1xcL2RlZXBcXC8vZyxcIiBcIikpLHRbSS5wcmVmaXhlZE1hdGNoZXNTZWxlY3Rvcl0oZSl9dmFyIEM9ZnVuY3Rpb24odCl7cmV0dXJuIHQucGFyZW50Tm9kZXx8dC5ob3N0fTtmdW5jdGlvbiBqKHQsZSl7Zm9yKHZhciBuLHI9W10saT10OyhuPUMoaSkpJiZpIT09ZSYmbiE9PWkub3duZXJEb2N1bWVudDspci51bnNoaWZ0KGkpLGk9bjtyZXR1cm4gcn1mdW5jdGlvbiBGKHQsZSxuKXtmb3IoO3cuZWxlbWVudCh0KTspe2lmKFIodCxlKSlyZXR1cm4hMDtpZigodD1BKHQpKT09PW4pcmV0dXJuIFIodCxlKX1yZXR1cm4hMX1mdW5jdGlvbiBYKHQpe3JldHVybiB0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50fHx0fWZ1bmN0aW9uIFkodCl7dmFyIGU9dCBpbnN0YW5jZW9mIGsuU1ZHRWxlbWVudD90LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOnQuZ2V0Q2xpZW50UmVjdHMoKVswXTtyZXR1cm4gZSYme2xlZnQ6ZS5sZWZ0LHJpZ2h0OmUucmlnaHQsdG9wOmUudG9wLGJvdHRvbTplLmJvdHRvbSx3aWR0aDplLndpZHRofHxlLnJpZ2h0LWUubGVmdCxoZWlnaHQ6ZS5oZWlnaHR8fGUuYm90dG9tLWUudG9wfX1mdW5jdGlvbiBMKHQpe3ZhciBlLG49WSh0KTtpZighSS5pc0lPUzcmJm4pe3ZhciByPXt4OihlPShlPXkodCkpfHxnKS5zY3JvbGxYfHxlLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LHk6ZS5zY3JvbGxZfHxlLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3B9O24ubGVmdCs9ci54LG4ucmlnaHQrPXIueCxuLnRvcCs9ci55LG4uYm90dG9tKz1yLnl9cmV0dXJuIG59ZnVuY3Rpb24gcSh0KXtmb3IodmFyIGU9W107dDspZS5wdXNoKHQpLHQ9QSh0KTtyZXR1cm4gZX1mdW5jdGlvbiBCKHQpe3JldHVybiEhdy5zdHJpbmcodCkmJihrLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodCksITApfWZ1bmN0aW9uIFYodCxlKXtmb3IodmFyIG4gaW4gZSl0W25dPWVbbl07cmV0dXJuIHR9ZnVuY3Rpb24gVyh0LGUsbil7cmV0dXJuXCJwYXJlbnRcIj09PXQ/QShuKTpcInNlbGZcIj09PXQ/ZS5nZXRSZWN0KG4pOnoobix0KX1mdW5jdGlvbiBHKHQsZSxuLHIpe3ZhciBpPXQ7cmV0dXJuIHcuc3RyaW5nKGkpP2k9VyhpLGUsbik6dy5mdW5jKGkpJiYoaT1pLmFwcGx5KHZvaWQgMCxyKSksdy5lbGVtZW50KGkpJiYoaT1MKGkpKSxpfWZ1bmN0aW9uIE4odCl7cmV0dXJuIHQmJnt4OlwieFwiaW4gdD90Lng6dC5sZWZ0LHk6XCJ5XCJpbiB0P3QueTp0LnRvcH19ZnVuY3Rpb24gVSh0KXtyZXR1cm4hdHx8XCJ4XCJpbiB0JiZcInlcImluIHR8fCgodD1WKHt9LHQpKS54PXQubGVmdHx8MCx0Lnk9dC50b3B8fDAsdC53aWR0aD10LndpZHRofHwodC5yaWdodHx8MCktdC54LHQuaGVpZ2h0PXQuaGVpZ2h0fHwodC5ib3R0b218fDApLXQueSksdH1mdW5jdGlvbiBIKHQsZSxuKXt0LmxlZnQmJihlLmxlZnQrPW4ueCksdC5yaWdodCYmKGUucmlnaHQrPW4ueCksdC50b3AmJihlLnRvcCs9bi55KSx0LmJvdHRvbSYmKGUuYm90dG9tKz1uLnkpLGUud2lkdGg9ZS5yaWdodC1lLmxlZnQsZS5oZWlnaHQ9ZS5ib3R0b20tZS50b3B9ZnVuY3Rpb24gSyh0LGUsbil7dmFyIHI9biYmdC5vcHRpb25zW25dO3JldHVybiBOKEcociYmci5vcmlnaW58fHQub3B0aW9ucy5vcmlnaW4sdCxlLFt0JiZlXSkpfHx7eDowLHk6MH19ZnVuY3Rpb24gJCh0LGUpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpmdW5jdGlvbih0KXtyZXR1cm4hMH0scj1hcmd1bWVudHMubGVuZ3RoPjM/YXJndW1lbnRzWzNdOnZvaWQgMDtpZihyPXJ8fHt9LHcuc3RyaW5nKHQpJiYtMSE9PXQuc2VhcmNoKFwiIFwiKSYmKHQ9Sih0KSksdy5hcnJheSh0KSlyZXR1cm4gdC5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gJCh0LGUsbixyKX0pKSxyO2lmKHcub2JqZWN0KHQpJiYoZT10LHQ9XCJcIiksdy5mdW5jKGUpJiZuKHQpKXJbdF09clt0XXx8W10sclt0XS5wdXNoKGUpO2Vsc2UgaWYody5hcnJheShlKSlmb3IodmFyIGk9MCxvPWU7aTxvLmxlbmd0aDtpKyspe3ZhciBhPW9baV07JCh0LGEsbixyKX1lbHNlIGlmKHcub2JqZWN0KGUpKWZvcih2YXIgcyBpbiBlKXskKEoocykubWFwKChmdW5jdGlvbihlKXtyZXR1cm5cIlwiLmNvbmNhdCh0KS5jb25jYXQoZSl9KSksZVtzXSxuLHIpfXJldHVybiByfWZ1bmN0aW9uIEoodCl7cmV0dXJuIHQudHJpbSgpLnNwbGl0KC8gKy8pfXZhciBRPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIE1hdGguc3FydCh0KnQrZSplKX0sWj1bXCJ3ZWJraXRcIixcIm1velwiXTtmdW5jdGlvbiB0dCh0LGUpe3QuX19zZXR8fCh0Ll9fc2V0PXt9KTt2YXIgbj1mdW5jdGlvbihuKXtpZihaLnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiAwPT09bi5pbmRleE9mKHQpfSkpKXJldHVybiAxO1wiZnVuY3Rpb25cIiE9dHlwZW9mIHRbbl0mJlwiX19zZXRcIiE9PW4mJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4se2dldDpmdW5jdGlvbigpe3JldHVybiBuIGluIHQuX19zZXQ/dC5fX3NldFtuXTp0Ll9fc2V0W25dPWVbbl19LHNldDpmdW5jdGlvbihlKXt0Ll9fc2V0W25dPWV9LGNvbmZpZ3VyYWJsZTohMH0pfTtmb3IodmFyIHIgaW4gZSluKHIpO3JldHVybiB0fWZ1bmN0aW9uIGV0KHQsZSl7dC5wYWdlPXQucGFnZXx8e30sdC5wYWdlLng9ZS5wYWdlLngsdC5wYWdlLnk9ZS5wYWdlLnksdC5jbGllbnQ9dC5jbGllbnR8fHt9LHQuY2xpZW50Lng9ZS5jbGllbnQueCx0LmNsaWVudC55PWUuY2xpZW50LnksdC50aW1lU3RhbXA9ZS50aW1lU3RhbXB9ZnVuY3Rpb24gbnQodCl7dC5wYWdlLng9MCx0LnBhZ2UueT0wLHQuY2xpZW50Lng9MCx0LmNsaWVudC55PTB9ZnVuY3Rpb24gcnQodCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBrLkV2ZW50fHx0IGluc3RhbmNlb2Ygay5Ub3VjaH1mdW5jdGlvbiBpdCh0LGUsbil7cmV0dXJuIHQ9dHx8XCJwYWdlXCIsKG49bnx8e30pLng9ZVt0K1wiWFwiXSxuLnk9ZVt0K1wiWVwiXSxufWZ1bmN0aW9uIG90KHQsZSl7cmV0dXJuIGU9ZXx8e3g6MCx5OjB9LEkuaXNPcGVyYU1vYmlsZSYmcnQodCk/KGl0KFwic2NyZWVuXCIsdCxlKSxlLngrPXdpbmRvdy5zY3JvbGxYLGUueSs9d2luZG93LnNjcm9sbFkpOml0KFwicGFnZVwiLHQsZSksZX1mdW5jdGlvbiBhdCh0KXtyZXR1cm4gdy5udW1iZXIodC5wb2ludGVySWQpP3QucG9pbnRlcklkOnQuaWRlbnRpZmllcn1mdW5jdGlvbiBzdCh0LGUsbil7dmFyIHI9ZS5sZW5ndGg+MT9sdChlKTplWzBdO290KHIsdC5wYWdlKSxmdW5jdGlvbih0LGUpe2U9ZXx8e30sSS5pc09wZXJhTW9iaWxlJiZydCh0KT9pdChcInNjcmVlblwiLHQsZSk6aXQoXCJjbGllbnRcIix0LGUpfShyLHQuY2xpZW50KSx0LnRpbWVTdGFtcD1ufWZ1bmN0aW9uIGN0KHQpe3ZhciBlPVtdO3JldHVybiB3LmFycmF5KHQpPyhlWzBdPXRbMF0sZVsxXT10WzFdKTpcInRvdWNoZW5kXCI9PT10LnR5cGU/MT09PXQudG91Y2hlcy5sZW5ndGg/KGVbMF09dC50b3VjaGVzWzBdLGVbMV09dC5jaGFuZ2VkVG91Y2hlc1swXSk6MD09PXQudG91Y2hlcy5sZW5ndGgmJihlWzBdPXQuY2hhbmdlZFRvdWNoZXNbMF0sZVsxXT10LmNoYW5nZWRUb3VjaGVzWzFdKTooZVswXT10LnRvdWNoZXNbMF0sZVsxXT10LnRvdWNoZXNbMV0pLGV9ZnVuY3Rpb24gbHQodCl7Zm9yKHZhciBlPXtwYWdlWDowLHBhZ2VZOjAsY2xpZW50WDowLGNsaWVudFk6MCxzY3JlZW5YOjAsc2NyZWVuWTowfSxuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07Zm9yKHZhciBpIGluIGUpZVtpXSs9cltpXX1mb3IodmFyIG8gaW4gZSllW29dLz10Lmxlbmd0aDtyZXR1cm4gZX1mdW5jdGlvbiB1dCh0KXtpZighdC5sZW5ndGgpcmV0dXJuIG51bGw7dmFyIGU9Y3QodCksbj1NYXRoLm1pbihlWzBdLnBhZ2VYLGVbMV0ucGFnZVgpLHI9TWF0aC5taW4oZVswXS5wYWdlWSxlWzFdLnBhZ2VZKSxpPU1hdGgubWF4KGVbMF0ucGFnZVgsZVsxXS5wYWdlWCksbz1NYXRoLm1heChlWzBdLnBhZ2VZLGVbMV0ucGFnZVkpO3JldHVybnt4Om4seTpyLGxlZnQ6bix0b3A6cixyaWdodDppLGJvdHRvbTpvLHdpZHRoOmktbixoZWlnaHQ6by1yfX1mdW5jdGlvbiBwdCh0LGUpe3ZhciBuPWUrXCJYXCIscj1lK1wiWVwiLGk9Y3QodCksbz1pWzBdW25dLWlbMV1bbl0sYT1pWzBdW3JdLWlbMV1bcl07cmV0dXJuIFEobyxhKX1mdW5jdGlvbiBmdCh0LGUpe3ZhciBuPWUrXCJYXCIscj1lK1wiWVwiLGk9Y3QodCksbz1pWzFdW25dLWlbMF1bbl0sYT1pWzFdW3JdLWlbMF1bcl07cmV0dXJuIDE4MCpNYXRoLmF0YW4yKGEsbykvTWF0aC5QSX1mdW5jdGlvbiBkdCh0KXtyZXR1cm4gdy5zdHJpbmcodC5wb2ludGVyVHlwZSk/dC5wb2ludGVyVHlwZTp3Lm51bWJlcih0LnBvaW50ZXJUeXBlKT9bdm9pZCAwLHZvaWQgMCxcInRvdWNoXCIsXCJwZW5cIixcIm1vdXNlXCJdW3QucG9pbnRlclR5cGVdOi90b3VjaC8udGVzdCh0LnR5cGV8fFwiXCIpfHx0IGluc3RhbmNlb2Ygay5Ub3VjaD9cInRvdWNoXCI6XCJtb3VzZVwifWZ1bmN0aW9uIGh0KHQpe3ZhciBlPXcuZnVuYyh0LmNvbXBvc2VkUGF0aCk/dC5jb21wb3NlZFBhdGgoKTp0LnBhdGg7cmV0dXJuW1goZT9lWzBdOnQudGFyZ2V0KSxYKHQuY3VycmVudFRhcmdldCldfXZhciB2dD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSl7cih0aGlzLHQpLHRoaXMuaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkPSExLHRoaXMucHJvcGFnYXRpb25TdG9wcGVkPSExLHRoaXMuX2ludGVyYWN0aW9uPWV9cmV0dXJuIG8odCxbe2tleTpcInByZXZlbnREZWZhdWx0XCIsdmFsdWU6ZnVuY3Rpb24oKXt9fSx7a2V5Olwic3RvcFByb3BhZ2F0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZD0hMH19LHtrZXk6XCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkPXRoaXMucHJvcGFnYXRpb25TdG9wcGVkPSEwfX1dKSx0fSgpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh2dC5wcm90b3R5cGUsXCJpbnRlcmFjdGlvblwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faW50ZXJhY3Rpb24uX3Byb3h5fSxzZXQ6ZnVuY3Rpb24oKXt9fSk7dmFyIGd0PWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07dC5wdXNoKHIpfXJldHVybiB0fSxtdD1mdW5jdGlvbih0KXtyZXR1cm4gZ3QoW10sdCl9LHl0PWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspaWYoZSh0W25dLG4sdCkpcmV0dXJuIG47cmV0dXJuLTF9LGJ0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRbeXQodCxlKV19LHh0PWZ1bmN0aW9uKHQpe3Mobix0KTt2YXIgZT1wKG4pO2Z1bmN0aW9uIG4odCxpLG8pe3ZhciBhO3IodGhpcyxuKSwoYT1lLmNhbGwodGhpcyxpLl9pbnRlcmFjdGlvbikpLmRyb3B6b25lPXZvaWQgMCxhLmRyYWdFdmVudD12b2lkIDAsYS5yZWxhdGVkVGFyZ2V0PXZvaWQgMCxhLmRyYWdnYWJsZT12b2lkIDAsYS5wcm9wYWdhdGlvblN0b3BwZWQ9ITEsYS5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ9ITE7dmFyIHM9XCJkcmFnbGVhdmVcIj09PW8/dC5wcmV2OnQuY3VyLGM9cy5lbGVtZW50LGw9cy5kcm9wem9uZTtyZXR1cm4gYS50eXBlPW8sYS50YXJnZXQ9YyxhLmN1cnJlbnRUYXJnZXQ9YyxhLmRyb3B6b25lPWwsYS5kcmFnRXZlbnQ9aSxhLnJlbGF0ZWRUYXJnZXQ9aS50YXJnZXQsYS5kcmFnZ2FibGU9aS5pbnRlcmFjdGFibGUsYS50aW1lU3RhbXA9aS50aW1lU3RhbXAsYX1yZXR1cm4gbyhuLFt7a2V5OlwicmVqZWN0XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dGhpcy5faW50ZXJhY3Rpb24uZHJvcFN0YXRlO2lmKFwiZHJvcGFjdGl2YXRlXCI9PT10aGlzLnR5cGV8fHRoaXMuZHJvcHpvbmUmJmUuY3VyLmRyb3B6b25lPT09dGhpcy5kcm9wem9uZSYmZS5jdXIuZWxlbWVudD09PXRoaXMudGFyZ2V0KWlmKGUucHJldi5kcm9wem9uZT10aGlzLmRyb3B6b25lLGUucHJldi5lbGVtZW50PXRoaXMudGFyZ2V0LGUucmVqZWN0ZWQ9ITAsZS5ldmVudHMuZW50ZXI9bnVsbCx0aGlzLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLFwiZHJvcGFjdGl2YXRlXCI9PT10aGlzLnR5cGUpe3ZhciByPWUuYWN0aXZlRHJvcHMsaT15dChyLChmdW5jdGlvbihlKXt2YXIgbj1lLmRyb3B6b25lLHI9ZS5lbGVtZW50O3JldHVybiBuPT09dC5kcm9wem9uZSYmcj09PXQudGFyZ2V0fSkpO2UuYWN0aXZlRHJvcHMuc3BsaWNlKGksMSk7dmFyIG89bmV3IG4oZSx0aGlzLmRyYWdFdmVudCxcImRyb3BkZWFjdGl2YXRlXCIpO28uZHJvcHpvbmU9dGhpcy5kcm9wem9uZSxvLnRhcmdldD10aGlzLnRhcmdldCx0aGlzLmRyb3B6b25lLmZpcmUobyl9ZWxzZSB0aGlzLmRyb3B6b25lLmZpcmUobmV3IG4oZSx0aGlzLmRyYWdFdmVudCxcImRyYWdsZWF2ZVwiKSl9fSx7a2V5OlwicHJldmVudERlZmF1bHRcIix2YWx1ZTpmdW5jdGlvbigpe319LHtrZXk6XCJzdG9wUHJvcGFnYXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucHJvcGFnYXRpb25TdG9wcGVkPSEwfX0se2tleTpcInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ9dGhpcy5wcm9wYWdhdGlvblN0b3BwZWQ9ITB9fV0pLG59KHZ0KTtmdW5jdGlvbiB3dCh0LGUpe2Zvcih2YXIgbj0wLHI9dC5zbGljZSgpO248ci5sZW5ndGg7bisrKXt2YXIgaT1yW25dLG89aS5kcm9wem9uZSxhPWkuZWxlbWVudDtlLmRyb3B6b25lPW8sZS50YXJnZXQ9YSxvLmZpcmUoZSksZS5wcm9wYWdhdGlvblN0b3BwZWQ9ZS5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ9ITF9fWZ1bmN0aW9uIEV0KHQsZSl7Zm9yKHZhciBuPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPVtdLHI9MCxpPXQuaW50ZXJhY3RhYmxlcy5saXN0O3I8aS5sZW5ndGg7cisrKXt2YXIgbz1pW3JdO2lmKG8ub3B0aW9ucy5kcm9wLmVuYWJsZWQpe3ZhciBhPW8ub3B0aW9ucy5kcm9wLmFjY2VwdDtpZighKHcuZWxlbWVudChhKSYmYSE9PWV8fHcuc3RyaW5nKGEpJiYhUihlLGEpfHx3LmZ1bmMoYSkmJiFhKHtkcm9wem9uZTpvLGRyYWdnYWJsZUVsZW1lbnQ6ZX0pKSlmb3IodmFyIHM9MCxjPW8uZ2V0QWxsRWxlbWVudHMoKTtzPGMubGVuZ3RoO3MrKyl7dmFyIGw9Y1tzXTtsIT09ZSYmbi5wdXNoKHtkcm9wem9uZTpvLGVsZW1lbnQ6bCxyZWN0Om8uZ2V0UmVjdChsKX0pfX19cmV0dXJuIG59KHQsZSkscj0wO3I8bi5sZW5ndGg7cisrKXt2YXIgaT1uW3JdO2kucmVjdD1pLmRyb3B6b25lLmdldFJlY3QoaS5lbGVtZW50KX1yZXR1cm4gbn1mdW5jdGlvbiBUdCh0LGUsbil7Zm9yKHZhciByPXQuZHJvcFN0YXRlLGk9dC5pbnRlcmFjdGFibGUsbz10LmVsZW1lbnQsYT1bXSxzPTAsYz1yLmFjdGl2ZURyb3BzO3M8Yy5sZW5ndGg7cysrKXt2YXIgbD1jW3NdLHU9bC5kcm9wem9uZSxwPWwuZWxlbWVudCxmPWwucmVjdCxkPXUuZHJvcENoZWNrKGUsbixpLG8scCxmKTthLnB1c2goZD9wOm51bGwpfXZhciBoPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxuLHIsaT1bXSxvPTA7bzx0Lmxlbmd0aDtvKyspe3ZhciBhPXRbb10scz10W2VdO2lmKGEmJm8hPT1lKWlmKHMpe3ZhciBjPUMoYSksbD1DKHMpO2lmKGMhPT1hLm93bmVyRG9jdW1lbnQpaWYobCE9PWEub3duZXJEb2N1bWVudClpZihjIT09bCl7aT1pLmxlbmd0aD9pOmoocyk7dmFyIHU9dm9pZCAwO2lmKHMgaW5zdGFuY2VvZiBrLkhUTUxFbGVtZW50JiZhIGluc3RhbmNlb2Ygay5TVkdFbGVtZW50JiYhKGEgaW5zdGFuY2VvZiBrLlNWR1NWR0VsZW1lbnQpKXtpZihhPT09bCljb250aW51ZTt1PWEub3duZXJTVkdFbGVtZW50fWVsc2UgdT1hO2Zvcih2YXIgcD1qKHUscy5vd25lckRvY3VtZW50KSxmPTA7cFtmXSYmcFtmXT09PWlbZl07KWYrKzt2YXIgZD1bcFtmLTFdLHBbZl0saVtmXV07aWYoZFswXSlmb3IodmFyIGg9ZFswXS5sYXN0Q2hpbGQ7aDspe2lmKGg9PT1kWzFdKXtlPW8saT1wO2JyZWFrfWlmKGg9PT1kWzJdKWJyZWFrO2g9aC5wcmV2aW91c1NpYmxpbmd9fWVsc2Ugcj1zLHZvaWQgMCx2b2lkIDAsKHBhcnNlSW50KHkobj1hKS5nZXRDb21wdXRlZFN0eWxlKG4pLnpJbmRleCwxMCl8fDApPj0ocGFyc2VJbnQoeShyKS5nZXRDb21wdXRlZFN0eWxlKHIpLnpJbmRleCwxMCl8fDApJiYoZT1vKTtlbHNlIGU9b31lbHNlIGU9b31yZXR1cm4gZX0oYSk7cmV0dXJuIHIuYWN0aXZlRHJvcHNbaF18fG51bGx9ZnVuY3Rpb24gU3QodCxlLG4pe3ZhciByPXQuZHJvcFN0YXRlLGk9e2VudGVyOm51bGwsbGVhdmU6bnVsbCxhY3RpdmF0ZTpudWxsLGRlYWN0aXZhdGU6bnVsbCxtb3ZlOm51bGwsZHJvcDpudWxsfTtyZXR1cm5cImRyYWdzdGFydFwiPT09bi50eXBlJiYoaS5hY3RpdmF0ZT1uZXcgeHQocixuLFwiZHJvcGFjdGl2YXRlXCIpLGkuYWN0aXZhdGUudGFyZ2V0PW51bGwsaS5hY3RpdmF0ZS5kcm9wem9uZT1udWxsKSxcImRyYWdlbmRcIj09PW4udHlwZSYmKGkuZGVhY3RpdmF0ZT1uZXcgeHQocixuLFwiZHJvcGRlYWN0aXZhdGVcIiksaS5kZWFjdGl2YXRlLnRhcmdldD1udWxsLGkuZGVhY3RpdmF0ZS5kcm9wem9uZT1udWxsKSxyLnJlamVjdGVkfHwoci5jdXIuZWxlbWVudCE9PXIucHJldi5lbGVtZW50JiYoci5wcmV2LmRyb3B6b25lJiYoaS5sZWF2ZT1uZXcgeHQocixuLFwiZHJhZ2xlYXZlXCIpLG4uZHJhZ0xlYXZlPWkubGVhdmUudGFyZ2V0PXIucHJldi5lbGVtZW50LG4ucHJldkRyb3B6b25lPWkubGVhdmUuZHJvcHpvbmU9ci5wcmV2LmRyb3B6b25lKSxyLmN1ci5kcm9wem9uZSYmKGkuZW50ZXI9bmV3IHh0KHIsbixcImRyYWdlbnRlclwiKSxuLmRyYWdFbnRlcj1yLmN1ci5lbGVtZW50LG4uZHJvcHpvbmU9ci5jdXIuZHJvcHpvbmUpKSxcImRyYWdlbmRcIj09PW4udHlwZSYmci5jdXIuZHJvcHpvbmUmJihpLmRyb3A9bmV3IHh0KHIsbixcImRyb3BcIiksbi5kcm9wem9uZT1yLmN1ci5kcm9wem9uZSxuLnJlbGF0ZWRUYXJnZXQ9ci5jdXIuZWxlbWVudCksXCJkcmFnbW92ZVwiPT09bi50eXBlJiZyLmN1ci5kcm9wem9uZSYmKGkubW92ZT1uZXcgeHQocixuLFwiZHJvcG1vdmVcIiksbi5kcm9wem9uZT1yLmN1ci5kcm9wem9uZSkpLGl9ZnVuY3Rpb24gX3QodCxlKXt2YXIgbj10LmRyb3BTdGF0ZSxyPW4uYWN0aXZlRHJvcHMsaT1uLmN1cixvPW4ucHJldjtlLmxlYXZlJiZvLmRyb3B6b25lLmZpcmUoZS5sZWF2ZSksZS5lbnRlciYmaS5kcm9wem9uZS5maXJlKGUuZW50ZXIpLGUubW92ZSYmaS5kcm9wem9uZS5maXJlKGUubW92ZSksZS5kcm9wJiZpLmRyb3B6b25lLmZpcmUoZS5kcm9wKSxlLmRlYWN0aXZhdGUmJnd0KHIsZS5kZWFjdGl2YXRlKSxuLnByZXYuZHJvcHpvbmU9aS5kcm9wem9uZSxuLnByZXYuZWxlbWVudD1pLmVsZW1lbnR9ZnVuY3Rpb24gUHQodCxlKXt2YXIgbj10LmludGVyYWN0aW9uLHI9dC5pRXZlbnQsaT10LmV2ZW50O2lmKFwiZHJhZ21vdmVcIj09PXIudHlwZXx8XCJkcmFnZW5kXCI9PT1yLnR5cGUpe3ZhciBvPW4uZHJvcFN0YXRlO2UuZHluYW1pY0Ryb3AmJihvLmFjdGl2ZURyb3BzPUV0KGUsbi5lbGVtZW50KSk7dmFyIGE9cixzPVR0KG4sYSxpKTtvLnJlamVjdGVkPW8ucmVqZWN0ZWQmJiEhcyYmcy5kcm9wem9uZT09PW8uY3VyLmRyb3B6b25lJiZzLmVsZW1lbnQ9PT1vLmN1ci5lbGVtZW50LG8uY3VyLmRyb3B6b25lPXMmJnMuZHJvcHpvbmUsby5jdXIuZWxlbWVudD1zJiZzLmVsZW1lbnQsby5ldmVudHM9U3QobiwwLGEpfX12YXIgT3Q9e2lkOlwiYWN0aW9ucy9kcm9wXCIsaW5zdGFsbDpmdW5jdGlvbih0KXt2YXIgZT10LmFjdGlvbnMsbj10LmludGVyYWN0U3RhdGljLHI9dC5JbnRlcmFjdGFibGUsaT10LmRlZmF1bHRzO3QudXNlUGx1Z2luKF8pLHIucHJvdG90eXBlLmRyb3B6b25lPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbih0LGUpe2lmKHcub2JqZWN0KGUpKXtpZih0Lm9wdGlvbnMuZHJvcC5lbmFibGVkPSExIT09ZS5lbmFibGVkLGUubGlzdGVuZXJzKXt2YXIgbj0kKGUubGlzdGVuZXJzKSxyPU9iamVjdC5rZXlzKG4pLnJlZHVjZSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdFsvXihlbnRlcnxsZWF2ZSkvLnRlc3QoZSk/XCJkcmFnXCIuY29uY2F0KGUpOi9eKGFjdGl2YXRlfGRlYWN0aXZhdGV8bW92ZSkvLnRlc3QoZSk/XCJkcm9wXCIuY29uY2F0KGUpOmVdPW5bZV0sdH0pLHt9KSxpPXQub3B0aW9ucy5kcm9wLmxpc3RlbmVycztpJiZ0Lm9mZihpKSx0Lm9uKHIpLHQub3B0aW9ucy5kcm9wLmxpc3RlbmVycz1yfXJldHVybiB3LmZ1bmMoZS5vbmRyb3ApJiZ0Lm9uKFwiZHJvcFwiLGUub25kcm9wKSx3LmZ1bmMoZS5vbmRyb3BhY3RpdmF0ZSkmJnQub24oXCJkcm9wYWN0aXZhdGVcIixlLm9uZHJvcGFjdGl2YXRlKSx3LmZ1bmMoZS5vbmRyb3BkZWFjdGl2YXRlKSYmdC5vbihcImRyb3BkZWFjdGl2YXRlXCIsZS5vbmRyb3BkZWFjdGl2YXRlKSx3LmZ1bmMoZS5vbmRyYWdlbnRlcikmJnQub24oXCJkcmFnZW50ZXJcIixlLm9uZHJhZ2VudGVyKSx3LmZ1bmMoZS5vbmRyYWdsZWF2ZSkmJnQub24oXCJkcmFnbGVhdmVcIixlLm9uZHJhZ2xlYXZlKSx3LmZ1bmMoZS5vbmRyb3Btb3ZlKSYmdC5vbihcImRyb3Btb3ZlXCIsZS5vbmRyb3Btb3ZlKSwvXihwb2ludGVyfGNlbnRlcikkLy50ZXN0KGUub3ZlcmxhcCk/dC5vcHRpb25zLmRyb3Aub3ZlcmxhcD1lLm92ZXJsYXA6dy5udW1iZXIoZS5vdmVybGFwKSYmKHQub3B0aW9ucy5kcm9wLm92ZXJsYXA9TWF0aC5tYXgoTWF0aC5taW4oMSxlLm92ZXJsYXApLDApKSxcImFjY2VwdFwiaW4gZSYmKHQub3B0aW9ucy5kcm9wLmFjY2VwdD1lLmFjY2VwdCksXCJjaGVja2VyXCJpbiBlJiYodC5vcHRpb25zLmRyb3AuY2hlY2tlcj1lLmNoZWNrZXIpLHR9aWYody5ib29sKGUpKXJldHVybiB0Lm9wdGlvbnMuZHJvcC5lbmFibGVkPWUsdDtyZXR1cm4gdC5vcHRpb25zLmRyb3B9KHRoaXMsdCl9LHIucHJvdG90eXBlLmRyb3BDaGVjaz1mdW5jdGlvbih0LGUsbixyLGksbyl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEpe3ZhciBzPSExO2lmKCEoYT1hfHx0LmdldFJlY3QobykpKXJldHVybiEhdC5vcHRpb25zLmRyb3AuY2hlY2tlciYmdC5vcHRpb25zLmRyb3AuY2hlY2tlcihlLG4scyx0LG8scixpKTt2YXIgYz10Lm9wdGlvbnMuZHJvcC5vdmVybGFwO2lmKFwicG9pbnRlclwiPT09Yyl7dmFyIGw9SyhyLGksXCJkcmFnXCIpLHU9b3QoZSk7dS54Kz1sLngsdS55Kz1sLnk7dmFyIHA9dS54PmEubGVmdCYmdS54PGEucmlnaHQsZj11Lnk+YS50b3AmJnUueTxhLmJvdHRvbTtzPXAmJmZ9dmFyIGQ9ci5nZXRSZWN0KGkpO2lmKGQmJlwiY2VudGVyXCI9PT1jKXt2YXIgaD1kLmxlZnQrZC53aWR0aC8yLHY9ZC50b3ArZC5oZWlnaHQvMjtzPWg+PWEubGVmdCYmaDw9YS5yaWdodCYmdj49YS50b3AmJnY8PWEuYm90dG9tfWlmKGQmJncubnVtYmVyKGMpKXtzPU1hdGgubWF4KDAsTWF0aC5taW4oYS5yaWdodCxkLnJpZ2h0KS1NYXRoLm1heChhLmxlZnQsZC5sZWZ0KSkqTWF0aC5tYXgoMCxNYXRoLm1pbihhLmJvdHRvbSxkLmJvdHRvbSktTWF0aC5tYXgoYS50b3AsZC50b3ApKS8oZC53aWR0aCpkLmhlaWdodCk+PWN9dC5vcHRpb25zLmRyb3AuY2hlY2tlciYmKHM9dC5vcHRpb25zLmRyb3AuY2hlY2tlcihlLG4scyx0LG8scixpKSk7cmV0dXJuIHN9KHRoaXMsdCxlLG4scixpLG8pfSxuLmR5bmFtaWNEcm9wPWZ1bmN0aW9uKGUpe3JldHVybiB3LmJvb2woZSk/KHQuZHluYW1pY0Ryb3A9ZSxuKTp0LmR5bmFtaWNEcm9wfSxWKGUucGhhc2VsZXNzVHlwZXMse2RyYWdlbnRlcjohMCxkcmFnbGVhdmU6ITAsZHJvcGFjdGl2YXRlOiEwLGRyb3BkZWFjdGl2YXRlOiEwLGRyb3Btb3ZlOiEwLGRyb3A6ITB9KSxlLm1ldGhvZERpY3QuZHJvcD1cImRyb3B6b25lXCIsdC5keW5hbWljRHJvcD0hMSxpLmFjdGlvbnMuZHJvcD1PdC5kZWZhdWx0c30sbGlzdGVuZXJzOntcImludGVyYWN0aW9uczpiZWZvcmUtYWN0aW9uLXN0YXJ0XCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbjtcImRyYWdcIj09PWUucHJlcGFyZWQubmFtZSYmKGUuZHJvcFN0YXRlPXtjdXI6e2Ryb3B6b25lOm51bGwsZWxlbWVudDpudWxsfSxwcmV2Ontkcm9wem9uZTpudWxsLGVsZW1lbnQ6bnVsbH0scmVqZWN0ZWQ6bnVsbCxldmVudHM6bnVsbCxhY3RpdmVEcm9wczpbXX0pfSxcImludGVyYWN0aW9uczphZnRlci1hY3Rpb24tc3RhcnRcIjpmdW5jdGlvbih0LGUpe3ZhciBuPXQuaW50ZXJhY3Rpb24scj0odC5ldmVudCx0LmlFdmVudCk7aWYoXCJkcmFnXCI9PT1uLnByZXBhcmVkLm5hbWUpe3ZhciBpPW4uZHJvcFN0YXRlO2kuYWN0aXZlRHJvcHM9W10saS5ldmVudHM9e30saS5hY3RpdmVEcm9wcz1FdChlLG4uZWxlbWVudCksaS5ldmVudHM9U3QobiwwLHIpLGkuZXZlbnRzLmFjdGl2YXRlJiYod3QoaS5hY3RpdmVEcm9wcyxpLmV2ZW50cy5hY3RpdmF0ZSksZS5maXJlKFwiYWN0aW9ucy9kcm9wOnN0YXJ0XCIse2ludGVyYWN0aW9uOm4sZHJhZ0V2ZW50OnJ9KSl9fSxcImludGVyYWN0aW9uczphY3Rpb24tbW92ZVwiOlB0LFwiaW50ZXJhY3Rpb25zOmFmdGVyLWFjdGlvbi1tb3ZlXCI6ZnVuY3Rpb24odCxlKXt2YXIgbj10LmludGVyYWN0aW9uLHI9dC5pRXZlbnQ7aWYoXCJkcmFnXCI9PT1uLnByZXBhcmVkLm5hbWUpe3ZhciBpPW4uZHJvcFN0YXRlO190KG4saS5ldmVudHMpLGUuZmlyZShcImFjdGlvbnMvZHJvcDptb3ZlXCIse2ludGVyYWN0aW9uOm4sZHJhZ0V2ZW50OnJ9KSxpLmV2ZW50cz17fX19LFwiaW50ZXJhY3Rpb25zOmFjdGlvbi1lbmRcIjpmdW5jdGlvbih0LGUpe2lmKFwiZHJhZ1wiPT09dC5pbnRlcmFjdGlvbi5wcmVwYXJlZC5uYW1lKXt2YXIgbj10LmludGVyYWN0aW9uLHI9dC5pRXZlbnQ7UHQodCxlKSxfdChuLG4uZHJvcFN0YXRlLmV2ZW50cyksZS5maXJlKFwiYWN0aW9ucy9kcm9wOmVuZFwiLHtpbnRlcmFjdGlvbjpuLGRyYWdFdmVudDpyfSl9fSxcImludGVyYWN0aW9uczpzdG9wXCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbjtpZihcImRyYWdcIj09PWUucHJlcGFyZWQubmFtZSl7dmFyIG49ZS5kcm9wU3RhdGU7biYmKG4uYWN0aXZlRHJvcHM9bnVsbCxuLmV2ZW50cz1udWxsLG4uY3VyLmRyb3B6b25lPW51bGwsbi5jdXIuZWxlbWVudD1udWxsLG4ucHJldi5kcm9wem9uZT1udWxsLG4ucHJldi5lbGVtZW50PW51bGwsbi5yZWplY3RlZD0hMSl9fX0sZ2V0QWN0aXZlRHJvcHM6RXQsZ2V0RHJvcDpUdCxnZXREcm9wRXZlbnRzOlN0LGZpcmVEcm9wRXZlbnRzOl90LGZpbHRlckV2ZW50VHlwZTpmdW5jdGlvbih0KXtyZXR1cm4gMD09PXQuc2VhcmNoKFwiZHJhZ1wiKXx8MD09PXQuc2VhcmNoKFwiZHJvcFwiKX0sZGVmYXVsdHM6e2VuYWJsZWQ6ITEsYWNjZXB0Om51bGwsb3ZlcmxhcDpcInBvaW50ZXJcIn19LGt0PU90O2Z1bmN0aW9uIER0KHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24sbj10LmlFdmVudCxyPXQucGhhc2U7aWYoXCJnZXN0dXJlXCI9PT1lLnByZXBhcmVkLm5hbWUpe3ZhciBpPWUucG9pbnRlcnMubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5wb2ludGVyfSkpLG89XCJzdGFydFwiPT09cixhPVwiZW5kXCI9PT1yLHM9ZS5pbnRlcmFjdGFibGUub3B0aW9ucy5kZWx0YVNvdXJjZTtpZihuLnRvdWNoZXM9W2lbMF0saVsxXV0sbyluLmRpc3RhbmNlPXB0KGkscyksbi5ib3g9dXQoaSksbi5zY2FsZT0xLG4uZHM9MCxuLmFuZ2xlPWZ0KGkscyksbi5kYT0wLGUuZ2VzdHVyZS5zdGFydERpc3RhbmNlPW4uZGlzdGFuY2UsZS5nZXN0dXJlLnN0YXJ0QW5nbGU9bi5hbmdsZTtlbHNlIGlmKGF8fGUucG9pbnRlcnMubGVuZ3RoPDIpe3ZhciBjPWUucHJldkV2ZW50O24uZGlzdGFuY2U9Yy5kaXN0YW5jZSxuLmJveD1jLmJveCxuLnNjYWxlPWMuc2NhbGUsbi5kcz0wLG4uYW5nbGU9Yy5hbmdsZSxuLmRhPTB9ZWxzZSBuLmRpc3RhbmNlPXB0KGkscyksbi5ib3g9dXQoaSksbi5zY2FsZT1uLmRpc3RhbmNlL2UuZ2VzdHVyZS5zdGFydERpc3RhbmNlLG4uYW5nbGU9ZnQoaSxzKSxuLmRzPW4uc2NhbGUtZS5nZXN0dXJlLnNjYWxlLG4uZGE9bi5hbmdsZS1lLmdlc3R1cmUuYW5nbGU7ZS5nZXN0dXJlLmRpc3RhbmNlPW4uZGlzdGFuY2UsZS5nZXN0dXJlLmFuZ2xlPW4uYW5nbGUsdy5udW1iZXIobi5zY2FsZSkmJm4uc2NhbGUhPT0xLzAmJiFpc05hTihuLnNjYWxlKSYmKGUuZ2VzdHVyZS5zY2FsZT1uLnNjYWxlKX19dmFyIEl0PXtpZDpcImFjdGlvbnMvZ2VzdHVyZVwiLGJlZm9yZTpbXCJhY3Rpb25zL2RyYWdcIixcImFjdGlvbnMvcmVzaXplXCJdLGluc3RhbGw6ZnVuY3Rpb24odCl7dmFyIGU9dC5hY3Rpb25zLG49dC5JbnRlcmFjdGFibGUscj10LmRlZmF1bHRzO24ucHJvdG90eXBlLmdlc3R1cmFibGU9ZnVuY3Rpb24odCl7cmV0dXJuIHcub2JqZWN0KHQpPyh0aGlzLm9wdGlvbnMuZ2VzdHVyZS5lbmFibGVkPSExIT09dC5lbmFibGVkLHRoaXMuc2V0UGVyQWN0aW9uKFwiZ2VzdHVyZVwiLHQpLHRoaXMuc2V0T25FdmVudHMoXCJnZXN0dXJlXCIsdCksdGhpcyk6dy5ib29sKHQpPyh0aGlzLm9wdGlvbnMuZ2VzdHVyZS5lbmFibGVkPXQsdGhpcyk6dGhpcy5vcHRpb25zLmdlc3R1cmV9LGUubWFwLmdlc3R1cmU9SXQsZS5tZXRob2REaWN0Lmdlc3R1cmU9XCJnZXN0dXJhYmxlXCIsci5hY3Rpb25zLmdlc3R1cmU9SXQuZGVmYXVsdHN9LGxpc3RlbmVyczp7XCJpbnRlcmFjdGlvbnM6YWN0aW9uLXN0YXJ0XCI6RHQsXCJpbnRlcmFjdGlvbnM6YWN0aW9uLW1vdmVcIjpEdCxcImludGVyYWN0aW9uczphY3Rpb24tZW5kXCI6RHQsXCJpbnRlcmFjdGlvbnM6bmV3XCI6ZnVuY3Rpb24odCl7dC5pbnRlcmFjdGlvbi5nZXN0dXJlPXthbmdsZTowLGRpc3RhbmNlOjAsc2NhbGU6MSxzdGFydEFuZ2xlOjAsc3RhcnREaXN0YW5jZTowfX0sXCJhdXRvLXN0YXJ0OmNoZWNrXCI6ZnVuY3Rpb24odCl7aWYoISh0LmludGVyYWN0aW9uLnBvaW50ZXJzLmxlbmd0aDwyKSl7dmFyIGU9dC5pbnRlcmFjdGFibGUub3B0aW9ucy5nZXN0dXJlO2lmKGUmJmUuZW5hYmxlZClyZXR1cm4gdC5hY3Rpb249e25hbWU6XCJnZXN0dXJlXCJ9LCExfX19LGRlZmF1bHRzOnt9LGdldEN1cnNvcjpmdW5jdGlvbigpe3JldHVyblwiXCJ9LGZpbHRlckV2ZW50VHlwZTpmdW5jdGlvbih0KXtyZXR1cm4gMD09PXQuc2VhcmNoKFwiZ2VzdHVyZVwiKX19LE10PUl0O2Z1bmN0aW9uIHp0KHQsZSxuLHIsaSxvLGEpe2lmKCFlKXJldHVybiExO2lmKCEwPT09ZSl7dmFyIHM9dy5udW1iZXIoby53aWR0aCk/by53aWR0aDpvLnJpZ2h0LW8ubGVmdCxjPXcubnVtYmVyKG8uaGVpZ2h0KT9vLmhlaWdodDpvLmJvdHRvbS1vLnRvcDtpZihhPU1hdGgubWluKGEsTWF0aC5hYnMoKFwibGVmdFwiPT09dHx8XCJyaWdodFwiPT09dD9zOmMpLzIpKSxzPDAmJihcImxlZnRcIj09PXQ/dD1cInJpZ2h0XCI6XCJyaWdodFwiPT09dCYmKHQ9XCJsZWZ0XCIpKSxjPDAmJihcInRvcFwiPT09dD90PVwiYm90dG9tXCI6XCJib3R0b21cIj09PXQmJih0PVwidG9wXCIpKSxcImxlZnRcIj09PXQpe3ZhciBsPXM+PTA/by5sZWZ0Om8ucmlnaHQ7cmV0dXJuIG4ueDxsK2F9aWYoXCJ0b3BcIj09PXQpe3ZhciB1PWM+PTA/by50b3A6by5ib3R0b207cmV0dXJuIG4ueTx1K2F9aWYoXCJyaWdodFwiPT09dClyZXR1cm4gbi54PihzPj0wP28ucmlnaHQ6by5sZWZ0KS1hO2lmKFwiYm90dG9tXCI9PT10KXJldHVybiBuLnk+KGM+PTA/by5ib3R0b206by50b3ApLWF9cmV0dXJuISF3LmVsZW1lbnQocikmJih3LmVsZW1lbnQoZSk/ZT09PXI6RihyLGUsaSkpfWZ1bmN0aW9uIEF0KHQpe3ZhciBlPXQuaUV2ZW50LG49dC5pbnRlcmFjdGlvbjtpZihcInJlc2l6ZVwiPT09bi5wcmVwYXJlZC5uYW1lJiZuLnJlc2l6ZUF4ZXMpe3ZhciByPWU7bi5pbnRlcmFjdGFibGUub3B0aW9ucy5yZXNpemUuc3F1YXJlPyhcInlcIj09PW4ucmVzaXplQXhlcz9yLmRlbHRhLng9ci5kZWx0YS55OnIuZGVsdGEueT1yLmRlbHRhLngsci5heGVzPVwieHlcIik6KHIuYXhlcz1uLnJlc2l6ZUF4ZXMsXCJ4XCI9PT1uLnJlc2l6ZUF4ZXM/ci5kZWx0YS55PTA6XCJ5XCI9PT1uLnJlc2l6ZUF4ZXMmJihyLmRlbHRhLng9MCkpfX12YXIgUnQsQ3QsanQ9e2lkOlwiYWN0aW9ucy9yZXNpemVcIixiZWZvcmU6W1wiYWN0aW9ucy9kcmFnXCJdLGluc3RhbGw6ZnVuY3Rpb24odCl7dmFyIGU9dC5hY3Rpb25zLG49dC5icm93c2VyLHI9dC5JbnRlcmFjdGFibGUsaT10LmRlZmF1bHRzO2p0LmN1cnNvcnM9ZnVuY3Rpb24odCl7cmV0dXJuIHQuaXNJZTk/e3g6XCJlLXJlc2l6ZVwiLHk6XCJzLXJlc2l6ZVwiLHh5Olwic2UtcmVzaXplXCIsdG9wOlwibi1yZXNpemVcIixsZWZ0Olwidy1yZXNpemVcIixib3R0b206XCJzLXJlc2l6ZVwiLHJpZ2h0OlwiZS1yZXNpemVcIix0b3BsZWZ0Olwic2UtcmVzaXplXCIsYm90dG9tcmlnaHQ6XCJzZS1yZXNpemVcIix0b3ByaWdodDpcIm5lLXJlc2l6ZVwiLGJvdHRvbWxlZnQ6XCJuZS1yZXNpemVcIn06e3g6XCJldy1yZXNpemVcIix5OlwibnMtcmVzaXplXCIseHk6XCJud3NlLXJlc2l6ZVwiLHRvcDpcIm5zLXJlc2l6ZVwiLGxlZnQ6XCJldy1yZXNpemVcIixib3R0b206XCJucy1yZXNpemVcIixyaWdodDpcImV3LXJlc2l6ZVwiLHRvcGxlZnQ6XCJud3NlLXJlc2l6ZVwiLGJvdHRvbXJpZ2h0OlwibndzZS1yZXNpemVcIix0b3ByaWdodDpcIm5lc3ctcmVzaXplXCIsYm90dG9tbGVmdDpcIm5lc3ctcmVzaXplXCJ9fShuKSxqdC5kZWZhdWx0TWFyZ2luPW4uc3VwcG9ydHNUb3VjaHx8bi5zdXBwb3J0c1BvaW50ZXJFdmVudD8yMDoxMCxyLnByb3RvdHlwZS5yZXNpemFibGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXtpZih3Lm9iamVjdChlKSlyZXR1cm4gdC5vcHRpb25zLnJlc2l6ZS5lbmFibGVkPSExIT09ZS5lbmFibGVkLHQuc2V0UGVyQWN0aW9uKFwicmVzaXplXCIsZSksdC5zZXRPbkV2ZW50cyhcInJlc2l6ZVwiLGUpLHcuc3RyaW5nKGUuYXhpcykmJi9eeCR8XnkkfF54eSQvLnRlc3QoZS5heGlzKT90Lm9wdGlvbnMucmVzaXplLmF4aXM9ZS5heGlzOm51bGw9PT1lLmF4aXMmJih0Lm9wdGlvbnMucmVzaXplLmF4aXM9bi5kZWZhdWx0cy5hY3Rpb25zLnJlc2l6ZS5heGlzKSx3LmJvb2woZS5wcmVzZXJ2ZUFzcGVjdFJhdGlvKT90Lm9wdGlvbnMucmVzaXplLnByZXNlcnZlQXNwZWN0UmF0aW89ZS5wcmVzZXJ2ZUFzcGVjdFJhdGlvOncuYm9vbChlLnNxdWFyZSkmJih0Lm9wdGlvbnMucmVzaXplLnNxdWFyZT1lLnNxdWFyZSksdDtpZih3LmJvb2woZSkpcmV0dXJuIHQub3B0aW9ucy5yZXNpemUuZW5hYmxlZD1lLHQ7cmV0dXJuIHQub3B0aW9ucy5yZXNpemV9KHRoaXMsZSx0KX0sZS5tYXAucmVzaXplPWp0LGUubWV0aG9kRGljdC5yZXNpemU9XCJyZXNpemFibGVcIixpLmFjdGlvbnMucmVzaXplPWp0LmRlZmF1bHRzfSxsaXN0ZW5lcnM6e1wiaW50ZXJhY3Rpb25zOm5ld1wiOmZ1bmN0aW9uKHQpe3QuaW50ZXJhY3Rpb24ucmVzaXplQXhlcz1cInh5XCJ9LFwiaW50ZXJhY3Rpb25zOmFjdGlvbi1zdGFydFwiOmZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXt2YXIgZT10LmlFdmVudCxuPXQuaW50ZXJhY3Rpb247aWYoXCJyZXNpemVcIj09PW4ucHJlcGFyZWQubmFtZSYmbi5wcmVwYXJlZC5lZGdlcyl7dmFyIHI9ZSxpPW4ucmVjdDtuLl9yZWN0cz17c3RhcnQ6Vih7fSxpKSxjb3JyZWN0ZWQ6Vih7fSxpKSxwcmV2aW91czpWKHt9LGkpLGRlbHRhOntsZWZ0OjAscmlnaHQ6MCx3aWR0aDowLHRvcDowLGJvdHRvbTowLGhlaWdodDowfX0sci5lZGdlcz1uLnByZXBhcmVkLmVkZ2VzLHIucmVjdD1uLl9yZWN0cy5jb3JyZWN0ZWQsci5kZWx0YVJlY3Q9bi5fcmVjdHMuZGVsdGF9fSh0KSxBdCh0KX0sXCJpbnRlcmFjdGlvbnM6YWN0aW9uLW1vdmVcIjpmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7dmFyIGU9dC5pRXZlbnQsbj10LmludGVyYWN0aW9uO2lmKFwicmVzaXplXCI9PT1uLnByZXBhcmVkLm5hbWUmJm4ucHJlcGFyZWQuZWRnZXMpe3ZhciByPWUsaT1uLmludGVyYWN0YWJsZS5vcHRpb25zLnJlc2l6ZS5pbnZlcnQsbz1cInJlcG9zaXRpb25cIj09PWl8fFwibmVnYXRlXCI9PT1pLGE9bi5yZWN0LHM9bi5fcmVjdHMsYz1zLnN0YXJ0LGw9cy5jb3JyZWN0ZWQsdT1zLmRlbHRhLHA9cy5wcmV2aW91cztpZihWKHAsbCksbyl7aWYoVihsLGEpLFwicmVwb3NpdGlvblwiPT09aSl7aWYobC50b3A+bC5ib3R0b20pe3ZhciBmPWwudG9wO2wudG9wPWwuYm90dG9tLGwuYm90dG9tPWZ9aWYobC5sZWZ0PmwucmlnaHQpe3ZhciBkPWwubGVmdDtsLmxlZnQ9bC5yaWdodCxsLnJpZ2h0PWR9fX1lbHNlIGwudG9wPU1hdGgubWluKGEudG9wLGMuYm90dG9tKSxsLmJvdHRvbT1NYXRoLm1heChhLmJvdHRvbSxjLnRvcCksbC5sZWZ0PU1hdGgubWluKGEubGVmdCxjLnJpZ2h0KSxsLnJpZ2h0PU1hdGgubWF4KGEucmlnaHQsYy5sZWZ0KTtmb3IodmFyIGggaW4gbC53aWR0aD1sLnJpZ2h0LWwubGVmdCxsLmhlaWdodD1sLmJvdHRvbS1sLnRvcCxsKXVbaF09bFtoXS1wW2hdO3IuZWRnZXM9bi5wcmVwYXJlZC5lZGdlcyxyLnJlY3Q9bCxyLmRlbHRhUmVjdD11fX0odCksQXQodCl9LFwiaW50ZXJhY3Rpb25zOmFjdGlvbi1lbmRcIjpmdW5jdGlvbih0KXt2YXIgZT10LmlFdmVudCxuPXQuaW50ZXJhY3Rpb247aWYoXCJyZXNpemVcIj09PW4ucHJlcGFyZWQubmFtZSYmbi5wcmVwYXJlZC5lZGdlcyl7dmFyIHI9ZTtyLmVkZ2VzPW4ucHJlcGFyZWQuZWRnZXMsci5yZWN0PW4uX3JlY3RzLmNvcnJlY3RlZCxyLmRlbHRhUmVjdD1uLl9yZWN0cy5kZWx0YX19LFwiYXV0by1zdGFydDpjaGVja1wiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24sbj10LmludGVyYWN0YWJsZSxyPXQuZWxlbWVudCxpPXQucmVjdCxvPXQuYnV0dG9ucztpZihpKXt2YXIgYT1WKHt9LGUuY29vcmRzLmN1ci5wYWdlKSxzPW4ub3B0aW9ucy5yZXNpemU7aWYocyYmcy5lbmFibGVkJiYoIWUucG9pbnRlcklzRG93bnx8IS9tb3VzZXxwb2ludGVyLy50ZXN0KGUucG9pbnRlclR5cGUpfHwwIT0obyZzLm1vdXNlQnV0dG9ucykpKXtpZih3Lm9iamVjdChzLmVkZ2VzKSl7dmFyIGM9e2xlZnQ6ITEscmlnaHQ6ITEsdG9wOiExLGJvdHRvbTohMX07Zm9yKHZhciBsIGluIGMpY1tsXT16dChsLHMuZWRnZXNbbF0sYSxlLl9sYXRlc3RQb2ludGVyLmV2ZW50VGFyZ2V0LHIsaSxzLm1hcmdpbnx8anQuZGVmYXVsdE1hcmdpbik7Yy5sZWZ0PWMubGVmdCYmIWMucmlnaHQsYy50b3A9Yy50b3AmJiFjLmJvdHRvbSwoYy5sZWZ0fHxjLnJpZ2h0fHxjLnRvcHx8Yy5ib3R0b20pJiYodC5hY3Rpb249e25hbWU6XCJyZXNpemVcIixlZGdlczpjfSl9ZWxzZXt2YXIgdT1cInlcIiE9PXMuYXhpcyYmYS54PmkucmlnaHQtanQuZGVmYXVsdE1hcmdpbixwPVwieFwiIT09cy5heGlzJiZhLnk+aS5ib3R0b20tanQuZGVmYXVsdE1hcmdpbjsodXx8cCkmJih0LmFjdGlvbj17bmFtZTpcInJlc2l6ZVwiLGF4ZXM6KHU/XCJ4XCI6XCJcIikrKHA/XCJ5XCI6XCJcIil9KX1yZXR1cm4hdC5hY3Rpb24mJnZvaWQgMH19fX0sZGVmYXVsdHM6e3NxdWFyZTohMSxwcmVzZXJ2ZUFzcGVjdFJhdGlvOiExLGF4aXM6XCJ4eVwiLG1hcmdpbjpOYU4sZWRnZXM6bnVsbCxpbnZlcnQ6XCJub25lXCJ9LGN1cnNvcnM6bnVsbCxnZXRDdXJzb3I6ZnVuY3Rpb24odCl7dmFyIGU9dC5lZGdlcyxuPXQuYXhpcyxyPXQubmFtZSxpPWp0LmN1cnNvcnMsbz1udWxsO2lmKG4pbz1pW3Irbl07ZWxzZSBpZihlKXtmb3IodmFyIGE9XCJcIixzPTAsYz1bXCJ0b3BcIixcImJvdHRvbVwiLFwibGVmdFwiLFwicmlnaHRcIl07czxjLmxlbmd0aDtzKyspe3ZhciBsPWNbc107ZVtsXSYmKGErPWwpfW89aVthXX1yZXR1cm4gb30sZmlsdGVyRXZlbnRUeXBlOmZ1bmN0aW9uKHQpe3JldHVybiAwPT09dC5zZWFyY2goXCJyZXNpemVcIil9LGRlZmF1bHRNYXJnaW46bnVsbH0sRnQ9anQsWHQ9e2lkOlwiYWN0aW9uc1wiLGluc3RhbGw6ZnVuY3Rpb24odCl7dC51c2VQbHVnaW4oTXQpLHQudXNlUGx1Z2luKEZ0KSx0LnVzZVBsdWdpbihfKSx0LnVzZVBsdWdpbihrdCl9fSxZdD0wO3ZhciBMdD17cmVxdWVzdDpmdW5jdGlvbih0KXtyZXR1cm4gUnQodCl9LGNhbmNlbDpmdW5jdGlvbih0KXtyZXR1cm4gQ3QodCl9LGluaXQ6ZnVuY3Rpb24odCl7aWYoUnQ9dC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsQ3Q9dC5jYW5jZWxBbmltYXRpb25GcmFtZSwhUnQpZm9yKHZhciBlPVtcIm1zXCIsXCJtb3pcIixcIndlYmtpdFwiLFwib1wiXSxuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07UnQ9dFtcIlwiLmNvbmNhdChyLFwiUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIpXSxDdD10W1wiXCIuY29uY2F0KHIsXCJDYW5jZWxBbmltYXRpb25GcmFtZVwiKV18fHRbXCJcIi5jb25jYXQocixcIkNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZVwiKV19UnQ9UnQmJlJ0LmJpbmQodCksQ3Q9Q3QmJkN0LmJpbmQodCksUnR8fChSdD1mdW5jdGlvbihlKXt2YXIgbj1EYXRlLm5vdygpLHI9TWF0aC5tYXgoMCwxNi0obi1ZdCkpLGk9dC5zZXRUaW1lb3V0KChmdW5jdGlvbigpe2UobityKX0pLHIpO3JldHVybiBZdD1uK3IsaX0sQ3Q9ZnVuY3Rpb24odCl7cmV0dXJuIGNsZWFyVGltZW91dCh0KX0pfX07dmFyIHF0PXtkZWZhdWx0czp7ZW5hYmxlZDohMSxtYXJnaW46NjAsY29udGFpbmVyOm51bGwsc3BlZWQ6MzAwfSxub3c6RGF0ZS5ub3csaW50ZXJhY3Rpb246bnVsbCxpOjAseDowLHk6MCxpc1Njcm9sbGluZzohMSxwcmV2VGltZTowLG1hcmdpbjowLHNwZWVkOjAsc3RhcnQ6ZnVuY3Rpb24odCl7cXQuaXNTY3JvbGxpbmc9ITAsTHQuY2FuY2VsKHF0LmkpLHQuYXV0b1Njcm9sbD1xdCxxdC5pbnRlcmFjdGlvbj10LHF0LnByZXZUaW1lPXF0Lm5vdygpLHF0Lmk9THQucmVxdWVzdChxdC5zY3JvbGwpfSxzdG9wOmZ1bmN0aW9uKCl7cXQuaXNTY3JvbGxpbmc9ITEscXQuaW50ZXJhY3Rpb24mJihxdC5pbnRlcmFjdGlvbi5hdXRvU2Nyb2xsPW51bGwpLEx0LmNhbmNlbChxdC5pKX0sc2Nyb2xsOmZ1bmN0aW9uKCl7dmFyIHQ9cXQuaW50ZXJhY3Rpb24sZT10LmludGVyYWN0YWJsZSxuPXQuZWxlbWVudCxyPXQucHJlcGFyZWQubmFtZSxpPWUub3B0aW9uc1tyXS5hdXRvU2Nyb2xsLG89QnQoaS5jb250YWluZXIsZSxuKSxhPXF0Lm5vdygpLHM9KGEtcXQucHJldlRpbWUpLzFlMyxjPWkuc3BlZWQqcztpZihjPj0xKXt2YXIgbD17eDpxdC54KmMseTpxdC55KmN9O2lmKGwueHx8bC55KXt2YXIgdT1WdChvKTt3LndpbmRvdyhvKT9vLnNjcm9sbEJ5KGwueCxsLnkpOm8mJihvLnNjcm9sbExlZnQrPWwueCxvLnNjcm9sbFRvcCs9bC55KTt2YXIgcD1WdChvKSxmPXt4OnAueC11LngseTpwLnktdS55fTsoZi54fHxmLnkpJiZlLmZpcmUoe3R5cGU6XCJhdXRvc2Nyb2xsXCIsdGFyZ2V0Om4saW50ZXJhY3RhYmxlOmUsZGVsdGE6ZixpbnRlcmFjdGlvbjp0LGNvbnRhaW5lcjpvfSl9cXQucHJldlRpbWU9YX1xdC5pc1Njcm9sbGluZyYmKEx0LmNhbmNlbChxdC5pKSxxdC5pPUx0LnJlcXVlc3QocXQuc2Nyb2xsKSl9LGNoZWNrOmZ1bmN0aW9uKHQsZSl7dmFyIG47cmV0dXJuIG51bGw9PShuPXQub3B0aW9uc1tlXS5hdXRvU2Nyb2xsKT92b2lkIDA6bi5lbmFibGVkfSxvbkludGVyYWN0aW9uTW92ZTpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uLG49dC5wb2ludGVyO2lmKGUuaW50ZXJhY3RpbmcoKSYmcXQuY2hlY2soZS5pbnRlcmFjdGFibGUsZS5wcmVwYXJlZC5uYW1lKSlpZihlLnNpbXVsYXRpb24pcXQueD1xdC55PTA7ZWxzZXt2YXIgcixpLG8sYSxzPWUuaW50ZXJhY3RhYmxlLGM9ZS5lbGVtZW50LGw9ZS5wcmVwYXJlZC5uYW1lLHU9cy5vcHRpb25zW2xdLmF1dG9TY3JvbGwscD1CdCh1LmNvbnRhaW5lcixzLGMpO2lmKHcud2luZG93KHApKWE9bi5jbGllbnRYPHF0Lm1hcmdpbixyPW4uY2xpZW50WTxxdC5tYXJnaW4saT1uLmNsaWVudFg+cC5pbm5lcldpZHRoLXF0Lm1hcmdpbixvPW4uY2xpZW50WT5wLmlubmVySGVpZ2h0LXF0Lm1hcmdpbjtlbHNle3ZhciBmPVkocCk7YT1uLmNsaWVudFg8Zi5sZWZ0K3F0Lm1hcmdpbixyPW4uY2xpZW50WTxmLnRvcCtxdC5tYXJnaW4saT1uLmNsaWVudFg+Zi5yaWdodC1xdC5tYXJnaW4sbz1uLmNsaWVudFk+Zi5ib3R0b20tcXQubWFyZ2lufXF0Lng9aT8xOmE/LTE6MCxxdC55PW8/MTpyPy0xOjAscXQuaXNTY3JvbGxpbmd8fChxdC5tYXJnaW49dS5tYXJnaW4scXQuc3BlZWQ9dS5zcGVlZCxxdC5zdGFydChlKSl9fX07ZnVuY3Rpb24gQnQodCxlLG4pe3JldHVybih3LnN0cmluZyh0KT9XKHQsZSxuKTp0KXx8eShuKX1mdW5jdGlvbiBWdCh0KXtyZXR1cm4gdy53aW5kb3codCkmJih0PXdpbmRvdy5kb2N1bWVudC5ib2R5KSx7eDp0LnNjcm9sbExlZnQseTp0LnNjcm9sbFRvcH19dmFyIFd0PXtpZDpcImF1dG8tc2Nyb2xsXCIsaW5zdGFsbDpmdW5jdGlvbih0KXt2YXIgZT10LmRlZmF1bHRzLG49dC5hY3Rpb25zO3QuYXV0b1Njcm9sbD1xdCxxdC5ub3c9ZnVuY3Rpb24oKXtyZXR1cm4gdC5ub3coKX0sbi5waGFzZWxlc3NUeXBlcy5hdXRvc2Nyb2xsPSEwLGUucGVyQWN0aW9uLmF1dG9TY3JvbGw9cXQuZGVmYXVsdHN9LGxpc3RlbmVyczp7XCJpbnRlcmFjdGlvbnM6bmV3XCI6ZnVuY3Rpb24odCl7dC5pbnRlcmFjdGlvbi5hdXRvU2Nyb2xsPW51bGx9LFwiaW50ZXJhY3Rpb25zOmRlc3Ryb3lcIjpmdW5jdGlvbih0KXt0LmludGVyYWN0aW9uLmF1dG9TY3JvbGw9bnVsbCxxdC5zdG9wKCkscXQuaW50ZXJhY3Rpb24mJihxdC5pbnRlcmFjdGlvbj1udWxsKX0sXCJpbnRlcmFjdGlvbnM6c3RvcFwiOnF0LnN0b3AsXCJpbnRlcmFjdGlvbnM6YWN0aW9uLW1vdmVcIjpmdW5jdGlvbih0KXtyZXR1cm4gcXQub25JbnRlcmFjdGlvbk1vdmUodCl9fX0sR3Q9V3Q7ZnVuY3Rpb24gTnQodCxlKXt2YXIgbj0hMTtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbnx8KGcuY29uc29sZS53YXJuKGUpLG49ITApLHQuYXBwbHkodGhpcyxhcmd1bWVudHMpfX1mdW5jdGlvbiBVdCh0LGUpe3JldHVybiB0Lm5hbWU9ZS5uYW1lLHQuYXhpcz1lLmF4aXMsdC5lZGdlcz1lLmVkZ2VzLHR9ZnVuY3Rpb24gSHQodCl7cmV0dXJuIHcuYm9vbCh0KT8odGhpcy5vcHRpb25zLnN0eWxlQ3Vyc29yPXQsdGhpcyk6bnVsbD09PXQ/KGRlbGV0ZSB0aGlzLm9wdGlvbnMuc3R5bGVDdXJzb3IsdGhpcyk6dGhpcy5vcHRpb25zLnN0eWxlQ3Vyc29yfWZ1bmN0aW9uIEt0KHQpe3JldHVybiB3LmZ1bmModCk/KHRoaXMub3B0aW9ucy5hY3Rpb25DaGVja2VyPXQsdGhpcyk6bnVsbD09PXQ/KGRlbGV0ZSB0aGlzLm9wdGlvbnMuYWN0aW9uQ2hlY2tlcix0aGlzKTp0aGlzLm9wdGlvbnMuYWN0aW9uQ2hlY2tlcn12YXIgJHQ9e2lkOlwiYXV0by1zdGFydC9pbnRlcmFjdGFibGVNZXRob2RzXCIsaW5zdGFsbDpmdW5jdGlvbih0KXt2YXIgZT10LkludGVyYWN0YWJsZTtlLnByb3RvdHlwZS5nZXRBY3Rpb249ZnVuY3Rpb24oZSxuLHIsaSl7dmFyIG89ZnVuY3Rpb24odCxlLG4scixpKXt2YXIgbz10LmdldFJlY3QociksYT1lLmJ1dHRvbnN8fHswOjEsMTo0LDM6OCw0OjE2fVtlLmJ1dHRvbl0scz17YWN0aW9uOm51bGwsaW50ZXJhY3RhYmxlOnQsaW50ZXJhY3Rpb246bixlbGVtZW50OnIscmVjdDpvLGJ1dHRvbnM6YX07cmV0dXJuIGkuZmlyZShcImF1dG8tc3RhcnQ6Y2hlY2tcIixzKSxzLmFjdGlvbn0odGhpcyxuLHIsaSx0KTtyZXR1cm4gdGhpcy5vcHRpb25zLmFjdGlvbkNoZWNrZXI/dGhpcy5vcHRpb25zLmFjdGlvbkNoZWNrZXIoZSxuLG8sdGhpcyxpLHIpOm99LGUucHJvdG90eXBlLmlnbm9yZUZyb209TnQoKGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9iYWNrQ29tcGF0T3B0aW9uKFwiaWdub3JlRnJvbVwiLHQpfSksXCJJbnRlcmFjdGFibGUuaWdub3JlRnJvbSgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBJbnRlcmFjdGJsZS5kcmFnZ2FibGUoe2lnbm9yZUZyb206IG5ld1ZhbHVlfSkuXCIpLGUucHJvdG90eXBlLmFsbG93RnJvbT1OdCgoZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2JhY2tDb21wYXRPcHRpb24oXCJhbGxvd0Zyb21cIix0KX0pLFwiSW50ZXJhY3RhYmxlLmFsbG93RnJvbSgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBJbnRlcmFjdGJsZS5kcmFnZ2FibGUoe2FsbG93RnJvbTogbmV3VmFsdWV9KS5cIiksZS5wcm90b3R5cGUuYWN0aW9uQ2hlY2tlcj1LdCxlLnByb3RvdHlwZS5zdHlsZUN1cnNvcj1IdH19O2Z1bmN0aW9uIEp0KHQsZSxuLHIsaSl7cmV0dXJuIGUudGVzdElnbm9yZUFsbG93KGUub3B0aW9uc1t0Lm5hbWVdLG4scikmJmUub3B0aW9uc1t0Lm5hbWVdLmVuYWJsZWQmJmVlKGUsbix0LGkpP3Q6bnVsbH1mdW5jdGlvbiBRdCh0LGUsbixyLGksbyxhKXtmb3IodmFyIHM9MCxjPXIubGVuZ3RoO3M8YztzKyspe3ZhciBsPXJbc10sdT1pW3NdLHA9bC5nZXRBY3Rpb24oZSxuLHQsdSk7aWYocCl7dmFyIGY9SnQocCxsLHUsbyxhKTtpZihmKXJldHVybnthY3Rpb246ZixpbnRlcmFjdGFibGU6bCxlbGVtZW50OnV9fX1yZXR1cm57YWN0aW9uOm51bGwsaW50ZXJhY3RhYmxlOm51bGwsZWxlbWVudDpudWxsfX1mdW5jdGlvbiBadCh0LGUsbixyLGkpe3ZhciBvPVtdLGE9W10scz1yO2Z1bmN0aW9uIGModCl7by5wdXNoKHQpLGEucHVzaChzKX1mb3IoO3cuZWxlbWVudChzKTspe289W10sYT1bXSxpLmludGVyYWN0YWJsZXMuZm9yRWFjaE1hdGNoKHMsYyk7dmFyIGw9UXQodCxlLG4sbyxhLHIsaSk7aWYobC5hY3Rpb24mJiFsLmludGVyYWN0YWJsZS5vcHRpb25zW2wuYWN0aW9uLm5hbWVdLm1hbnVhbFN0YXJ0KXJldHVybiBsO3M9QShzKX1yZXR1cm57YWN0aW9uOm51bGwsaW50ZXJhY3RhYmxlOm51bGwsZWxlbWVudDpudWxsfX1mdW5jdGlvbiB0ZSh0LGUsbil7dmFyIHI9ZS5hY3Rpb24saT1lLmludGVyYWN0YWJsZSxvPWUuZWxlbWVudDtyPXJ8fHtuYW1lOm51bGx9LHQuaW50ZXJhY3RhYmxlPWksdC5lbGVtZW50PW8sVXQodC5wcmVwYXJlZCxyKSx0LnJlY3Q9aSYmci5uYW1lP2kuZ2V0UmVjdChvKTpudWxsLGllKHQsbiksbi5maXJlKFwiYXV0b1N0YXJ0OnByZXBhcmVkXCIse2ludGVyYWN0aW9uOnR9KX1mdW5jdGlvbiBlZSh0LGUsbixyKXt2YXIgaT10Lm9wdGlvbnMsbz1pW24ubmFtZV0ubWF4LGE9aVtuLm5hbWVdLm1heFBlckVsZW1lbnQscz1yLmF1dG9TdGFydC5tYXhJbnRlcmFjdGlvbnMsYz0wLGw9MCx1PTA7aWYoIShvJiZhJiZzKSlyZXR1cm4hMTtmb3IodmFyIHA9MCxmPXIuaW50ZXJhY3Rpb25zLmxpc3Q7cDxmLmxlbmd0aDtwKyspe3ZhciBkPWZbcF0saD1kLnByZXBhcmVkLm5hbWU7aWYoZC5pbnRlcmFjdGluZygpKXtpZigrK2M+PXMpcmV0dXJuITE7aWYoZC5pbnRlcmFjdGFibGU9PT10KXtpZigobCs9aD09PW4ubmFtZT8xOjApPj1vKXJldHVybiExO2lmKGQuZWxlbWVudD09PWUmJih1KyssaD09PW4ubmFtZSYmdT49YSkpcmV0dXJuITF9fX1yZXR1cm4gcz4wfWZ1bmN0aW9uIG5lKHQsZSl7cmV0dXJuIHcubnVtYmVyKHQpPyhlLmF1dG9TdGFydC5tYXhJbnRlcmFjdGlvbnM9dCx0aGlzKTplLmF1dG9TdGFydC5tYXhJbnRlcmFjdGlvbnN9ZnVuY3Rpb24gcmUodCxlLG4pe3ZhciByPW4uYXV0b1N0YXJ0LmN1cnNvckVsZW1lbnQ7ciYmciE9PXQmJihyLnN0eWxlLmN1cnNvcj1cIlwiKSx0Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLmN1cnNvcj1lLHQuc3R5bGUuY3Vyc29yPWUsbi5hdXRvU3RhcnQuY3Vyc29yRWxlbWVudD1lP3Q6bnVsbH1mdW5jdGlvbiBpZSh0LGUpe3ZhciBuPXQuaW50ZXJhY3RhYmxlLHI9dC5lbGVtZW50LGk9dC5wcmVwYXJlZDtpZihcIm1vdXNlXCI9PT10LnBvaW50ZXJUeXBlJiZuJiZuLm9wdGlvbnMuc3R5bGVDdXJzb3Ipe3ZhciBvPVwiXCI7aWYoaS5uYW1lKXt2YXIgYT1uLm9wdGlvbnNbaS5uYW1lXS5jdXJzb3JDaGVja2VyO289dy5mdW5jKGEpP2EoaSxuLHIsdC5faW50ZXJhY3RpbmcpOmUuYWN0aW9ucy5tYXBbaS5uYW1lXS5nZXRDdXJzb3IoaSl9cmUodC5lbGVtZW50LG98fFwiXCIsZSl9ZWxzZSBlLmF1dG9TdGFydC5jdXJzb3JFbGVtZW50JiZyZShlLmF1dG9TdGFydC5jdXJzb3JFbGVtZW50LFwiXCIsZSl9dmFyIG9lPXtpZDpcImF1dG8tc3RhcnQvYmFzZVwiLGJlZm9yZTpbXCJhY3Rpb25zXCJdLGluc3RhbGw6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdFN0YXRpYyxuPXQuZGVmYXVsdHM7dC51c2VQbHVnaW4oJHQpLG4uYmFzZS5hY3Rpb25DaGVja2VyPW51bGwsbi5iYXNlLnN0eWxlQ3Vyc29yPSEwLFYobi5wZXJBY3Rpb24se21hbnVhbFN0YXJ0OiExLG1heDoxLzAsbWF4UGVyRWxlbWVudDoxLGFsbG93RnJvbTpudWxsLGlnbm9yZUZyb206bnVsbCxtb3VzZUJ1dHRvbnM6MX0pLGUubWF4SW50ZXJhY3Rpb25zPWZ1bmN0aW9uKGUpe3JldHVybiBuZShlLHQpfSx0LmF1dG9TdGFydD17bWF4SW50ZXJhY3Rpb25zOjEvMCx3aXRoaW5JbnRlcmFjdGlvbkxpbWl0OmVlLGN1cnNvckVsZW1lbnQ6bnVsbH19LGxpc3RlbmVyczp7XCJpbnRlcmFjdGlvbnM6ZG93blwiOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5pbnRlcmFjdGlvbixyPXQucG9pbnRlcixpPXQuZXZlbnQsbz10LmV2ZW50VGFyZ2V0O24uaW50ZXJhY3RpbmcoKXx8dGUobixadChuLHIsaSxvLGUpLGUpfSxcImludGVyYWN0aW9uczptb3ZlXCI6ZnVuY3Rpb24odCxlKXshZnVuY3Rpb24odCxlKXt2YXIgbj10LmludGVyYWN0aW9uLHI9dC5wb2ludGVyLGk9dC5ldmVudCxvPXQuZXZlbnRUYXJnZXQ7XCJtb3VzZVwiIT09bi5wb2ludGVyVHlwZXx8bi5wb2ludGVySXNEb3dufHxuLmludGVyYWN0aW5nKCl8fHRlKG4sWnQobixyLGksbyxlKSxlKX0odCxlKSxmdW5jdGlvbih0LGUpe3ZhciBuPXQuaW50ZXJhY3Rpb247aWYobi5wb2ludGVySXNEb3duJiYhbi5pbnRlcmFjdGluZygpJiZuLnBvaW50ZXJXYXNNb3ZlZCYmbi5wcmVwYXJlZC5uYW1lKXtlLmZpcmUoXCJhdXRvU3RhcnQ6YmVmb3JlLXN0YXJ0XCIsdCk7dmFyIHI9bi5pbnRlcmFjdGFibGUsaT1uLnByZXBhcmVkLm5hbWU7aSYmciYmKHIub3B0aW9uc1tpXS5tYW51YWxTdGFydHx8IWVlKHIsbi5lbGVtZW50LG4ucHJlcGFyZWQsZSk/bi5zdG9wKCk6KG4uc3RhcnQobi5wcmVwYXJlZCxyLG4uZWxlbWVudCksaWUobixlKSkpfX0odCxlKX0sXCJpbnRlcmFjdGlvbnM6c3RvcFwiOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5pbnRlcmFjdGlvbixyPW4uaW50ZXJhY3RhYmxlO3ImJnIub3B0aW9ucy5zdHlsZUN1cnNvciYmcmUobi5lbGVtZW50LFwiXCIsZSl9fSxtYXhJbnRlcmFjdGlvbnM6bmUsd2l0aGluSW50ZXJhY3Rpb25MaW1pdDplZSx2YWxpZGF0ZUFjdGlvbjpKdH0sYWU9b2U7dmFyIHNlPXtpZDpcImF1dG8tc3RhcnQvZHJhZ0F4aXNcIixsaXN0ZW5lcnM6e1wiYXV0b1N0YXJ0OmJlZm9yZS1zdGFydFwiOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5pbnRlcmFjdGlvbixyPXQuZXZlbnRUYXJnZXQsaT10LmR4LG89dC5keTtpZihcImRyYWdcIj09PW4ucHJlcGFyZWQubmFtZSl7dmFyIGE9TWF0aC5hYnMoaSkscz1NYXRoLmFicyhvKSxjPW4uaW50ZXJhY3RhYmxlLm9wdGlvbnMuZHJhZyxsPWMuc3RhcnRBeGlzLHU9YT5zP1wieFwiOmE8cz9cInlcIjpcInh5XCI7aWYobi5wcmVwYXJlZC5heGlzPVwic3RhcnRcIj09PWMubG9ja0F4aXM/dVswXTpjLmxvY2tBeGlzLFwieHlcIiE9PXUmJlwieHlcIiE9PWwmJmwhPT11KXtuLnByZXBhcmVkLm5hbWU9bnVsbDtmb3IodmFyIHA9cixmPWZ1bmN0aW9uKHQpe2lmKHQhPT1uLmludGVyYWN0YWJsZSl7dmFyIGk9bi5pbnRlcmFjdGFibGUub3B0aW9ucy5kcmFnO2lmKCFpLm1hbnVhbFN0YXJ0JiZ0LnRlc3RJZ25vcmVBbGxvdyhpLHAscikpe3ZhciBvPXQuZ2V0QWN0aW9uKG4uZG93blBvaW50ZXIsbi5kb3duRXZlbnQsbixwKTtpZihvJiZcImRyYWdcIj09PW8ubmFtZSYmZnVuY3Rpb24odCxlKXtpZighZSlyZXR1cm4hMTt2YXIgbj1lLm9wdGlvbnMuZHJhZy5zdGFydEF4aXM7cmV0dXJuXCJ4eVwiPT09dHx8XCJ4eVwiPT09bnx8bj09PXR9KHUsdCkmJmFlLnZhbGlkYXRlQWN0aW9uKG8sdCxwLHIsZSkpcmV0dXJuIHR9fX07dy5lbGVtZW50KHApOyl7dmFyIGQ9ZS5pbnRlcmFjdGFibGVzLmZvckVhY2hNYXRjaChwLGYpO2lmKGQpe24ucHJlcGFyZWQubmFtZT1cImRyYWdcIixuLmludGVyYWN0YWJsZT1kLG4uZWxlbWVudD1wO2JyZWFrfXA9QShwKX19fX19fTtmdW5jdGlvbiBjZSh0KXt2YXIgZT10LnByZXBhcmVkJiZ0LnByZXBhcmVkLm5hbWU7aWYoIWUpcmV0dXJuIG51bGw7dmFyIG49dC5pbnRlcmFjdGFibGUub3B0aW9ucztyZXR1cm4gbltlXS5ob2xkfHxuW2VdLmRlbGF5fXZhciBsZT17aWQ6XCJhdXRvLXN0YXJ0L2hvbGRcIixpbnN0YWxsOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZGVmYXVsdHM7dC51c2VQbHVnaW4oYWUpLGUucGVyQWN0aW9uLmhvbGQ9MCxlLnBlckFjdGlvbi5kZWxheT0wfSxsaXN0ZW5lcnM6e1wiaW50ZXJhY3Rpb25zOm5ld1wiOmZ1bmN0aW9uKHQpe3QuaW50ZXJhY3Rpb24uYXV0b1N0YXJ0SG9sZFRpbWVyPW51bGx9LFwiYXV0b1N0YXJ0OnByZXBhcmVkXCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbixuPWNlKGUpO24+MCYmKGUuYXV0b1N0YXJ0SG9sZFRpbWVyPXNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7ZS5zdGFydChlLnByZXBhcmVkLGUuaW50ZXJhY3RhYmxlLGUuZWxlbWVudCl9KSxuKSl9LFwiaW50ZXJhY3Rpb25zOm1vdmVcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uLG49dC5kdXBsaWNhdGU7ZS5hdXRvU3RhcnRIb2xkVGltZXImJmUucG9pbnRlcldhc01vdmVkJiYhbiYmKGNsZWFyVGltZW91dChlLmF1dG9TdGFydEhvbGRUaW1lciksZS5hdXRvU3RhcnRIb2xkVGltZXI9bnVsbCl9LFwiYXV0b1N0YXJ0OmJlZm9yZS1zdGFydFwiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb247Y2UoZSk+MCYmKGUucHJlcGFyZWQubmFtZT1udWxsKX19LGdldEhvbGREdXJhdGlvbjpjZX0sdWU9bGUscGU9e2lkOlwiYXV0by1zdGFydFwiLGluc3RhbGw6ZnVuY3Rpb24odCl7dC51c2VQbHVnaW4oYWUpLHQudXNlUGx1Z2luKHVlKSx0LnVzZVBsdWdpbihzZSl9fSxmZT1mdW5jdGlvbih0KXtyZXR1cm4vXihhbHdheXN8bmV2ZXJ8YXV0bykkLy50ZXN0KHQpPyh0aGlzLm9wdGlvbnMucHJldmVudERlZmF1bHQ9dCx0aGlzKTp3LmJvb2wodCk/KHRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdD10P1wiYWx3YXlzXCI6XCJuZXZlclwiLHRoaXMpOnRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdH07ZnVuY3Rpb24gZGUodCl7dmFyIGU9dC5pbnRlcmFjdGlvbixuPXQuZXZlbnQ7ZS5pbnRlcmFjdGFibGUmJmUuaW50ZXJhY3RhYmxlLmNoZWNrQW5kUHJldmVudERlZmF1bHQobil9dmFyIGhlPXtpZDpcImNvcmUvaW50ZXJhY3RhYmxlUHJldmVudERlZmF1bHRcIixpbnN0YWxsOmZ1bmN0aW9uKHQpe3ZhciBlPXQuSW50ZXJhY3RhYmxlO2UucHJvdG90eXBlLnByZXZlbnREZWZhdWx0PWZlLGUucHJvdG90eXBlLmNoZWNrQW5kUHJldmVudERlZmF1bHQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10Lm9wdGlvbnMucHJldmVudERlZmF1bHQ7aWYoXCJuZXZlclwiIT09cilpZihcImFsd2F5c1wiIT09cil7aWYoZS5ldmVudHMuc3VwcG9ydHNQYXNzaXZlJiYvXnRvdWNoKHN0YXJ0fG1vdmUpJC8udGVzdChuLnR5cGUpKXt2YXIgaT15KG4udGFyZ2V0KS5kb2N1bWVudCxvPWUuZ2V0RG9jT3B0aW9ucyhpKTtpZighb3x8IW8uZXZlbnRzfHwhMSE9PW8uZXZlbnRzLnBhc3NpdmUpcmV0dXJufS9eKG1vdXNlfHBvaW50ZXJ8dG91Y2gpKihkb3dufHN0YXJ0KS9pLnRlc3Qobi50eXBlKXx8dy5lbGVtZW50KG4udGFyZ2V0KSYmUihuLnRhcmdldCxcImlucHV0LHNlbGVjdCx0ZXh0YXJlYSxbY29udGVudGVkaXRhYmxlPXRydWVdLFtjb250ZW50ZWRpdGFibGU9dHJ1ZV0gKlwiKXx8bi5wcmV2ZW50RGVmYXVsdCgpfWVsc2Ugbi5wcmV2ZW50RGVmYXVsdCgpfSh0aGlzLHQsZSl9LHQuaW50ZXJhY3Rpb25zLmRvY0V2ZW50cy5wdXNoKHt0eXBlOlwiZHJhZ3N0YXJ0XCIsbGlzdGVuZXI6ZnVuY3Rpb24oZSl7Zm9yKHZhciBuPTAscj10LmludGVyYWN0aW9ucy5saXN0O248ci5sZW5ndGg7bisrKXt2YXIgaT1yW25dO2lmKGkuZWxlbWVudCYmKGkuZWxlbWVudD09PWUudGFyZ2V0fHxNKGkuZWxlbWVudCxlLnRhcmdldCkpKXJldHVybiB2b2lkIGkuaW50ZXJhY3RhYmxlLmNoZWNrQW5kUHJldmVudERlZmF1bHQoZSl9fX0pfSxsaXN0ZW5lcnM6W1wiZG93blwiLFwibW92ZVwiLFwidXBcIixcImNhbmNlbFwiXS5yZWR1Y2UoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRbXCJpbnRlcmFjdGlvbnM6XCIuY29uY2F0KGUpXT1kZSx0fSkse30pfTtmdW5jdGlvbiB2ZSh0LGUpe2lmKGUucGhhc2VsZXNzVHlwZXNbdF0pcmV0dXJuITA7Zm9yKHZhciBuIGluIGUubWFwKWlmKDA9PT10LmluZGV4T2YobikmJnQuc3Vic3RyKG4ubGVuZ3RoKWluIGUucGhhc2VzKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIGdlKHQpe3ZhciBlPXt9O2Zvcih2YXIgbiBpbiB0KXt2YXIgcj10W25dO3cucGxhaW5PYmplY3Qocik/ZVtuXT1nZShyKTp3LmFycmF5KHIpP2Vbbl09bXQocik6ZVtuXT1yfXJldHVybiBlfXZhciBtZT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSl7cih0aGlzLHQpLHRoaXMuc3RhdGVzPVtdLHRoaXMuc3RhcnRPZmZzZXQ9e2xlZnQ6MCxyaWdodDowLHRvcDowLGJvdHRvbTowfSx0aGlzLnN0YXJ0RGVsdGE9dm9pZCAwLHRoaXMucmVzdWx0PXZvaWQgMCx0aGlzLmVuZFJlc3VsdD12b2lkIDAsdGhpcy5zdGFydEVkZ2VzPXZvaWQgMCx0aGlzLmVkZ2VzPXZvaWQgMCx0aGlzLmludGVyYWN0aW9uPXZvaWQgMCx0aGlzLmludGVyYWN0aW9uPWUsdGhpcy5yZXN1bHQ9eWUoKSx0aGlzLmVkZ2VzPXtsZWZ0OiExLHJpZ2h0OiExLHRvcDohMSxib3R0b206ITF9fXJldHVybiBvKHQsW3trZXk6XCJzdGFydFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIG4scixpPXQucGhhc2Usbz10aGlzLmludGVyYWN0aW9uLGE9ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGFibGUub3B0aW9uc1t0LnByZXBhcmVkLm5hbWVdLG49ZS5tb2RpZmllcnM7aWYobiYmbi5sZW5ndGgpcmV0dXJuIG47cmV0dXJuW1wic25hcFwiLFwic25hcFNpemVcIixcInNuYXBFZGdlc1wiLFwicmVzdHJpY3RcIixcInJlc3RyaWN0RWRnZXNcIixcInJlc3RyaWN0U2l6ZVwiXS5tYXAoKGZ1bmN0aW9uKHQpe3ZhciBuPWVbdF07cmV0dXJuIG4mJm4uZW5hYmxlZCYme29wdGlvbnM6bixtZXRob2RzOm4uX21ldGhvZHN9fSkpLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuISF0fSkpfShvKTt0aGlzLnByZXBhcmVTdGF0ZXMoYSksdGhpcy5zdGFydEVkZ2VzPVYoe30sby5lZGdlcyksdGhpcy5lZGdlcz1WKHt9LHRoaXMuc3RhcnRFZGdlcyksdGhpcy5zdGFydE9mZnNldD0obj1vLnJlY3Qscj1lLG4/e2xlZnQ6ci54LW4ubGVmdCx0b3A6ci55LW4udG9wLHJpZ2h0Om4ucmlnaHQtci54LGJvdHRvbTpuLmJvdHRvbS1yLnl9OntsZWZ0OjAsdG9wOjAscmlnaHQ6MCxib3R0b206MH0pLHRoaXMuc3RhcnREZWx0YT17eDowLHk6MH07dmFyIHM9dGhpcy5maWxsQXJnKHtwaGFzZTppLHBhZ2VDb29yZHM6ZSxwcmVFbmQ6ITF9KTtyZXR1cm4gdGhpcy5yZXN1bHQ9eWUoKSx0aGlzLnN0YXJ0QWxsKHMpLHRoaXMucmVzdWx0PXRoaXMuc2V0QWxsKHMpfX0se2tleTpcImZpbGxBcmdcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmludGVyYWN0aW9uO3JldHVybiB0LmludGVyYWN0aW9uPWUsdC5pbnRlcmFjdGFibGU9ZS5pbnRlcmFjdGFibGUsdC5lbGVtZW50PWUuZWxlbWVudCx0LnJlY3R8fCh0LnJlY3Q9ZS5yZWN0KSx0LmVkZ2VzfHwodC5lZGdlcz10aGlzLnN0YXJ0RWRnZXMpLHQuc3RhcnRPZmZzZXQ9dGhpcy5zdGFydE9mZnNldCx0fX0se2tleTpcInN0YXJ0QWxsXCIsdmFsdWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTAsbj10aGlzLnN0YXRlcztlPG4ubGVuZ3RoO2UrKyl7dmFyIHI9bltlXTtyLm1ldGhvZHMuc3RhcnQmJih0LnN0YXRlPXIsci5tZXRob2RzLnN0YXJ0KHQpKX19fSx7a2V5Olwic2V0QWxsXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dC5waGFzZSxuPXQucHJlRW5kLHI9dC5za2lwTW9kaWZpZXJzLGk9dC5yZWN0LG89dC5lZGdlczt0LmNvb3Jkcz1WKHt9LHQucGFnZUNvb3JkcyksdC5yZWN0PVYoe30saSksdC5lZGdlcz1WKHt9LG8pO2Zvcih2YXIgYT1yP3RoaXMuc3RhdGVzLnNsaWNlKHIpOnRoaXMuc3RhdGVzLHM9eWUodC5jb29yZHMsdC5yZWN0KSxjPTA7YzxhLmxlbmd0aDtjKyspe3ZhciBsLHU9YVtjXSxwPXUub3B0aW9ucyxmPVYoe30sdC5jb29yZHMpLGQ9bnVsbDtudWxsIT0obD11Lm1ldGhvZHMpJiZsLnNldCYmdGhpcy5zaG91bGREbyhwLG4sZSkmJih0LnN0YXRlPXUsZD11Lm1ldGhvZHMuc2V0KHQpLEgodC5lZGdlcyx0LnJlY3Qse3g6dC5jb29yZHMueC1mLngseTp0LmNvb3Jkcy55LWYueX0pKSxzLmV2ZW50UHJvcHMucHVzaChkKX1WKHRoaXMuZWRnZXMsdC5lZGdlcykscy5kZWx0YS54PXQuY29vcmRzLngtdC5wYWdlQ29vcmRzLngscy5kZWx0YS55PXQuY29vcmRzLnktdC5wYWdlQ29vcmRzLnkscy5yZWN0RGVsdGEubGVmdD10LnJlY3QubGVmdC1pLmxlZnQscy5yZWN0RGVsdGEucmlnaHQ9dC5yZWN0LnJpZ2h0LWkucmlnaHQscy5yZWN0RGVsdGEudG9wPXQucmVjdC50b3AtaS50b3Ascy5yZWN0RGVsdGEuYm90dG9tPXQucmVjdC5ib3R0b20taS5ib3R0b207dmFyIGg9dGhpcy5yZXN1bHQuY29vcmRzLHY9dGhpcy5yZXN1bHQucmVjdDtpZihoJiZ2KXt2YXIgZz1zLnJlY3QubGVmdCE9PXYubGVmdHx8cy5yZWN0LnJpZ2h0IT09di5yaWdodHx8cy5yZWN0LnRvcCE9PXYudG9wfHxzLnJlY3QuYm90dG9tIT09di5ib3R0b207cy5jaGFuZ2VkPWd8fGgueCE9PXMuY29vcmRzLnh8fGgueSE9PXMuY29vcmRzLnl9cmV0dXJuIHN9fSx7a2V5OlwiYXBwbHlUb0ludGVyYWN0aW9uXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5pbnRlcmFjdGlvbixuPXQucGhhc2Uscj1lLmNvb3Jkcy5jdXIsaT1lLmNvb3Jkcy5zdGFydCxvPXRoaXMucmVzdWx0LGE9dGhpcy5zdGFydERlbHRhLHM9by5kZWx0YTtcInN0YXJ0XCI9PT1uJiZWKHRoaXMuc3RhcnREZWx0YSxvLmRlbHRhKTtmb3IodmFyIGM9MCxsPVtbaSxhXSxbcixzXV07YzxsLmxlbmd0aDtjKyspe3ZhciB1PWxbY10scD11WzBdLGY9dVsxXTtwLnBhZ2UueCs9Zi54LHAucGFnZS55Kz1mLnkscC5jbGllbnQueCs9Zi54LHAuY2xpZW50LnkrPWYueX12YXIgZD10aGlzLnJlc3VsdC5yZWN0RGVsdGEsaD10LnJlY3R8fGUucmVjdDtoLmxlZnQrPWQubGVmdCxoLnJpZ2h0Kz1kLnJpZ2h0LGgudG9wKz1kLnRvcCxoLmJvdHRvbSs9ZC5ib3R0b20saC53aWR0aD1oLnJpZ2h0LWgubGVmdCxoLmhlaWdodD1oLmJvdHRvbS1oLnRvcH19LHtrZXk6XCJzZXRBbmRBcHBseVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuaW50ZXJhY3Rpb24sbj10LnBoYXNlLHI9dC5wcmVFbmQsaT10LnNraXBNb2RpZmllcnMsbz10aGlzLnNldEFsbCh0aGlzLmZpbGxBcmcoe3ByZUVuZDpyLHBoYXNlOm4scGFnZUNvb3Jkczp0Lm1vZGlmaWVkQ29vcmRzfHxlLmNvb3Jkcy5jdXIucGFnZX0pKTtpZih0aGlzLnJlc3VsdD1vLCFvLmNoYW5nZWQmJighaXx8aTx0aGlzLnN0YXRlcy5sZW5ndGgpJiZlLmludGVyYWN0aW5nKCkpcmV0dXJuITE7aWYodC5tb2RpZmllZENvb3Jkcyl7dmFyIGE9ZS5jb29yZHMuY3VyLnBhZ2Uscz17eDp0Lm1vZGlmaWVkQ29vcmRzLngtYS54LHk6dC5tb2RpZmllZENvb3Jkcy55LWEueX07by5jb29yZHMueCs9cy54LG8uY29vcmRzLnkrPXMueSxvLmRlbHRhLngrPXMueCxvLmRlbHRhLnkrPXMueX10aGlzLmFwcGx5VG9JbnRlcmFjdGlvbih0KX19LHtrZXk6XCJiZWZvcmVFbmRcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uLG49dC5ldmVudCxyPXRoaXMuc3RhdGVzO2lmKHImJnIubGVuZ3RoKXtmb3IodmFyIGk9ITEsbz0wO288ci5sZW5ndGg7bysrKXt2YXIgYT1yW29dO3Quc3RhdGU9YTt2YXIgcz1hLm9wdGlvbnMsYz1hLm1ldGhvZHMsbD1jLmJlZm9yZUVuZCYmYy5iZWZvcmVFbmQodCk7aWYobClyZXR1cm4gdGhpcy5lbmRSZXN1bHQ9bCwhMTtpPWl8fCFpJiZ0aGlzLnNob3VsZERvKHMsITAsdC5waGFzZSwhMCl9aSYmZS5tb3ZlKHtldmVudDpuLHByZUVuZDohMH0pfX19LHtrZXk6XCJzdG9wXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbjtpZih0aGlzLnN0YXRlcyYmdGhpcy5zdGF0ZXMubGVuZ3RoKXt2YXIgbj1WKHtzdGF0ZXM6dGhpcy5zdGF0ZXMsaW50ZXJhY3RhYmxlOmUuaW50ZXJhY3RhYmxlLGVsZW1lbnQ6ZS5lbGVtZW50LHJlY3Q6bnVsbH0sdCk7dGhpcy5maWxsQXJnKG4pO2Zvcih2YXIgcj0wLGk9dGhpcy5zdGF0ZXM7cjxpLmxlbmd0aDtyKyspe3ZhciBvPWlbcl07bi5zdGF0ZT1vLG8ubWV0aG9kcy5zdG9wJiZvLm1ldGhvZHMuc3RvcChuKX10aGlzLnN0YXRlcz1udWxsLHRoaXMuZW5kUmVzdWx0PW51bGx9fX0se2tleTpcInByZXBhcmVTdGF0ZXNcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLnN0YXRlcz1bXTtmb3IodmFyIGU9MDtlPHQubGVuZ3RoO2UrKyl7dmFyIG49dFtlXSxyPW4ub3B0aW9ucyxpPW4ubWV0aG9kcyxvPW4ubmFtZTt0aGlzLnN0YXRlcy5wdXNoKHtvcHRpb25zOnIsbWV0aG9kczppLGluZGV4OmUsbmFtZTpvfSl9cmV0dXJuIHRoaXMuc3RhdGVzfX0se2tleTpcInJlc3RvcmVJbnRlcmFjdGlvbkNvb3Jkc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24sbj1lLmNvb3JkcyxyPWUucmVjdCxpPWUubW9kaWZpY2F0aW9uO2lmKGkucmVzdWx0KXtmb3IodmFyIG89aS5zdGFydERlbHRhLGE9aS5yZXN1bHQscz1hLmRlbHRhLGM9YS5yZWN0RGVsdGEsbD0wLHU9W1tuLnN0YXJ0LG9dLFtuLmN1cixzXV07bDx1Lmxlbmd0aDtsKyspe3ZhciBwPXVbbF0sZj1wWzBdLGQ9cFsxXTtmLnBhZ2UueC09ZC54LGYucGFnZS55LT1kLnksZi5jbGllbnQueC09ZC54LGYuY2xpZW50LnktPWQueX1yLmxlZnQtPWMubGVmdCxyLnJpZ2h0LT1jLnJpZ2h0LHIudG9wLT1jLnRvcCxyLmJvdHRvbS09Yy5ib3R0b219fX0se2tleTpcInNob3VsZERvXCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuISghdHx8ITE9PT10LmVuYWJsZWR8fHImJiF0LmVuZE9ubHl8fHQuZW5kT25seSYmIWV8fFwic3RhcnRcIj09PW4mJiF0LnNldFN0YXJ0KX19LHtrZXk6XCJjb3B5RnJvbVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuc3RhcnRPZmZzZXQ9dC5zdGFydE9mZnNldCx0aGlzLnN0YXJ0RGVsdGE9dC5zdGFydERlbHRhLHRoaXMuc3RhcnRFZGdlcz10LnN0YXJ0RWRnZXMsdGhpcy5lZGdlcz10LmVkZ2VzLHRoaXMuc3RhdGVzPXQuc3RhdGVzLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIGdlKHQpfSkpLHRoaXMucmVzdWx0PXllKFYoe30sdC5yZXN1bHQuY29vcmRzKSxWKHt9LHQucmVzdWx0LnJlY3QpKX19LHtrZXk6XCJkZXN0cm95XCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIHQgaW4gdGhpcyl0aGlzW3RdPW51bGx9fV0pLHR9KCk7ZnVuY3Rpb24geWUodCxlKXtyZXR1cm57cmVjdDplLGNvb3Jkczp0LGRlbHRhOnt4OjAseTowfSxyZWN0RGVsdGE6e2xlZnQ6MCxyaWdodDowLHRvcDowLGJvdHRvbTowfSxldmVudFByb3BzOltdLGNoYW5nZWQ6ITB9fWZ1bmN0aW9uIGJlKHQsZSl7dmFyIG49dC5kZWZhdWx0cyxyPXtzdGFydDp0LnN0YXJ0LHNldDp0LnNldCxiZWZvcmVFbmQ6dC5iZWZvcmVFbmQsc3RvcDp0LnN0b3B9LGk9ZnVuY3Rpb24odCl7dmFyIGk9dHx8e307Zm9yKHZhciBvIGluIGkuZW5hYmxlZD0hMSE9PWkuZW5hYmxlZCxuKW8gaW4gaXx8KGlbb109bltvXSk7dmFyIGE9e29wdGlvbnM6aSxtZXRob2RzOnIsbmFtZTplLGVuYWJsZTpmdW5jdGlvbigpe3JldHVybiBpLmVuYWJsZWQ9ITAsYX0sZGlzYWJsZTpmdW5jdGlvbigpe3JldHVybiBpLmVuYWJsZWQ9ITEsYX19O3JldHVybiBhfTtyZXR1cm4gZSYmXCJzdHJpbmdcIj09dHlwZW9mIGUmJihpLl9kZWZhdWx0cz1uLGkuX21ldGhvZHM9ciksaX1mdW5jdGlvbiB4ZSh0KXt2YXIgZT10LmlFdmVudCxuPXQuaW50ZXJhY3Rpb24ubW9kaWZpY2F0aW9uLnJlc3VsdDtuJiYoZS5tb2RpZmllcnM9bi5ldmVudFByb3BzKX12YXIgd2U9e2lkOlwibW9kaWZpZXJzL2Jhc2VcIixiZWZvcmU6W1wiYWN0aW9uc1wiXSxpbnN0YWxsOmZ1bmN0aW9uKHQpe3QuZGVmYXVsdHMucGVyQWN0aW9uLm1vZGlmaWVycz1bXX0sbGlzdGVuZXJzOntcImludGVyYWN0aW9uczpuZXdcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uO2UubW9kaWZpY2F0aW9uPW5ldyBtZShlKX0sXCJpbnRlcmFjdGlvbnM6YmVmb3JlLWFjdGlvbi1zdGFydFwiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24sbj10LmludGVyYWN0aW9uLm1vZGlmaWNhdGlvbjtuLnN0YXJ0KHQsZS5jb29yZHMuc3RhcnQucGFnZSksZS5lZGdlcz1uLmVkZ2VzLG4uYXBwbHlUb0ludGVyYWN0aW9uKHQpfSxcImludGVyYWN0aW9uczpiZWZvcmUtYWN0aW9uLW1vdmVcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uLG49ZS5tb2RpZmljYXRpb24scj1uLnNldEFuZEFwcGx5KHQpO3JldHVybiBlLmVkZ2VzPW4uZWRnZXMscn0sXCJpbnRlcmFjdGlvbnM6YmVmb3JlLWFjdGlvbi1lbmRcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uLG49ZS5tb2RpZmljYXRpb24scj1uLmJlZm9yZUVuZCh0KTtyZXR1cm4gZS5lZGdlcz1uLnN0YXJ0RWRnZXMscn0sXCJpbnRlcmFjdGlvbnM6YWN0aW9uLXN0YXJ0XCI6eGUsXCJpbnRlcmFjdGlvbnM6YWN0aW9uLW1vdmVcIjp4ZSxcImludGVyYWN0aW9uczphY3Rpb24tZW5kXCI6eGUsXCJpbnRlcmFjdGlvbnM6YWZ0ZXItYWN0aW9uLXN0YXJ0XCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuaW50ZXJhY3Rpb24ubW9kaWZpY2F0aW9uLnJlc3RvcmVJbnRlcmFjdGlvbkNvb3Jkcyh0KX0sXCJpbnRlcmFjdGlvbnM6YWZ0ZXItYWN0aW9uLW1vdmVcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5pbnRlcmFjdGlvbi5tb2RpZmljYXRpb24ucmVzdG9yZUludGVyYWN0aW9uQ29vcmRzKHQpfSxcImludGVyYWN0aW9uczpzdG9wXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuaW50ZXJhY3Rpb24ubW9kaWZpY2F0aW9uLnN0b3AodCl9fX0sRWU9d2UsVGU9e2Jhc2U6e3ByZXZlbnREZWZhdWx0OlwiYXV0b1wiLGRlbHRhU291cmNlOlwicGFnZVwifSxwZXJBY3Rpb246e2VuYWJsZWQ6ITEsb3JpZ2luOnt4OjAseTowfX0sYWN0aW9uczp7fX0sU2U9ZnVuY3Rpb24odCl7cyhuLHQpO3ZhciBlPXAobik7ZnVuY3Rpb24gbih0LGksbyxhLHMsYyxsKXt2YXIgcDtyKHRoaXMsbiksKHA9ZS5jYWxsKHRoaXMsdCkpLnJlbGF0ZWRUYXJnZXQ9bnVsbCxwLnNjcmVlblg9dm9pZCAwLHAuc2NyZWVuWT12b2lkIDAscC5idXR0b249dm9pZCAwLHAuYnV0dG9ucz12b2lkIDAscC5jdHJsS2V5PXZvaWQgMCxwLnNoaWZ0S2V5PXZvaWQgMCxwLmFsdEtleT12b2lkIDAscC5tZXRhS2V5PXZvaWQgMCxwLnBhZ2U9dm9pZCAwLHAuY2xpZW50PXZvaWQgMCxwLmRlbHRhPXZvaWQgMCxwLnJlY3Q9dm9pZCAwLHAueDA9dm9pZCAwLHAueTA9dm9pZCAwLHAudDA9dm9pZCAwLHAuZHQ9dm9pZCAwLHAuZHVyYXRpb249dm9pZCAwLHAuY2xpZW50WDA9dm9pZCAwLHAuY2xpZW50WTA9dm9pZCAwLHAudmVsb2NpdHk9dm9pZCAwLHAuc3BlZWQ9dm9pZCAwLHAuc3dpcGU9dm9pZCAwLHAuYXhlcz12b2lkIDAscC5wcmVFbmQ9dm9pZCAwLHM9c3x8dC5lbGVtZW50O3ZhciBmPXQuaW50ZXJhY3RhYmxlLGQ9KGYmJmYub3B0aW9uc3x8VGUpLmRlbHRhU291cmNlLGg9SyhmLHMsbyksdj1cInN0YXJ0XCI9PT1hLGc9XCJlbmRcIj09PWEsbT12P3UocCk6dC5wcmV2RXZlbnQseT12P3QuY29vcmRzLnN0YXJ0Omc/e3BhZ2U6bS5wYWdlLGNsaWVudDptLmNsaWVudCx0aW1lU3RhbXA6dC5jb29yZHMuY3VyLnRpbWVTdGFtcH06dC5jb29yZHMuY3VyO3JldHVybiBwLnBhZ2U9Vih7fSx5LnBhZ2UpLHAuY2xpZW50PVYoe30seS5jbGllbnQpLHAucmVjdD1WKHt9LHQucmVjdCkscC50aW1lU3RhbXA9eS50aW1lU3RhbXAsZ3x8KHAucGFnZS54LT1oLngscC5wYWdlLnktPWgueSxwLmNsaWVudC54LT1oLngscC5jbGllbnQueS09aC55KSxwLmN0cmxLZXk9aS5jdHJsS2V5LHAuYWx0S2V5PWkuYWx0S2V5LHAuc2hpZnRLZXk9aS5zaGlmdEtleSxwLm1ldGFLZXk9aS5tZXRhS2V5LHAuYnV0dG9uPWkuYnV0dG9uLHAuYnV0dG9ucz1pLmJ1dHRvbnMscC50YXJnZXQ9cyxwLmN1cnJlbnRUYXJnZXQ9cyxwLnByZUVuZD1jLHAudHlwZT1sfHxvKyhhfHxcIlwiKSxwLmludGVyYWN0YWJsZT1mLHAudDA9dj90LnBvaW50ZXJzW3QucG9pbnRlcnMubGVuZ3RoLTFdLmRvd25UaW1lOm0udDAscC54MD10LmNvb3Jkcy5zdGFydC5wYWdlLngtaC54LHAueTA9dC5jb29yZHMuc3RhcnQucGFnZS55LWgueSxwLmNsaWVudFgwPXQuY29vcmRzLnN0YXJ0LmNsaWVudC54LWgueCxwLmNsaWVudFkwPXQuY29vcmRzLnN0YXJ0LmNsaWVudC55LWgueSxwLmRlbHRhPXZ8fGc/e3g6MCx5OjB9Ont4OnBbZF0ueC1tW2RdLngseTpwW2RdLnktbVtkXS55fSxwLmR0PXQuY29vcmRzLmRlbHRhLnRpbWVTdGFtcCxwLmR1cmF0aW9uPXAudGltZVN0YW1wLXAudDAscC52ZWxvY2l0eT1WKHt9LHQuY29vcmRzLnZlbG9jaXR5W2RdKSxwLnNwZWVkPVEocC52ZWxvY2l0eS54LHAudmVsb2NpdHkueSkscC5zd2lwZT1nfHxcImluZXJ0aWFzdGFydFwiPT09YT9wLmdldFN3aXBlKCk6bnVsbCxwfXJldHVybiBvKG4sW3trZXk6XCJnZXRTd2lwZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5faW50ZXJhY3Rpb247aWYodC5wcmV2RXZlbnQuc3BlZWQ8NjAwfHx0aGlzLnRpbWVTdGFtcC10LnByZXZFdmVudC50aW1lU3RhbXA+MTUwKXJldHVybiBudWxsO3ZhciBlPTE4MCpNYXRoLmF0YW4yKHQucHJldkV2ZW50LnZlbG9jaXR5WSx0LnByZXZFdmVudC52ZWxvY2l0eVgpL01hdGguUEk7ZTwwJiYoZSs9MzYwKTt2YXIgbj0xMTIuNTw9ZSYmZTwyNDcuNSxyPTIwMi41PD1lJiZlPDMzNy41O3JldHVybnt1cDpyLGRvd246IXImJjIyLjU8PWUmJmU8MTU3LjUsbGVmdDpuLHJpZ2h0OiFuJiYoMjkyLjU8PWV8fGU8NjcuNSksYW5nbGU6ZSxzcGVlZDp0LnByZXZFdmVudC5zcGVlZCx2ZWxvY2l0eTp7eDp0LnByZXZFdmVudC52ZWxvY2l0eVgseTp0LnByZXZFdmVudC52ZWxvY2l0eVl9fX19LHtrZXk6XCJwcmV2ZW50RGVmYXVsdFwiLHZhbHVlOmZ1bmN0aW9uKCl7fX0se2tleTpcInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ9dGhpcy5wcm9wYWdhdGlvblN0b3BwZWQ9ITB9fSx7a2V5Olwic3RvcFByb3BhZ2F0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZD0hMH19XSksbn0odnQpO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFNlLnByb3RvdHlwZSx7cGFnZVg6e2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhZ2UueH0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMucGFnZS54PXR9fSxwYWdlWTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFnZS55fSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5wYWdlLnk9dH19LGNsaWVudFg6e2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNsaWVudC54fSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5jbGllbnQueD10fX0sY2xpZW50WTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2xpZW50Lnl9LHNldDpmdW5jdGlvbih0KXt0aGlzLmNsaWVudC55PXR9fSxkeDp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVsdGEueH0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuZGVsdGEueD10fX0sZHk6e2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRlbHRhLnl9LHNldDpmdW5jdGlvbih0KXt0aGlzLmRlbHRhLnk9dH19LHZlbG9jaXR5WDp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmVsb2NpdHkueH0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMudmVsb2NpdHkueD10fX0sdmVsb2NpdHlZOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52ZWxvY2l0eS55fSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy52ZWxvY2l0eS55PXR9fX0pO3ZhciBfZT1vKChmdW5jdGlvbiB0KGUsbixpLG8sYSl7cih0aGlzLHQpLHRoaXMuaWQ9dm9pZCAwLHRoaXMucG9pbnRlcj12b2lkIDAsdGhpcy5ldmVudD12b2lkIDAsdGhpcy5kb3duVGltZT12b2lkIDAsdGhpcy5kb3duVGFyZ2V0PXZvaWQgMCx0aGlzLmlkPWUsdGhpcy5wb2ludGVyPW4sdGhpcy5ldmVudD1pLHRoaXMuZG93blRpbWU9byx0aGlzLmRvd25UYXJnZXQ9YX0pKSxQZT1mdW5jdGlvbih0KXtyZXR1cm4gdC5pbnRlcmFjdGFibGU9XCJcIix0LmVsZW1lbnQ9XCJcIix0LnByZXBhcmVkPVwiXCIsdC5wb2ludGVySXNEb3duPVwiXCIsdC5wb2ludGVyV2FzTW92ZWQ9XCJcIix0Ll9wcm94eT1cIlwiLHR9KHt9KSxPZT1mdW5jdGlvbih0KXtyZXR1cm4gdC5zdGFydD1cIlwiLHQubW92ZT1cIlwiLHQuZW5kPVwiXCIsdC5zdG9wPVwiXCIsdC5pbnRlcmFjdGluZz1cIlwiLHR9KHt9KSxrZT0wLERlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlKXt2YXIgbj10aGlzLGk9ZS5wb2ludGVyVHlwZSxvPWUuc2NvcGVGaXJlO3IodGhpcyx0KSx0aGlzLmludGVyYWN0YWJsZT1udWxsLHRoaXMuZWxlbWVudD1udWxsLHRoaXMucmVjdD1udWxsLHRoaXMuX3JlY3RzPXZvaWQgMCx0aGlzLmVkZ2VzPW51bGwsdGhpcy5fc2NvcGVGaXJlPXZvaWQgMCx0aGlzLnByZXBhcmVkPXtuYW1lOm51bGwsYXhpczpudWxsLGVkZ2VzOm51bGx9LHRoaXMucG9pbnRlclR5cGU9dm9pZCAwLHRoaXMucG9pbnRlcnM9W10sdGhpcy5kb3duRXZlbnQ9bnVsbCx0aGlzLmRvd25Qb2ludGVyPXt9LHRoaXMuX2xhdGVzdFBvaW50ZXI9e3BvaW50ZXI6bnVsbCxldmVudDpudWxsLGV2ZW50VGFyZ2V0Om51bGx9LHRoaXMucHJldkV2ZW50PW51bGwsdGhpcy5wb2ludGVySXNEb3duPSExLHRoaXMucG9pbnRlcldhc01vdmVkPSExLHRoaXMuX2ludGVyYWN0aW5nPSExLHRoaXMuX2VuZGluZz0hMSx0aGlzLl9zdG9wcGVkPSEwLHRoaXMuX3Byb3h5PXZvaWQgMCx0aGlzLnNpbXVsYXRpb249bnVsbCx0aGlzLmRvTW92ZT1OdCgoZnVuY3Rpb24odCl7dGhpcy5tb3ZlKHQpfSksXCJUaGUgaW50ZXJhY3Rpb24uZG9Nb3ZlKCkgbWV0aG9kIGhhcyBiZWVuIHJlbmFtZWQgdG8gaW50ZXJhY3Rpb24ubW92ZSgpXCIpLHRoaXMuY29vcmRzPXtzdGFydDp7cGFnZTp7eDowLHk6MH0sY2xpZW50Ont4OjAseTowfSx0aW1lU3RhbXA6MH0scHJldjp7cGFnZTp7eDowLHk6MH0sY2xpZW50Ont4OjAseTowfSx0aW1lU3RhbXA6MH0sY3VyOntwYWdlOnt4OjAseTowfSxjbGllbnQ6e3g6MCx5OjB9LHRpbWVTdGFtcDowfSxkZWx0YTp7cGFnZTp7eDowLHk6MH0sY2xpZW50Ont4OjAseTowfSx0aW1lU3RhbXA6MH0sdmVsb2NpdHk6e3BhZ2U6e3g6MCx5OjB9LGNsaWVudDp7eDowLHk6MH0sdGltZVN0YW1wOjB9fSx0aGlzLl9pZD1rZSsrLHRoaXMuX3Njb3BlRmlyZT1vLHRoaXMucG9pbnRlclR5cGU9aTt2YXIgYT10aGlzO3RoaXMuX3Byb3h5PXt9O3ZhciBzPWZ1bmN0aW9uKHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLl9wcm94eSx0LHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYVt0XX19KX07Zm9yKHZhciBjIGluIFBlKXMoYyk7dmFyIGw9ZnVuY3Rpb24odCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KG4uX3Byb3h5LHQse3ZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIGFbdF0uYXBwbHkoYSxhcmd1bWVudHMpfX0pfTtmb3IodmFyIHUgaW4gT2UpbCh1KTt0aGlzLl9zY29wZUZpcmUoXCJpbnRlcmFjdGlvbnM6bmV3XCIse2ludGVyYWN0aW9uOnRoaXN9KX1yZXR1cm4gbyh0LFt7a2V5OlwicG9pbnRlck1vdmVUb2xlcmFuY2VcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gMX19LHtrZXk6XCJwb2ludGVyRG93blwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10aGlzLnVwZGF0ZVBvaW50ZXIodCxlLG4sITApLGk9dGhpcy5wb2ludGVyc1tyXTt0aGlzLl9zY29wZUZpcmUoXCJpbnRlcmFjdGlvbnM6ZG93blwiLHtwb2ludGVyOnQsZXZlbnQ6ZSxldmVudFRhcmdldDpuLHBvaW50ZXJJbmRleDpyLHBvaW50ZXJJbmZvOmksdHlwZTpcImRvd25cIixpbnRlcmFjdGlvbjp0aGlzfSl9fSx7a2V5Olwic3RhcnRcIix2YWx1ZTpmdW5jdGlvbih0LGUsbil7cmV0dXJuISh0aGlzLmludGVyYWN0aW5nKCl8fCF0aGlzLnBvaW50ZXJJc0Rvd258fHRoaXMucG9pbnRlcnMubGVuZ3RoPChcImdlc3R1cmVcIj09PXQubmFtZT8yOjEpfHwhZS5vcHRpb25zW3QubmFtZV0uZW5hYmxlZCkmJihVdCh0aGlzLnByZXBhcmVkLHQpLHRoaXMuaW50ZXJhY3RhYmxlPWUsdGhpcy5lbGVtZW50PW4sdGhpcy5yZWN0PWUuZ2V0UmVjdChuKSx0aGlzLmVkZ2VzPXRoaXMucHJlcGFyZWQuZWRnZXM/Vih7fSx0aGlzLnByZXBhcmVkLmVkZ2VzKTp7bGVmdDohMCxyaWdodDohMCx0b3A6ITAsYm90dG9tOiEwfSx0aGlzLl9zdG9wcGVkPSExLHRoaXMuX2ludGVyYWN0aW5nPXRoaXMuX2RvUGhhc2Uoe2ludGVyYWN0aW9uOnRoaXMsZXZlbnQ6dGhpcy5kb3duRXZlbnQscGhhc2U6XCJzdGFydFwifSkmJiF0aGlzLl9zdG9wcGVkLHRoaXMuX2ludGVyYWN0aW5nKX19LHtrZXk6XCJwb2ludGVyTW92ZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuKXt0aGlzLnNpbXVsYXRpb258fHRoaXMubW9kaWZpY2F0aW9uJiZ0aGlzLm1vZGlmaWNhdGlvbi5lbmRSZXN1bHR8fHRoaXMudXBkYXRlUG9pbnRlcih0LGUsbiwhMSk7dmFyIHIsaSxvPXRoaXMuY29vcmRzLmN1ci5wYWdlLng9PT10aGlzLmNvb3Jkcy5wcmV2LnBhZ2UueCYmdGhpcy5jb29yZHMuY3VyLnBhZ2UueT09PXRoaXMuY29vcmRzLnByZXYucGFnZS55JiZ0aGlzLmNvb3Jkcy5jdXIuY2xpZW50Lng9PT10aGlzLmNvb3Jkcy5wcmV2LmNsaWVudC54JiZ0aGlzLmNvb3Jkcy5jdXIuY2xpZW50Lnk9PT10aGlzLmNvb3Jkcy5wcmV2LmNsaWVudC55O3RoaXMucG9pbnRlcklzRG93biYmIXRoaXMucG9pbnRlcldhc01vdmVkJiYocj10aGlzLmNvb3Jkcy5jdXIuY2xpZW50LngtdGhpcy5jb29yZHMuc3RhcnQuY2xpZW50LngsaT10aGlzLmNvb3Jkcy5jdXIuY2xpZW50LnktdGhpcy5jb29yZHMuc3RhcnQuY2xpZW50LnksdGhpcy5wb2ludGVyV2FzTW92ZWQ9UShyLGkpPnRoaXMucG9pbnRlck1vdmVUb2xlcmFuY2UpO3ZhciBhLHMsYyxsPXRoaXMuZ2V0UG9pbnRlckluZGV4KHQpLHU9e3BvaW50ZXI6dCxwb2ludGVySW5kZXg6bCxwb2ludGVySW5mbzp0aGlzLnBvaW50ZXJzW2xdLGV2ZW50OmUsdHlwZTpcIm1vdmVcIixldmVudFRhcmdldDpuLGR4OnIsZHk6aSxkdXBsaWNhdGU6byxpbnRlcmFjdGlvbjp0aGlzfTtvfHwoYT10aGlzLmNvb3Jkcy52ZWxvY2l0eSxzPXRoaXMuY29vcmRzLmRlbHRhLGM9TWF0aC5tYXgocy50aW1lU3RhbXAvMWUzLC4wMDEpLGEucGFnZS54PXMucGFnZS54L2MsYS5wYWdlLnk9cy5wYWdlLnkvYyxhLmNsaWVudC54PXMuY2xpZW50LngvYyxhLmNsaWVudC55PXMuY2xpZW50LnkvYyxhLnRpbWVTdGFtcD1jKSx0aGlzLl9zY29wZUZpcmUoXCJpbnRlcmFjdGlvbnM6bW92ZVwiLHUpLG98fHRoaXMuc2ltdWxhdGlvbnx8KHRoaXMuaW50ZXJhY3RpbmcoKSYmKHUudHlwZT1udWxsLHRoaXMubW92ZSh1KSksdGhpcy5wb2ludGVyV2FzTW92ZWQmJmV0KHRoaXMuY29vcmRzLnByZXYsdGhpcy5jb29yZHMuY3VyKSl9fSx7a2V5OlwibW92ZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3QmJnQuZXZlbnR8fG50KHRoaXMuY29vcmRzLmRlbHRhKSwodD1WKHtwb2ludGVyOnRoaXMuX2xhdGVzdFBvaW50ZXIucG9pbnRlcixldmVudDp0aGlzLl9sYXRlc3RQb2ludGVyLmV2ZW50LGV2ZW50VGFyZ2V0OnRoaXMuX2xhdGVzdFBvaW50ZXIuZXZlbnRUYXJnZXQsaW50ZXJhY3Rpb246dGhpc30sdHx8e30pKS5waGFzZT1cIm1vdmVcIix0aGlzLl9kb1BoYXNlKHQpfX0se2tleTpcInBvaW50ZXJVcFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBpPXRoaXMuZ2V0UG9pbnRlckluZGV4KHQpOy0xPT09aSYmKGk9dGhpcy51cGRhdGVQb2ludGVyKHQsZSxuLCExKSk7dmFyIG89L2NhbmNlbCQvaS50ZXN0KGUudHlwZSk/XCJjYW5jZWxcIjpcInVwXCI7dGhpcy5fc2NvcGVGaXJlKFwiaW50ZXJhY3Rpb25zOlwiLmNvbmNhdChvKSx7cG9pbnRlcjp0LHBvaW50ZXJJbmRleDppLHBvaW50ZXJJbmZvOnRoaXMucG9pbnRlcnNbaV0sZXZlbnQ6ZSxldmVudFRhcmdldDpuLHR5cGU6byxjdXJFdmVudFRhcmdldDpyLGludGVyYWN0aW9uOnRoaXN9KSx0aGlzLnNpbXVsYXRpb258fHRoaXMuZW5kKGUpLHRoaXMucmVtb3ZlUG9pbnRlcih0LGUpfX0se2tleTpcImRvY3VtZW50Qmx1clwiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuZW5kKHQpLHRoaXMuX3Njb3BlRmlyZShcImludGVyYWN0aW9uczpibHVyXCIse2V2ZW50OnQsdHlwZTpcImJsdXJcIixpbnRlcmFjdGlvbjp0aGlzfSl9fSx7a2V5OlwiZW5kXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU7dGhpcy5fZW5kaW5nPSEwLHQ9dHx8dGhpcy5fbGF0ZXN0UG9pbnRlci5ldmVudCx0aGlzLmludGVyYWN0aW5nKCkmJihlPXRoaXMuX2RvUGhhc2Uoe2V2ZW50OnQsaW50ZXJhY3Rpb246dGhpcyxwaGFzZTpcImVuZFwifSkpLHRoaXMuX2VuZGluZz0hMSwhMD09PWUmJnRoaXMuc3RvcCgpfX0se2tleTpcImN1cnJlbnRBY3Rpb25cIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pbnRlcmFjdGluZz90aGlzLnByZXBhcmVkLm5hbWU6bnVsbH19LHtrZXk6XCJpbnRlcmFjdGluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2ludGVyYWN0aW5nfX0se2tleTpcInN0b3BcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX3Njb3BlRmlyZShcImludGVyYWN0aW9uczpzdG9wXCIse2ludGVyYWN0aW9uOnRoaXN9KSx0aGlzLmludGVyYWN0YWJsZT10aGlzLmVsZW1lbnQ9bnVsbCx0aGlzLl9pbnRlcmFjdGluZz0hMSx0aGlzLl9zdG9wcGVkPSEwLHRoaXMucHJlcGFyZWQubmFtZT10aGlzLnByZXZFdmVudD1udWxsfX0se2tleTpcImdldFBvaW50ZXJJbmRleFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPWF0KHQpO3JldHVyblwibW91c2VcIj09PXRoaXMucG9pbnRlclR5cGV8fFwicGVuXCI9PT10aGlzLnBvaW50ZXJUeXBlP3RoaXMucG9pbnRlcnMubGVuZ3RoLTE6eXQodGhpcy5wb2ludGVycywoZnVuY3Rpb24odCl7cmV0dXJuIHQuaWQ9PT1lfSkpfX0se2tleTpcImdldFBvaW50ZXJJbmZvXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucG9pbnRlcnNbdGhpcy5nZXRQb2ludGVySW5kZXgodCldfX0se2tleTpcInVwZGF0ZVBvaW50ZXJcIix2YWx1ZTpmdW5jdGlvbih0LGUsbixyKXt2YXIgaSxvLGEscz1hdCh0KSxjPXRoaXMuZ2V0UG9pbnRlckluZGV4KHQpLGw9dGhpcy5wb2ludGVyc1tjXTtyZXR1cm4gcj0hMSE9PXImJihyfHwvKGRvd258c3RhcnQpJC9pLnRlc3QoZS50eXBlKSksbD9sLnBvaW50ZXI9dDoobD1uZXcgX2Uocyx0LGUsbnVsbCxudWxsKSxjPXRoaXMucG9pbnRlcnMubGVuZ3RoLHRoaXMucG9pbnRlcnMucHVzaChsKSksc3QodGhpcy5jb29yZHMuY3VyLHRoaXMucG9pbnRlcnMubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5wb2ludGVyfSkpLHRoaXMuX25vdygpKSxpPXRoaXMuY29vcmRzLmRlbHRhLG89dGhpcy5jb29yZHMucHJldixhPXRoaXMuY29vcmRzLmN1cixpLnBhZ2UueD1hLnBhZ2UueC1vLnBhZ2UueCxpLnBhZ2UueT1hLnBhZ2UueS1vLnBhZ2UueSxpLmNsaWVudC54PWEuY2xpZW50Lngtby5jbGllbnQueCxpLmNsaWVudC55PWEuY2xpZW50Lnktby5jbGllbnQueSxpLnRpbWVTdGFtcD1hLnRpbWVTdGFtcC1vLnRpbWVTdGFtcCxyJiYodGhpcy5wb2ludGVySXNEb3duPSEwLGwuZG93blRpbWU9dGhpcy5jb29yZHMuY3VyLnRpbWVTdGFtcCxsLmRvd25UYXJnZXQ9bix0dCh0aGlzLmRvd25Qb2ludGVyLHQpLHRoaXMuaW50ZXJhY3RpbmcoKXx8KGV0KHRoaXMuY29vcmRzLnN0YXJ0LHRoaXMuY29vcmRzLmN1ciksZXQodGhpcy5jb29yZHMucHJldix0aGlzLmNvb3Jkcy5jdXIpLHRoaXMuZG93bkV2ZW50PWUsdGhpcy5wb2ludGVyV2FzTW92ZWQ9ITEpKSx0aGlzLl91cGRhdGVMYXRlc3RQb2ludGVyKHQsZSxuKSx0aGlzLl9zY29wZUZpcmUoXCJpbnRlcmFjdGlvbnM6dXBkYXRlLXBvaW50ZXJcIix7cG9pbnRlcjp0LGV2ZW50OmUsZXZlbnRUYXJnZXQ6bixkb3duOnIscG9pbnRlckluZm86bCxwb2ludGVySW5kZXg6YyxpbnRlcmFjdGlvbjp0aGlzfSksY319LHtrZXk6XCJyZW1vdmVQb2ludGVyXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdldFBvaW50ZXJJbmRleCh0KTtpZigtMSE9PW4pe3ZhciByPXRoaXMucG9pbnRlcnNbbl07dGhpcy5fc2NvcGVGaXJlKFwiaW50ZXJhY3Rpb25zOnJlbW92ZS1wb2ludGVyXCIse3BvaW50ZXI6dCxldmVudDplLGV2ZW50VGFyZ2V0Om51bGwscG9pbnRlckluZGV4Om4scG9pbnRlckluZm86cixpbnRlcmFjdGlvbjp0aGlzfSksdGhpcy5wb2ludGVycy5zcGxpY2UobiwxKSx0aGlzLnBvaW50ZXJJc0Rvd249ITF9fX0se2tleTpcIl91cGRhdGVMYXRlc3RQb2ludGVyXCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4pe3RoaXMuX2xhdGVzdFBvaW50ZXIucG9pbnRlcj10LHRoaXMuX2xhdGVzdFBvaW50ZXIuZXZlbnQ9ZSx0aGlzLl9sYXRlc3RQb2ludGVyLmV2ZW50VGFyZ2V0PW59fSx7a2V5OlwiZGVzdHJveVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fbGF0ZXN0UG9pbnRlci5wb2ludGVyPW51bGwsdGhpcy5fbGF0ZXN0UG9pbnRlci5ldmVudD1udWxsLHRoaXMuX2xhdGVzdFBvaW50ZXIuZXZlbnRUYXJnZXQ9bnVsbH19LHtrZXk6XCJfY3JlYXRlUHJlcGFyZWRFdmVudFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiBuZXcgU2UodGhpcyx0LHRoaXMucHJlcGFyZWQubmFtZSxlLHRoaXMuZWxlbWVudCxuLHIpfX0se2tleTpcIl9maXJlRXZlbnRcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZTtudWxsPT0oZT10aGlzLmludGVyYWN0YWJsZSl8fGUuZmlyZSh0KSwoIXRoaXMucHJldkV2ZW50fHx0LnRpbWVTdGFtcD49dGhpcy5wcmV2RXZlbnQudGltZVN0YW1wKSYmKHRoaXMucHJldkV2ZW50PXQpfX0se2tleTpcIl9kb1BoYXNlXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dC5ldmVudCxuPXQucGhhc2Uscj10LnByZUVuZCxpPXQudHlwZSxvPXRoaXMucmVjdDtpZihvJiZcIm1vdmVcIj09PW4mJihIKHRoaXMuZWRnZXMsbyx0aGlzLmNvb3Jkcy5kZWx0YVt0aGlzLmludGVyYWN0YWJsZS5vcHRpb25zLmRlbHRhU291cmNlXSksby53aWR0aD1vLnJpZ2h0LW8ubGVmdCxvLmhlaWdodD1vLmJvdHRvbS1vLnRvcCksITE9PT10aGlzLl9zY29wZUZpcmUoXCJpbnRlcmFjdGlvbnM6YmVmb3JlLWFjdGlvbi1cIi5jb25jYXQobiksdCkpcmV0dXJuITE7dmFyIGE9dC5pRXZlbnQ9dGhpcy5fY3JlYXRlUHJlcGFyZWRFdmVudChlLG4scixpKTtyZXR1cm4gdGhpcy5fc2NvcGVGaXJlKFwiaW50ZXJhY3Rpb25zOmFjdGlvbi1cIi5jb25jYXQobiksdCksXCJzdGFydFwiPT09biYmKHRoaXMucHJldkV2ZW50PWEpLHRoaXMuX2ZpcmVFdmVudChhKSx0aGlzLl9zY29wZUZpcmUoXCJpbnRlcmFjdGlvbnM6YWZ0ZXItYWN0aW9uLVwiLmNvbmNhdChuKSx0KSwhMH19LHtrZXk6XCJfbm93XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKX19XSksdH0oKTtmdW5jdGlvbiBJZSh0KXtNZSh0LmludGVyYWN0aW9uKX1mdW5jdGlvbiBNZSh0KXtpZighZnVuY3Rpb24odCl7cmV0dXJuISghdC5vZmZzZXQucGVuZGluZy54JiYhdC5vZmZzZXQucGVuZGluZy55KX0odCkpcmV0dXJuITE7dmFyIGU9dC5vZmZzZXQucGVuZGluZztyZXR1cm4gQWUodC5jb29yZHMuY3VyLGUpLEFlKHQuY29vcmRzLmRlbHRhLGUpLEgodC5lZGdlcyx0LnJlY3QsZSksZS54PTAsZS55PTAsITB9ZnVuY3Rpb24gemUodCl7dmFyIGU9dC54LG49dC55O3RoaXMub2Zmc2V0LnBlbmRpbmcueCs9ZSx0aGlzLm9mZnNldC5wZW5kaW5nLnkrPW4sdGhpcy5vZmZzZXQudG90YWwueCs9ZSx0aGlzLm9mZnNldC50b3RhbC55Kz1ufWZ1bmN0aW9uIEFlKHQsZSl7dmFyIG49dC5wYWdlLHI9dC5jbGllbnQsaT1lLngsbz1lLnk7bi54Kz1pLG4ueSs9byxyLngrPWksci55Kz1vfU9lLm9mZnNldEJ5PVwiXCI7dmFyIFJlPXtpZDpcIm9mZnNldFwiLGJlZm9yZTpbXCJtb2RpZmllcnNcIixcInBvaW50ZXItZXZlbnRzXCIsXCJhY3Rpb25zXCIsXCJpbmVydGlhXCJdLGluc3RhbGw6ZnVuY3Rpb24odCl7dC5JbnRlcmFjdGlvbi5wcm90b3R5cGUub2Zmc2V0Qnk9emV9LGxpc3RlbmVyczp7XCJpbnRlcmFjdGlvbnM6bmV3XCI6ZnVuY3Rpb24odCl7dC5pbnRlcmFjdGlvbi5vZmZzZXQ9e3RvdGFsOnt4OjAseTowfSxwZW5kaW5nOnt4OjAseTowfX19LFwiaW50ZXJhY3Rpb25zOnVwZGF0ZS1wb2ludGVyXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3QucG9pbnRlcklzRG93biYmKEFlKHQuY29vcmRzLmN1cix0Lm9mZnNldC50b3RhbCksdC5vZmZzZXQucGVuZGluZy54PTAsdC5vZmZzZXQucGVuZGluZy55PTApfSh0LmludGVyYWN0aW9uKX0sXCJpbnRlcmFjdGlvbnM6YmVmb3JlLWFjdGlvbi1zdGFydFwiOkllLFwiaW50ZXJhY3Rpb25zOmJlZm9yZS1hY3Rpb24tbW92ZVwiOkllLFwiaW50ZXJhY3Rpb25zOmJlZm9yZS1hY3Rpb24tZW5kXCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbjtpZihNZShlKSlyZXR1cm4gZS5tb3ZlKHtvZmZzZXQ6ITB9KSxlLmVuZCgpLCExfSxcImludGVyYWN0aW9uczpzdG9wXCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbjtlLm9mZnNldC50b3RhbC54PTAsZS5vZmZzZXQudG90YWwueT0wLGUub2Zmc2V0LnBlbmRpbmcueD0wLGUub2Zmc2V0LnBlbmRpbmcueT0wfX19LENlPVJlO3ZhciBqZT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSl7cih0aGlzLHQpLHRoaXMuYWN0aXZlPSExLHRoaXMuaXNNb2RpZmllZD0hMSx0aGlzLnNtb290aEVuZD0hMSx0aGlzLmFsbG93UmVzdW1lPSExLHRoaXMubW9kaWZpY2F0aW9uPXZvaWQgMCx0aGlzLm1vZGlmaWVyQ291bnQ9MCx0aGlzLm1vZGlmaWVyQXJnPXZvaWQgMCx0aGlzLnN0YXJ0Q29vcmRzPXZvaWQgMCx0aGlzLnQwPTAsdGhpcy52MD0wLHRoaXMudGU9MCx0aGlzLnRhcmdldE9mZnNldD12b2lkIDAsdGhpcy5tb2RpZmllZE9mZnNldD12b2lkIDAsdGhpcy5jdXJyZW50T2Zmc2V0PXZvaWQgMCx0aGlzLmxhbWJkYV92MD0wLHRoaXMub25lX3ZlX3YwPTAsdGhpcy50aW1lb3V0PXZvaWQgMCx0aGlzLmludGVyYWN0aW9uPXZvaWQgMCx0aGlzLmludGVyYWN0aW9uPWV9cmV0dXJuIG8odCxbe2tleTpcInN0YXJ0XCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5pbnRlcmFjdGlvbixuPUZlKGUpO2lmKCFufHwhbi5lbmFibGVkKXJldHVybiExO3ZhciByPWUuY29vcmRzLnZlbG9jaXR5LmNsaWVudCxpPVEoci54LHIueSksbz10aGlzLm1vZGlmaWNhdGlvbnx8KHRoaXMubW9kaWZpY2F0aW9uPW5ldyBtZShlKSk7aWYoby5jb3B5RnJvbShlLm1vZGlmaWNhdGlvbiksdGhpcy50MD1lLl9ub3coKSx0aGlzLmFsbG93UmVzdW1lPW4uYWxsb3dSZXN1bWUsdGhpcy52MD1pLHRoaXMuY3VycmVudE9mZnNldD17eDowLHk6MH0sdGhpcy5zdGFydENvb3Jkcz1lLmNvb3Jkcy5jdXIucGFnZSx0aGlzLm1vZGlmaWVyQXJnPW8uZmlsbEFyZyh7cGFnZUNvb3Jkczp0aGlzLnN0YXJ0Q29vcmRzLHByZUVuZDohMCxwaGFzZTpcImluZXJ0aWFzdGFydFwifSksdGhpcy50MC1lLmNvb3Jkcy5jdXIudGltZVN0YW1wPDUwJiZpPm4ubWluU3BlZWQmJmk+bi5lbmRTcGVlZCl0aGlzLnN0YXJ0SW5lcnRpYSgpO2Vsc2V7aWYoby5yZXN1bHQ9by5zZXRBbGwodGhpcy5tb2RpZmllckFyZyksIW8ucmVzdWx0LmNoYW5nZWQpcmV0dXJuITE7dGhpcy5zdGFydFNtb290aEVuZCgpfXJldHVybiBlLm1vZGlmaWNhdGlvbi5yZXN1bHQucmVjdD1udWxsLGUub2Zmc2V0QnkodGhpcy50YXJnZXRPZmZzZXQpLGUuX2RvUGhhc2Uoe2ludGVyYWN0aW9uOmUsZXZlbnQ6dCxwaGFzZTpcImluZXJ0aWFzdGFydFwifSksZS5vZmZzZXRCeSh7eDotdGhpcy50YXJnZXRPZmZzZXQueCx5Oi10aGlzLnRhcmdldE9mZnNldC55fSksZS5tb2RpZmljYXRpb24ucmVzdWx0LnJlY3Q9bnVsbCx0aGlzLmFjdGl2ZT0hMCxlLnNpbXVsYXRpb249dGhpcywhMH19LHtrZXk6XCJzdGFydEluZXJ0aWFcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10aGlzLmludGVyYWN0aW9uLmNvb3Jkcy52ZWxvY2l0eS5jbGllbnQsbj1GZSh0aGlzLmludGVyYWN0aW9uKSxyPW4ucmVzaXN0YW5jZSxpPS1NYXRoLmxvZyhuLmVuZFNwZWVkL3RoaXMudjApL3I7dGhpcy50YXJnZXRPZmZzZXQ9e3g6KGUueC1pKS9yLHk6KGUueS1pKS9yfSx0aGlzLnRlPWksdGhpcy5sYW1iZGFfdjA9ci90aGlzLnYwLHRoaXMub25lX3ZlX3YwPTEtbi5lbmRTcGVlZC90aGlzLnYwO3ZhciBvPXRoaXMubW9kaWZpY2F0aW9uLGE9dGhpcy5tb2RpZmllckFyZzthLnBhZ2VDb29yZHM9e3g6dGhpcy5zdGFydENvb3Jkcy54K3RoaXMudGFyZ2V0T2Zmc2V0LngseTp0aGlzLnN0YXJ0Q29vcmRzLnkrdGhpcy50YXJnZXRPZmZzZXQueX0sby5yZXN1bHQ9by5zZXRBbGwoYSksby5yZXN1bHQuY2hhbmdlZCYmKHRoaXMuaXNNb2RpZmllZD0hMCx0aGlzLm1vZGlmaWVkT2Zmc2V0PXt4OnRoaXMudGFyZ2V0T2Zmc2V0Lngrby5yZXN1bHQuZGVsdGEueCx5OnRoaXMudGFyZ2V0T2Zmc2V0Lnkrby5yZXN1bHQuZGVsdGEueX0pLHRoaXMub25OZXh0RnJhbWUoKGZ1bmN0aW9uKCl7cmV0dXJuIHQuaW5lcnRpYVRpY2soKX0pKX19LHtrZXk6XCJzdGFydFNtb290aEVuZFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLnNtb290aEVuZD0hMCx0aGlzLmlzTW9kaWZpZWQ9ITAsdGhpcy50YXJnZXRPZmZzZXQ9e3g6dGhpcy5tb2RpZmljYXRpb24ucmVzdWx0LmRlbHRhLngseTp0aGlzLm1vZGlmaWNhdGlvbi5yZXN1bHQuZGVsdGEueX0sdGhpcy5vbk5leHRGcmFtZSgoZnVuY3Rpb24oKXtyZXR1cm4gdC5zbW9vdGhFbmRUaWNrKCl9KSl9fSx7a2V5Olwib25OZXh0RnJhbWVcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzO3RoaXMudGltZW91dD1MdC5yZXF1ZXN0KChmdW5jdGlvbigpe2UuYWN0aXZlJiZ0KCl9KSl9fSx7a2V5OlwiaW5lcnRpYVRpY2tcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0LGUsbixyLGksbyxhLHM9dGhpcyxjPXRoaXMuaW50ZXJhY3Rpb24sbD1GZShjKS5yZXNpc3RhbmNlLHU9KGMuX25vdygpLXRoaXMudDApLzFlMztpZih1PHRoaXMudGUpe3ZhciBwLGY9MS0oTWF0aC5leHAoLWwqdSktdGhpcy5sYW1iZGFfdjApL3RoaXMub25lX3ZlX3YwO3RoaXMuaXNNb2RpZmllZD8odD0wLGU9MCxuPXRoaXMudGFyZ2V0T2Zmc2V0Lngscj10aGlzLnRhcmdldE9mZnNldC55LGk9dGhpcy5tb2RpZmllZE9mZnNldC54LG89dGhpcy5tb2RpZmllZE9mZnNldC55LHA9e3g6WWUoYT1mLHQsbixpKSx5OlllKGEsZSxyLG8pfSk6cD17eDp0aGlzLnRhcmdldE9mZnNldC54KmYseTp0aGlzLnRhcmdldE9mZnNldC55KmZ9O3ZhciBkPXt4OnAueC10aGlzLmN1cnJlbnRPZmZzZXQueCx5OnAueS10aGlzLmN1cnJlbnRPZmZzZXQueX07dGhpcy5jdXJyZW50T2Zmc2V0LngrPWQueCx0aGlzLmN1cnJlbnRPZmZzZXQueSs9ZC55LGMub2Zmc2V0QnkoZCksYy5tb3ZlKCksdGhpcy5vbk5leHRGcmFtZSgoZnVuY3Rpb24oKXtyZXR1cm4gcy5pbmVydGlhVGljaygpfSkpfWVsc2UgYy5vZmZzZXRCeSh7eDp0aGlzLm1vZGlmaWVkT2Zmc2V0LngtdGhpcy5jdXJyZW50T2Zmc2V0LngseTp0aGlzLm1vZGlmaWVkT2Zmc2V0LnktdGhpcy5jdXJyZW50T2Zmc2V0Lnl9KSx0aGlzLmVuZCgpfX0se2tleTpcInNtb290aEVuZFRpY2tcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10aGlzLmludGVyYWN0aW9uLG49ZS5fbm93KCktdGhpcy50MCxyPUZlKGUpLnNtb290aEVuZER1cmF0aW9uO2lmKG48cil7dmFyIGk9e3g6TGUobiwwLHRoaXMudGFyZ2V0T2Zmc2V0LngscikseTpMZShuLDAsdGhpcy50YXJnZXRPZmZzZXQueSxyKX0sbz17eDppLngtdGhpcy5jdXJyZW50T2Zmc2V0LngseTppLnktdGhpcy5jdXJyZW50T2Zmc2V0Lnl9O3RoaXMuY3VycmVudE9mZnNldC54Kz1vLngsdGhpcy5jdXJyZW50T2Zmc2V0LnkrPW8ueSxlLm9mZnNldEJ5KG8pLGUubW92ZSh7c2tpcE1vZGlmaWVyczp0aGlzLm1vZGlmaWVyQ291bnR9KSx0aGlzLm9uTmV4dEZyYW1lKChmdW5jdGlvbigpe3JldHVybiB0LnNtb290aEVuZFRpY2soKX0pKX1lbHNlIGUub2Zmc2V0Qnkoe3g6dGhpcy50YXJnZXRPZmZzZXQueC10aGlzLmN1cnJlbnRPZmZzZXQueCx5OnRoaXMudGFyZ2V0T2Zmc2V0LnktdGhpcy5jdXJyZW50T2Zmc2V0Lnl9KSx0aGlzLmVuZCgpfX0se2tleTpcInJlc3VtZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXQucG9pbnRlcixuPXQuZXZlbnQscj10LmV2ZW50VGFyZ2V0LGk9dGhpcy5pbnRlcmFjdGlvbjtpLm9mZnNldEJ5KHt4Oi10aGlzLmN1cnJlbnRPZmZzZXQueCx5Oi10aGlzLmN1cnJlbnRPZmZzZXQueX0pLGkudXBkYXRlUG9pbnRlcihlLG4sciwhMCksaS5fZG9QaGFzZSh7aW50ZXJhY3Rpb246aSxldmVudDpuLHBoYXNlOlwicmVzdW1lXCJ9KSxldChpLmNvb3Jkcy5wcmV2LGkuY29vcmRzLmN1ciksdGhpcy5zdG9wKCl9fSx7a2V5OlwiZW5kXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmludGVyYWN0aW9uLm1vdmUoKSx0aGlzLmludGVyYWN0aW9uLmVuZCgpLHRoaXMuc3RvcCgpfX0se2tleTpcInN0b3BcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuYWN0aXZlPXRoaXMuc21vb3RoRW5kPSExLHRoaXMuaW50ZXJhY3Rpb24uc2ltdWxhdGlvbj1udWxsLEx0LmNhbmNlbCh0aGlzLnRpbWVvdXQpfX1dKSx0fSgpO2Z1bmN0aW9uIEZlKHQpe3ZhciBlPXQuaW50ZXJhY3RhYmxlLG49dC5wcmVwYXJlZDtyZXR1cm4gZSYmZS5vcHRpb25zJiZuLm5hbWUmJmUub3B0aW9uc1tuLm5hbWVdLmluZXJ0aWF9dmFyIFhlPXtpZDpcImluZXJ0aWFcIixiZWZvcmU6W1wibW9kaWZpZXJzXCIsXCJhY3Rpb25zXCJdLGluc3RhbGw6ZnVuY3Rpb24odCl7dmFyIGU9dC5kZWZhdWx0czt0LnVzZVBsdWdpbihDZSksdC51c2VQbHVnaW4oRWUpLHQuYWN0aW9ucy5waGFzZXMuaW5lcnRpYXN0YXJ0PSEwLHQuYWN0aW9ucy5waGFzZXMucmVzdW1lPSEwLGUucGVyQWN0aW9uLmluZXJ0aWE9e2VuYWJsZWQ6ITEscmVzaXN0YW5jZToxMCxtaW5TcGVlZDoxMDAsZW5kU3BlZWQ6MTAsYWxsb3dSZXN1bWU6ITAsc21vb3RoRW5kRHVyYXRpb246MzAwfX0sbGlzdGVuZXJzOntcImludGVyYWN0aW9uczpuZXdcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uO2UuaW5lcnRpYT1uZXcgamUoZSl9LFwiaW50ZXJhY3Rpb25zOmJlZm9yZS1hY3Rpb24tZW5kXCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbixuPXQuZXZlbnQ7cmV0dXJuKCFlLl9pbnRlcmFjdGluZ3x8ZS5zaW11bGF0aW9ufHwhZS5pbmVydGlhLnN0YXJ0KG4pKSYmbnVsbH0sXCJpbnRlcmFjdGlvbnM6ZG93blwiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24sbj10LmV2ZW50VGFyZ2V0LHI9ZS5pbmVydGlhO2lmKHIuYWN0aXZlKWZvcih2YXIgaT1uO3cuZWxlbWVudChpKTspe2lmKGk9PT1lLmVsZW1lbnQpe3IucmVzdW1lKHQpO2JyZWFrfWk9QShpKX19LFwiaW50ZXJhY3Rpb25zOnN0b3BcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uLmluZXJ0aWE7ZS5hY3RpdmUmJmUuc3RvcCgpfSxcImludGVyYWN0aW9uczpiZWZvcmUtYWN0aW9uLXJlc3VtZVwiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24ubW9kaWZpY2F0aW9uO2Uuc3RvcCh0KSxlLnN0YXJ0KHQsdC5pbnRlcmFjdGlvbi5jb29yZHMuY3VyLnBhZ2UpLGUuYXBwbHlUb0ludGVyYWN0aW9uKHQpfSxcImludGVyYWN0aW9uczpiZWZvcmUtYWN0aW9uLWluZXJ0aWFzdGFydFwiOmZ1bmN0aW9uKHQpe3JldHVybiB0LmludGVyYWN0aW9uLm1vZGlmaWNhdGlvbi5zZXRBbmRBcHBseSh0KX0sXCJpbnRlcmFjdGlvbnM6YWN0aW9uLXJlc3VtZVwiOnhlLFwiaW50ZXJhY3Rpb25zOmFjdGlvbi1pbmVydGlhc3RhcnRcIjp4ZSxcImludGVyYWN0aW9uczphZnRlci1hY3Rpb24taW5lcnRpYXN0YXJ0XCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuaW50ZXJhY3Rpb24ubW9kaWZpY2F0aW9uLnJlc3RvcmVJbnRlcmFjdGlvbkNvb3Jkcyh0KX0sXCJpbnRlcmFjdGlvbnM6YWZ0ZXItYWN0aW9uLXJlc3VtZVwiOmZ1bmN0aW9uKHQpe3JldHVybiB0LmludGVyYWN0aW9uLm1vZGlmaWNhdGlvbi5yZXN0b3JlSW50ZXJhY3Rpb25Db29yZHModCl9fX07ZnVuY3Rpb24gWWUodCxlLG4scil7dmFyIGk9MS10O3JldHVybiBpKmkqZSsyKmkqdCpuK3QqdCpyfWZ1bmN0aW9uIExlKHQsZSxuLHIpe3JldHVybi1uKih0Lz1yKSoodC0yKStlfXZhciBxZT1YZTtmdW5jdGlvbiBCZSh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO2lmKHQuaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKWJyZWFrO3IodCl9fXZhciBWZT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSl7cih0aGlzLHQpLHRoaXMub3B0aW9ucz12b2lkIDAsdGhpcy50eXBlcz17fSx0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZD0hMSx0aGlzLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZD0hMSx0aGlzLmdsb2JhbD12b2lkIDAsdGhpcy5vcHRpb25zPVYoe30sZXx8e30pfXJldHVybiBvKHQsW3trZXk6XCJmaXJlXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGUsbj10aGlzLmdsb2JhbDsoZT10aGlzLnR5cGVzW3QudHlwZV0pJiZCZSh0LGUpLCF0LnByb3BhZ2F0aW9uU3RvcHBlZCYmbiYmKGU9blt0LnR5cGVdKSYmQmUodCxlKX19LHtrZXk6XCJvblwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIG49JCh0LGUpO2Zvcih0IGluIG4pdGhpcy50eXBlc1t0XT1ndCh0aGlzLnR5cGVzW3RdfHxbXSxuW3RdKX19LHtrZXk6XCJvZmZcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBuPSQodCxlKTtmb3IodCBpbiBuKXt2YXIgcj10aGlzLnR5cGVzW3RdO2lmKHImJnIubGVuZ3RoKWZvcih2YXIgaT0wLG89blt0XTtpPG8ubGVuZ3RoO2krKyl7dmFyIGE9b1tpXSxzPXIuaW5kZXhPZihhKTstMSE9PXMmJnIuc3BsaWNlKHMsMSl9fX19LHtrZXk6XCJnZXRSZWN0XCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIG51bGx9fV0pLHR9KCk7dmFyIFdlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlKXtyKHRoaXMsdCksdGhpcy5jdXJyZW50VGFyZ2V0PXZvaWQgMCx0aGlzLm9yaWdpbmFsRXZlbnQ9dm9pZCAwLHRoaXMudHlwZT12b2lkIDAsdGhpcy5vcmlnaW5hbEV2ZW50PWUsdHQodGhpcyxlKX1yZXR1cm4gbyh0LFt7a2V5OlwicHJldmVudE9yaWdpbmFsRGVmYXVsdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5vcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCl9fSx7a2V5Olwic3RvcFByb3BhZ2F0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLm9yaWdpbmFsRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCl9fSx7a2V5Olwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLm9yaWdpbmFsRXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCl9fV0pLHR9KCk7ZnVuY3Rpb24gR2UodCl7cmV0dXJuIHcub2JqZWN0KHQpP3tjYXB0dXJlOiEhdC5jYXB0dXJlLHBhc3NpdmU6ISF0LnBhc3NpdmV9OntjYXB0dXJlOiEhdCxwYXNzaXZlOiExfX1mdW5jdGlvbiBOZSh0LGUpe3JldHVybiB0PT09ZXx8KFwiYm9vbGVhblwiPT10eXBlb2YgdD8hIWUuY2FwdHVyZT09PXQmJiExPT0hIWUucGFzc2l2ZTohIXQuY2FwdHVyZT09ISFlLmNhcHR1cmUmJiEhdC5wYXNzaXZlPT0hIWUucGFzc2l2ZSl9dmFyIFVlPXtpZDpcImV2ZW50c1wiLGluc3RhbGw6ZnVuY3Rpb24odCl7dmFyIGUsbj1bXSxyPXt9LGk9W10sbz17YWRkOmEscmVtb3ZlOnMsYWRkRGVsZWdhdGU6ZnVuY3Rpb24odCxlLG4sbyxzKXt2YXIgdT1HZShzKTtpZighcltuXSl7cltuXT1bXTtmb3IodmFyIHA9MDtwPGkubGVuZ3RoO3ArKyl7dmFyIGY9aVtwXTthKGYsbixjKSxhKGYsbixsLCEwKX19dmFyIGQ9cltuXSxoPWJ0KGQsKGZ1bmN0aW9uKG4pe3JldHVybiBuLnNlbGVjdG9yPT09dCYmbi5jb250ZXh0PT09ZX0pKTtofHwoaD17c2VsZWN0b3I6dCxjb250ZXh0OmUsbGlzdGVuZXJzOltdfSxkLnB1c2goaCkpO2gubGlzdGVuZXJzLnB1c2goe2Z1bmM6byxvcHRpb25zOnV9KX0scmVtb3ZlRGVsZWdhdGU6ZnVuY3Rpb24odCxlLG4saSxvKXt2YXIgYSx1PUdlKG8pLHA9cltuXSxmPSExO2lmKCFwKXJldHVybjtmb3IoYT1wLmxlbmd0aC0xO2E+PTA7YS0tKXt2YXIgZD1wW2FdO2lmKGQuc2VsZWN0b3I9PT10JiZkLmNvbnRleHQ9PT1lKXtmb3IodmFyIGg9ZC5saXN0ZW5lcnMsdj1oLmxlbmd0aC0xO3Y+PTA7di0tKXt2YXIgZz1oW3ZdO2lmKGcuZnVuYz09PWkmJk5lKGcub3B0aW9ucyx1KSl7aC5zcGxpY2UodiwxKSxoLmxlbmd0aHx8KHAuc3BsaWNlKGEsMSkscyhlLG4sYykscyhlLG4sbCwhMCkpLGY9ITA7YnJlYWt9fWlmKGYpYnJlYWt9fX0sZGVsZWdhdGVMaXN0ZW5lcjpjLGRlbGVnYXRlVXNlQ2FwdHVyZTpsLGRlbGVnYXRlZEV2ZW50czpyLGRvY3VtZW50czppLHRhcmdldHM6bixzdXBwb3J0c09wdGlvbnM6ITEsc3VwcG9ydHNQYXNzaXZlOiExfTtmdW5jdGlvbiBhKHQsZSxyLGkpe2lmKHQuYWRkRXZlbnRMaXN0ZW5lcil7dmFyIGE9R2UoaSkscz1idChuLChmdW5jdGlvbihlKXtyZXR1cm4gZS5ldmVudFRhcmdldD09PXR9KSk7c3x8KHM9e2V2ZW50VGFyZ2V0OnQsZXZlbnRzOnt9fSxuLnB1c2gocykpLHMuZXZlbnRzW2VdfHwocy5ldmVudHNbZV09W10pLGJ0KHMuZXZlbnRzW2VdLChmdW5jdGlvbih0KXtyZXR1cm4gdC5mdW5jPT09ciYmTmUodC5vcHRpb25zLGEpfSkpfHwodC5hZGRFdmVudExpc3RlbmVyKGUscixvLnN1cHBvcnRzT3B0aW9ucz9hOmEuY2FwdHVyZSkscy5ldmVudHNbZV0ucHVzaCh7ZnVuYzpyLG9wdGlvbnM6YX0pKX19ZnVuY3Rpb24gcyh0LGUscixpKXtpZih0LmFkZEV2ZW50TGlzdGVuZXImJnQucmVtb3ZlRXZlbnRMaXN0ZW5lcil7dmFyIGE9eXQobiwoZnVuY3Rpb24oZSl7cmV0dXJuIGUuZXZlbnRUYXJnZXQ9PT10fSkpLGM9blthXTtpZihjJiZjLmV2ZW50cylpZihcImFsbFwiIT09ZSl7dmFyIGw9ITEsdT1jLmV2ZW50c1tlXTtpZih1KXtpZihcImFsbFwiPT09cil7Zm9yKHZhciBwPXUubGVuZ3RoLTE7cD49MDtwLS0pe3ZhciBmPXVbcF07cyh0LGUsZi5mdW5jLGYub3B0aW9ucyl9cmV0dXJufWZvcih2YXIgZD1HZShpKSxoPTA7aDx1Lmxlbmd0aDtoKyspe3ZhciB2PXVbaF07aWYodi5mdW5jPT09ciYmTmUodi5vcHRpb25zLGQpKXt0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZSxyLG8uc3VwcG9ydHNPcHRpb25zP2Q6ZC5jYXB0dXJlKSx1LnNwbGljZShoLDEpLDA9PT11Lmxlbmd0aCYmKGRlbGV0ZSBjLmV2ZW50c1tlXSxsPSEwKTticmVha319fWwmJiFPYmplY3Qua2V5cyhjLmV2ZW50cykubGVuZ3RoJiZuLnNwbGljZShhLDEpfWVsc2UgZm9yKGUgaW4gYy5ldmVudHMpYy5ldmVudHMuaGFzT3duUHJvcGVydHkoZSkmJnModCxlLFwiYWxsXCIpfX1mdW5jdGlvbiBjKHQsZSl7Zm9yKHZhciBuPUdlKGUpLGk9bmV3IFdlKHQpLG89clt0LnR5cGVdLGE9aHQodClbMF0scz1hO3cuZWxlbWVudChzKTspe2Zvcih2YXIgYz0wO2M8by5sZW5ndGg7YysrKXt2YXIgbD1vW2NdLHU9bC5zZWxlY3RvcixwPWwuY29udGV4dDtpZihSKHMsdSkmJk0ocCxhKSYmTShwLHMpKXt2YXIgZj1sLmxpc3RlbmVycztpLmN1cnJlbnRUYXJnZXQ9cztmb3IodmFyIGQ9MDtkPGYubGVuZ3RoO2QrKyl7dmFyIGg9ZltkXTtOZShoLm9wdGlvbnMsbikmJmguZnVuYyhpKX19fXM9QShzKX19ZnVuY3Rpb24gbCh0KXtyZXR1cm4gYyh0LCEwKX1yZXR1cm4gbnVsbD09KGU9dC5kb2N1bWVudCl8fGUuY3JlYXRlRWxlbWVudChcImRpdlwiKS5hZGRFdmVudExpc3RlbmVyKFwidGVzdFwiLG51bGwse2dldCBjYXB0dXJlKCl7cmV0dXJuIG8uc3VwcG9ydHNPcHRpb25zPSEwfSxnZXQgcGFzc2l2ZSgpe3JldHVybiBvLnN1cHBvcnRzUGFzc2l2ZT0hMH19KSx0LmV2ZW50cz1vLG99fSxIZT17bWV0aG9kT3JkZXI6W1wic2ltdWxhdGlvblJlc3VtZVwiLFwibW91c2VPclBlblwiLFwiaGFzUG9pbnRlclwiLFwiaWRsZVwiXSxzZWFyY2g6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTAsbj1IZS5tZXRob2RPcmRlcjtlPG4ubGVuZ3RoO2UrKyl7dmFyIHI9bltlXSxpPUhlW3JdKHQpO2lmKGkpcmV0dXJuIGl9cmV0dXJuIG51bGx9LHNpbXVsYXRpb25SZXN1bWU6ZnVuY3Rpb24odCl7dmFyIGU9dC5wb2ludGVyVHlwZSxuPXQuZXZlbnRUeXBlLHI9dC5ldmVudFRhcmdldCxpPXQuc2NvcGU7aWYoIS9kb3dufHN0YXJ0L2kudGVzdChuKSlyZXR1cm4gbnVsbDtmb3IodmFyIG89MCxhPWkuaW50ZXJhY3Rpb25zLmxpc3Q7bzxhLmxlbmd0aDtvKyspe3ZhciBzPWFbb10sYz1yO2lmKHMuc2ltdWxhdGlvbiYmcy5zaW11bGF0aW9uLmFsbG93UmVzdW1lJiZzLnBvaW50ZXJUeXBlPT09ZSlmb3IoO2M7KXtpZihjPT09cy5lbGVtZW50KXJldHVybiBzO2M9QShjKX19cmV0dXJuIG51bGx9LG1vdXNlT3JQZW46ZnVuY3Rpb24odCl7dmFyIGUsbj10LnBvaW50ZXJJZCxyPXQucG9pbnRlclR5cGUsaT10LmV2ZW50VHlwZSxvPXQuc2NvcGU7aWYoXCJtb3VzZVwiIT09ciYmXCJwZW5cIiE9PXIpcmV0dXJuIG51bGw7Zm9yKHZhciBhPTAscz1vLmludGVyYWN0aW9ucy5saXN0O2E8cy5sZW5ndGg7YSsrKXt2YXIgYz1zW2FdO2lmKGMucG9pbnRlclR5cGU9PT1yKXtpZihjLnNpbXVsYXRpb24mJiFLZShjLG4pKWNvbnRpbnVlO2lmKGMuaW50ZXJhY3RpbmcoKSlyZXR1cm4gYztlfHwoZT1jKX19aWYoZSlyZXR1cm4gZTtmb3IodmFyIGw9MCx1PW8uaW50ZXJhY3Rpb25zLmxpc3Q7bDx1Lmxlbmd0aDtsKyspe3ZhciBwPXVbbF07aWYoIShwLnBvaW50ZXJUeXBlIT09cnx8L2Rvd24vaS50ZXN0KGkpJiZwLnNpbXVsYXRpb24pKXJldHVybiBwfXJldHVybiBudWxsfSxoYXNQb2ludGVyOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LnBvaW50ZXJJZCxuPTAscj10LnNjb3BlLmludGVyYWN0aW9ucy5saXN0O248ci5sZW5ndGg7bisrKXt2YXIgaT1yW25dO2lmKEtlKGksZSkpcmV0dXJuIGl9cmV0dXJuIG51bGx9LGlkbGU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQucG9pbnRlclR5cGUsbj0wLHI9dC5zY29wZS5pbnRlcmFjdGlvbnMubGlzdDtuPHIubGVuZ3RoO24rKyl7dmFyIGk9cltuXTtpZigxPT09aS5wb2ludGVycy5sZW5ndGgpe3ZhciBvPWkuaW50ZXJhY3RhYmxlO2lmKG8mJighby5vcHRpb25zLmdlc3R1cmV8fCFvLm9wdGlvbnMuZ2VzdHVyZS5lbmFibGVkKSljb250aW51ZX1lbHNlIGlmKGkucG9pbnRlcnMubGVuZ3RoPj0yKWNvbnRpbnVlO2lmKCFpLmludGVyYWN0aW5nKCkmJmU9PT1pLnBvaW50ZXJUeXBlKXJldHVybiBpfXJldHVybiBudWxsfX07ZnVuY3Rpb24gS2UodCxlKXtyZXR1cm4gdC5wb2ludGVycy5zb21lKChmdW5jdGlvbih0KXtyZXR1cm4gdC5pZD09PWV9KSl9dmFyICRlPUhlLEplPVtcInBvaW50ZXJEb3duXCIsXCJwb2ludGVyTW92ZVwiLFwicG9pbnRlclVwXCIsXCJ1cGRhdGVQb2ludGVyXCIsXCJyZW1vdmVQb2ludGVyXCIsXCJ3aW5kb3dCbHVyXCJdO2Z1bmN0aW9uIFFlKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKG4pe3ZhciByPWUuaW50ZXJhY3Rpb25zLmxpc3QsaT1kdChuKSxvPWh0KG4pLGE9b1swXSxzPW9bMV0sYz1bXTtpZigvXnRvdWNoLy50ZXN0KG4udHlwZSkpe2UucHJldlRvdWNoVGltZT1lLm5vdygpO2Zvcih2YXIgbD0wLHU9bi5jaGFuZ2VkVG91Y2hlcztsPHUubGVuZ3RoO2wrKyl7dmFyIHA9dVtsXSxmPXtwb2ludGVyOnAscG9pbnRlcklkOmF0KHApLHBvaW50ZXJUeXBlOmksZXZlbnRUeXBlOm4udHlwZSxldmVudFRhcmdldDphLGN1ckV2ZW50VGFyZ2V0OnMsc2NvcGU6ZX0sZD1aZShmKTtjLnB1c2goW2YucG9pbnRlcixmLmV2ZW50VGFyZ2V0LGYuY3VyRXZlbnRUYXJnZXQsZF0pfX1lbHNle3ZhciBoPSExO2lmKCFJLnN1cHBvcnRzUG9pbnRlckV2ZW50JiYvbW91c2UvLnRlc3Qobi50eXBlKSl7Zm9yKHZhciB2PTA7djxyLmxlbmd0aCYmIWg7disrKWg9XCJtb3VzZVwiIT09clt2XS5wb2ludGVyVHlwZSYmclt2XS5wb2ludGVySXNEb3duO2g9aHx8ZS5ub3coKS1lLnByZXZUb3VjaFRpbWU8NTAwfHwwPT09bi50aW1lU3RhbXB9aWYoIWgpe3ZhciBnPXtwb2ludGVyOm4scG9pbnRlcklkOmF0KG4pLHBvaW50ZXJUeXBlOmksZXZlbnRUeXBlOm4udHlwZSxjdXJFdmVudFRhcmdldDpzLGV2ZW50VGFyZ2V0OmEsc2NvcGU6ZX0sbT1aZShnKTtjLnB1c2goW2cucG9pbnRlcixnLmV2ZW50VGFyZ2V0LGcuY3VyRXZlbnRUYXJnZXQsbV0pfX1mb3IodmFyIHk9MDt5PGMubGVuZ3RoO3krKyl7dmFyIGI9Y1t5XSx4PWJbMF0sdz1iWzFdLEU9YlsyXTtiWzNdW3RdKHgsbix3LEUpfX19ZnVuY3Rpb24gWmUodCl7dmFyIGU9dC5wb2ludGVyVHlwZSxuPXQuc2NvcGUscj17aW50ZXJhY3Rpb246JGUuc2VhcmNoKHQpLHNlYXJjaERldGFpbHM6dH07cmV0dXJuIG4uZmlyZShcImludGVyYWN0aW9uczpmaW5kXCIsciksci5pbnRlcmFjdGlvbnx8bi5pbnRlcmFjdGlvbnMubmV3KHtwb2ludGVyVHlwZTplfSl9ZnVuY3Rpb24gdG4odCxlKXt2YXIgbj10LmRvYyxyPXQuc2NvcGUsaT10Lm9wdGlvbnMsbz1yLmludGVyYWN0aW9ucy5kb2NFdmVudHMsYT1yLmV2ZW50cyxzPWFbZV07Zm9yKHZhciBjIGluIHIuYnJvd3Nlci5pc0lPUyYmIWkuZXZlbnRzJiYoaS5ldmVudHM9e3Bhc3NpdmU6ITF9KSxhLmRlbGVnYXRlZEV2ZW50cylzKG4sYyxhLmRlbGVnYXRlTGlzdGVuZXIpLHMobixjLGEuZGVsZWdhdGVVc2VDYXB0dXJlLCEwKTtmb3IodmFyIGw9aSYmaS5ldmVudHMsdT0wO3U8by5sZW5ndGg7dSsrKXt2YXIgcD1vW3VdO3MobixwLnR5cGUscC5saXN0ZW5lcixsKX19dmFyIGVuPXtpZDpcImNvcmUvaW50ZXJhY3Rpb25zXCIsaW5zdGFsbDpmdW5jdGlvbih0KXtmb3IodmFyIGU9e30sbj0wO248SmUubGVuZ3RoO24rKyl7dmFyIGk9SmVbbl07ZVtpXT1RZShpLHQpfXZhciBhLGM9SS5wRXZlbnRUeXBlcztmdW5jdGlvbiBsKCl7Zm9yKHZhciBlPTAsbj10LmludGVyYWN0aW9ucy5saXN0O2U8bi5sZW5ndGg7ZSsrKXt2YXIgcj1uW2VdO2lmKHIucG9pbnRlcklzRG93biYmXCJ0b3VjaFwiPT09ci5wb2ludGVyVHlwZSYmIXIuX2ludGVyYWN0aW5nKWZvcih2YXIgaT1mdW5jdGlvbigpe3ZhciBlPWFbb107dC5kb2N1bWVudHMuc29tZSgoZnVuY3Rpb24odCl7cmV0dXJuIE0odC5kb2MsZS5kb3duVGFyZ2V0KX0pKXx8ci5yZW1vdmVQb2ludGVyKGUucG9pbnRlcixlLmV2ZW50KX0sbz0wLGE9ci5wb2ludGVycztvPGEubGVuZ3RoO28rKylpKCl9fShhPWsuUG9pbnRlckV2ZW50P1t7dHlwZTpjLmRvd24sbGlzdGVuZXI6bH0se3R5cGU6Yy5kb3duLGxpc3RlbmVyOmUucG9pbnRlckRvd259LHt0eXBlOmMubW92ZSxsaXN0ZW5lcjplLnBvaW50ZXJNb3ZlfSx7dHlwZTpjLnVwLGxpc3RlbmVyOmUucG9pbnRlclVwfSx7dHlwZTpjLmNhbmNlbCxsaXN0ZW5lcjplLnBvaW50ZXJVcH1dOlt7dHlwZTpcIm1vdXNlZG93blwiLGxpc3RlbmVyOmUucG9pbnRlckRvd259LHt0eXBlOlwibW91c2Vtb3ZlXCIsbGlzdGVuZXI6ZS5wb2ludGVyTW92ZX0se3R5cGU6XCJtb3VzZXVwXCIsbGlzdGVuZXI6ZS5wb2ludGVyVXB9LHt0eXBlOlwidG91Y2hzdGFydFwiLGxpc3RlbmVyOmx9LHt0eXBlOlwidG91Y2hzdGFydFwiLGxpc3RlbmVyOmUucG9pbnRlckRvd259LHt0eXBlOlwidG91Y2htb3ZlXCIsbGlzdGVuZXI6ZS5wb2ludGVyTW92ZX0se3R5cGU6XCJ0b3VjaGVuZFwiLGxpc3RlbmVyOmUucG9pbnRlclVwfSx7dHlwZTpcInRvdWNoY2FuY2VsXCIsbGlzdGVuZXI6ZS5wb2ludGVyVXB9XSkucHVzaCh7dHlwZTpcImJsdXJcIixsaXN0ZW5lcjpmdW5jdGlvbihlKXtmb3IodmFyIG49MCxyPXQuaW50ZXJhY3Rpb25zLmxpc3Q7bjxyLmxlbmd0aDtuKyspe3Jbbl0uZG9jdW1lbnRCbHVyKGUpfX19KSx0LnByZXZUb3VjaFRpbWU9MCx0LkludGVyYWN0aW9uPWZ1bmN0aW9uKGUpe3MoaSxlKTt2YXIgbj1wKGkpO2Z1bmN0aW9uIGkoKXtyZXR1cm4gcih0aGlzLGkpLG4uYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBvKGksW3trZXk6XCJwb2ludGVyTW92ZVRvbGVyYW5jZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0LmludGVyYWN0aW9ucy5wb2ludGVyTW92ZVRvbGVyYW5jZX0sc2V0OmZ1bmN0aW9uKGUpe3QuaW50ZXJhY3Rpb25zLnBvaW50ZXJNb3ZlVG9sZXJhbmNlPWV9fSx7a2V5OlwiX25vd1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHQubm93KCl9fV0pLGl9KERlKSx0LmludGVyYWN0aW9ucz17bGlzdDpbXSxuZXc6ZnVuY3Rpb24oZSl7ZS5zY29wZUZpcmU9ZnVuY3Rpb24oZSxuKXtyZXR1cm4gdC5maXJlKGUsbil9O3ZhciBuPW5ldyB0LkludGVyYWN0aW9uKGUpO3JldHVybiB0LmludGVyYWN0aW9ucy5saXN0LnB1c2gobiksbn0sbGlzdGVuZXJzOmUsZG9jRXZlbnRzOmEscG9pbnRlck1vdmVUb2xlcmFuY2U6MX0sdC51c2VQbHVnaW4oaGUpfSxsaXN0ZW5lcnM6e1wic2NvcGU6YWRkLWRvY3VtZW50XCI6ZnVuY3Rpb24odCl7cmV0dXJuIHRuKHQsXCJhZGRcIil9LFwic2NvcGU6cmVtb3ZlLWRvY3VtZW50XCI6ZnVuY3Rpb24odCl7cmV0dXJuIHRuKHQsXCJyZW1vdmVcIil9LFwiaW50ZXJhY3RhYmxlOnVuc2V0XCI6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5pbnRlcmFjdGFibGUscj1lLmludGVyYWN0aW9ucy5saXN0Lmxlbmd0aC0xO3I+PTA7ci0tKXt2YXIgaT1lLmludGVyYWN0aW9ucy5saXN0W3JdO2kuaW50ZXJhY3RhYmxlPT09biYmKGkuc3RvcCgpLGUuZmlyZShcImludGVyYWN0aW9uczpkZXN0cm95XCIse2ludGVyYWN0aW9uOml9KSxpLmRlc3Ryb3koKSxlLmludGVyYWN0aW9ucy5saXN0Lmxlbmd0aD4yJiZlLmludGVyYWN0aW9ucy5saXN0LnNwbGljZShyLDEpKX19fSxvbkRvY1NpZ25hbDp0bixkb09uSW50ZXJhY3Rpb25zOlFlLG1ldGhvZE5hbWVzOkplfSxubj1lbixybj1mdW5jdGlvbih0KXtyZXR1cm4gdFt0Lk9uPTBdPVwiT25cIix0W3QuT2ZmPTFdPVwiT2ZmXCIsdH0ocm58fHt9KSxvbj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSxuLGksbyl7cih0aGlzLHQpLHRoaXMudGFyZ2V0PXZvaWQgMCx0aGlzLm9wdGlvbnM9dm9pZCAwLHRoaXMuX2FjdGlvbnM9dm9pZCAwLHRoaXMuZXZlbnRzPW5ldyBWZSx0aGlzLl9jb250ZXh0PXZvaWQgMCx0aGlzLl93aW49dm9pZCAwLHRoaXMuX2RvYz12b2lkIDAsdGhpcy5fc2NvcGVFdmVudHM9dm9pZCAwLHRoaXMuX2FjdGlvbnM9bi5hY3Rpb25zLHRoaXMudGFyZ2V0PWUsdGhpcy5fY29udGV4dD1uLmNvbnRleHR8fGksdGhpcy5fd2luPXkoQihlKT90aGlzLl9jb250ZXh0OmUpLHRoaXMuX2RvYz10aGlzLl93aW4uZG9jdW1lbnQsdGhpcy5fc2NvcGVFdmVudHM9byx0aGlzLnNldChuKX1yZXR1cm4gbyh0LFt7a2V5OlwiX2RlZmF1bHRzXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJue2Jhc2U6e30scGVyQWN0aW9uOnt9LGFjdGlvbnM6e319fX0se2tleTpcInNldE9uRXZlbnRzXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdy5mdW5jKGUub25zdGFydCkmJnRoaXMub24oXCJcIi5jb25jYXQodCxcInN0YXJ0XCIpLGUub25zdGFydCksdy5mdW5jKGUub25tb3ZlKSYmdGhpcy5vbihcIlwiLmNvbmNhdCh0LFwibW92ZVwiKSxlLm9ubW92ZSksdy5mdW5jKGUub25lbmQpJiZ0aGlzLm9uKFwiXCIuY29uY2F0KHQsXCJlbmRcIiksZS5vbmVuZCksdy5mdW5jKGUub25pbmVydGlhc3RhcnQpJiZ0aGlzLm9uKFwiXCIuY29uY2F0KHQsXCJpbmVydGlhc3RhcnRcIiksZS5vbmluZXJ0aWFzdGFydCksdGhpc319LHtrZXk6XCJ1cGRhdGVQZXJBY3Rpb25MaXN0ZW5lcnNcIix2YWx1ZTpmdW5jdGlvbih0LGUsbil7dmFyIHIsaT10aGlzLG89bnVsbD09KHI9dGhpcy5fYWN0aW9ucy5tYXBbdF0pP3ZvaWQgMDpyLmZpbHRlckV2ZW50VHlwZSxhPWZ1bmN0aW9uKHQpe3JldHVybihudWxsPT1vfHxvKHQpKSYmdmUodCxpLl9hY3Rpb25zKX07KHcuYXJyYXkoZSl8fHcub2JqZWN0KGUpKSYmdGhpcy5fb25PZmYocm4uT2ZmLHQsZSx2b2lkIDAsYSksKHcuYXJyYXkobil8fHcub2JqZWN0KG4pKSYmdGhpcy5fb25PZmYocm4uT24sdCxuLHZvaWQgMCxhKX19LHtrZXk6XCJzZXRQZXJBY3Rpb25cIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuX2RlZmF1bHRzO2Zvcih2YXIgciBpbiBlKXt2YXIgaT1yLG89dGhpcy5vcHRpb25zW3RdLGE9ZVtpXTtcImxpc3RlbmVyc1wiPT09aSYmdGhpcy51cGRhdGVQZXJBY3Rpb25MaXN0ZW5lcnModCxvLmxpc3RlbmVycyxhKSx3LmFycmF5KGEpP29baV09bXQoYSk6dy5wbGFpbk9iamVjdChhKT8ob1tpXT1WKG9baV18fHt9LGdlKGEpKSx3Lm9iamVjdChuLnBlckFjdGlvbltpXSkmJlwiZW5hYmxlZFwiaW4gbi5wZXJBY3Rpb25baV0mJihvW2ldLmVuYWJsZWQ9ITEhPT1hLmVuYWJsZWQpKTp3LmJvb2woYSkmJncub2JqZWN0KG4ucGVyQWN0aW9uW2ldKT9vW2ldLmVuYWJsZWQ9YTpvW2ldPWF9fX0se2tleTpcImdldFJlY3RcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdD10fHwody5lbGVtZW50KHRoaXMudGFyZ2V0KT90aGlzLnRhcmdldDpudWxsKSx3LnN0cmluZyh0aGlzLnRhcmdldCkmJih0PXR8fHRoaXMuX2NvbnRleHQucXVlcnlTZWxlY3Rvcih0aGlzLnRhcmdldCkpLEwodCl9fSx7a2V5OlwicmVjdENoZWNrZXJcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzO3JldHVybiB3LmZ1bmModCk/KHRoaXMuZ2V0UmVjdD1mdW5jdGlvbihuKXt2YXIgcj1WKHt9LHQuYXBwbHkoZSxuKSk7cmV0dXJuXCJ3aWR0aFwiaW4gcnx8KHIud2lkdGg9ci5yaWdodC1yLmxlZnQsci5oZWlnaHQ9ci5ib3R0b20tci50b3ApLHJ9LHRoaXMpOm51bGw9PT10PyhkZWxldGUgdGhpcy5nZXRSZWN0LHRoaXMpOnRoaXMuZ2V0UmVjdH19LHtrZXk6XCJfYmFja0NvbXBhdE9wdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7aWYoQihlKXx8dy5vYmplY3QoZSkpe2Zvcih2YXIgbiBpbiB0aGlzLm9wdGlvbnNbdF09ZSx0aGlzLl9hY3Rpb25zLm1hcCl0aGlzLm9wdGlvbnNbbl1bdF09ZTtyZXR1cm4gdGhpc31yZXR1cm4gdGhpcy5vcHRpb25zW3RdfX0se2tleTpcIm9yaWdpblwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9iYWNrQ29tcGF0T3B0aW9uKFwib3JpZ2luXCIsdCl9fSx7a2V5OlwiZGVsdGFTb3VyY2VcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm5cInBhZ2VcIj09PXR8fFwiY2xpZW50XCI9PT10Pyh0aGlzLm9wdGlvbnMuZGVsdGFTb3VyY2U9dCx0aGlzKTp0aGlzLm9wdGlvbnMuZGVsdGFTb3VyY2V9fSx7a2V5OlwiZ2V0QWxsRWxlbWVudHNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMudGFyZ2V0O3JldHVybiB3LnN0cmluZyh0KT9BcnJheS5mcm9tKHRoaXMuX2NvbnRleHQucXVlcnlTZWxlY3RvckFsbCh0KSk6dy5mdW5jKHQpJiZ0LmdldEFsbEVsZW1lbnRzP3QuZ2V0QWxsRWxlbWVudHMoKTp3LmVsZW1lbnQodCk/W3RdOltdfX0se2tleTpcImNvbnRleHRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jb250ZXh0fX0se2tleTpcImluQ29udGV4dFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9jb250ZXh0PT09dC5vd25lckRvY3VtZW50fHxNKHRoaXMuX2NvbnRleHQsdCl9fSx7a2V5OlwidGVzdElnbm9yZUFsbG93XCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4pe3JldHVybiF0aGlzLnRlc3RJZ25vcmUodC5pZ25vcmVGcm9tLGUsbikmJnRoaXMudGVzdEFsbG93KHQuYWxsb3dGcm9tLGUsbil9fSx7a2V5OlwidGVzdEFsbG93XCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4pe3JldHVybiF0fHwhIXcuZWxlbWVudChuKSYmKHcuc3RyaW5nKHQpP0Yobix0LGUpOiEhdy5lbGVtZW50KHQpJiZNKHQsbikpfX0se2tleTpcInRlc3RJZ25vcmVcIix2YWx1ZTpmdW5jdGlvbih0LGUsbil7cmV0dXJuISghdHx8IXcuZWxlbWVudChuKSkmJih3LnN0cmluZyh0KT9GKG4sdCxlKTohIXcuZWxlbWVudCh0KSYmTSh0LG4pKX19LHtrZXk6XCJmaXJlXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZXZlbnRzLmZpcmUodCksdGhpc319LHtrZXk6XCJfb25PZmZcIix2YWx1ZTpmdW5jdGlvbih0LGUsbixyLGkpe3cub2JqZWN0KGUpJiYhdy5hcnJheShlKSYmKHI9bixuPW51bGwpO3ZhciBvPSQoZSxuLGkpO2Zvcih2YXIgYSBpbiBvKXtcIndoZWVsXCI9PT1hJiYoYT1JLndoZWVsRXZlbnQpO2Zvcih2YXIgcz0wLGM9b1thXTtzPGMubGVuZ3RoO3MrKyl7dmFyIGw9Y1tzXTt2ZShhLHRoaXMuX2FjdGlvbnMpP3RoaXMuZXZlbnRzW3Q9PT1ybi5Pbj9cIm9uXCI6XCJvZmZcIl0oYSxsKTp3LnN0cmluZyh0aGlzLnRhcmdldCk/dGhpcy5fc2NvcGVFdmVudHNbdD09PXJuLk9uP1wiYWRkRGVsZWdhdGVcIjpcInJlbW92ZURlbGVnYXRlXCJdKHRoaXMudGFyZ2V0LHRoaXMuX2NvbnRleHQsYSxsLHIpOnRoaXMuX3Njb3BlRXZlbnRzW3Q9PT1ybi5Pbj9cImFkZFwiOlwicmVtb3ZlXCJdKHRoaXMudGFyZ2V0LGEsbCxyKX19cmV0dXJuIHRoaXN9fSx7a2V5Olwib25cIix2YWx1ZTpmdW5jdGlvbih0LGUsbil7cmV0dXJuIHRoaXMuX29uT2ZmKHJuLk9uLHQsZSxuKX19LHtrZXk6XCJvZmZcIix2YWx1ZTpmdW5jdGlvbih0LGUsbil7cmV0dXJuIHRoaXMuX29uT2ZmKHJuLk9mZix0LGUsbil9fSx7a2V5Olwic2V0XCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5fZGVmYXVsdHM7Zm9yKHZhciBuIGluIHcub2JqZWN0KHQpfHwodD17fSksdGhpcy5vcHRpb25zPWdlKGUuYmFzZSksdGhpcy5fYWN0aW9ucy5tZXRob2REaWN0KXt2YXIgcj1uLGk9dGhpcy5fYWN0aW9ucy5tZXRob2REaWN0W3JdO3RoaXMub3B0aW9uc1tyXT17fSx0aGlzLnNldFBlckFjdGlvbihyLFYoVih7fSxlLnBlckFjdGlvbiksZS5hY3Rpb25zW3JdKSksdGhpc1tpXSh0W3JdKX1mb3IodmFyIG8gaW4gdClcImdldFJlY3RcIiE9PW8/dy5mdW5jKHRoaXNbb10pJiZ0aGlzW29dKHRbb10pOnRoaXMucmVjdENoZWNrZXIodC5nZXRSZWN0KTtyZXR1cm4gdGhpc319LHtrZXk6XCJ1bnNldFwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYody5zdHJpbmcodGhpcy50YXJnZXQpKWZvcih2YXIgdCBpbiB0aGlzLl9zY29wZUV2ZW50cy5kZWxlZ2F0ZWRFdmVudHMpZm9yKHZhciBlPXRoaXMuX3Njb3BlRXZlbnRzLmRlbGVnYXRlZEV2ZW50c1t0XSxuPWUubGVuZ3RoLTE7bj49MDtuLS0pe3ZhciByPWVbbl0saT1yLnNlbGVjdG9yLG89ci5jb250ZXh0LGE9ci5saXN0ZW5lcnM7aT09PXRoaXMudGFyZ2V0JiZvPT09dGhpcy5fY29udGV4dCYmZS5zcGxpY2UobiwxKTtmb3IodmFyIHM9YS5sZW5ndGgtMTtzPj0wO3MtLSl0aGlzLl9zY29wZUV2ZW50cy5yZW1vdmVEZWxlZ2F0ZSh0aGlzLnRhcmdldCx0aGlzLl9jb250ZXh0LHQsYVtzXVswXSxhW3NdWzFdKX1lbHNlIHRoaXMuX3Njb3BlRXZlbnRzLnJlbW92ZSh0aGlzLnRhcmdldCxcImFsbFwiKX19XSksdH0oKSxhbj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSl7dmFyIG49dGhpcztyKHRoaXMsdCksdGhpcy5saXN0PVtdLHRoaXMuc2VsZWN0b3JNYXA9e30sdGhpcy5zY29wZT12b2lkIDAsdGhpcy5zY29wZT1lLGUuYWRkTGlzdGVuZXJzKHtcImludGVyYWN0YWJsZTp1bnNldFwiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3RhYmxlLHI9ZS50YXJnZXQsaT13LnN0cmluZyhyKT9uLnNlbGVjdG9yTWFwW3JdOnJbbi5zY29wZS5pZF0sbz15dChpLChmdW5jdGlvbih0KXtyZXR1cm4gdD09PWV9KSk7aS5zcGxpY2UobywxKX19KX1yZXR1cm4gbyh0LFt7a2V5OlwibmV3XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtlPVYoZXx8e30se2FjdGlvbnM6dGhpcy5zY29wZS5hY3Rpb25zfSk7dmFyIG49bmV3IHRoaXMuc2NvcGUuSW50ZXJhY3RhYmxlKHQsZSx0aGlzLnNjb3BlLmRvY3VtZW50LHRoaXMuc2NvcGUuZXZlbnRzKTtyZXR1cm4gdGhpcy5zY29wZS5hZGREb2N1bWVudChuLl9kb2MpLHRoaXMubGlzdC5wdXNoKG4pLHcuc3RyaW5nKHQpPyh0aGlzLnNlbGVjdG9yTWFwW3RdfHwodGhpcy5zZWxlY3Rvck1hcFt0XT1bXSksdGhpcy5zZWxlY3Rvck1hcFt0XS5wdXNoKG4pKToobi50YXJnZXRbdGhpcy5zY29wZS5pZF18fE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHRoaXMuc2NvcGUuaWQse3ZhbHVlOltdLGNvbmZpZ3VyYWJsZTohMH0pLHRbdGhpcy5zY29wZS5pZF0ucHVzaChuKSksdGhpcy5zY29wZS5maXJlKFwiaW50ZXJhY3RhYmxlOm5ld1wiLHt0YXJnZXQ6dCxvcHRpb25zOmUsaW50ZXJhY3RhYmxlOm4sd2luOnRoaXMuc2NvcGUuX3dpbn0pLG59fSx7a2V5OlwiZ2V0RXhpc3RpbmdcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBuPWUmJmUuY29udGV4dHx8dGhpcy5zY29wZS5kb2N1bWVudCxyPXcuc3RyaW5nKHQpLGk9cj90aGlzLnNlbGVjdG9yTWFwW3RdOnRbdGhpcy5zY29wZS5pZF07aWYoaSlyZXR1cm4gYnQoaSwoZnVuY3Rpb24oZSl7cmV0dXJuIGUuX2NvbnRleHQ9PT1uJiYocnx8ZS5pbkNvbnRleHQodCkpfSkpfX0se2tleTpcImZvckVhY2hNYXRjaFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTAscj10aGlzLmxpc3Q7bjxyLmxlbmd0aDtuKyspe3ZhciBpPXJbbl0sbz12b2lkIDA7aWYoKHcuc3RyaW5nKGkudGFyZ2V0KT93LmVsZW1lbnQodCkmJlIodCxpLnRhcmdldCk6dD09PWkudGFyZ2V0KSYmaS5pbkNvbnRleHQodCkmJihvPWUoaSkpLHZvaWQgMCE9PW8pcmV0dXJuIG99fX1dKSx0fSgpO3ZhciBzbj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt2YXIgZT10aGlzO3IodGhpcyx0KSx0aGlzLmlkPVwiX19pbnRlcmFjdF9zY29wZV9cIi5jb25jYXQoTWF0aC5mbG9vcigxMDAqTWF0aC5yYW5kb20oKSkpLHRoaXMuaXNJbml0aWFsaXplZD0hMSx0aGlzLmxpc3RlbmVyTWFwcz1bXSx0aGlzLmJyb3dzZXI9SSx0aGlzLmRlZmF1bHRzPWdlKFRlKSx0aGlzLkV2ZW50YWJsZT1WZSx0aGlzLmFjdGlvbnM9e21hcDp7fSxwaGFzZXM6e3N0YXJ0OiEwLG1vdmU6ITAsZW5kOiEwfSxtZXRob2REaWN0Ont9LHBoYXNlbGVzc1R5cGVzOnt9fSx0aGlzLmludGVyYWN0U3RhdGljPWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uIGUobixyKXt2YXIgaT10LmludGVyYWN0YWJsZXMuZ2V0RXhpc3RpbmcobixyKTtyZXR1cm4gaXx8KChpPXQuaW50ZXJhY3RhYmxlcy5uZXcobixyKSkuZXZlbnRzLmdsb2JhbD1lLmdsb2JhbEV2ZW50cyksaX07cmV0dXJuIGUuZ2V0UG9pbnRlckF2ZXJhZ2U9bHQsZS5nZXRUb3VjaEJCb3g9dXQsZS5nZXRUb3VjaERpc3RhbmNlPXB0LGUuZ2V0VG91Y2hBbmdsZT1mdCxlLmdldEVsZW1lbnRSZWN0PUwsZS5nZXRFbGVtZW50Q2xpZW50UmVjdD1ZLGUubWF0Y2hlc1NlbGVjdG9yPVIsZS5jbG9zZXN0PXosZS5nbG9iYWxFdmVudHM9e30sZS52ZXJzaW9uPVwiMS4xMC4yNlwiLGUuc2NvcGU9dCxlLnVzZT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnNjb3BlLnVzZVBsdWdpbih0LGUpLHRoaXN9LGUuaXNTZXQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4hIXRoaXMuc2NvcGUuaW50ZXJhY3RhYmxlcy5nZXQodCxlJiZlLmNvbnRleHQpfSxlLm9uPU50KChmdW5jdGlvbih0LGUsbil7aWYody5zdHJpbmcodCkmJi0xIT09dC5zZWFyY2goXCIgXCIpJiYodD10LnRyaW0oKS5zcGxpdCgvICsvKSksdy5hcnJheSh0KSl7Zm9yKHZhciByPTAsaT10O3I8aS5sZW5ndGg7cisrKXt2YXIgbz1pW3JdO3RoaXMub24obyxlLG4pfXJldHVybiB0aGlzfWlmKHcub2JqZWN0KHQpKXtmb3IodmFyIGEgaW4gdCl0aGlzLm9uKGEsdFthXSxlKTtyZXR1cm4gdGhpc31yZXR1cm4gdmUodCx0aGlzLnNjb3BlLmFjdGlvbnMpP3RoaXMuZ2xvYmFsRXZlbnRzW3RdP3RoaXMuZ2xvYmFsRXZlbnRzW3RdLnB1c2goZSk6dGhpcy5nbG9iYWxFdmVudHNbdF09W2VdOnRoaXMuc2NvcGUuZXZlbnRzLmFkZCh0aGlzLnNjb3BlLmRvY3VtZW50LHQsZSx7b3B0aW9uczpufSksdGhpc30pLFwiVGhlIGludGVyYWN0Lm9uKCkgbWV0aG9kIGlzIGJlaW5nIGRlcHJlY2F0ZWRcIiksZS5vZmY9TnQoKGZ1bmN0aW9uKHQsZSxuKXtpZih3LnN0cmluZyh0KSYmLTEhPT10LnNlYXJjaChcIiBcIikmJih0PXQudHJpbSgpLnNwbGl0KC8gKy8pKSx3LmFycmF5KHQpKXtmb3IodmFyIHI9MCxpPXQ7cjxpLmxlbmd0aDtyKyspe3ZhciBvPWlbcl07dGhpcy5vZmYobyxlLG4pfXJldHVybiB0aGlzfWlmKHcub2JqZWN0KHQpKXtmb3IodmFyIGEgaW4gdCl0aGlzLm9mZihhLHRbYV0sZSk7cmV0dXJuIHRoaXN9dmFyIHM7cmV0dXJuIHZlKHQsdGhpcy5zY29wZS5hY3Rpb25zKT90IGluIHRoaXMuZ2xvYmFsRXZlbnRzJiYtMSE9PShzPXRoaXMuZ2xvYmFsRXZlbnRzW3RdLmluZGV4T2YoZSkpJiZ0aGlzLmdsb2JhbEV2ZW50c1t0XS5zcGxpY2UocywxKTp0aGlzLnNjb3BlLmV2ZW50cy5yZW1vdmUodGhpcy5zY29wZS5kb2N1bWVudCx0LGUsbiksdGhpc30pLFwiVGhlIGludGVyYWN0Lm9mZigpIG1ldGhvZCBpcyBiZWluZyBkZXByZWNhdGVkXCIpLGUuZGVidWc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zY29wZX0sZS5zdXBwb3J0c1RvdWNoPWZ1bmN0aW9uKCl7cmV0dXJuIEkuc3VwcG9ydHNUb3VjaH0sZS5zdXBwb3J0c1BvaW50ZXJFdmVudD1mdW5jdGlvbigpe3JldHVybiBJLnN1cHBvcnRzUG9pbnRlckV2ZW50fSxlLnN0b3A9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MCxlPXRoaXMuc2NvcGUuaW50ZXJhY3Rpb25zLmxpc3Q7dDxlLmxlbmd0aDt0KyspZVt0XS5zdG9wKCk7cmV0dXJuIHRoaXN9LGUucG9pbnRlck1vdmVUb2xlcmFuY2U9ZnVuY3Rpb24odCl7cmV0dXJuIHcubnVtYmVyKHQpPyh0aGlzLnNjb3BlLmludGVyYWN0aW9ucy5wb2ludGVyTW92ZVRvbGVyYW5jZT10LHRoaXMpOnRoaXMuc2NvcGUuaW50ZXJhY3Rpb25zLnBvaW50ZXJNb3ZlVG9sZXJhbmNlfSxlLmFkZERvY3VtZW50PWZ1bmN0aW9uKHQsZSl7dGhpcy5zY29wZS5hZGREb2N1bWVudCh0LGUpfSxlLnJlbW92ZURvY3VtZW50PWZ1bmN0aW9uKHQpe3RoaXMuc2NvcGUucmVtb3ZlRG9jdW1lbnQodCl9LGV9KHRoaXMpLHRoaXMuSW50ZXJhY3RFdmVudD1TZSx0aGlzLkludGVyYWN0YWJsZT12b2lkIDAsdGhpcy5pbnRlcmFjdGFibGVzPW5ldyBhbih0aGlzKSx0aGlzLl93aW49dm9pZCAwLHRoaXMuZG9jdW1lbnQ9dm9pZCAwLHRoaXMud2luZG93PXZvaWQgMCx0aGlzLmRvY3VtZW50cz1bXSx0aGlzLl9wbHVnaW5zPXtsaXN0OltdLG1hcDp7fX0sdGhpcy5vbldpbmRvd1VubG9hZD1mdW5jdGlvbih0KXtyZXR1cm4gZS5yZW1vdmVEb2N1bWVudCh0LnRhcmdldCl9O3ZhciBuPXRoaXM7dGhpcy5JbnRlcmFjdGFibGU9ZnVuY3Rpb24odCl7cyhpLHQpO3ZhciBlPXAoaSk7ZnVuY3Rpb24gaSgpe3JldHVybiByKHRoaXMsaSksZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIG8oaSxbe2tleTpcIl9kZWZhdWx0c1wiLGdldDpmdW5jdGlvbigpe3JldHVybiBuLmRlZmF1bHRzfX0se2tleTpcInNldFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiBmKGMoaS5wcm90b3R5cGUpLFwic2V0XCIsdGhpcykuY2FsbCh0aGlzLHQpLG4uZmlyZShcImludGVyYWN0YWJsZTpzZXRcIix7b3B0aW9uczp0LGludGVyYWN0YWJsZTp0aGlzfSksdGhpc319LHtrZXk6XCJ1bnNldFwiLHZhbHVlOmZ1bmN0aW9uKCl7ZihjKGkucHJvdG90eXBlKSxcInVuc2V0XCIsdGhpcykuY2FsbCh0aGlzKTt2YXIgdD1uLmludGVyYWN0YWJsZXMubGlzdC5pbmRleE9mKHRoaXMpO3Q8MHx8KG4uaW50ZXJhY3RhYmxlcy5saXN0LnNwbGljZSh0LDEpLG4uZmlyZShcImludGVyYWN0YWJsZTp1bnNldFwiLHtpbnRlcmFjdGFibGU6dGhpc30pKX19XSksaX0ob24pfXJldHVybiBvKHQsW3trZXk6XCJhZGRMaXN0ZW5lcnNcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3RoaXMubGlzdGVuZXJNYXBzLnB1c2goe2lkOmUsbWFwOnR9KX19LHtrZXk6XCJmaXJlXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MCxyPXRoaXMubGlzdGVuZXJNYXBzO248ci5sZW5ndGg7bisrKXt2YXIgaT1yW25dLm1hcFt0XTtpZihpJiYhMT09PWkoZSx0aGlzLHQpKXJldHVybiExfX19LHtrZXk6XCJpbml0XCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaXNJbml0aWFsaXplZD90aGlzOmZ1bmN0aW9uKHQsZSl7dC5pc0luaXRpYWxpemVkPSEwLHcud2luZG93KGUpJiZtKGUpO3JldHVybiBrLmluaXQoZSksSS5pbml0KGUpLEx0LmluaXQoZSksdC53aW5kb3c9ZSx0LmRvY3VtZW50PWUuZG9jdW1lbnQsdC51c2VQbHVnaW4obm4pLHQudXNlUGx1Z2luKFVlKSx0fSh0aGlzLHQpfX0se2tleTpcInBsdWdpbklzSW5zdGFsbGVkXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dC5pZDtyZXR1cm4gZT8hIXRoaXMuX3BsdWdpbnMubWFwW2VdOi0xIT09dGhpcy5fcGx1Z2lucy5saXN0LmluZGV4T2YodCl9fSx7a2V5OlwidXNlUGx1Z2luXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtpZighdGhpcy5pc0luaXRpYWxpemVkKXJldHVybiB0aGlzO2lmKHRoaXMucGx1Z2luSXNJbnN0YWxsZWQodCkpcmV0dXJuIHRoaXM7aWYodC5pZCYmKHRoaXMuX3BsdWdpbnMubWFwW3QuaWRdPXQpLHRoaXMuX3BsdWdpbnMubGlzdC5wdXNoKHQpLHQuaW5zdGFsbCYmdC5pbnN0YWxsKHRoaXMsZSksdC5saXN0ZW5lcnMmJnQuYmVmb3JlKXtmb3IodmFyIG49MCxyPXRoaXMubGlzdGVuZXJNYXBzLmxlbmd0aCxpPXQuYmVmb3JlLnJlZHVjZSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdFtlXT0hMCx0W2NuKGUpXT0hMCx0fSkse30pO248cjtuKyspe3ZhciBvPXRoaXMubGlzdGVuZXJNYXBzW25dLmlkO2lmKG8mJihpW29dfHxpW2NuKG8pXSkpYnJlYWt9dGhpcy5saXN0ZW5lck1hcHMuc3BsaWNlKG4sMCx7aWQ6dC5pZCxtYXA6dC5saXN0ZW5lcnN9KX1lbHNlIHQubGlzdGVuZXJzJiZ0aGlzLmxpc3RlbmVyTWFwcy5wdXNoKHtpZDp0LmlkLG1hcDp0Lmxpc3RlbmVyc30pO3JldHVybiB0aGlzfX0se2tleTpcImFkZERvY3VtZW50XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtpZigtMSE9PXRoaXMuZ2V0RG9jSW5kZXgodCkpcmV0dXJuITE7dmFyIG49eSh0KTtlPWU/Vih7fSxlKTp7fSx0aGlzLmRvY3VtZW50cy5wdXNoKHtkb2M6dCxvcHRpb25zOmV9KSx0aGlzLmV2ZW50cy5kb2N1bWVudHMucHVzaCh0KSx0IT09dGhpcy5kb2N1bWVudCYmdGhpcy5ldmVudHMuYWRkKG4sXCJ1bmxvYWRcIix0aGlzLm9uV2luZG93VW5sb2FkKSx0aGlzLmZpcmUoXCJzY29wZTphZGQtZG9jdW1lbnRcIix7ZG9jOnQsd2luZG93Om4sc2NvcGU6dGhpcyxvcHRpb25zOmV9KX19LHtrZXk6XCJyZW1vdmVEb2N1bWVudFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0RG9jSW5kZXgodCksbj15KHQpLHI9dGhpcy5kb2N1bWVudHNbZV0ub3B0aW9uczt0aGlzLmV2ZW50cy5yZW1vdmUobixcInVubG9hZFwiLHRoaXMub25XaW5kb3dVbmxvYWQpLHRoaXMuZG9jdW1lbnRzLnNwbGljZShlLDEpLHRoaXMuZXZlbnRzLmRvY3VtZW50cy5zcGxpY2UoZSwxKSx0aGlzLmZpcmUoXCJzY29wZTpyZW1vdmUtZG9jdW1lbnRcIix7ZG9jOnQsd2luZG93Om4sc2NvcGU6dGhpcyxvcHRpb25zOnJ9KX19LHtrZXk6XCJnZXREb2NJbmRleFwiLHZhbHVlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dGhpcy5kb2N1bWVudHMubGVuZ3RoO2UrKylpZih0aGlzLmRvY3VtZW50c1tlXS5kb2M9PT10KXJldHVybiBlO3JldHVybi0xfX0se2tleTpcImdldERvY09wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmdldERvY0luZGV4KHQpO3JldHVybi0xPT09ZT9udWxsOnRoaXMuZG9jdW1lbnRzW2VdLm9wdGlvbnN9fSx7a2V5Olwibm93XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy53aW5kb3cuRGF0ZXx8RGF0ZSkubm93KCl9fV0pLHR9KCk7ZnVuY3Rpb24gY24odCl7cmV0dXJuIHQmJnQucmVwbGFjZSgvXFwvLiokLyxcIlwiKX12YXIgbG49bmV3IHNuLHVuPWxuLmludGVyYWN0U3RhdGljLHBuPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWxUaGlzP2dsb2JhbFRoaXM6d2luZG93O2xuLmluaXQocG4pO3ZhciBmbj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxlZGdlVGFyZ2V0OmZ1bmN0aW9uKCl7fSxlbGVtZW50czpmdW5jdGlvbigpe30sZ3JpZDpmdW5jdGlvbih0KXt2YXIgZT1bW1wieFwiLFwieVwiXSxbXCJsZWZ0XCIsXCJ0b3BcIl0sW1wicmlnaHRcIixcImJvdHRvbVwiXSxbXCJ3aWR0aFwiLFwiaGVpZ2h0XCJdXS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3ZhciBuPWVbMF0scj1lWzFdO3JldHVybiBuIGluIHR8fHIgaW4gdH0pKSxuPWZ1bmN0aW9uKG4scil7Zm9yKHZhciBpPXQucmFuZ2Usbz10LmxpbWl0cyxhPXZvaWQgMD09PW8/e2xlZnQ6LTEvMCxyaWdodDoxLzAsdG9wOi0xLzAsYm90dG9tOjEvMH06byxzPXQub2Zmc2V0LGM9dm9pZCAwPT09cz97eDowLHk6MH06cyxsPXtyYW5nZTppLGdyaWQ6dCx4Om51bGwseTpudWxsfSx1PTA7dTxlLmxlbmd0aDt1Kyspe3ZhciBwPWVbdV0sZj1wWzBdLGQ9cFsxXSxoPU1hdGgucm91bmQoKG4tYy54KS90W2ZdKSx2PU1hdGgucm91bmQoKHItYy55KS90W2RdKTtsW2ZdPU1hdGgubWF4KGEubGVmdCxNYXRoLm1pbihhLnJpZ2h0LGgqdFtmXStjLngpKSxsW2RdPU1hdGgubWF4KGEudG9wLE1hdGgubWluKGEuYm90dG9tLHYqdFtkXStjLnkpKX1yZXR1cm4gbH07cmV0dXJuIG4uZ3JpZD10LG4uY29vcmRGaWVsZHM9ZSxufX0pLGRuPXtpZDpcInNuYXBwZXJzXCIsaW5zdGFsbDpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0U3RhdGljO2Uuc25hcHBlcnM9VihlLnNuYXBwZXJzfHx7fSxmbiksZS5jcmVhdGVTbmFwR3JpZD1lLnNuYXBwZXJzLmdyaWR9fSxobj1kbix2bj17c3RhcnQ6ZnVuY3Rpb24odCl7dmFyIG49dC5zdGF0ZSxyPXQucmVjdCxpPXQuZWRnZXMsbz10LnBhZ2VDb29yZHMsYT1uLm9wdGlvbnMscz1hLnJhdGlvLGM9YS5lbmFibGVkLGw9bi5vcHRpb25zLHU9bC5lcXVhbERlbHRhLHA9bC5tb2RpZmllcnM7XCJwcmVzZXJ2ZVwiPT09cyYmKHM9ci53aWR0aC9yLmhlaWdodCksbi5zdGFydENvb3Jkcz1WKHt9LG8pLG4uc3RhcnRSZWN0PVYoe30sciksbi5yYXRpbz1zLG4uZXF1YWxEZWx0YT11O3ZhciBmPW4ubGlua2VkRWRnZXM9e3RvcDppLnRvcHx8aS5sZWZ0JiYhaS5ib3R0b20sbGVmdDppLmxlZnR8fGkudG9wJiYhaS5yaWdodCxib3R0b206aS5ib3R0b218fGkucmlnaHQmJiFpLnRvcCxyaWdodDppLnJpZ2h0fHxpLmJvdHRvbSYmIWkubGVmdH07aWYobi54SXNQcmltYXJ5QXhpcz0hKCFpLmxlZnQmJiFpLnJpZ2h0KSxuLmVxdWFsRGVsdGEpe3ZhciBkPShmLmxlZnQ/MTotMSkqKGYudG9wPzE6LTEpO24uZWRnZVNpZ249e3g6ZCx5OmR9fWVsc2Ugbi5lZGdlU2lnbj17eDpmLmxlZnQ/LTE6MSx5OmYudG9wPy0xOjF9O2lmKCExIT09YyYmVihpLGYpLG51bGwhPXAmJnAubGVuZ3RoKXt2YXIgaD1uZXcgbWUodC5pbnRlcmFjdGlvbik7aC5jb3B5RnJvbSh0LmludGVyYWN0aW9uLm1vZGlmaWNhdGlvbiksaC5wcmVwYXJlU3RhdGVzKHApLG4uc3ViTW9kaWZpY2F0aW9uPWgsaC5zdGFydEFsbChlKHt9LHQpKX19LHNldDpmdW5jdGlvbih0KXt2YXIgbj10LnN0YXRlLHI9dC5yZWN0LGk9dC5jb29yZHMsbz1uLmxpbmtlZEVkZ2VzLGE9Vih7fSxpKSxzPW4uZXF1YWxEZWx0YT9nbjptbjtpZihWKHQuZWRnZXMsbykscyhuLG4ueElzUHJpbWFyeUF4aXMsaSxyKSwhbi5zdWJNb2RpZmljYXRpb24pcmV0dXJuIG51bGw7dmFyIGM9Vih7fSxyKTtIKG8sYyx7eDppLngtYS54LHk6aS55LWEueX0pO3ZhciBsPW4uc3ViTW9kaWZpY2F0aW9uLnNldEFsbChlKGUoe30sdCkse30se3JlY3Q6YyxlZGdlczpvLHBhZ2VDb29yZHM6aSxwcmV2Q29vcmRzOmkscHJldlJlY3Q6Y30pKSx1PWwuZGVsdGE7bC5jaGFuZ2VkJiYocyhuLE1hdGguYWJzKHUueCk+TWF0aC5hYnModS55KSxsLmNvb3JkcyxsLnJlY3QpLFYoaSxsLmNvb3JkcykpO3JldHVybiBsLmV2ZW50UHJvcHN9LGRlZmF1bHRzOntyYXRpbzpcInByZXNlcnZlXCIsZXF1YWxEZWx0YTohMSxtb2RpZmllcnM6W10sZW5hYmxlZDohMX19O2Z1bmN0aW9uIGduKHQsZSxuKXt2YXIgcj10LnN0YXJ0Q29vcmRzLGk9dC5lZGdlU2lnbjtlP24ueT1yLnkrKG4ueC1yLngpKmkueTpuLng9ci54KyhuLnktci55KSppLnh9ZnVuY3Rpb24gbW4odCxlLG4scil7dmFyIGk9dC5zdGFydFJlY3Qsbz10LnN0YXJ0Q29vcmRzLGE9dC5yYXRpbyxzPXQuZWRnZVNpZ247aWYoZSl7dmFyIGM9ci53aWR0aC9hO24ueT1vLnkrKGMtaS5oZWlnaHQpKnMueX1lbHNle3ZhciBsPXIuaGVpZ2h0KmE7bi54PW8ueCsobC1pLndpZHRoKSpzLnh9fXZhciB5bj1iZSh2bixcImFzcGVjdFJhdGlvXCIpLGJuPWZ1bmN0aW9uKCl7fTtibi5fZGVmYXVsdHM9e307dmFyIHhuPWJuO2Z1bmN0aW9uIHduKHQsZSxuKXtyZXR1cm4gdy5mdW5jKHQpP0codCxlLmludGVyYWN0YWJsZSxlLmVsZW1lbnQsW24ueCxuLnksZV0pOkcodCxlLmludGVyYWN0YWJsZSxlLmVsZW1lbnQpfXZhciBFbj17c3RhcnQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5yZWN0LG49dC5zdGFydE9mZnNldCxyPXQuc3RhdGUsaT10LmludGVyYWN0aW9uLG89dC5wYWdlQ29vcmRzLGE9ci5vcHRpb25zLHM9YS5lbGVtZW50UmVjdCxjPVYoe2xlZnQ6MCx0b3A6MCxyaWdodDowLGJvdHRvbTowfSxhLm9mZnNldHx8e30pO2lmKGUmJnMpe3ZhciBsPXduKGEucmVzdHJpY3Rpb24saSxvKTtpZihsKXt2YXIgdT1sLnJpZ2h0LWwubGVmdC1lLndpZHRoLHA9bC5ib3R0b20tbC50b3AtZS5oZWlnaHQ7dTwwJiYoYy5sZWZ0Kz11LGMucmlnaHQrPXUpLHA8MCYmKGMudG9wKz1wLGMuYm90dG9tKz1wKX1jLmxlZnQrPW4ubGVmdC1lLndpZHRoKnMubGVmdCxjLnRvcCs9bi50b3AtZS5oZWlnaHQqcy50b3AsYy5yaWdodCs9bi5yaWdodC1lLndpZHRoKigxLXMucmlnaHQpLGMuYm90dG9tKz1uLmJvdHRvbS1lLmhlaWdodCooMS1zLmJvdHRvbSl9ci5vZmZzZXQ9Y30sc2V0OmZ1bmN0aW9uKHQpe3ZhciBlPXQuY29vcmRzLG49dC5pbnRlcmFjdGlvbixyPXQuc3RhdGUsaT1yLm9wdGlvbnMsbz1yLm9mZnNldCxhPXduKGkucmVzdHJpY3Rpb24sbixlKTtpZihhKXt2YXIgcz1mdW5jdGlvbih0KXtyZXR1cm4hdHx8XCJsZWZ0XCJpbiB0JiZcInRvcFwiaW4gdHx8KCh0PVYoe30sdCkpLmxlZnQ9dC54fHwwLHQudG9wPXQueXx8MCx0LnJpZ2h0PXQucmlnaHR8fHQubGVmdCt0LndpZHRoLHQuYm90dG9tPXQuYm90dG9tfHx0LnRvcCt0LmhlaWdodCksdH0oYSk7ZS54PU1hdGgubWF4KE1hdGgubWluKHMucmlnaHQtby5yaWdodCxlLngpLHMubGVmdCtvLmxlZnQpLGUueT1NYXRoLm1heChNYXRoLm1pbihzLmJvdHRvbS1vLmJvdHRvbSxlLnkpLHMudG9wK28udG9wKX19LGRlZmF1bHRzOntyZXN0cmljdGlvbjpudWxsLGVsZW1lbnRSZWN0Om51bGwsb2Zmc2V0Om51bGwsZW5kT25seTohMSxlbmFibGVkOiExfX0sVG49YmUoRW4sXCJyZXN0cmljdFwiKSxTbj17dG9wOjEvMCxsZWZ0OjEvMCxib3R0b206LTEvMCxyaWdodDotMS8wfSxfbj17dG9wOi0xLzAsbGVmdDotMS8wLGJvdHRvbToxLzAscmlnaHQ6MS8wfTtmdW5jdGlvbiBQbih0LGUpe2Zvcih2YXIgbj0wLHI9W1widG9wXCIsXCJsZWZ0XCIsXCJib3R0b21cIixcInJpZ2h0XCJdO248ci5sZW5ndGg7bisrKXt2YXIgaT1yW25dO2kgaW4gdHx8KHRbaV09ZVtpXSl9cmV0dXJuIHR9dmFyIE9uPXtub0lubmVyOlNuLG5vT3V0ZXI6X24sc3RhcnQ6ZnVuY3Rpb24odCl7dmFyIGUsbj10LmludGVyYWN0aW9uLHI9dC5zdGFydE9mZnNldCxpPXQuc3RhdGUsbz1pLm9wdGlvbnM7byYmKGU9Tih3bihvLm9mZnNldCxuLG4uY29vcmRzLnN0YXJ0LnBhZ2UpKSksZT1lfHx7eDowLHk6MH0saS5vZmZzZXQ9e3RvcDplLnkrci50b3AsbGVmdDplLngrci5sZWZ0LGJvdHRvbTplLnktci5ib3R0b20scmlnaHQ6ZS54LXIucmlnaHR9fSxzZXQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5jb29yZHMsbj10LmVkZ2VzLHI9dC5pbnRlcmFjdGlvbixpPXQuc3RhdGUsbz1pLm9mZnNldCxhPWkub3B0aW9ucztpZihuKXt2YXIgcz1WKHt9LGUpLGM9d24oYS5pbm5lcixyLHMpfHx7fSxsPXduKGEub3V0ZXIscixzKXx8e307UG4oYyxTbiksUG4obCxfbiksbi50b3A/ZS55PU1hdGgubWluKE1hdGgubWF4KGwudG9wK28udG9wLHMueSksYy50b3Arby50b3ApOm4uYm90dG9tJiYoZS55PU1hdGgubWF4KE1hdGgubWluKGwuYm90dG9tK28uYm90dG9tLHMueSksYy5ib3R0b20rby5ib3R0b20pKSxuLmxlZnQ/ZS54PU1hdGgubWluKE1hdGgubWF4KGwubGVmdCtvLmxlZnQscy54KSxjLmxlZnQrby5sZWZ0KTpuLnJpZ2h0JiYoZS54PU1hdGgubWF4KE1hdGgubWluKGwucmlnaHQrby5yaWdodCxzLngpLGMucmlnaHQrby5yaWdodCkpfX0sZGVmYXVsdHM6e2lubmVyOm51bGwsb3V0ZXI6bnVsbCxvZmZzZXQ6bnVsbCxlbmRPbmx5OiExLGVuYWJsZWQ6ITF9fSxrbj1iZShPbixcInJlc3RyaWN0RWRnZXNcIiksRG49Vih7Z2V0IGVsZW1lbnRSZWN0KCl7cmV0dXJue3RvcDowLGxlZnQ6MCxib3R0b206MSxyaWdodDoxfX0sc2V0IGVsZW1lbnRSZWN0KHQpe319LEVuLmRlZmF1bHRzKSxJbj1iZSh7c3RhcnQ6RW4uc3RhcnQsc2V0OkVuLnNldCxkZWZhdWx0czpEbn0sXCJyZXN0cmljdFJlY3RcIiksTW49e3dpZHRoOi0xLzAsaGVpZ2h0Oi0xLzB9LHpuPXt3aWR0aDoxLzAsaGVpZ2h0OjEvMH07dmFyIEFuPWJlKHtzdGFydDpmdW5jdGlvbih0KXtyZXR1cm4gT24uc3RhcnQodCl9LHNldDpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uLG49dC5zdGF0ZSxyPXQucmVjdCxpPXQuZWRnZXMsbz1uLm9wdGlvbnM7aWYoaSl7dmFyIGE9VSh3bihvLm1pbixlLHQuY29vcmRzKSl8fE1uLHM9VSh3bihvLm1heCxlLHQuY29vcmRzKSl8fHpuO24ub3B0aW9ucz17ZW5kT25seTpvLmVuZE9ubHksaW5uZXI6Vih7fSxPbi5ub0lubmVyKSxvdXRlcjpWKHt9LE9uLm5vT3V0ZXIpfSxpLnRvcD8obi5vcHRpb25zLmlubmVyLnRvcD1yLmJvdHRvbS1hLmhlaWdodCxuLm9wdGlvbnMub3V0ZXIudG9wPXIuYm90dG9tLXMuaGVpZ2h0KTppLmJvdHRvbSYmKG4ub3B0aW9ucy5pbm5lci5ib3R0b209ci50b3ArYS5oZWlnaHQsbi5vcHRpb25zLm91dGVyLmJvdHRvbT1yLnRvcCtzLmhlaWdodCksaS5sZWZ0PyhuLm9wdGlvbnMuaW5uZXIubGVmdD1yLnJpZ2h0LWEud2lkdGgsbi5vcHRpb25zLm91dGVyLmxlZnQ9ci5yaWdodC1zLndpZHRoKTppLnJpZ2h0JiYobi5vcHRpb25zLmlubmVyLnJpZ2h0PXIubGVmdCthLndpZHRoLG4ub3B0aW9ucy5vdXRlci5yaWdodD1yLmxlZnQrcy53aWR0aCksT24uc2V0KHQpLG4ub3B0aW9ucz1vfX0sZGVmYXVsdHM6e21pbjpudWxsLG1heDpudWxsLGVuZE9ubHk6ITEsZW5hYmxlZDohMX19LFwicmVzdHJpY3RTaXplXCIpO3ZhciBSbj17c3RhcnQ6ZnVuY3Rpb24odCl7dmFyIGUsbj10LmludGVyYWN0aW9uLHI9dC5pbnRlcmFjdGFibGUsaT10LmVsZW1lbnQsbz10LnJlY3QsYT10LnN0YXRlLHM9dC5zdGFydE9mZnNldCxjPWEub3B0aW9ucyxsPWMub2Zmc2V0V2l0aE9yaWdpbj9mdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uLmVsZW1lbnQsbj1OKEcodC5zdGF0ZS5vcHRpb25zLm9yaWdpbixudWxsLG51bGwsW2VdKSkscj1ufHxLKHQuaW50ZXJhY3RhYmxlLGUsdC5pbnRlcmFjdGlvbi5wcmVwYXJlZC5uYW1lKTtyZXR1cm4gcn0odCk6e3g6MCx5OjB9O2lmKFwic3RhcnRDb29yZHNcIj09PWMub2Zmc2V0KWU9e3g6bi5jb29yZHMuc3RhcnQucGFnZS54LHk6bi5jb29yZHMuc3RhcnQucGFnZS55fTtlbHNle3ZhciB1PUcoYy5vZmZzZXQscixpLFtuXSk7KGU9Tih1KXx8e3g6MCx5OjB9KS54Kz1sLngsZS55Kz1sLnl9dmFyIHA9Yy5yZWxhdGl2ZVBvaW50czthLm9mZnNldHM9byYmcCYmcC5sZW5ndGg/cC5tYXAoKGZ1bmN0aW9uKHQsbil7cmV0dXJue2luZGV4Om4scmVsYXRpdmVQb2ludDp0LHg6cy5sZWZ0LW8ud2lkdGgqdC54K2UueCx5OnMudG9wLW8uaGVpZ2h0KnQueStlLnl9fSkpOlt7aW5kZXg6MCxyZWxhdGl2ZVBvaW50Om51bGwseDplLngseTplLnl9XX0sc2V0OmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24sbj10LmNvb3JkcyxyPXQuc3RhdGUsaT1yLm9wdGlvbnMsbz1yLm9mZnNldHMsYT1LKGUuaW50ZXJhY3RhYmxlLGUuZWxlbWVudCxlLnByZXBhcmVkLm5hbWUpLHM9Vih7fSxuKSxjPVtdO2kub2Zmc2V0V2l0aE9yaWdpbnx8KHMueC09YS54LHMueS09YS55KTtmb3IodmFyIGw9MCx1PW87bDx1Lmxlbmd0aDtsKyspZm9yKHZhciBwPXVbbF0sZj1zLngtcC54LGQ9cy55LXAueSxoPTAsdj1pLnRhcmdldHMubGVuZ3RoO2g8djtoKyspe3ZhciBnPWkudGFyZ2V0c1toXSxtPXZvaWQgMDsobT13LmZ1bmMoZyk/ZyhmLGQsZS5fcHJveHkscCxoKTpnKSYmYy5wdXNoKHt4Oih3Lm51bWJlcihtLngpP20ueDpmKStwLngseToody5udW1iZXIobS55KT9tLnk6ZCkrcC55LHJhbmdlOncubnVtYmVyKG0ucmFuZ2UpP20ucmFuZ2U6aS5yYW5nZSxzb3VyY2U6ZyxpbmRleDpoLG9mZnNldDpwfSl9Zm9yKHZhciB5PXt0YXJnZXQ6bnVsbCxpblJhbmdlOiExLGRpc3RhbmNlOjAscmFuZ2U6MCxkZWx0YTp7eDowLHk6MH19LGI9MDtiPGMubGVuZ3RoO2IrKyl7dmFyIHg9Y1tiXSxFPXgucmFuZ2UsVD14Lngtcy54LFM9eC55LXMueSxfPVEoVCxTKSxQPV88PUU7RT09PTEvMCYmeS5pblJhbmdlJiZ5LnJhbmdlIT09MS8wJiYoUD0hMSkseS50YXJnZXQmJiEoUD95LmluUmFuZ2UmJkUhPT0xLzA/Xy9FPHkuZGlzdGFuY2UveS5yYW5nZTpFPT09MS8wJiZ5LnJhbmdlIT09MS8wfHxfPHkuZGlzdGFuY2U6IXkuaW5SYW5nZSYmXzx5LmRpc3RhbmNlKXx8KHkudGFyZ2V0PXgseS5kaXN0YW5jZT1fLHkucmFuZ2U9RSx5LmluUmFuZ2U9UCx5LmRlbHRhLng9VCx5LmRlbHRhLnk9Uyl9cmV0dXJuIHkuaW5SYW5nZSYmKG4ueD15LnRhcmdldC54LG4ueT15LnRhcmdldC55KSxyLmNsb3Nlc3Q9eSx5fSxkZWZhdWx0czp7cmFuZ2U6MS8wLHRhcmdldHM6bnVsbCxvZmZzZXQ6bnVsbCxvZmZzZXRXaXRoT3JpZ2luOiEwLG9yaWdpbjpudWxsLHJlbGF0aXZlUG9pbnRzOm51bGwsZW5kT25seTohMSxlbmFibGVkOiExfX0sQ249YmUoUm4sXCJzbmFwXCIpO3ZhciBqbj17c3RhcnQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5zdGF0ZSxuPXQuZWRnZXMscj1lLm9wdGlvbnM7aWYoIW4pcmV0dXJuIG51bGw7dC5zdGF0ZT17b3B0aW9uczp7dGFyZ2V0czpudWxsLHJlbGF0aXZlUG9pbnRzOlt7eDpuLmxlZnQ/MDoxLHk6bi50b3A/MDoxfV0sb2Zmc2V0OnIub2Zmc2V0fHxcInNlbGZcIixvcmlnaW46e3g6MCx5OjB9LHJhbmdlOnIucmFuZ2V9fSxlLnRhcmdldEZpZWxkcz1lLnRhcmdldEZpZWxkc3x8W1tcIndpZHRoXCIsXCJoZWlnaHRcIl0sW1wieFwiLFwieVwiXV0sUm4uc3RhcnQodCksZS5vZmZzZXRzPXQuc3RhdGUub2Zmc2V0cyx0LnN0YXRlPWV9LHNldDpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uLG49dC5zdGF0ZSxyPXQuY29vcmRzLGk9bi5vcHRpb25zLG89bi5vZmZzZXRzLGE9e3g6ci54LW9bMF0ueCx5OnIueS1vWzBdLnl9O24ub3B0aW9ucz1WKHt9LGkpLG4ub3B0aW9ucy50YXJnZXRzPVtdO2Zvcih2YXIgcz0wLGM9aS50YXJnZXRzfHxbXTtzPGMubGVuZ3RoO3MrKyl7dmFyIGw9Y1tzXSx1PXZvaWQgMDtpZih1PXcuZnVuYyhsKT9sKGEueCxhLnksZSk6bCl7Zm9yKHZhciBwPTAsZj1uLnRhcmdldEZpZWxkcztwPGYubGVuZ3RoO3ArKyl7dmFyIGQ9ZltwXSxoPWRbMF0sdj1kWzFdO2lmKGggaW4gdXx8diBpbiB1KXt1Lng9dVtoXSx1Lnk9dVt2XTticmVha319bi5vcHRpb25zLnRhcmdldHMucHVzaCh1KX19dmFyIGc9Um4uc2V0KHQpO3JldHVybiBuLm9wdGlvbnM9aSxnfSxkZWZhdWx0czp7cmFuZ2U6MS8wLHRhcmdldHM6bnVsbCxvZmZzZXQ6bnVsbCxlbmRPbmx5OiExLGVuYWJsZWQ6ITF9fSxGbj1iZShqbixcInNuYXBTaXplXCIpO3ZhciBYbj17YXNwZWN0UmF0aW86eW4scmVzdHJpY3RFZGdlczprbixyZXN0cmljdDpUbixyZXN0cmljdFJlY3Q6SW4scmVzdHJpY3RTaXplOkFuLHNuYXBFZGdlczpiZSh7c3RhcnQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5lZGdlcztyZXR1cm4gZT8odC5zdGF0ZS50YXJnZXRGaWVsZHM9dC5zdGF0ZS50YXJnZXRGaWVsZHN8fFtbZS5sZWZ0P1wibGVmdFwiOlwicmlnaHRcIixlLnRvcD9cInRvcFwiOlwiYm90dG9tXCJdXSxqbi5zdGFydCh0KSk6bnVsbH0sc2V0OmpuLnNldCxkZWZhdWx0czpWKGdlKGpuLmRlZmF1bHRzKSx7dGFyZ2V0czp2b2lkIDAscmFuZ2U6dm9pZCAwLG9mZnNldDp7eDowLHk6MH19KX0sXCJzbmFwRWRnZXNcIiksc25hcDpDbixzbmFwU2l6ZTpGbixzcHJpbmc6eG4sYXZvaWQ6eG4sdHJhbnNmb3JtOnhuLHJ1YmJlcmJhbmQ6eG59LFluPXtpZDpcIm1vZGlmaWVyc1wiLGluc3RhbGw6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdFN0YXRpYztmb3IodmFyIG4gaW4gdC51c2VQbHVnaW4oRWUpLHQudXNlUGx1Z2luKGhuKSxlLm1vZGlmaWVycz1YbixYbil7dmFyIHI9WG5bbl0saT1yLl9kZWZhdWx0cyxvPXIuX21ldGhvZHM7aS5fbWV0aG9kcz1vLHQuZGVmYXVsdHMucGVyQWN0aW9uW25dPWl9fX0sTG49WW4scW49ZnVuY3Rpb24odCl7cyhuLHQpO3ZhciBlPXAobik7ZnVuY3Rpb24gbih0LGksbyxhLHMsYyl7dmFyIGw7aWYocih0aGlzLG4pLHR0KHUobD1lLmNhbGwodGhpcyxzKSksbyksbyE9PWkmJnR0KHUobCksaSksbC50aW1lU3RhbXA9YyxsLm9yaWdpbmFsRXZlbnQ9byxsLnR5cGU9dCxsLnBvaW50ZXJJZD1hdChpKSxsLnBvaW50ZXJUeXBlPWR0KGkpLGwudGFyZ2V0PWEsbC5jdXJyZW50VGFyZ2V0PW51bGwsXCJ0YXBcIj09PXQpe3ZhciBwPXMuZ2V0UG9pbnRlckluZGV4KGkpO2wuZHQ9bC50aW1lU3RhbXAtcy5wb2ludGVyc1twXS5kb3duVGltZTt2YXIgZj1sLnRpbWVTdGFtcC1zLnRhcFRpbWU7bC5kb3VibGU9ISFzLnByZXZUYXAmJlwiZG91YmxldGFwXCIhPT1zLnByZXZUYXAudHlwZSYmcy5wcmV2VGFwLnRhcmdldD09PWwudGFyZ2V0JiZmPDUwMH1lbHNlXCJkb3VibGV0YXBcIj09PXQmJihsLmR0PWkudGltZVN0YW1wLXMudGFwVGltZSxsLmRvdWJsZT0hMCk7cmV0dXJuIGx9cmV0dXJuIG8obixbe2tleTpcIl9zdWJ0cmFjdE9yaWdpblwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXQueCxuPXQueTtyZXR1cm4gdGhpcy5wYWdlWC09ZSx0aGlzLnBhZ2VZLT1uLHRoaXMuY2xpZW50WC09ZSx0aGlzLmNsaWVudFktPW4sdGhpc319LHtrZXk6XCJfYWRkT3JpZ2luXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dC54LG49dC55O3JldHVybiB0aGlzLnBhZ2VYKz1lLHRoaXMucGFnZVkrPW4sdGhpcy5jbGllbnRYKz1lLHRoaXMuY2xpZW50WSs9bix0aGlzfX0se2tleTpcInByZXZlbnREZWZhdWx0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLm9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKX19XSksbn0odnQpLEJuPXtpZDpcInBvaW50ZXItZXZlbnRzL2Jhc2VcIixiZWZvcmU6W1wiaW5lcnRpYVwiLFwibW9kaWZpZXJzXCIsXCJhdXRvLXN0YXJ0XCIsXCJhY3Rpb25zXCJdLGluc3RhbGw6ZnVuY3Rpb24odCl7dC5wb2ludGVyRXZlbnRzPUJuLHQuZGVmYXVsdHMuYWN0aW9ucy5wb2ludGVyRXZlbnRzPUJuLmRlZmF1bHRzLFYodC5hY3Rpb25zLnBoYXNlbGVzc1R5cGVzLEJuLnR5cGVzKX0sbGlzdGVuZXJzOntcImludGVyYWN0aW9uczpuZXdcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uO2UucHJldlRhcD1udWxsLGUudGFwVGltZT0wfSxcImludGVyYWN0aW9uczp1cGRhdGUtcG9pbnRlclwiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZG93bixuPXQucG9pbnRlckluZm87aWYoIWUmJm4uaG9sZClyZXR1cm47bi5ob2xkPXtkdXJhdGlvbjoxLzAsdGltZW91dDpudWxsfX0sXCJpbnRlcmFjdGlvbnM6bW92ZVwiOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5pbnRlcmFjdGlvbixyPXQucG9pbnRlcixpPXQuZXZlbnQsbz10LmV2ZW50VGFyZ2V0O3QuZHVwbGljYXRlfHxuLnBvaW50ZXJJc0Rvd24mJiFuLnBvaW50ZXJXYXNNb3ZlZHx8KG4ucG9pbnRlcklzRG93biYmR24odCksVm4oe2ludGVyYWN0aW9uOm4scG9pbnRlcjpyLGV2ZW50OmksZXZlbnRUYXJnZXQ6byx0eXBlOlwibW92ZVwifSxlKSl9LFwiaW50ZXJhY3Rpb25zOmRvd25cIjpmdW5jdGlvbih0LGUpeyFmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10LmludGVyYWN0aW9uLHI9dC5wb2ludGVyLGk9dC5ldmVudCxvPXQuZXZlbnRUYXJnZXQsYT10LnBvaW50ZXJJbmRleCxzPW4ucG9pbnRlcnNbYV0uaG9sZCxjPXEobyksbD17aW50ZXJhY3Rpb246bixwb2ludGVyOnIsZXZlbnQ6aSxldmVudFRhcmdldDpvLHR5cGU6XCJob2xkXCIsdGFyZ2V0czpbXSxwYXRoOmMsbm9kZTpudWxsfSx1PTA7dTxjLmxlbmd0aDt1Kyspe3ZhciBwPWNbdV07bC5ub2RlPXAsZS5maXJlKFwicG9pbnRlckV2ZW50czpjb2xsZWN0LXRhcmdldHNcIixsKX1pZighbC50YXJnZXRzLmxlbmd0aClyZXR1cm47Zm9yKHZhciBmPTEvMCxkPTAsaD1sLnRhcmdldHM7ZDxoLmxlbmd0aDtkKyspe3ZhciB2PWhbZF0uZXZlbnRhYmxlLm9wdGlvbnMuaG9sZER1cmF0aW9uO3Y8ZiYmKGY9dil9cy5kdXJhdGlvbj1mLHMudGltZW91dD1zZXRUaW1lb3V0KChmdW5jdGlvbigpe1ZuKHtpbnRlcmFjdGlvbjpuLGV2ZW50VGFyZ2V0Om8scG9pbnRlcjpyLGV2ZW50OmksdHlwZTpcImhvbGRcIn0sZSl9KSxmKX0odCxlKSxWbih0LGUpfSxcImludGVyYWN0aW9uczp1cFwiOmZ1bmN0aW9uKHQsZSl7R24odCksVm4odCxlKSxmdW5jdGlvbih0LGUpe3ZhciBuPXQuaW50ZXJhY3Rpb24scj10LnBvaW50ZXIsaT10LmV2ZW50LG89dC5ldmVudFRhcmdldDtuLnBvaW50ZXJXYXNNb3ZlZHx8Vm4oe2ludGVyYWN0aW9uOm4sZXZlbnRUYXJnZXQ6byxwb2ludGVyOnIsZXZlbnQ6aSx0eXBlOlwidGFwXCJ9LGUpfSh0LGUpfSxcImludGVyYWN0aW9uczpjYW5jZWxcIjpmdW5jdGlvbih0LGUpe0duKHQpLFZuKHQsZSl9fSxQb2ludGVyRXZlbnQ6cW4sZmlyZTpWbixjb2xsZWN0RXZlbnRUYXJnZXRzOlduLGRlZmF1bHRzOntob2xkRHVyYXRpb246NjAwLGlnbm9yZUZyb206bnVsbCxhbGxvd0Zyb206bnVsbCxvcmlnaW46e3g6MCx5OjB9fSx0eXBlczp7ZG93bjohMCxtb3ZlOiEwLHVwOiEwLGNhbmNlbDohMCx0YXA6ITAsZG91YmxldGFwOiEwLGhvbGQ6ITB9fTtmdW5jdGlvbiBWbih0LGUpe3ZhciBuPXQuaW50ZXJhY3Rpb24scj10LnBvaW50ZXIsaT10LmV2ZW50LG89dC5ldmVudFRhcmdldCxhPXQudHlwZSxzPXQudGFyZ2V0cyxjPXZvaWQgMD09PXM/V24odCxlKTpzLGw9bmV3IHFuKGEscixpLG8sbixlLm5vdygpKTtlLmZpcmUoXCJwb2ludGVyRXZlbnRzOm5ld1wiLHtwb2ludGVyRXZlbnQ6bH0pO2Zvcih2YXIgdT17aW50ZXJhY3Rpb246bixwb2ludGVyOnIsZXZlbnQ6aSxldmVudFRhcmdldDpvLHRhcmdldHM6Yyx0eXBlOmEscG9pbnRlckV2ZW50Omx9LHA9MDtwPGMubGVuZ3RoO3ArKyl7dmFyIGY9Y1twXTtmb3IodmFyIGQgaW4gZi5wcm9wc3x8e30pbFtkXT1mLnByb3BzW2RdO3ZhciBoPUsoZi5ldmVudGFibGUsZi5ub2RlKTtpZihsLl9zdWJ0cmFjdE9yaWdpbihoKSxsLmV2ZW50YWJsZT1mLmV2ZW50YWJsZSxsLmN1cnJlbnRUYXJnZXQ9Zi5ub2RlLGYuZXZlbnRhYmxlLmZpcmUobCksbC5fYWRkT3JpZ2luKGgpLGwuaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkfHxsLnByb3BhZ2F0aW9uU3RvcHBlZCYmcCsxPGMubGVuZ3RoJiZjW3ArMV0ubm9kZSE9PWwuY3VycmVudFRhcmdldClicmVha31pZihlLmZpcmUoXCJwb2ludGVyRXZlbnRzOmZpcmVkXCIsdSksXCJ0YXBcIj09PWEpe3ZhciB2PWwuZG91YmxlP1ZuKHtpbnRlcmFjdGlvbjpuLHBvaW50ZXI6cixldmVudDppLGV2ZW50VGFyZ2V0Om8sdHlwZTpcImRvdWJsZXRhcFwifSxlKTpsO24ucHJldlRhcD12LG4udGFwVGltZT12LnRpbWVTdGFtcH1yZXR1cm4gbH1mdW5jdGlvbiBXbih0LGUpe3ZhciBuPXQuaW50ZXJhY3Rpb24scj10LnBvaW50ZXIsaT10LmV2ZW50LG89dC5ldmVudFRhcmdldCxhPXQudHlwZSxzPW4uZ2V0UG9pbnRlckluZGV4KHIpLGM9bi5wb2ludGVyc1tzXTtpZihcInRhcFwiPT09YSYmKG4ucG9pbnRlcldhc01vdmVkfHwhY3x8Yy5kb3duVGFyZ2V0IT09bykpcmV0dXJuW107Zm9yKHZhciBsPXEobyksdT17aW50ZXJhY3Rpb246bixwb2ludGVyOnIsZXZlbnQ6aSxldmVudFRhcmdldDpvLHR5cGU6YSxwYXRoOmwsdGFyZ2V0czpbXSxub2RlOm51bGx9LHA9MDtwPGwubGVuZ3RoO3ArKyl7dmFyIGY9bFtwXTt1Lm5vZGU9ZixlLmZpcmUoXCJwb2ludGVyRXZlbnRzOmNvbGxlY3QtdGFyZ2V0c1wiLHUpfXJldHVyblwiaG9sZFwiPT09YSYmKHUudGFyZ2V0cz11LnRhcmdldHMuZmlsdGVyKChmdW5jdGlvbih0KXt2YXIgZSxyO3JldHVybiB0LmV2ZW50YWJsZS5vcHRpb25zLmhvbGREdXJhdGlvbj09PShudWxsPT0oZT1uLnBvaW50ZXJzW3NdKXx8bnVsbD09KHI9ZS5ob2xkKT92b2lkIDA6ci5kdXJhdGlvbil9KSkpLHUudGFyZ2V0c31mdW5jdGlvbiBHbih0KXt2YXIgZT10LmludGVyYWN0aW9uLG49dC5wb2ludGVySW5kZXgscj1lLnBvaW50ZXJzW25dLmhvbGQ7ciYmci50aW1lb3V0JiYoY2xlYXJUaW1lb3V0KHIudGltZW91dCksci50aW1lb3V0PW51bGwpfXZhciBObj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxkZWZhdWx0OkJufSk7ZnVuY3Rpb24gVW4odCl7dmFyIGU9dC5pbnRlcmFjdGlvbjtlLmhvbGRJbnRlcnZhbEhhbmRsZSYmKGNsZWFySW50ZXJ2YWwoZS5ob2xkSW50ZXJ2YWxIYW5kbGUpLGUuaG9sZEludGVydmFsSGFuZGxlPW51bGwpfXZhciBIbj17aWQ6XCJwb2ludGVyLWV2ZW50cy9ob2xkUmVwZWF0XCIsaW5zdGFsbDpmdW5jdGlvbih0KXt0LnVzZVBsdWdpbihCbik7dmFyIGU9dC5wb2ludGVyRXZlbnRzO2UuZGVmYXVsdHMuaG9sZFJlcGVhdEludGVydmFsPTAsZS50eXBlcy5ob2xkcmVwZWF0PXQuYWN0aW9ucy5waGFzZWxlc3NUeXBlcy5ob2xkcmVwZWF0PSEwfSxsaXN0ZW5lcnM6W1wibW92ZVwiLFwidXBcIixcImNhbmNlbFwiLFwiZW5kYWxsXCJdLnJlZHVjZSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdFtcInBvaW50ZXJFdmVudHM6XCIuY29uY2F0KGUpXT1Vbix0fSkse1wicG9pbnRlckV2ZW50czpuZXdcIjpmdW5jdGlvbih0KXt2YXIgZT10LnBvaW50ZXJFdmVudDtcImhvbGRcIj09PWUudHlwZSYmKGUuY291bnQ9KGUuY291bnR8fDApKzEpfSxcInBvaW50ZXJFdmVudHM6ZmlyZWRcIjpmdW5jdGlvbih0LGUpe3ZhciBuPXQuaW50ZXJhY3Rpb24scj10LnBvaW50ZXJFdmVudCxpPXQuZXZlbnRUYXJnZXQsbz10LnRhcmdldHM7aWYoXCJob2xkXCI9PT1yLnR5cGUmJm8ubGVuZ3RoKXt2YXIgYT1vWzBdLmV2ZW50YWJsZS5vcHRpb25zLmhvbGRSZXBlYXRJbnRlcnZhbDthPD0wfHwobi5ob2xkSW50ZXJ2YWxIYW5kbGU9c2V0VGltZW91dCgoZnVuY3Rpb24oKXtlLnBvaW50ZXJFdmVudHMuZmlyZSh7aW50ZXJhY3Rpb246bixldmVudFRhcmdldDppLHR5cGU6XCJob2xkXCIscG9pbnRlcjpyLGV2ZW50OnJ9LGUpfSksYSkpfX19KX0sS249SG47dmFyICRuPXtpZDpcInBvaW50ZXItZXZlbnRzL2ludGVyYWN0YWJsZVRhcmdldHNcIixpbnN0YWxsOmZ1bmN0aW9uKHQpe3ZhciBlPXQuSW50ZXJhY3RhYmxlO2UucHJvdG90eXBlLnBvaW50ZXJFdmVudHM9ZnVuY3Rpb24odCl7cmV0dXJuIFYodGhpcy5ldmVudHMub3B0aW9ucyx0KSx0aGlzfTt2YXIgbj1lLnByb3RvdHlwZS5fYmFja0NvbXBhdE9wdGlvbjtlLnByb3RvdHlwZS5fYmFja0NvbXBhdE9wdGlvbj1mdW5jdGlvbih0LGUpe3ZhciByPW4uY2FsbCh0aGlzLHQsZSk7cmV0dXJuIHI9PT10aGlzJiYodGhpcy5ldmVudHMub3B0aW9uc1t0XT1lKSxyfX0sbGlzdGVuZXJzOntcInBvaW50ZXJFdmVudHM6Y29sbGVjdC10YXJnZXRzXCI6ZnVuY3Rpb24odCxlKXt2YXIgbj10LnRhcmdldHMscj10Lm5vZGUsaT10LnR5cGUsbz10LmV2ZW50VGFyZ2V0O2UuaW50ZXJhY3RhYmxlcy5mb3JFYWNoTWF0Y2gociwoZnVuY3Rpb24odCl7dmFyIGU9dC5ldmVudHMsYT1lLm9wdGlvbnM7ZS50eXBlc1tpXSYmZS50eXBlc1tpXS5sZW5ndGgmJnQudGVzdElnbm9yZUFsbG93KGEscixvKSYmbi5wdXNoKHtub2RlOnIsZXZlbnRhYmxlOmUscHJvcHM6e2ludGVyYWN0YWJsZTp0fX0pfSkpfSxcImludGVyYWN0YWJsZTpuZXdcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0YWJsZTtlLmV2ZW50cy5nZXRSZWN0PWZ1bmN0aW9uKHQpe3JldHVybiBlLmdldFJlY3QodCl9fSxcImludGVyYWN0YWJsZTpzZXRcIjpmdW5jdGlvbih0LGUpe3ZhciBuPXQuaW50ZXJhY3RhYmxlLHI9dC5vcHRpb25zO1Yobi5ldmVudHMub3B0aW9ucyxlLnBvaW50ZXJFdmVudHMuZGVmYXVsdHMpLFYobi5ldmVudHMub3B0aW9ucyxyLnBvaW50ZXJFdmVudHN8fHt9KX19fSxKbj0kbixRbj17aWQ6XCJwb2ludGVyLWV2ZW50c1wiLGluc3RhbGw6ZnVuY3Rpb24odCl7dC51c2VQbHVnaW4oTm4pLHQudXNlUGx1Z2luKEtuKSx0LnVzZVBsdWdpbihKbil9fSxabj1Rbjt2YXIgdHI9e2lkOlwicmVmbG93XCIsaW5zdGFsbDpmdW5jdGlvbih0KXt2YXIgZT10LkludGVyYWN0YWJsZTt0LmFjdGlvbnMucGhhc2VzLnJlZmxvdz0hMCxlLnByb3RvdHlwZS5yZWZsb3c9ZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIHI9dC5nZXRBbGxFbGVtZW50cygpLGk9bi53aW5kb3cuUHJvbWlzZSxvPWk/W106bnVsbCxhPWZ1bmN0aW9uKCl7dmFyIGE9cltzXSxjPXQuZ2V0UmVjdChhKTtpZighYylyZXR1cm4gMTt2YXIgbCx1PWJ0KG4uaW50ZXJhY3Rpb25zLmxpc3QsKGZ1bmN0aW9uKG4pe3JldHVybiBuLmludGVyYWN0aW5nKCkmJm4uaW50ZXJhY3RhYmxlPT09dCYmbi5lbGVtZW50PT09YSYmbi5wcmVwYXJlZC5uYW1lPT09ZS5uYW1lfSkpO2lmKHUpdS5tb3ZlKCksbyYmKGw9dS5fcmVmbG93UHJvbWlzZXx8bmV3IGkoKGZ1bmN0aW9uKHQpe3UuX3JlZmxvd1Jlc29sdmU9dH0pKSk7ZWxzZXt2YXIgcD1VKGMpLGY9ZnVuY3Rpb24odCl7cmV0dXJue2Nvb3Jkczp0LGdldCBwYWdlKCl7cmV0dXJuIHRoaXMuY29vcmRzLnBhZ2V9LGdldCBjbGllbnQoKXtyZXR1cm4gdGhpcy5jb29yZHMuY2xpZW50fSxnZXQgdGltZVN0YW1wKCl7cmV0dXJuIHRoaXMuY29vcmRzLnRpbWVTdGFtcH0sZ2V0IHBhZ2VYKCl7cmV0dXJuIHRoaXMuY29vcmRzLnBhZ2UueH0sZ2V0IHBhZ2VZKCl7cmV0dXJuIHRoaXMuY29vcmRzLnBhZ2UueX0sZ2V0IGNsaWVudFgoKXtyZXR1cm4gdGhpcy5jb29yZHMuY2xpZW50Lnh9LGdldCBjbGllbnRZKCl7cmV0dXJuIHRoaXMuY29vcmRzLmNsaWVudC55fSxnZXQgcG9pbnRlcklkKCl7cmV0dXJuIHRoaXMuY29vcmRzLnBvaW50ZXJJZH0sZ2V0IHRhcmdldCgpe3JldHVybiB0aGlzLmNvb3Jkcy50YXJnZXR9LGdldCB0eXBlKCl7cmV0dXJuIHRoaXMuY29vcmRzLnR5cGV9LGdldCBwb2ludGVyVHlwZSgpe3JldHVybiB0aGlzLmNvb3Jkcy5wb2ludGVyVHlwZX0sZ2V0IGJ1dHRvbnMoKXtyZXR1cm4gdGhpcy5jb29yZHMuYnV0dG9uc30scHJldmVudERlZmF1bHQ6ZnVuY3Rpb24oKXt9fX0oe3BhZ2U6e3g6cC54LHk6cC55fSxjbGllbnQ6e3g6cC54LHk6cC55fSx0aW1lU3RhbXA6bi5ub3coKX0pO2w9ZnVuY3Rpb24odCxlLG4scixpKXt2YXIgbz10LmludGVyYWN0aW9ucy5uZXcoe3BvaW50ZXJUeXBlOlwicmVmbG93XCJ9KSxhPXtpbnRlcmFjdGlvbjpvLGV2ZW50OmkscG9pbnRlcjppLGV2ZW50VGFyZ2V0Om4scGhhc2U6XCJyZWZsb3dcIn07by5pbnRlcmFjdGFibGU9ZSxvLmVsZW1lbnQ9bixvLnByZXZFdmVudD1pLG8udXBkYXRlUG9pbnRlcihpLGksbiwhMCksbnQoby5jb29yZHMuZGVsdGEpLFV0KG8ucHJlcGFyZWQsciksby5fZG9QaGFzZShhKTt2YXIgcz10LndpbmRvdyxjPXMuUHJvbWlzZSxsPWM/bmV3IGMoKGZ1bmN0aW9uKHQpe28uX3JlZmxvd1Jlc29sdmU9dH0pKTp2b2lkIDA7by5fcmVmbG93UHJvbWlzZT1sLG8uc3RhcnQocixlLG4pLG8uX2ludGVyYWN0aW5nPyhvLm1vdmUoYSksby5lbmQoaSkpOihvLnN0b3AoKSxvLl9yZWZsb3dSZXNvbHZlKCkpO3JldHVybiBvLnJlbW92ZVBvaW50ZXIoaSxpKSxsfShuLHQsYSxlLGYpfW8mJm8ucHVzaChsKX0scz0wO3M8ci5sZW5ndGgmJiFhKCk7cysrKTtyZXR1cm4gbyYmaS5hbGwobykudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gdH0pKX0odGhpcyxlLHQpfX0sbGlzdGVuZXJzOntcImludGVyYWN0aW9uczpzdG9wXCI6ZnVuY3Rpb24odCxlKXt2YXIgbj10LmludGVyYWN0aW9uO1wicmVmbG93XCI9PT1uLnBvaW50ZXJUeXBlJiYobi5fcmVmbG93UmVzb2x2ZSYmbi5fcmVmbG93UmVzb2x2ZSgpLGZ1bmN0aW9uKHQsZSl7dC5zcGxpY2UodC5pbmRleE9mKGUpLDEpfShlLmludGVyYWN0aW9ucy5saXN0LG4pKX19fSxlcj10cjtpZih1bi51c2UoaGUpLHVuLnVzZShDZSksdW4udXNlKFpuKSx1bi51c2UocWUpLHVuLnVzZShMbiksdW4udXNlKHBlKSx1bi51c2UoWHQpLHVuLnVzZShHdCksdW4udXNlKGVyKSx1bi5kZWZhdWx0PXVuLFwib2JqZWN0XCI9PT0oXCJ1bmRlZmluZWRcIj09dHlwZW9mIG1vZHVsZT9cInVuZGVmaW5lZFwiOm4obW9kdWxlKSkmJm1vZHVsZSl0cnl7bW9kdWxlLmV4cG9ydHM9dW59Y2F0Y2godCl7fXJldHVybiB1bi5kZWZhdWx0PXVuLHVufSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJhY3QubWluLmpzLm1hcFxuIiwiLyogZm9sbG93cyBcIkFuIGltcGxlbWVudGF0aW9uIG9mIHRvcC1kb3duIHNwbGF5aW5nXCJcbiAqIGJ5IEQuIFNsZWF0b3IgPHNsZWF0b3JAY3MuY211LmVkdT4gTWFyY2ggMTk5MlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeyp9IEtleVxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7Kn0gVmFsdWVcbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKG5vZGU6Tm9kZSk6dm9pZH0gVmlzaXRvclxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oYTpLZXksIGI6S2V5KTpudW1iZXJ9IENvbXBhcmF0b3JcbiAqL1xuXG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbihub2RlOk5vZGUpOnN0cmluZ30gTm9kZVByaW50ZXJcbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gIE5vZGVcbiAqIEBwcm9wZXJ0eSB7S2V5fSAgICBLZXlcbiAqIEBwcm9wZXJ0eSB7VmFsdWU9fSBkYXRhXG4gKiBAcHJvcGVydHkge05vZGV9ICAgbGVmdFxuICogQHByb3BlcnR5IHtOb2RlfSAgIHJpZ2h0XG4gKi9cblxudmFyIE5vZGUgPSBmdW5jdGlvbiBOb2RlIChrZXksIGRhdGEpIHtcbiAgdGhpcy5rZXkgID0ga2V5O1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmxlZnQgPSBudWxsO1xuICB0aGlzLnJpZ2h0PSBudWxsO1xufTtcblxuZnVuY3Rpb24gREVGQVVMVF9DT01QQVJFIChhLCBiKSB7IHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDsgfVxuXG5cbi8qKlxuICogU2ltcGxlIHRvcCBkb3duIHNwbGF5LCBub3QgcmVxdWlyaW5nIGkgdG8gYmUgaW4gdGhlIHRyZWUgdC5cbiAqIEBwYXJhbSB7S2V5fSBpXG4gKiBAcGFyYW0ge05vZGU/fSB0XG4gKiBAcGFyYW0ge0NvbXBhcmF0b3J9IGNvbXBhcmF0b3JcbiAqL1xuZnVuY3Rpb24gc3BsYXkgKGksIHQsIGNvbXBhcmF0b3IpIHtcbiAgaWYgKHQgPT09IG51bGwpIHsgcmV0dXJuIHQ7IH1cbiAgdmFyIGwsIHIsIHk7XG4gIHZhciBOID0gbmV3IE5vZGUoKTtcbiAgbCA9IHIgPSBOO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIGNtcCA9IGNvbXBhcmF0b3IoaSwgdC5rZXkpO1xuICAgIC8vaWYgKGkgPCB0LmtleSkge1xuICAgIGlmIChjbXAgPCAwKSB7XG4gICAgICBpZiAodC5sZWZ0ID09PSBudWxsKSB7IGJyZWFrOyB9XG4gICAgICAvL2lmIChpIDwgdC5sZWZ0LmtleSkge1xuICAgICAgaWYgKGNvbXBhcmF0b3IoaSwgdC5sZWZ0LmtleSkgPCAwKSB7XG4gICAgICAgIHkgPSB0LmxlZnQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogcm90YXRlIHJpZ2h0ICovXG4gICAgICAgIHQubGVmdCA9IHkucmlnaHQ7XG4gICAgICAgIHkucmlnaHQgPSB0O1xuICAgICAgICB0ID0geTtcbiAgICAgICAgaWYgKHQubGVmdCA9PT0gbnVsbCkgeyBicmVhazsgfVxuICAgICAgfVxuICAgICAgci5sZWZ0ID0gdDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGluayByaWdodCAqL1xuICAgICAgciA9IHQ7XG4gICAgICB0ID0gdC5sZWZ0O1xuICAgIC8vfSBlbHNlIGlmIChpID4gdC5rZXkpIHtcbiAgICB9IGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgIGlmICh0LnJpZ2h0ID09PSBudWxsKSB7IGJyZWFrOyB9XG4gICAgICAvL2lmIChpID4gdC5yaWdodC5rZXkpIHtcbiAgICAgIGlmIChjb21wYXJhdG9yKGksIHQucmlnaHQua2V5KSA+IDApIHtcbiAgICAgICAgeSA9IHQucmlnaHQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAvKiByb3RhdGUgbGVmdCAqL1xuICAgICAgICB0LnJpZ2h0ID0geS5sZWZ0O1xuICAgICAgICB5LmxlZnQgPSB0O1xuICAgICAgICB0ID0geTtcbiAgICAgICAgaWYgKHQucmlnaHQgPT09IG51bGwpIHsgYnJlYWs7IH1cbiAgICAgIH1cbiAgICAgIGwucmlnaHQgPSB0OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxpbmsgbGVmdCAqL1xuICAgICAgbCA9IHQ7XG4gICAgICB0ID0gdC5yaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8qIGFzc2VtYmxlICovXG4gIGwucmlnaHQgPSB0LmxlZnQ7XG4gIHIubGVmdCA9IHQucmlnaHQ7XG4gIHQubGVmdCA9IE4ucmlnaHQ7XG4gIHQucmlnaHQgPSBOLmxlZnQ7XG4gIHJldHVybiB0O1xufVxuXG5cbi8qKlxuICogQHBhcmFtICB7S2V5fSAgICAgICAgaVxuICogQHBhcmFtICB7VmFsdWV9ICAgICAgZGF0YVxuICogQHBhcmFtICB7Q29tcGFyYXRvcn0gY29tcGFyYXRvclxuICogQHBhcmFtICB7VHJlZX0gICAgICAgdHJlZVxuICogQHJldHVybiB7Tm9kZX0gICAgICByb290XG4gKi9cbmZ1bmN0aW9uIGluc2VydCAoaSwgZGF0YSwgdCwgY29tcGFyYXRvciwgdHJlZSkge1xuICB2YXIgbm9kZSA9IG5ldyBOb2RlKGksIGRhdGEpO1xuXG4gIHRyZWUuX3NpemUrKztcblxuICBpZiAodCA9PT0gbnVsbCkge1xuICAgIG5vZGUubGVmdCA9IG5vZGUucmlnaHQgPSBudWxsO1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgdCA9IHNwbGF5KGksIHQsIGNvbXBhcmF0b3IpO1xuICB2YXIgY21wID0gY29tcGFyYXRvcihpLCB0LmtleSk7XG4gIGlmIChjbXAgPCAwKSB7XG4gICAgbm9kZS5sZWZ0ID0gdC5sZWZ0O1xuICAgIG5vZGUucmlnaHQgPSB0O1xuICAgIHQubGVmdCA9IG51bGw7XG4gIH0gZWxzZSBpZiAoY21wID49IDApIHtcbiAgICBub2RlLnJpZ2h0ID0gdC5yaWdodDtcbiAgICBub2RlLmxlZnQgPSB0O1xuICAgIHQucmlnaHQgPSBudWxsO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG5cbi8qKlxuICogSW5zZXJ0IGkgaW50byB0aGUgdHJlZSB0LCB1bmxlc3MgaXQncyBhbHJlYWR5IHRoZXJlLlxuICogQHBhcmFtICB7S2V5fSAgICAgICAgaVxuICogQHBhcmFtICB7VmFsdWV9ICAgICAgZGF0YVxuICogQHBhcmFtICB7Q29tcGFyYXRvcn0gY29tcGFyYXRvclxuICogQHBhcmFtICB7VHJlZX0gICAgICAgdHJlZVxuICogQHJldHVybiB7Tm9kZX0gICAgICAgcm9vdFxuICovXG5mdW5jdGlvbiBhZGQgKGksIGRhdGEsIHQsIGNvbXBhcmF0b3IsIHRyZWUpIHtcbiAgdmFyIG5vZGUgPSBuZXcgTm9kZShpLCBkYXRhKTtcblxuICBpZiAodCA9PT0gbnVsbCkge1xuICAgIG5vZGUubGVmdCA9IG5vZGUucmlnaHQgPSBudWxsO1xuICAgIHRyZWUuX3NpemUrKztcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHQgPSBzcGxheShpLCB0LCBjb21wYXJhdG9yKTtcbiAgdmFyIGNtcCA9IGNvbXBhcmF0b3IoaSwgdC5rZXkpO1xuICBpZiAoY21wID09PSAwKSB7IHJldHVybiB0OyB9XG4gIGVsc2Uge1xuICAgIGlmIChjbXAgPCAwKSB7XG4gICAgICBub2RlLmxlZnQgPSB0LmxlZnQ7XG4gICAgICBub2RlLnJpZ2h0ID0gdDtcbiAgICAgIHQubGVmdCA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICBub2RlLnJpZ2h0ID0gdC5yaWdodDtcbiAgICAgIG5vZGUubGVmdCA9IHQ7XG4gICAgICB0LnJpZ2h0ID0gbnVsbDtcbiAgICB9XG4gICAgdHJlZS5fc2l6ZSsrO1xuICAgIHJldHVybiBub2RlO1xuICB9XG59XG5cblxuLyoqXG4gKiBEZWxldGVzIGkgZnJvbSB0aGUgdHJlZSBpZiBpdCdzIHRoZXJlXG4gKiBAcGFyYW0ge0tleX0gICAgICAgIGlcbiAqIEBwYXJhbSB7VHJlZX0gICAgICAgdHJlZVxuICogQHBhcmFtIHtDb21wYXJhdG9yfSBjb21wYXJhdG9yXG4gKiBAcGFyYW0ge1RyZWV9ICAgICAgIHRyZWVcbiAqIEByZXR1cm4ge05vZGV9ICAgICAgbmV3IHJvb3RcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlIChpLCB0LCBjb21wYXJhdG9yLCB0cmVlKSB7XG4gIHZhciB4O1xuICBpZiAodCA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbDsgfVxuICB0ID0gc3BsYXkoaSwgdCwgY29tcGFyYXRvcik7XG4gIHZhciBjbXAgPSBjb21wYXJhdG9yKGksIHQua2V5KTtcbiAgaWYgKGNtcCA9PT0gMCkgeyAgICAgICAgICAgICAgIC8qIGZvdW5kIGl0ICovXG4gICAgaWYgKHQubGVmdCA9PT0gbnVsbCkge1xuICAgICAgeCA9IHQucmlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSBzcGxheShpLCB0LmxlZnQsIGNvbXBhcmF0b3IpO1xuICAgICAgeC5yaWdodCA9IHQucmlnaHQ7XG4gICAgfVxuICAgIHRyZWUuX3NpemUtLTtcbiAgICByZXR1cm4geDtcbiAgfVxuICByZXR1cm4gdDsgICAgICAgICAgICAgICAgICAgICAgICAgLyogSXQgd2Fzbid0IHRoZXJlICovXG59XG5cblxuZnVuY3Rpb24gc3BsaXQgKGtleSwgdiwgY29tcGFyYXRvcikge1xuICB2YXIgbGVmdCwgcmlnaHQ7XG4gIGlmICh2ID09PSBudWxsKSB7XG4gICAgbGVmdCA9IHJpZ2h0ID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB2ID0gc3BsYXkoa2V5LCB2LCBjb21wYXJhdG9yKTtcblxuICAgIHZhciBjbXAgPSBjb21wYXJhdG9yKHYua2V5LCBrZXkpO1xuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIGxlZnQgID0gdi5sZWZ0O1xuICAgICAgcmlnaHQgPSB2LnJpZ2h0O1xuICAgIH0gZWxzZSBpZiAoY21wIDwgMCkge1xuICAgICAgcmlnaHQgICA9IHYucmlnaHQ7XG4gICAgICB2LnJpZ2h0ID0gbnVsbDtcbiAgICAgIGxlZnQgICAgPSB2O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0ICAgPSB2LmxlZnQ7XG4gICAgICB2LmxlZnQgPSBudWxsO1xuICAgICAgcmlnaHQgID0gdjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgbGVmdDogbGVmdCwgcmlnaHQ6IHJpZ2h0IH07XG59XG5cblxuZnVuY3Rpb24gbWVyZ2UgKGxlZnQsIHJpZ2h0LCBjb21wYXJhdG9yKSB7XG4gIGlmIChyaWdodCA9PT0gbnVsbCkgeyByZXR1cm4gbGVmdDsgfVxuICBpZiAobGVmdCAgPT09IG51bGwpIHsgcmV0dXJuIHJpZ2h0OyB9XG5cbiAgcmlnaHQgPSBzcGxheShsZWZ0LmtleSwgcmlnaHQsIGNvbXBhcmF0b3IpO1xuICByaWdodC5sZWZ0ID0gbGVmdDtcbiAgcmV0dXJuIHJpZ2h0O1xufVxuXG5cbi8qKlxuICogUHJpbnRzIGxldmVsIG9mIHRoZSB0cmVlXG4gKiBAcGFyYW0gIHtOb2RlfSAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RcbiAqIEBwYXJhbSAge1N0cmluZ30gICAgICAgICAgICAgICAgICAgICAgcHJlZml4XG4gKiBAcGFyYW0gIHtCb29sZWFufSAgICAgICAgICAgICAgICAgICAgIGlzVGFpbFxuICogQHBhcmFtICB7QXJyYXk8c3RyaW5nPn0gICAgICAgICAgICAgICBvdXRcbiAqIEBwYXJhbSAge0Z1bmN0aW9uKG5vZGU6Tm9kZSk6U3RyaW5nfSAgcHJpbnROb2RlXG4gKi9cbmZ1bmN0aW9uIHByaW50Um93IChyb290LCBwcmVmaXgsIGlzVGFpbCwgb3V0LCBwcmludE5vZGUpIHtcbiAgaWYgKHJvb3QpIHtcbiAgICBvdXQoKFwiXCIgKyBwcmVmaXggKyAoaXNUYWlsID8gJ+KUlOKUgOKUgCAnIDogJ+KUnOKUgOKUgCAnKSArIChwcmludE5vZGUocm9vdCkpICsgXCJcXG5cIikpO1xuICAgIHZhciBpbmRlbnQgPSBwcmVmaXggKyAoaXNUYWlsID8gJyAgICAnIDogJ+KUgiAgICcpO1xuICAgIGlmIChyb290LmxlZnQpICB7IHByaW50Um93KHJvb3QubGVmdCwgIGluZGVudCwgZmFsc2UsIG91dCwgcHJpbnROb2RlKTsgfVxuICAgIGlmIChyb290LnJpZ2h0KSB7IHByaW50Um93KHJvb3QucmlnaHQsIGluZGVudCwgdHJ1ZSwgIG91dCwgcHJpbnROb2RlKTsgfVxuICB9XG59XG5cblxudmFyIFRyZWUgPSBmdW5jdGlvbiBUcmVlIChjb21wYXJhdG9yKSB7XG4gIGlmICggY29tcGFyYXRvciA9PT0gdm9pZCAwICkgY29tcGFyYXRvciA9IERFRkFVTFRfQ09NUEFSRTtcblxuICB0aGlzLl9jb21wYXJhdG9yID0gY29tcGFyYXRvcjtcbiAgdGhpcy5fcm9vdCA9IG51bGw7XG4gIHRoaXMuX3NpemUgPSAwO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgc2l6ZTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5cbi8qKlxuICogSW5zZXJ0cyBhIGtleSwgYWxsb3dzIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbXtLZXl9ICBrZXlcbiAqIEBwYXJhbXtWYWx1ZT19IGRhdGFcbiAqIEByZXR1cm4ge05vZGV8bnVsbH1cbiAqL1xuVHJlZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gaW5zZXJ0JDEgKGtleSwgZGF0YSkge1xuICByZXR1cm4gdGhpcy5fcm9vdCA9IGluc2VydChrZXksIGRhdGEsIHRoaXMuX3Jvb3QsIHRoaXMuX2NvbXBhcmF0b3IsIHRoaXMpO1xufTtcblxuXG4vKipcbiAqIEFkZHMgYSBrZXksIGlmIGl0IGlzIG5vdCBwcmVzZW50IGluIHRoZSB0cmVlXG4gKiBAcGFyYW17S2V5fSAga2V5XG4gKiBAcGFyYW17VmFsdWU9fSBkYXRhXG4gKiBAcmV0dXJuIHtOb2RlfG51bGx9XG4gKi9cblRyZWUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCQxIChrZXksIGRhdGEpIHtcbiAgcmV0dXJuIHRoaXMuX3Jvb3QgPSBhZGQoa2V5LCBkYXRhLCB0aGlzLl9yb290LCB0aGlzLl9jb21wYXJhdG9yLCB0aGlzKTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW17S2V5fSBrZXlcbiAqIEByZXR1cm4ge05vZGV8bnVsbH1cbiAqL1xuVHJlZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlJDEgKGtleSkge1xuICB0aGlzLl9yb290ID0gcmVtb3ZlKGtleSwgdGhpcy5fcm9vdCwgdGhpcy5fY29tcGFyYXRvciwgdGhpcyk7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlcyBhbmQgcmV0dXJucyB0aGUgbm9kZSB3aXRoIHNtYWxsZXN0IGtleVxuICogQHJldHVybiB7P05vZGV9XG4gKi9cblRyZWUucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uIHBvcCAoKSB7XG4gIHZhciBub2RlID0gdGhpcy5fcm9vdDtcbiAgaWYgKG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZS5sZWZ0KSB7IG5vZGUgPSBub2RlLmxlZnQ7IH1cbiAgICB0aGlzLl9yb290ID0gc3BsYXkobm9kZS5rZXksdGhpcy5fcm9vdCwgdGhpcy5fY29tcGFyYXRvcik7XG4gICAgdGhpcy5fcm9vdCA9IHJlbW92ZShub2RlLmtleSwgdGhpcy5fcm9vdCwgdGhpcy5fY29tcGFyYXRvciwgdGhpcyk7XG4gICAgcmV0dXJuIHsga2V5OiBub2RlLmtleSwgZGF0YTogbm9kZS5kYXRhIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5cbi8qKlxuICogQHBhcmFte0tleX0ga2V5XG4gKiBAcmV0dXJuIHtOb2RlfG51bGx9XG4gKi9cblRyZWUucHJvdG90eXBlLmZpbmRTdGF0aWMgPSBmdW5jdGlvbiBmaW5kU3RhdGljIChrZXkpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLl9yb290O1xuICB2YXIgY29tcGFyZSA9IHRoaXMuX2NvbXBhcmF0b3I7XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgdmFyIGNtcCA9IGNvbXBhcmUoa2V5LCBjdXJyZW50LmtleSk7XG4gICAgaWYgKGNtcCA9PT0gMCkgIHsgcmV0dXJuIGN1cnJlbnQ7IH1cbiAgICBlbHNlIGlmIChjbXAgPCAwKSB7IGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7IH1cbiAgICBlbHNlICAgICAgICAgICAgeyBjdXJyZW50ID0gY3VycmVudC5yaWdodDsgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbXtLZXl9IGtleVxuICogQHJldHVybiB7Tm9kZXxudWxsfVxuICovXG5UcmVlLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gZmluZCAoa2V5KSB7XG4gIGlmICh0aGlzLl9yb290KSB7XG4gICAgdGhpcy5fcm9vdCA9IHNwbGF5KGtleSwgdGhpcy5fcm9vdCwgdGhpcy5fY29tcGFyYXRvcik7XG4gICAgaWYgKHRoaXMuX2NvbXBhcmF0b3Ioa2V5LCB0aGlzLl9yb290LmtleSkgIT09IDApIHsgcmV0dXJuIG51bGw7IH1cbiAgfVxuICByZXR1cm4gdGhpcy5fcm9vdDtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW17S2V5fSBrZXlcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblRyZWUucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gY29udGFpbnMgKGtleSkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuX3Jvb3Q7XG4gIHZhciBjb21wYXJlID0gdGhpcy5fY29tcGFyYXRvcjtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICB2YXIgY21wID0gY29tcGFyZShrZXksIGN1cnJlbnQua2V5KTtcbiAgICBpZiAoY21wID09PSAwKSAgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGVsc2UgaWYgKGNtcCA8IDApIHsgY3VycmVudCA9IGN1cnJlbnQubGVmdDsgfVxuICAgIGVsc2UgICAgICAgICAgICB7IGN1cnJlbnQgPSBjdXJyZW50LnJpZ2h0OyB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbXtWaXNpdG9yfSB2aXNpdG9yXG4gKiBAcGFyYW17Kj19ICAgIGN0eFxuICogQHJldHVybiB7U3BsYXlUcmVlfVxuICovXG5UcmVlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaCAodmlzaXRvciwgY3R4KSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5fcm9vdDtcbiAgdmFyIFEgPSBbXTsvKiBJbml0aWFsaXplIHN0YWNrIHMgKi9cbiAgdmFyIGRvbmUgPSBmYWxzZTtcblxuICB3aGlsZSAoIWRvbmUpIHtcbiAgICBpZiAoY3VycmVudCAhPT1udWxsKSB7XG4gICAgICBRLnB1c2goY3VycmVudCk7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5sZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoUS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgY3VycmVudCA9IFEucG9wKCk7XG4gICAgICAgIHZpc2l0b3IuY2FsbChjdHgsIGN1cnJlbnQpO1xuXG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJpZ2h0O1xuICAgICAgfSBlbHNlIHsgZG9uZSA9IHRydWU7IH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogV2FsayBrZXkgcmFuZ2UgZnJvbSBgbG93YCB0byBgaGlnaGAuIFN0b3BzIGlmIGBmbmAgcmV0dXJucyBhIHZhbHVlLlxuICogQHBhcmFte0tleX0gICAgbG93XG4gKiBAcGFyYW17S2V5fSAgICBoaWdoXG4gKiBAcGFyYW17RnVuY3Rpb259IGZuXG4gKiBAcGFyYW17Kj99ICAgICBjdHhcbiAqIEByZXR1cm4ge1NwbGF5VHJlZX1cbiAqL1xuVHJlZS5wcm90b3R5cGUucmFuZ2UgPSBmdW5jdGlvbiByYW5nZSAobG93LCBoaWdoLCBmbiwgY3R4KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIFEgPSBbXTtcbiAgdmFyIGNvbXBhcmUgPSB0aGlzLl9jb21wYXJhdG9yO1xuICB2YXIgbm9kZSA9IHRoaXMuX3Jvb3QsIGNtcDtcblxuICB3aGlsZSAoUS5sZW5ndGggIT09IDAgfHwgbm9kZSkge1xuICAgIGlmIChub2RlKSB7XG4gICAgICBRLnB1c2gobm9kZSk7XG4gICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gUS5wb3AoKTtcbiAgICAgIGNtcCA9IGNvbXBhcmUobm9kZS5rZXksIGhpZ2gpO1xuICAgICAgaWYgKGNtcCA+IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKGNvbXBhcmUobm9kZS5rZXksIGxvdykgPj0gMCkge1xuICAgICAgICBpZiAoZm4uY2FsbChjdHgsIG5vZGUpKSB7IHJldHVybiB0aGlzJDE7IH0gLy8gc3RvcCBpZiBzbXRoIGlzIHJldHVybmVkXG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5yaWdodDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyBhcnJheSBvZiBrZXlzXG4gKiBAcmV0dXJuIHtBcnJheTxLZXk+fVxuICovXG5UcmVlLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24ga2V5cyAoKSB7XG4gIHZhciBrZXlzID0gW107XG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgICB2YXIga2V5ID0gcmVmLmtleTtcblxuICAgICAgcmV0dXJuIGtleXMucHVzaChrZXkpO1xuICAgIH0pO1xuICByZXR1cm4ga2V5cztcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIGFycmF5IG9mIGFsbCB0aGUgZGF0YSBpbiB0aGUgbm9kZXNcbiAqIEByZXR1cm4ge0FycmF5PFZhbHVlPn1cbiAqL1xuVHJlZS5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gdmFsdWVzICgpIHtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcblxuICAgICAgcmV0dXJuIHZhbHVlcy5wdXNoKGRhdGEpO1xuICAgIH0pO1xuICByZXR1cm4gdmFsdWVzO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge0tleXxudWxsfVxuICovXG5UcmVlLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiBtaW4gKCkge1xuICBpZiAodGhpcy5fcm9vdCkgeyByZXR1cm4gdGhpcy5taW5Ob2RlKHRoaXMuX3Jvb3QpLmtleTsgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtLZXl8bnVsbH1cbiAqL1xuVHJlZS5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24gbWF4ICgpIHtcbiAgaWYgKHRoaXMuX3Jvb3QpIHsgcmV0dXJuIHRoaXMubWF4Tm9kZSh0aGlzLl9yb290KS5rZXk7IH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7Tm9kZXxudWxsfVxuICovXG5UcmVlLnByb3RvdHlwZS5taW5Ob2RlID0gZnVuY3Rpb24gbWluTm9kZSAodCkge1xuICAgIGlmICggdCA9PT0gdm9pZCAwICkgdCA9IHRoaXMuX3Jvb3Q7XG5cbiAgaWYgKHQpIHsgd2hpbGUgKHQubGVmdCkgeyB0ID0gdC5sZWZ0OyB9IH1cbiAgcmV0dXJuIHQ7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7Tm9kZXxudWxsfVxuICovXG5UcmVlLnByb3RvdHlwZS5tYXhOb2RlID0gZnVuY3Rpb24gbWF4Tm9kZSAodCkge1xuICAgIGlmICggdCA9PT0gdm9pZCAwICkgdCA9IHRoaXMuX3Jvb3Q7XG5cbiAgaWYgKHQpIHsgd2hpbGUgKHQucmlnaHQpIHsgdCA9IHQucmlnaHQ7IH0gfVxuICByZXR1cm4gdDtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIG5vZGUgYXQgZ2l2ZW4gaW5kZXhcbiAqIEBwYXJhbXtudW1iZXJ9IGluZGV4XG4gKiBAcmV0dXJuIHs/Tm9kZX1cbiAqL1xuVHJlZS5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBhdCAoaW5kZXgpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLl9yb290LCBkb25lID0gZmFsc2UsIGkgPSAwO1xuICB2YXIgUSA9IFtdO1xuXG4gIHdoaWxlICghZG9uZSkge1xuICAgIGlmIChjdXJyZW50KSB7XG4gICAgICBRLnB1c2goY3VycmVudCk7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5sZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoUS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGN1cnJlbnQgPSBRLnBvcCgpO1xuICAgICAgICBpZiAoaSA9PT0gaW5kZXgpIHsgcmV0dXJuIGN1cnJlbnQ7IH1cbiAgICAgICAgaSsrO1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcbiAgICAgIH0gZWxzZSB7IGRvbmUgPSB0cnVlOyB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbXtOb2RlfSBkXG4gKiBAcmV0dXJuIHtOb2RlfG51bGx9XG4gKi9cblRyZWUucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiBuZXh0IChkKSB7XG4gIHZhciByb290ID0gdGhpcy5fcm9vdDtcbiAgdmFyIHN1Y2Nlc3NvciA9IG51bGw7XG5cbiAgaWYgKGQucmlnaHQpIHtcbiAgICBzdWNjZXNzb3IgPSBkLnJpZ2h0O1xuICAgIHdoaWxlIChzdWNjZXNzb3IubGVmdCkgeyBzdWNjZXNzb3IgPSBzdWNjZXNzb3IubGVmdDsgfVxuICAgIHJldHVybiBzdWNjZXNzb3I7XG4gIH1cblxuICB2YXIgY29tcGFyYXRvciA9IHRoaXMuX2NvbXBhcmF0b3I7XG4gIHdoaWxlIChyb290KSB7XG4gICAgdmFyIGNtcCA9IGNvbXBhcmF0b3IoZC5rZXksIHJvb3Qua2V5KTtcbiAgICBpZiAoY21wID09PSAwKSB7IGJyZWFrOyB9XG4gICAgZWxzZSBpZiAoY21wIDwgMCkge1xuICAgICAgc3VjY2Vzc29yID0gcm9vdDtcbiAgICAgIHJvb3QgPSByb290LmxlZnQ7XG4gICAgfSBlbHNlIHsgcm9vdCA9IHJvb3QucmlnaHQ7IH1cbiAgfVxuXG4gIHJldHVybiBzdWNjZXNzb3I7XG59O1xuXG5cbi8qKlxuICogQHBhcmFte05vZGV9IGRcbiAqIEByZXR1cm4ge05vZGV8bnVsbH1cbiAqL1xuVHJlZS5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uIHByZXYgKGQpIHtcbiAgdmFyIHJvb3QgPSB0aGlzLl9yb290O1xuICB2YXIgcHJlZGVjZXNzb3IgPSBudWxsO1xuXG4gIGlmIChkLmxlZnQgIT09IG51bGwpIHtcbiAgICBwcmVkZWNlc3NvciA9IGQubGVmdDtcbiAgICB3aGlsZSAocHJlZGVjZXNzb3IucmlnaHQpIHsgcHJlZGVjZXNzb3IgPSBwcmVkZWNlc3Nvci5yaWdodDsgfVxuICAgIHJldHVybiBwcmVkZWNlc3NvcjtcbiAgfVxuXG4gIHZhciBjb21wYXJhdG9yID0gdGhpcy5fY29tcGFyYXRvcjtcbiAgd2hpbGUgKHJvb3QpIHtcbiAgICB2YXIgY21wID0gY29tcGFyYXRvcihkLmtleSwgcm9vdC5rZXkpO1xuICAgIGlmIChjbXAgPT09IDApIHsgYnJlYWs7IH1cbiAgICBlbHNlIGlmIChjbXAgPCAwKSB7IHJvb3QgPSByb290LmxlZnQ7IH1cbiAgICBlbHNlIHtcbiAgICAgIHByZWRlY2Vzc29yID0gcm9vdDtcbiAgICAgIHJvb3QgPSByb290LnJpZ2h0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJlZGVjZXNzb3I7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7U3BsYXlUcmVlfVxuICovXG5UcmVlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgdGhpcy5fcm9vdCA9IG51bGw7XG4gIHRoaXMuX3NpemUgPSAwO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtOb2RlTGlzdH1cbiAqL1xuVHJlZS5wcm90b3R5cGUudG9MaXN0ID0gZnVuY3Rpb24gdG9MaXN0JDEgKCkge1xuICByZXR1cm4gdG9MaXN0KHRoaXMuX3Jvb3QpO1xufTtcblxuXG4vKipcbiAqIEJ1bGstbG9hZCBpdGVtcy4gQm90aCBhcnJheSBoYXZlIHRvIGJlIHNhbWUgc2l6ZVxuICogQHBhcmFte0FycmF5PEtleT59ICBrZXlzXG4gKiBAcGFyYW17QXJyYXk8VmFsdWU+fVt2YWx1ZXNdXG4gKiBAcGFyYW17Qm9vbGVhbn0gICAgIFtwcmVzb3J0PWZhbHNlXSBQcmUtc29ydCBrZXlzIGFuZCB2YWx1ZXMsIHVzaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWUncyBjb21wYXJhdG9yLiBTb3J0aW5nIGlzIGRvbmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4tcGxhY2VcbiAqIEByZXR1cm4ge0FWTFRyZWV9XG4gKi9cblRyZWUucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiBsb2FkIChrZXlzLCB2YWx1ZXMsIHByZXNvcnQpIHtcbiAgICBpZiAoIGtleXMgPT09IHZvaWQgMCApIGtleXMgPSBbXTtcbiAgICBpZiAoIHZhbHVlcyA9PT0gdm9pZCAwICkgdmFsdWVzID0gW107XG4gICAgaWYgKCBwcmVzb3J0ID09PSB2b2lkIDAgKSBwcmVzb3J0ID0gZmFsc2U7XG5cbiAgdmFyIHNpemUgPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGNvbXBhcmF0b3IgPSB0aGlzLl9jb21wYXJhdG9yO1xuXG4gIC8vIHNvcnQgaWYgbmVlZGVkXG4gIGlmIChwcmVzb3J0KSB7IHNvcnQoa2V5cywgdmFsdWVzLCAwLCBzaXplIC0gMSwgY29tcGFyYXRvcik7IH1cblxuICBpZiAodGhpcy5fcm9vdCA9PT0gbnVsbCkgeyAvLyBlbXB0eSB0cmVlXG4gICAgdGhpcy5fcm9vdCA9IGxvYWRSZWN1cnNpdmUodGhpcy5fcm9vdCwga2V5cywgdmFsdWVzLCAwLCBzaXplKTtcbiAgICB0aGlzLl9zaXplID0gc2l6ZTtcbiAgfSBlbHNlIHsgLy8gdGhhdCByZS1idWlsZHMgdGhlIHdob2xlIHRyZWUgZnJvbSB0d28gaW4tb3JkZXIgdHJhdmVyc2Fsc1xuICAgIHZhciBtZXJnZWRMaXN0ID0gbWVyZ2VMaXN0cyh0aGlzLnRvTGlzdCgpLCBjcmVhdGVMaXN0KGtleXMsIHZhbHVlcyksIGNvbXBhcmF0b3IpO1xuICAgIHNpemUgPSB0aGlzLl9zaXplICsgc2l6ZTtcbiAgICB0aGlzLl9yb290ID0gc29ydGVkTGlzdFRvQlNUKHsgaGVhZDogbWVyZ2VkTGlzdCB9LCAwLCBzaXplKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5UcmVlLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSAoKSB7IHJldHVybiB0aGlzLl9yb290ID09PSBudWxsOyB9O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuc2l6ZS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zaXplOyB9O1xuXG5cbi8qKlxuICogQHBhcmFte05vZGVQcmludGVyPX0gcHJpbnROb2RlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblRyZWUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKHByaW50Tm9kZSkge1xuICAgIGlmICggcHJpbnROb2RlID09PSB2b2lkIDAgKSBwcmludE5vZGUgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gbi5rZXk7IH07XG5cbiAgdmFyIG91dCA9IFtdO1xuICBwcmludFJvdyh0aGlzLl9yb290LCAnJywgdHJ1ZSwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG91dC5wdXNoKHYpOyB9LCBwcmludE5vZGUpO1xuICByZXR1cm4gb3V0LmpvaW4oJycpO1xufTtcblxuXG5UcmVlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKGtleSwgbmV3S2V5LCBuZXdEYXRhKSB7XG4gIHZhciBjb21wYXJhdG9yID0gdGhpcy5fY29tcGFyYXRvcjtcbiAgdmFyIHJlZiA9IHNwbGl0KGtleSwgdGhpcy5fcm9vdCwgY29tcGFyYXRvcik7XG4gICAgdmFyIGxlZnQgPSByZWYubGVmdDtcbiAgICB2YXIgcmlnaHQgPSByZWYucmlnaHQ7XG4gIHRoaXMuX3NpemUtLTtcbiAgaWYgKGNvbXBhcmF0b3Ioa2V5LCBuZXdLZXkpIDwgMCkge1xuICAgIHJpZ2h0ID0gaW5zZXJ0KG5ld0tleSwgbmV3RGF0YSwgcmlnaHQsIGNvbXBhcmF0b3IsIHRoaXMpO1xuICB9IGVsc2Uge1xuICAgIGxlZnQgPSBpbnNlcnQobmV3S2V5LCBuZXdEYXRhLCBsZWZ0LCBjb21wYXJhdG9yLCB0aGlzKTtcbiAgfVxuICB0aGlzLl9yb290ID0gbWVyZ2UobGVmdCwgcmlnaHQsIGNvbXBhcmF0b3IpO1xufTtcblxuXG5UcmVlLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0JDEgKGtleSkge1xuICByZXR1cm4gc3BsaXQoa2V5LCB0aGlzLl9yb290LCB0aGlzLl9jb21wYXJhdG9yKTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUcmVlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cblxuZnVuY3Rpb24gbG9hZFJlY3Vyc2l2ZSAocGFyZW50LCBrZXlzLCB2YWx1ZXMsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNpemUgPSBlbmQgLSBzdGFydDtcbiAgaWYgKHNpemUgPiAwKSB7XG4gICAgdmFyIG1pZGRsZSA9IHN0YXJ0ICsgTWF0aC5mbG9vcihzaXplIC8gMik7XG4gICAgdmFyIGtleSAgICA9IGtleXNbbWlkZGxlXTtcbiAgICB2YXIgZGF0YSAgID0gdmFsdWVzW21pZGRsZV07XG4gICAgdmFyIG5vZGUgICA9IHsga2V5OiBrZXksIGRhdGE6IGRhdGEsIHBhcmVudDogcGFyZW50IH07XG4gICAgbm9kZS5sZWZ0ICAgID0gbG9hZFJlY3Vyc2l2ZShub2RlLCBrZXlzLCB2YWx1ZXMsIHN0YXJ0LCBtaWRkbGUpO1xuICAgIG5vZGUucmlnaHQgICA9IGxvYWRSZWN1cnNpdmUobm9kZSwga2V5cywgdmFsdWVzLCBtaWRkbGUgKyAxLCBlbmQpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUxpc3Qoa2V5cywgdmFsdWVzKSB7XG4gIHZhciBoZWFkID0geyBuZXh0OiBudWxsIH07XG4gIHZhciBwID0gaGVhZDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgcCA9IHAubmV4dCA9IHsga2V5OiBrZXlzW2ldLCBkYXRhOiB2YWx1ZXNbaV0gfTtcbiAgfVxuICBwLm5leHQgPSBudWxsO1xuICByZXR1cm4gaGVhZC5uZXh0O1xufVxuXG5cbmZ1bmN0aW9uIHRvTGlzdCAocm9vdCkge1xuICB2YXIgY3VycmVudCA9IHJvb3Q7XG4gIHZhciBRID0gW10sIGRvbmUgPSBmYWxzZTtcblxuICB2YXIgaGVhZCA9IHsgbmV4dDogbnVsbCB9O1xuICB2YXIgcCA9IGhlYWQ7XG5cbiAgd2hpbGUgKCFkb25lKSB7XG4gICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgIFEucHVzaChjdXJyZW50KTtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChRLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY3VycmVudCA9IHAgPSBwLm5leHQgPSBRLnBvcCgpO1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcbiAgICAgIH0gZWxzZSB7IGRvbmUgPSB0cnVlOyB9XG4gICAgfVxuICB9XG4gIHAubmV4dCA9IG51bGw7IC8vIHRoYXQnbGwgd29yayBldmVuIGlmIHRoZSB0cmVlIHdhcyBlbXB0eVxuICByZXR1cm4gaGVhZC5uZXh0O1xufVxuXG5cbmZ1bmN0aW9uIHNvcnRlZExpc3RUb0JTVChsaXN0LCBzdGFydCwgZW5kKSB7XG4gIHZhciBzaXplID0gZW5kIC0gc3RhcnQ7XG4gIGlmIChzaXplID4gMCkge1xuICAgIHZhciBtaWRkbGUgPSBzdGFydCArIE1hdGguZmxvb3Ioc2l6ZSAvIDIpO1xuICAgIHZhciBsZWZ0ID0gc29ydGVkTGlzdFRvQlNUKGxpc3QsIHN0YXJ0LCBtaWRkbGUpO1xuXG4gICAgdmFyIHJvb3QgPSBsaXN0LmhlYWQ7XG4gICAgcm9vdC5sZWZ0ID0gbGVmdDtcblxuICAgIGxpc3QuaGVhZCA9IGxpc3QuaGVhZC5uZXh0O1xuXG4gICAgcm9vdC5yaWdodCA9IHNvcnRlZExpc3RUb0JTVChsaXN0LCBtaWRkbGUgKyAxLCBlbmQpO1xuICAgIHJldHVybiByb290O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5cbmZ1bmN0aW9uIG1lcmdlTGlzdHMgKGwxLCBsMiwgY29tcGFyZSkge1xuICBpZiAoIGNvbXBhcmUgPT09IHZvaWQgMCApIGNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAtIGI7IH07XG5cbiAgdmFyIGhlYWQgPSB7fTsgLy8gZHVtbXlcbiAgdmFyIHAgPSBoZWFkO1xuXG4gIHZhciBwMSA9IGwxO1xuICB2YXIgcDIgPSBsMjtcblxuICB3aGlsZSAocDEgIT09IG51bGwgJiYgcDIgIT09IG51bGwpIHtcbiAgICBpZiAoY29tcGFyZShwMS5rZXksIHAyLmtleSkgPCAwKSB7XG4gICAgICBwLm5leHQgPSBwMTtcbiAgICAgIHAxID0gcDEubmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgcC5uZXh0ID0gcDI7XG4gICAgICBwMiA9IHAyLm5leHQ7XG4gICAgfVxuICAgIHAgPSBwLm5leHQ7XG4gIH1cblxuICBpZiAocDEgIT09IG51bGwpICAgICAgeyBwLm5leHQgPSBwMTsgfVxuICBlbHNlIGlmIChwMiAhPT0gbnVsbCkgeyBwLm5leHQgPSBwMjsgfVxuXG4gIHJldHVybiBoZWFkLm5leHQ7XG59XG5cblxuZnVuY3Rpb24gc29ydChrZXlzLCB2YWx1ZXMsIGxlZnQsIHJpZ2h0LCBjb21wYXJlKSB7XG4gIGlmIChsZWZ0ID49IHJpZ2h0KSB7IHJldHVybjsgfVxuXG4gIHZhciBwaXZvdCA9IGtleXNbKGxlZnQgKyByaWdodCkgPj4gMV07XG4gIHZhciBpID0gbGVmdCAtIDE7XG4gIHZhciBqID0gcmlnaHQgKyAxO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgZG8geyBpKys7IH0gd2hpbGUgKGNvbXBhcmUoa2V5c1tpXSwgcGl2b3QpIDwgMCk7XG4gICAgZG8geyBqLS07IH0gd2hpbGUgKGNvbXBhcmUoa2V5c1tqXSwgcGl2b3QpID4gMCk7XG4gICAgaWYgKGkgPj0gaikgeyBicmVhazsgfVxuXG4gICAgdmFyIHRtcCA9IGtleXNbaV07XG4gICAga2V5c1tpXSA9IGtleXNbal07XG4gICAga2V5c1tqXSA9IHRtcDtcblxuICAgIHRtcCA9IHZhbHVlc1tpXTtcbiAgICB2YWx1ZXNbaV0gPSB2YWx1ZXNbal07XG4gICAgdmFsdWVzW2pdID0gdG1wO1xuICB9XG5cbiAgc29ydChrZXlzLCB2YWx1ZXMsICBsZWZ0LCAgICAgaiwgY29tcGFyZSk7XG4gIHNvcnQoa2V5cywgdmFsdWVzLCBqICsgMSwgcmlnaHQsIGNvbXBhcmUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFdmVudFF1ZXVlKGJ5WSkge1xuICB2YXIgcSA9IG5ldyBUcmVlKGJ5WSk7XG5cbiAgcmV0dXJuIHtcbiAgICBpc0VtcHR5OiBpc0VtcHR5LFxuICAgIHNpemU6IHNpemUsXG4gICAgcG9wOiBwb3AsXG4gICAgZmluZDogZmluZCxcbiAgICBpbnNlcnQ6IGluc2VydFxuICB9XG5cbiAgZnVuY3Rpb24gZmluZChwKSB7XG4gICAgcmV0dXJuIHEuZmluZChwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNpemUoKSB7XG4gICAgcmV0dXJuIHEuc2l6ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHEuaXNFbXB0eSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0KGV2ZW50KSB7XG4gICAgLy8gZGVidWdnZXI7XG4gICAgcS5hZGQoZXZlbnQucG9pbnQsIGV2ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvcCgpIHtcbiAgICB2YXIgbm9kZSA9IHEucG9wKCk7XG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5kYXRhO1xuICB9XG59XG5cbi8qKlxuICogSnVzdCBhIGNvbGxlY3Rpb24gb2YgZ2VvbWV0cnkgcmVsYXRlZCB1dGlsaXRpZXNcbiAqL1xuXG4vLyBUaGlzIGlzIHVzZWQgZm9yIHByZWNpc2lvbiBjaGVja2luZyAoZS5nLiB0d28gbnVtYmVycyBhcmUgZXF1YWxcbi8vIGlmIHRoZWlyIGRpZmZlcmVuY2UgaXMgc21hbGxlciB0aGFuIHRoaXMgbnVtYmVyKS4gVGhlIHZhbHVlIGlzIFxuLy8gY2hvc2VuIGVtcGlyaWNhbGx5LiBXZSBzdGlsbCBtYXkgcnVuIGludG8gcHJlY2lzaW9uIHJlbGF0ZWQgaXNzdWVzLlxuLy8gVE9ETzogd2Ugc2hvdWxkIGFsbG93IGNvbnN1bWVycyB0byBjb25maWd1cmUgdGhpcy5cbnZhciBFUFMgPSAxZS05Oy8vMTA7XG5cbmZ1bmN0aW9uIGdldEludGVyc2VjdGlvblhQb2ludChzZWdtZW50LCB4UG9zLCB5UG9zKSB7XG4gIHZhciBkeTEgPSBzZWdtZW50LmZyb20ueSAtIHlQb3M7XG4gIHZhciBkeTIgPSB5UG9zIC0gc2VnbWVudC50by55O1xuICB2YXIgZHkgPSBzZWdtZW50LnRvLnkgLSBzZWdtZW50LmZyb20ueTtcbiAgaWYgKE1hdGguYWJzKGR5MSkgPCBFUFMpIHtcbiAgICAvLyBUaGUgc2VnbWVudCBzdGFydHMgb24gdGhlIHN3ZWVwIGxpbmVcbiAgICBpZiAoTWF0aC5hYnMoZHkpIDwgRVBTKSB7XG4gICAgICAvLyB0aGUgc2VnbWVudCBpcyBob3Jpem9udGFsLiBJbnRlcnNlY3Rpb24gaXMgYXQgdGhlIHBvaW50XG4gICAgICBpZiAoeFBvcyA8PSBzZWdtZW50LmZyb20ueCkgeyByZXR1cm4gc2VnbWVudC5mcm9tLng7IH1cbiAgICAgIGlmICh4UG9zID4gc2VnbWVudC50by54KSB7IHJldHVybiBzZWdtZW50LnRvLng7IH1cbiAgICAgIHJldHVybiB4UG9zO1xuICAgIH1cbiAgICByZXR1cm4gc2VnbWVudC5mcm9tLng7XG4gIH1cbiAgXG4gIHZhciBkeCA9IChzZWdtZW50LnRvLnggLSBzZWdtZW50LmZyb20ueCk7IFxuICB2YXIgeE9mZnNldDsgXG4gIGlmIChkeTEgPj0gZHkyKSB7XG4gICAgeE9mZnNldCA9IGR5MSAqIChkeCAvIGR5KTsgXG4gICAgcmV0dXJuIChzZWdtZW50LmZyb20ueCAtIHhPZmZzZXQpO1xuICB9IFxuICB4T2Zmc2V0ID0gZHkyICogKGR4IC8gZHkpO1xuICByZXR1cm4gKHNlZ21lbnQudG8ueCArIHhPZmZzZXQpO1xufVxuXG5mdW5jdGlvbiBhbmdsZShkeCwgZHkpIHtcbiAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTY1NDIwNDIvZmFzdGVzdC13YXktdG8tc29ydC12ZWN0b3JzLWJ5LWFuZ2xlLXdpdGhvdXQtYWN0dWFsbHktY29tcHV0aW5nLXRoYXQtYW5nbGVcbiAgdmFyIHAgPSBkeC8oTWF0aC5hYnMoZHgpICsgTWF0aC5hYnMoZHkpKTsgLy8gLTEgLi4gMSBpbmNyZWFzaW5nIHdpdGggeFxuXG4gIGlmIChkeSA8IDApIHsgcmV0dXJuIHAgLSAxOyB9ICAvLyAtMiAuLiAwIGluY3JlYXNpbmcgd2l0aCB4XG4gIHJldHVybiAxIC0gcCAgICAgICAgICAgICAgIC8vICAwIC4uIDIgZGVjcmVhc2luZyB3aXRoIHhcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0U2VnbWVudHMoYSwgYikge1xuICAvLyAgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE5NjgzNDUvMTI1MzUxXG4gIHZhciBhU3RhcnQgPSBhLmZyb20sIGJTdGFydCA9IGIuZnJvbTtcbiAgdmFyIHAwX3ggPSBhU3RhcnQueCwgcDBfeSA9IGFTdGFydC55LFxuICAgICAgcDJfeCA9IGJTdGFydC54LCBwMl95ID0gYlN0YXJ0Lnk7XG5cbiAgdmFyIHMxX3ggPSBhLmR4LCBzMV95ID0gYS5keSwgczJfeCA9IGIuZHgsIHMyX3kgPSBiLmR5O1xuICB2YXIgZGl2ID0gczFfeCAqIHMyX3kgLSBzMl94ICogczFfeTtcblxuICB2YXIgcyA9IChzMV95ICogKHAwX3ggLSBwMl94KSAtIHMxX3ggKiAocDBfeSAtIHAyX3kpKSAvIGRpdjtcbiAgaWYgKHMgPCAwIHx8IHMgPiAxKSB7IHJldHVybjsgfVxuXG4gIHZhciB0ID0gKHMyX3ggKiAocDJfeSAtIHAwX3kpICsgczJfeSAqIChwMF94IC0gcDJfeCkpIC8gZGl2O1xuXG4gIGlmICh0ID49IDAgJiYgdCA8PSAxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHAwX3ggLSAodCAqIHMxX3gpLFxuICAgICAgeTogcDBfeSAtICh0ICogczFfeSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2FtZVBvaW50KGEsIGIpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGEueCAtIGIueCkgPCBFUFMgJiYgTWF0aC5hYnMoYS55IC0gYi55KSA8IEVQUztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHN3ZWVwIHN0YXR1cyBkYXRhIHN0cnVjdHVyZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3dlZXBTdGF0dXMob25FcnJvciwgRVBTJCQxKSB7XG4gIHZhciBsYXN0UG9pbnRZLCBwcmV2WTtcbiAgdmFyIGxhc3RQb2ludFgsIHByZXZYO1xuICB2YXIgdXNlQmVsb3cgPSBmYWxzZTtcbiAgdmFyIHN0YXR1cyA9IG5ldyBUcmVlKGNvbXBhcmVTZWdtZW50cyk7XG5cbiAgLy8gVG8gc2F2ZSBvbiBHQyB3ZSByZXR1cm4gbXV0YWJsZSBvYmplY3QuXG4gIHZhciBjdXJyZW50Qm91bmRhcnkgPSB7XG4gICAgYmVmb3JlTGVmdDogbnVsbCxcbiAgICBsZWZ0OiBudWxsLFxuICAgIHJpZ2h0OiBudWxsLFxuICAgIGFmdGVyUmlnaHQ6IG51bGwsXG4gIH07XG5cbiAgdmFyIGN1cnJlbnRMZWZ0UmlnaHQgPSB7bGVmdDogbnVsbCwgcmlnaHQ6IG51bGx9O1xuXG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogQWRkIG5ldyBzZWdtZW50cyBpbnRvIHRoZSBzdGF0dXMgdHJlZS5cbiAgICAgKi9cbiAgICBpbnNlcnRTZWdtZW50czogaW5zZXJ0U2VnbWVudHMsXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgc2VnbWVudHMgZnJvbSB0aGUgc3RhdHVzIHRyZWUuXG4gICAgICovXG4gICAgZGVsZXRlU2VnbWVudHM6IGRlbGV0ZVNlZ21lbnRzLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzZWdtZW50cyB0aGF0IGFyZSB0byB0aGUgbGVmdCBhbmQgcmlnaHQgZnJvbSBhIGdpdmVuIHBvaW50LlxuICAgICAqL1xuICAgIGdldExlZnRSaWdodFBvaW50OiBnZXRMZWZ0UmlnaHRQb2ludCxcblxuICAgIC8qKlxuICAgICAqIEZvciBhIGdpdmVuIGNvbGxlY3Rpb25zIG9mIHNlZ21lbnRzIGZpbmRzIHRoZSBtb3N0IGxlZnQgYW5kIHRoZSBtb3N0IHJpZ2h0XG4gICAgICogc2VnbWVudHMuIEFsc28gcmV0dXJucyBzZWdtZW50cyBpbW1lZGlhdGVseSBiZWZvcmUgbGVmdCwgYW5kIGFmdGVyIHJpZ2h0IHNlZ21lbnRzLlxuICAgICAqL1xuICAgIGdldEJvdW5kYXJ5U2VnbWVudHM6IGdldEJvdW5kYXJ5U2VnbWVudHMsXG5cbiAgICBmaW5kU2VnbWVudHNXaXRoUG9pbnQ6IGZpbmRTZWdtZW50c1dpdGhQb2ludCxcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgYmluYXJ5IHNlYXJjaCB0cmVlIHdpdGggc2VnbWVudHNcbiAgICAgKi9cbiAgICBzdGF0dXM6IHN0YXR1cyxcblxuICAgIC8qKlxuICAgICAqIEludHJvc3BlY3Rpb24gbWV0aG9kIHRoYXQgdmVyaWZpZXMgaWYgdGhlcmUgYXJlIGR1cGxpY2F0ZXMgaW4gdGhlIHNlZ21lbnQgdHJlZS5cbiAgICAgKiBJZiB0aGVyZSBhcmUgLSBgb25FcnJvcigpYCBpcyBjYWxsZWQuXG4gICAgICovXG4gICAgY2hlY2tEdXBsaWNhdGU6IGNoZWNrRHVwbGljYXRlLFxuXG4gICAgLyoqXG4gICAgICogUHJpbnRzIGN1cnJlbnQgc2VnbWVudHMgaW4gb3JkZXIgb2YgdGhlaXIgaW50ZXJzZWN0aW9uIHdpdGggc3dlZXAgbGluZS4gSW50cm9zcGVjdGlvbiBtZXRob2QuXG4gICAgICovXG4gICAgcHJpbnRTdGF0dXM6IHByaW50U3RhdHVzLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBzd2VlcCBsaW5lLlxuICAgICAqL1xuICAgIGdldExhc3RQb2ludDogZnVuY3Rpb24gZ2V0TGFzdFBvaW50KCkge1xuICAgICAgcmV0dXJuIHt4OiBsYXN0UG9pbnRYLCB5OiBsYXN0UG9pbnRZfTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21wYXJlU2VnbWVudHMoYSwgYikge1xuICAgIGlmIChhID09PSBiKSB7IHJldHVybiAwOyB9XG5cbiAgICB2YXIgYWsgPSBnZXRJbnRlcnNlY3Rpb25YUG9pbnQoYSwgbGFzdFBvaW50WCwgbGFzdFBvaW50WSk7XG4gICAgdmFyIGJrID0gZ2V0SW50ZXJzZWN0aW9uWFBvaW50KGIsIGxhc3RQb2ludFgsIGxhc3RQb2ludFkpO1xuXG4gICAgdmFyIHJlcyA9IGFrIC0gYms7XG4gICAgaWYgKE1hdGguYWJzKHJlcykgPj0gRVBTJCQxKSB7XG4gICAgICAvLyBXZSBhcmUgb2theSBmaW5lLiBJbnRlcnNlY3Rpb24gZGlzdGFuY2UgYmV0d2VlbiB0d28gc2VnbWVudHNcbiAgICAgIC8vIGlzIGdvb2QgdG8gZ2l2ZSBjb25jbHVzaXZlIGFuc3dlclxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICB2YXIgYUlzSG9yaXpvbnRhbCA9IE1hdGguYWJzKGEuZHkpIDwgRVBTJCQxO1xuICAgIHZhciBiSXNIb3Jpem9udGFsID0gTWF0aC5hYnMoYi5keSkgPCBFUFMkJDE7XG4gICAgaWYgKGFJc0hvcml6b250YWwgJiYgYklzSG9yaXpvbnRhbCkge1xuICAgICAgcmV0dXJuIGIudG8ueCAtIGEudG8ueDtcbiAgICB9XG4gICAgLy8gVE9ETzogV2hhdCBpZiBib3RoIGEgYW5kIGIgaXMgaG9yaXpvbnRhbD9cbiAgICAvLyBtb3ZlIGhvcml6b250YWwgdG8gZW5kXG4gICAgaWYgKGFJc0hvcml6b250YWwpIHsgXG4gICAgICByZXR1cm4gdXNlQmVsb3cgPyAtMSA6IDE7XG4gICAgfVxuXG4gICAgaWYgKGJJc0hvcml6b250YWwpIHtcbiAgICAgIGlmICh1c2VCZWxvdykge1xuICAgICAgICByZXR1cm4gKGIuZnJvbS54ID49IGxhc3RQb2ludFgpID8gLTEgOiAxXG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgICAvLyByZXR1cm4gdXNlQmVsb3cgPyAxIDogLTE7XG4gICAgfVxuICAgIHZhciBwYSA9IGEuYW5nbGU7XG4gICAgdmFyIHBiID0gYi5hbmdsZTtcbiAgICBpZiAoTWF0aC5hYnMocGEgLSBwYikgPj0gRVBTJCQxKSB7XG4gICAgICByZXR1cm4gdXNlQmVsb3cgPyBwYSAtIHBiIDogcGIgLSBwYTtcbiAgICB9XG5cbiAgICB2YXIgc2VnRGlzdCA9IGEuZnJvbS55IC0gYi5mcm9tLnk7XG4gICAgaWYgKE1hdGguYWJzKHNlZ0Rpc3QpID49IEVQUyQkMSkge1xuICAgICAgcmV0dXJuIC1zZWdEaXN0O1xuICAgIH1cbiAgICBzZWdEaXN0ID0gYS50by55IC0gYi50by55O1xuICAgIGlmIChNYXRoLmFicyhzZWdEaXN0KSA+PSBFUFMkJDEpIHtcbiAgICAgIC8vIFRPRE86IElzIHRoaXMgYWNjdXJhdGU/XG4gICAgICByZXR1cm4gLXNlZ0Rpc3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gICAgLy8gQ291bGQgYWxzbyB1c2U6XG4gICAgLy8gdmFyIGFBbmdsZSA9IE1hdGguYXRhbjIoYS5mcm9tLnkgLSBhLnRvLnksIGEuZnJvbS54IC0gYS50by54KTtcbiAgICAvLyB2YXIgYkFuZ2xlID0gTWF0aC5hdGFuMihiLmZyb20ueSAtIGIudG8ueSwgYi5mcm9tLnggLSBiLnRvLngpO1xuICAgIC8vIHJldHVybiB1c2VCZWxvdyA/IGJBbmdsZSAtIGFBbmdsZSA6IGFBbmdsZSAtIGJBbmdsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEJvdW5kYXJ5U2VnbWVudHModXBwZXIsIGludGVyaW9yKSB7XG4gICAgdmFyIGxlZnRNb3N0LCByaWdodE1vc3QsIGk7XG4gICAgdmFyIHVMZW5ndGggPSB1cHBlci5sZW5ndGg7XG5cbiAgICBpZiAodUxlbmd0aCA+IDApIHtcbiAgICAgIGxlZnRNb3N0ID0gcmlnaHRNb3N0ID0gdXBwZXJbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnRNb3N0ID0gcmlnaHRNb3N0ID0gaW50ZXJpb3JbMF07XG4gICAgfVxuXG4gICAgZm9yIChpID0gMTsgaSA8IHVMZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHMgPSB1cHBlcltpXTtcbiAgICAgIHZhciBjbXAgPSBjb21wYXJlU2VnbWVudHMobGVmdE1vc3QsIHMpO1xuICAgICAgaWYgKGNtcCA+IDApIHsgbGVmdE1vc3QgPSBzOyB9XG5cbiAgICAgIGNtcCA9IGNvbXBhcmVTZWdtZW50cyhyaWdodE1vc3QsIHMpO1xuICAgICAgaWYgKGNtcCA8IDApIHsgcmlnaHRNb3N0ID0gczsgfVxuICAgIH1cblxuICAgIHZhciBzdGFydEZyb20gPSB1TGVuZ3RoID4gMCA/IDAgOiAxO1xuICAgIGZvciAoaSA9IHN0YXJ0RnJvbTsgaSA8IGludGVyaW9yLmxlbmd0aDsgKytpKSB7XG4gICAgICBzID0gaW50ZXJpb3JbaV07XG4gICAgICBjbXAgPSBjb21wYXJlU2VnbWVudHMobGVmdE1vc3QsIHMpO1xuICAgICAgaWYgKGNtcCA+IDApIHsgbGVmdE1vc3QgPSBzOyB9XG5cbiAgICAgIGNtcCA9IGNvbXBhcmVTZWdtZW50cyhyaWdodE1vc3QsIHMpO1xuICAgICAgaWYgKGNtcCA8IDApIHsgcmlnaHRNb3N0ID0gczsgfVxuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBvdXIgbGVmdC9yaWdodCBzZWdtZW50cyBpbiB0aGUgc3RhdHVzLlxuICAgIC8vIExldCdzIGZpbmQgdGhlaXIgcHJldi9uZXh0IGVsZW1lbnRzIGFuZCByZXBvcnQgdGhlbSBiYWNrOlxuICAgIHZhciBsZWZ0ID0gc3RhdHVzLmZpbmQobGVmdE1vc3QpO1xuICAgIGlmICghbGVmdCkge1xuICAgICAgb25FcnJvcignTGVmdCBpcyBtaXNzaW5nLiBQcmVjaXNpb24gZXJyb3I/Jyk7XG4gICAgfVxuXG4gICAgdmFyIHJpZ2h0ID0gc3RhdHVzLmZpbmQocmlnaHRNb3N0KTtcbiAgICBpZiAoIXJpZ2h0KSB7XG4gICAgICBvbkVycm9yKCdSaWdodCBpcyBtaXNzaW5nLiBQcmVjaXNpb24gZXJyb3I/Jyk7XG4gICAgfVxuXG4gICAgdmFyIGJlZm9yZUxlZnQgPSBsZWZ0ICYmIHN0YXR1cy5wcmV2KGxlZnQpO1xuICAgIHZhciBhZnRlclJpZ2h0ID0gcmlnaHQgJiYgc3RhdHVzLm5leHQocmlnaHQpO1xuXG4gICAgd2hpbGUgKGFmdGVyUmlnaHQgJiYgcmlnaHQua2V5LmR5ID09PSAwICYmIGFmdGVyUmlnaHQua2V5LmR5ID09PSAwKSB7XG4gICAgICAvLyBob3Jpem9udGFsIHNlZ21lbnRzIGFyZSBzcGVjaWFsIDooXG4gICAgICBhZnRlclJpZ2h0ID0gc3RhdHVzLm5leHQoYWZ0ZXJSaWdodCk7XG4gICAgfVxuXG4gICAgY3VycmVudEJvdW5kYXJ5LmJlZm9yZUxlZnQgPSBiZWZvcmVMZWZ0ICYmIGJlZm9yZUxlZnQua2V5O1xuICAgIGN1cnJlbnRCb3VuZGFyeS5sZWZ0ID0gbGVmdCAmJiBsZWZ0LmtleTtcbiAgICBjdXJyZW50Qm91bmRhcnkucmlnaHQgPSByaWdodCAmJiByaWdodC5rZXk7XG4gICAgY3VycmVudEJvdW5kYXJ5LmFmdGVyUmlnaHQgPSBhZnRlclJpZ2h0ICYmIGFmdGVyUmlnaHQua2V5O1xuXG4gICAgcmV0dXJuIGN1cnJlbnRCb3VuZGFyeTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExlZnRSaWdodFBvaW50KHApIHtcbiAgICAvLyBXZSBhcmUgdHJ5aW5nIHRvIGZpbmQgbGVmdCBhbmQgcmlnaHQgc2VnbWVudHMgdGhhdCBhcmUgbmVhcmVzdCB0byB0aGVcbiAgICAvLyBwb2ludCBwLiBGb3IgdGhpcyB3ZSB0cmF2ZXJzZSB0aGUgYmluYXJ5IHNlYXJjaCB0cmVlLCBhbmQgcmVtZW1iZXJcbiAgICAvLyBub2RlIHdpdGggdGhlIHNob3J0ZXN0IGRpc3RhbmNlIHRvIHAuXG4gICAgdmFyIGxhc3RMZWZ0O1xuICAgIHZhciBjdXJyZW50ID0gc3RhdHVzLl9yb290O1xuICAgIHZhciBtaW5YID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICB2YXIgeCA9IGdldEludGVyc2VjdGlvblhQb2ludChjdXJyZW50LmtleSwgcC54LCBwLnkpO1xuICAgICAgdmFyIGR4ID0gcC54IC0geDtcbiAgICAgIGlmIChkeCA+PSAwKSB7XG4gICAgICAgIGlmIChkeCA8IG1pblgpIHtcbiAgICAgICAgICBtaW5YID0gZHg7XG4gICAgICAgICAgbGFzdExlZnQgPSBjdXJyZW50O1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgtZHggPCBtaW5YKSB7XG4gICAgICAgICAgbWluWCA9IC1keDtcbiAgICAgICAgICBsYXN0TGVmdCA9IGN1cnJlbnQ7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50TGVmdFJpZ2h0LmxlZnQgPSBsYXN0TGVmdCAmJiBsYXN0TGVmdC5rZXk7XG4gICAgdmFyIG5leHQgPSBsYXN0TGVmdCAmJiBzdGF0dXMubmV4dChsYXN0TGVmdCk7XG4gICAgY3VycmVudExlZnRSaWdodC5yaWdodCA9IG5leHQgJiYgbmV4dC5rZXk7XG4gICAgcmV0dXJuIGN1cnJlbnRMZWZ0UmlnaHQ7XG5cbiAgICAvLyBDb25jZXB0dWFsbHksIHRoZSBjb2RlIGFib3ZlIHNob3VsZCBiZSBlcXVpdmFsZW50IHRvIHRoZSBjb2RlIGJlbG93O1xuICAgIC8vIFRoZSBjb2RlIGJlbG93IGlzIGVhc2llciB0byB1bmRlcnN0YW5kLCBidXQgaW50dWl0aXZlbHksIHRoZSBjb2RlIGFib3ZlXG4gICAgLy8gc2hvdWxkIGhhdmUgYmV0dGVyIHBlcmZvcm1hbmNlIChhcyB3ZSBkbyBub3QgdHJhdmVyc2UgdGhlIGVudGlyZSBzdGF0dXNcbiAgICAvLyB0cmVlKVxuXG4gICAgLy8gdmFyIHJpZ2h0LCBsZWZ0LCAgeDtcbiAgICAvLyB2YXIgYWxsID0gc3RhdHVzLmtleXMoKVxuICAgIC8vIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gICB2YXIgc2VnbWVudCA9IGFsbFtpXTtcbiAgICAvLyAgIHggPSBnZXRJbnRlcnNlY3Rpb25YUG9pbnQoc2VnbWVudCwgcC54LCBwLnkpO1xuICAgIC8vICAgaWYgKHggPiBwLnggJiYgIXJpZ2h0KSB7XG4gICAgLy8gICAgIHJpZ2h0ID0gc2VnbWVudDtcbiAgICAvLyAgICAgYnJlYWs7XG4gICAgLy8gICB9IGVsc2UgaWYgKHggPCBwLngpIHtcbiAgICAvLyAgICAgbGVmdCA9IHNlZ21lbnQ7XG4gICAgLy8gICB9XG4gICAgLy8gfVxuXG4gICAgLy8gY3VycmVudExlZnRSaWdodC5sZWZ0ID0gbGVmdDtcbiAgICAvLyBjdXJyZW50TGVmdFJpZ2h0LnJpZ2h0ID0gcmlnaHQ7XG5cbiAgICAvLyByZXR1cm4gY3VycmVudExlZnRSaWdodDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRTZWdtZW50c1dpdGhQb2ludChwLCBvbkZvdW5kKSB7XG4gICAgLy8gT3B0aW9uIDEuXG4gICAgLy8gdmFyIGFyclJlc3VsdHMgPSBbXTtcbiAgICAvLyBzdGF0dXMuZm9yRWFjaChjdXJyZW50ID0+IHtcbiAgICAvLyAgIHZhciB4ID0gZ2V0SW50ZXJzZWN0aW9uWFBvaW50KGN1cnJlbnQua2V5LCBwLngsIHAueSk7XG4gICAgLy8gICB2YXIgZHggPSBwLnggLSB4O1xuICAgIC8vICAgaWYgKE1hdGguYWJzKGR4KSA8IEVQUykge1xuICAgIC8vICAgICBvbkZvdW5kKGN1cnJlbnQua2V5KTtcbiAgICAvLyAgICAvLyBhcnJSZXN1bHRzLnB1c2goY3VycmVudC5rZXkpXG4gICAgLy8gICB9XG4gICAgLy8gfSk7XG4gICAgLy8gcmV0dXJuIGFyclJlc3VsdHM7XG5cbiAgICAvLyBPcHRpb24gMi5cblxuICAgIC8vIGxldCBjdXJyZW50ID0gc3RhdHVzLl9yb290O1xuICAgIC8vIGNvbnN0IFEgPSBbXTsgIC8qIEluaXRpYWxpemUgc3RhY2sgcyAqL1xuICAgIC8vIGxldCBkb25lID0gZmFsc2U7XG4gICAgLy8gdmFyIHJlcyA9IFtdO1xuICAgIC8vIHZhciBicmVha0Vhcmx5ID0gZmFsc2U7XG5cbiAgICAvLyB3aGlsZSAoIWRvbmUpIHtcbiAgICAvLyAgIGlmIChjdXJyZW50ICE9PSAgbnVsbCkge1xuICAgIC8vICAgICBRLnB1c2goY3VycmVudCk7XG4gICAgLy8gICAgIGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7XG4gICAgLy8gICB9IGVsc2Uge1xuICAgIC8vICAgICBpZiAoUS5sZW5ndGggIT09IDApIHtcbiAgICAvLyAgICAgICBjdXJyZW50ID0gUS5wb3AoKTtcblxuICAgIC8vICAgICAgIHZhciB4ID0gZ2V0SW50ZXJzZWN0aW9uWFBvaW50KGN1cnJlbnQua2V5LCBwLngsIHAueSk7XG4gICAgLy8gICAgICAgdmFyIGR4ID0gcC54IC0geDtcbiAgICAvLyAgICAgICBpZiAoTWF0aC5hYnMoZHgpIDwgRVBTKSB7XG4gICAgLy8gICAgICAgICByZXMucHVzaChjdXJyZW50LmtleSlcbiAgICAvLyAgICAgICAgIGJyZWFrRWFybHkgPSB0cnVlO1xuICAgIC8vICAgICAgIH0gZWxzZSBpZiAoYnJlYWtFYXJseSkge1xuICAgIC8vICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgLy8gICAgICAgfVxuXG4gICAgLy8gICAgICAgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7XG4gICAgLy8gICAgIH0gZWxzZSBkb25lID0gdHJ1ZTtcbiAgICAvLyAgIH1cbiAgICAvLyB9XG5cbiAgICAvLyByZXR1cm4gcmVzO1xuXG4gICAgLy8gb3B0aW9uIDMuXG4gICAgdmFyIGN1cnJlbnQgPSBzdGF0dXMuX3Jvb3Q7XG5cbiAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgdmFyIHggPSBnZXRJbnRlcnNlY3Rpb25YUG9pbnQoY3VycmVudC5rZXksIHAueCwgcC55KTtcbiAgICAgIHZhciBkeCA9IHAueCAtIHg7XG4gICAgICBpZiAoTWF0aC5hYnMoZHgpIDwgRVBTJCQxKSB7XG4gICAgICAgIGNvbGxlY3RBZGphY2VudE5vZGVzKGN1cnJlbnQsIHAsIG9uRm91bmQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoZHggPCAwKSB7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb2xsZWN0QWRqYWNlbnROb2Rlcyhyb290LCBwLCBvbkZvdW5kKSB7XG4gICAgb25Gb3VuZChyb290LmtleSk7XG4gICAgZ29PdmVyUHJlZGVjZXNzb3JzKHJvb3QubGVmdCwgcCwgb25Gb3VuZCk7XG4gICAgZ29PdmVyU3VjY2Vzc29ycyhyb290LnJpZ2h0LCBwLCBvbkZvdW5kKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvT3ZlclByZWRlY2Vzc29ycyhyb290LCBwLCByZXMpIHtcbiAgICBpZiAoIXJvb3QpIHsgcmV0dXJuOyB9XG4gICAgdmFyIHggPSBnZXRJbnRlcnNlY3Rpb25YUG9pbnQocm9vdC5rZXksIHAueCwgcC55KTtcbiAgICB2YXIgZHggPSBwLnggLSB4O1xuICAgIGlmIChNYXRoLmFicyhkeCkgPCBFUFMkJDEpIHtcbiAgICAgIGNvbGxlY3RBZGphY2VudE5vZGVzKHJvb3QsIHAsIHJlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdvT3ZlclByZWRlY2Vzc29ycyhyb290LnJpZ2h0LCBwLCByZXMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdvT3ZlclN1Y2Nlc3NvcnMocm9vdCwgcCwgcmVzKSB7XG4gICAgaWYgKCFyb290KSB7IHJldHVybjsgfVxuICAgIHZhciB4ID0gZ2V0SW50ZXJzZWN0aW9uWFBvaW50KHJvb3Qua2V5LCBwLngsIHAueSk7XG4gICAgdmFyIGR4ID0gcC54IC0geDtcbiAgICBpZiAoTWF0aC5hYnMoZHgpIDwgRVBTJCQxKSB7XG4gICAgICBjb2xsZWN0QWRqYWNlbnROb2Rlcyhyb290LCBwLCByZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnb092ZXJTdWNjZXNzb3JzKHJvb3QubGVmdCwgcCwgcmVzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZSgpIHtcbiAgICB2YXIgcHJldjtcbiAgICBzdGF0dXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBub2RlLmtleTtcblxuICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgaWYgKHNhbWVQb2ludChwcmV2LmZyb20sIGN1cnJlbnQuZnJvbSkgJiYgc2FtZVBvaW50KHByZXYudG8sIGN1cnJlbnQudG8pKSB7XG4gICAgICAgICAgLy8gTGlrZWx5IHlvdSBoYXZlIHJlY2VpdmVkIGVycm9yIGJlZm9yZSBkdXJpbmcgc2VnbWVudCByZW1vdmFsLlxuICAgICAgICAgIG9uRXJyb3IoJ0R1cGxpY2F0ZSBrZXkgaW4gdGhlIHN0YXR1cyEgVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IEZsb2F0aW5nIFBvaW50IHJvdW5kaW5nIGVycm9yJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByZXYgPSBjdXJyZW50O1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRTdGF0dXMocHJlZml4KSB7XG4gICAgaWYgKCBwcmVmaXggPT09IHZvaWQgMCApIHByZWZpeCA9ICcnO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgY29uc29sZS5sb2cocHJlZml4LCAnc3RhdHVzIGxpbmU6ICcsIGxhc3RQb2ludFgsIGxhc3RQb2ludFkpO1xuICAgIHN0YXR1cy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgeCA9IGdldEludGVyc2VjdGlvblhQb2ludChub2RlLmtleSwgbGFzdFBvaW50WCwgbGFzdFBvaW50WSk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIGNvbnNvbGUubG9nKHggKyAnICcgKyBub2RlLmtleS5uYW1lKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydFNlZ21lbnRzKGludGVyaW9yLCB1cHBlciwgc3dlZXBMaW5lUG9zKSB7XG4gICAgbGFzdFBvaW50WSA9IHN3ZWVwTGluZVBvcy55O1xuICAgIGxhc3RQb2ludFggPSBzd2VlcExpbmVQb3MueDtcbiAgICB2YXIga2V5O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnRlcmlvci5sZW5ndGg7ICsraSkge1xuICAgICAga2V5ID0gaW50ZXJpb3JbaV07XG4gICAgICBzdGF0dXMuYWRkKGtleSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCB1cHBlci5sZW5ndGg7ICsraSkge1xuICAgICAga2V5ID0gdXBwZXJbaV07XG4gICAgICBzdGF0dXMuYWRkKGtleSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlU2VnbWVudHMobG93ZXIsIGludGVyaW9yLCBzd2VlcExpbmVQb3MpIHtcbiAgICAvLyBJIHNwZW50IG1vc3Qgb2YgdGhlIHRpbWUgZGVidWdnaW5nIHRoaXMgbWV0aG9kLiBEZXBlbmRpbmcgb24gdGhlXG4gICAgLy8gYWxnb3JpdGhtIHN0YXRlIHdlIGNhbiBydW4gaW50byBzaXR1YXRpb24gd2hlbiBkeW5hbWljIGtleXMgb2YgdGhlXG4gICAgLy8gYHN0YXR1c2AgdHJlZSBwcmVkaWN0IHdyb25nIGJyYW5jaCwgYW5kIHRodXMgd2UgYXJlIG5vdCBhYmxlIHRvIGZpbmRcbiAgICAvLyB0aGUgc2VnbWVudCB0aGF0IG5lZWRzIHRvIGJlIGRlbGV0ZWQuIElmIHRoYXQgaGFwcGVucyBJJ20gdHJ5aW5nIHRvXG4gICAgLy8gdXNlIHByZXZpb3VzIHBvaW50IGFuZCByZXBlYXQgdGhlIHByb2Nlc3MuIFRoaXMgbWF5IHJlc3VsdCBpbiBcbiAgICAvLyBpbmNvcnJlY3Qgc3RhdGUuIEluIHRoYXQgY2FzZSBJIHJlcG9ydCBhbiBlcnJvci4gXG4gICAgdmFyIGk7XG4gICAgdmFyIHByZXZDb3VudCA9IHN0YXR1cy5fc2l6ZTtcbiAgICBwcmV2WCA9IGxhc3RQb2ludFg7XG4gICAgcHJldlkgPSBsYXN0UG9pbnRZO1xuICAgIGxhc3RQb2ludFkgPSBzd2VlcExpbmVQb3MueTtcbiAgICBsYXN0UG9pbnRYID0gc3dlZXBMaW5lUG9zLng7XG5cbiAgICB1c2VCZWxvdyA9IHRydWU7XG4gICAgZm9yKGkgPSAwOyBpIDwgbG93ZXIubGVuZ3RoOyArK2kpIHtcbiAgICAgIHJlbW92ZVNlZ21lbnQobG93ZXJbaV0sIHN3ZWVwTGluZVBvcyk7XG4gICAgfVxuICAgIGZvcihpID0gMDsgaSA8IGludGVyaW9yLmxlbmd0aDsgKytpKSB7XG4gICAgICByZW1vdmVTZWdtZW50KGludGVyaW9yW2ldLCBzd2VlcExpbmVQb3MpO1xuICAgIH1cbiAgICB1c2VCZWxvdyA9IGZhbHNlO1xuXG4gICAgaWYgKHN0YXR1cy5fc2l6ZSAhPT0gcHJldkNvdW50IC0gaW50ZXJpb3IubGVuZ3RoIC0gbG93ZXIubGVuZ3RoKSB7XG4gICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiByb3VuZGluZyBlcnJvciBvY2N1cnMuIFlvdSBjYW4gdHJ5IHNjYWxpbmcgeW91ciBpbnB1dFxuICAgICAgb25FcnJvcignU2VnbWVudHMgd2VyZSBub3QgcmVtb3ZlZCBmcm9tIGEgdHJlZSBwcm9wZXJseS4gUHJlY2lzaW9uIGVycm9yPycpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVNlZ21lbnQoa2V5LCBzd2VlcExpbmVQb3MpIHtcbiAgICBpZiAoc3RhdHVzLmZpbmQoa2V5KSkge1xuICAgICAgc3RhdHVzLnJlbW92ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0UG9pbnRYID0gcHJldlg7XG4gICAgICBsYXN0UG9pbnRZID0gcHJldlk7XG4gICAgICBpZiAoc3RhdHVzLmZpbmQoa2V5KSkge1xuICAgICAgICBzdGF0dXMucmVtb3ZlKGtleSk7XG4gICAgICB9XG4gICAgICBsYXN0UG9pbnRZID0gc3dlZXBMaW5lUG9zLnk7XG4gICAgICBsYXN0UG9pbnRYID0gc3dlZXBMaW5lUG9zLng7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHNpbmdsZSBldmVudCBpbiB0aGUgc3dlZXAtbGluZSBhbGdvcml0aG1cbiAqL1xudmFyIFN3ZWVwRXZlbnQgPSBmdW5jdGlvbiBTd2VlcEV2ZW50KHBvaW50LCBzZWdtZW50KSB7XG4gIHRoaXMucG9pbnQgPSBwb2ludDtcbiAgaWYgKHNlZ21lbnQpIHsgdGhpcy5mcm9tID0gW3NlZ21lbnRdOyB9XG59O1xuXG4vKipcbiAqIEEgcG9pbnQgb24gYSBsaW5lXG4gKiBcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBvaW50XG4gKiBAcHJvcGVydHkge251bWJlcn0geCBjb29yZGluYXRlXG4gKiBAcHJvcGVydHkge251bWJlcn0geSBjb29yZGluYXRlXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNlZ21lbnQgXG4gKiBAcHJvcGVydHkge1BvaW50fSBmcm9tIHN0YXJ0IG9mIHRoZSBzZWdtZW50XG4gKiBAcHJvcGVydHkge1BvaW50fSB0byBlbmQgb2YgdGhlIHNlZ21lbnRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihwb2ludCA6IFBvaW50LCBpbnRlcmlvciA6IFNlZ21lbnRbXSwgbG93ZXIgOiBTZWdtZW50W10sIHVwcGVyIDogU2VnbWVudFtdKX0gUmVwb3J0SW50ZXJzZWN0aW9uQ2FsbGJhY2tcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IElTZWN0T3B0aW9ucyBcbiAqIEBwcm9wZXJ0eSB7UmVwb3J0SW50ZXJzZWN0aW9uQ2FsbGJhY2t9IG9uRm91bmQgXG4gKi9cblxuIC8qKlxuICAqIEB0eXBlZGVmIHtPYmplY3R9IElTZWN0UmVzdWx0XG4gICovXG5cbi8vIFdlIHVzZSBFTVBUWSBhcnJheSB0byBhdm9pZCBwcmVzc3VyZSBvbiBnYXJiYWdlIGNvbGxlY3Rvci4gTmVlZCB0byBiZVxuLy8gdmVyeSBjYXV0aW91cyB0byBub3QgbXV0YXRlIHRoaXMgYXJyYXkuXG52YXIgRU1QVFkgPSBbXTtcblxuLyoqXG4gKiBGaW5kcyBhbGwgaW50ZXJzZWN0aW9ucyBhbW9uZyBnaXZlbiBzZWdtZW50cy5cbiAqIFxuICogVGhlIGFsZ29yaXRobSBmb2xsb3dzIFwiQ29tcHV0YXRpb24gR2VvbWV0cnksIEFsZ29yaXRobXMgYW5kIEFwcGxpY2F0aW9uc1wiIGJvb2tcbiAqIGJ5IE1hcmsgZGUgQmVyZywgT3RmcmllZCBDaGVvbmcsIE1hcmMgdmFuIEtyZXZlbGQsIGFuZCBNYXJrIE92ZXJtYXJzLlxuICogXG4gKiBMaW5lIGlzIHN3ZXB0IHRvcC1kb3duXG4gKiBcbiAqIEBwYXJhbSB7U2VnbWVudFtdfSBzZWdtZW50c1xuICogQHBhcmFtIHtJU2VjdE9wdGlvbnM9fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7SVNlY3RSZXN1bHR9XG4gKi9cbmZ1bmN0aW9uIGlzZWN0KHNlZ21lbnRzLCBvcHRpb25zKSB7XG4gIHZhciByZXN1bHRzID0gW107XG4gIHZhciByZXBvcnRJbnRlcnNlY3Rpb24gPSAob3B0aW9ucyAmJiBvcHRpb25zLm9uRm91bmQpIHx8IGRlZmF1bHRJbnRlcnNlY3Rpb25SZXBvcnRlcjtcblxuICB2YXIgb25FcnJvciA9IChvcHRpb25zICYmIG9wdGlvbnMub25FcnJvcikgfHwgZGVmYXVsdEVycm9yUmVwb3J0ZXI7XG5cbiAgdmFyIGV2ZW50UXVldWUgPSBjcmVhdGVFdmVudFF1ZXVlKGJ5WSk7XG4gIHZhciBzd2VlcFN0YXR1cyA9IGNyZWF0ZVN3ZWVwU3RhdHVzKG9uRXJyb3IsIEVQUyk7XG4gIHZhciBsb3dlciwgaW50ZXJpb3IsIGxhc3RQb2ludDtcblxuICBzZWdtZW50cy5mb3JFYWNoKGFkZFNlZ21lbnQpO1xuXG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogRmluZCBhbGwgaW50ZXJzZWN0aW9ucyBzeW5jaHJvbm91c2x5LlxuICAgICAqIFxuICAgICAqIEByZXR1cm5zIGFycmF5IG9mIGZvdW5kIGludGVyc2VjdGlvbnMuXG4gICAgICovXG4gICAgcnVuOiBydW4sXG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIHNpbmdsZSBzdGVwIGluIHRoZSBzd2VlcCBsaW5lIGFsZ29yaXRobVxuICAgICAqIFxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlcmUgd2FzIHNvbWV0aGluZyB0byBwcm9jZXNzOyBGYWxzZSBpZiBubyBtb3JlIHdvcmsgdG8gZG9cbiAgICAgKi9cbiAgICBzdGVwOiBzdGVwLFxuXG4gICAgLy8gTWV0aG9kcyBiZWxvdyBhcmUgbG93IGxldmVsIEFQSSBmb3IgZmluZS1ncmFpbmVkIGNvbnRyb2wuXG4gICAgLy8gRG9uJ3QgdXNlIGl0IHVubGVzcyB5b3UgdW5kZXJzdGFuZCB0aGlzIGNvZGUgdGhvcm91Z2hseVxuXG4gICAgLyoqXG4gICAgICogQWRkIHNlZ21lbnQgaW50byB0aGUgXG4gICAgICovXG4gICAgYWRkU2VnbWVudDogYWRkU2VnbWVudCxcblxuICAgIC8qKlxuICAgICAqIERpcmVjdCBhY2Nlc3MgdG8gZXZlbnQgcXVldWUuIFF1ZXVlIGNvbnRhaW5zIHNlZ21lbnQgZW5kcG9pbnRzIGFuZFxuICAgICAqIHBlbmRpbmcgZGV0ZWN0ZWQgaW50ZXJzZWN0aW9ucy5cbiAgICAgKi9cbiAgICBldmVudFF1ZXVlOiBldmVudFF1ZXVlLCBcblxuICAgIC8qKlxuICAgICAqIERpcmVjdCBhY2Nlc3MgdG8gc3dlZXAgbGluZSBzdGF0dXMuIFwiU3RhdHVzXCIgaG9sZHMgaW5mb3JtYXRpb24gYWJvdXRcbiAgICAgKiBhbGwgaW50ZXJzZWN0ZWQgc2VnbWVudHMuXG4gICAgICovXG4gICAgc3dlZXBTdGF0dXM6IHN3ZWVwU3RhdHVzLFxuXG4gICAgLyoqXG4gICAgICogQWNjZXNzIHRvIHJlc3VsdHMgYXJyYXkuIFdvcmtzIG9ubHkgd2hlbiB5b3UgdXNlIGRlZmF1bHQgb25Gb3VuZCgpIGhhbmRsZXJcbiAgICAgKi9cbiAgICByZXN1bHRzOiByZXN1bHRzXG4gIH1cblxuICBmdW5jdGlvbiBydW4oKSB7XG4gICAgd2hpbGUgKCFldmVudFF1ZXVlLmlzRW1wdHkoKSkge1xuICAgICAgdmFyIGV2ZW50UG9pbnQgPSBldmVudFF1ZXVlLnBvcCgpO1xuICAgICAgaWYgKGhhbmRsZUV2ZW50UG9pbnQoZXZlbnRQb2ludCkpIHtcbiAgICAgICAgLy8gdGhleSBkZWNpZGVkIHRvIHN0b3AuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICBmdW5jdGlvbiBzdGVwKCkge1xuICAgIGlmICghZXZlbnRRdWV1ZS5pc0VtcHR5KCkpIHtcbiAgICAgIHZhciBldmVudFBvaW50ID0gZXZlbnRRdWV1ZS5wb3AoKTtcbiAgICAgIGhhbmRsZUV2ZW50UG9pbnQoZXZlbnRQb2ludCk7XG4gICAgICAvLyBOb3RlOiB3ZSBkb24ndCBjaGVjayByZXN1bHRzIG9mIGBoYW5kbGVFdmVudFBvaW50KClgXG4gICAgICAvLyBhc3N1bXB0aW9uIGlzIHRoYXQgY2xpZW50IGNvbnRyb2xzIGBzdGVwKClgIGFuZCB0aHVzIHRoZXkgXG4gICAgICAvLyBrbm93IGJldHRlciBpZiB0aGV5IHdhbnQgdG8gc3RvcC5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVFdmVudFBvaW50KHApIHtcbiAgICBsYXN0UG9pbnQgPSBwLnBvaW50O1xuICAgIHZhciB1cHBlciA9IHAuZnJvbSB8fCBFTVBUWTtcblxuICAgIGxvd2VyID0gaW50ZXJpb3IgPSB1bmRlZmluZWQ7XG4gICAgLy8gVE9ETzogbW92ZSBsb3dlci9pbnRlcmlvciBpbnRvIHN3ZWVwIHN0YXR1cyBtZXRob2Q/XG5cbiAgICBzd2VlcFN0YXR1cy5maW5kU2VnbWVudHNXaXRoUG9pbnQobGFzdFBvaW50LCBhZGRMb3dlck9ySW50ZXJpb3IpO1xuICAgIC8vIGlmIChzZWdtZW50c1dpdGhQb2ludCkge1xuICAgIC8vICAgc2VnbWVudHNXaXRoUG9pbnQuZm9yRWFjaCgpXG4gICAgLy8gfSBcblxuICAgIGlmICghbG93ZXIpIHsgbG93ZXIgPSBFTVBUWTsgfVxuICAgIGlmICghaW50ZXJpb3IpIHsgaW50ZXJpb3IgPSBFTVBUWTsgfVxuXG4gICAgdmFyIHVMZW5ndGggPSB1cHBlci5sZW5ndGg7XG4gICAgdmFyIGlMZW5ndGggPSBpbnRlcmlvci5sZW5ndGg7XG4gICAgdmFyIGxMZW5ndGggPSBsb3dlci5sZW5ndGg7XG4gICAgdmFyIGhhc0ludGVyc2VjdGlvbiA9IHVMZW5ndGggKyBpTGVuZ3RoICsgbExlbmd0aCA+IDE7XG4gICAgdmFyIGhhc1BvaW50SW50ZXJzZWN0aW9uID0gIWhhc0ludGVyc2VjdGlvbiAmJiAodUxlbmd0aCA9PT0gMCAmJiBsTGVuZ3RoID09PSAwICYmIGlMZW5ndGggPiAwKTtcblxuICAgIGlmIChoYXNJbnRlcnNlY3Rpb24gfHwgaGFzUG9pbnRJbnRlcnNlY3Rpb24pIHtcbiAgICAgIHAuaXNSZXBvcnRlZCA9IHRydWU7XG4gICAgICBpZiAocmVwb3J0SW50ZXJzZWN0aW9uKGxhc3RQb2ludCwgdW5pb24oaW50ZXJpb3IsIHVuaW9uKGxvd2VyLCB1cHBlcikpKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2VlcFN0YXR1cy5kZWxldGVTZWdtZW50cyhsb3dlciwgaW50ZXJpb3IsIGxhc3RQb2ludCk7XG4gICAgc3dlZXBTdGF0dXMuaW5zZXJ0U2VnbWVudHMoaW50ZXJpb3IsIHVwcGVyLCBsYXN0UG9pbnQpO1xuXG4gICAgdmFyIHNMZWZ0LCBzUmlnaHQ7XG5cbiAgICB2YXIgaGFzTm9Dcm9zc2luZyA9ICh1TGVuZ3RoICsgaUxlbmd0aCA9PT0gMCk7XG5cbiAgICBpZiAoaGFzTm9Dcm9zc2luZykge1xuICAgICAgdmFyIGxlZnRSaWdodCA9IHN3ZWVwU3RhdHVzLmdldExlZnRSaWdodFBvaW50KGxhc3RQb2ludCk7XG4gICAgICBzTGVmdCA9IGxlZnRSaWdodC5sZWZ0O1xuICAgICAgaWYgKCFzTGVmdCkgeyByZXR1cm47IH1cblxuICAgICAgc1JpZ2h0ID0gbGVmdFJpZ2h0LnJpZ2h0O1xuICAgICAgaWYgKCFzUmlnaHQpIHsgcmV0dXJuOyB9XG5cbiAgICAgIGZpbmROZXdFdmVudChzTGVmdCwgc1JpZ2h0LCBwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJvdW5kYXJ5U2VnbWVudHMgPSBzd2VlcFN0YXR1cy5nZXRCb3VuZGFyeVNlZ21lbnRzKHVwcGVyLCBpbnRlcmlvcik7XG5cbiAgICAgIGZpbmROZXdFdmVudChib3VuZGFyeVNlZ21lbnRzLmJlZm9yZUxlZnQsIGJvdW5kYXJ5U2VnbWVudHMubGVmdCwgcCk7XG4gICAgICBmaW5kTmV3RXZlbnQoYm91bmRhcnlTZWdtZW50cy5yaWdodCwgYm91bmRhcnlTZWdtZW50cy5hZnRlclJpZ2h0LCBwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRMb3dlck9ySW50ZXJpb3Iocykge1xuICAgIGlmIChzYW1lUG9pbnQocy50bywgbGFzdFBvaW50KSkge1xuICAgICAgaWYgKCFsb3dlcikgeyBsb3dlciA9IFtzXTsgfVxuICAgICAgZWxzZSB7IGxvd2VyLnB1c2gocyk7IH1cbiAgICB9IGVsc2UgaWYgKCFzYW1lUG9pbnQocy5mcm9tLCBsYXN0UG9pbnQpKSB7XG4gICAgICBpZiAoIWludGVyaW9yKSB7IGludGVyaW9yID0gW3NdOyB9XG4gICAgICBlbHNlIHsgaW50ZXJpb3IucHVzaChzKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmROZXdFdmVudChsZWZ0LCByaWdodCwgcCkge1xuICAgIGlmICghbGVmdCB8fCAhcmlnaHQpIHsgcmV0dXJuOyB9XG5cbiAgICB2YXIgaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0U2VnbWVudHMobGVmdCwgcmlnaHQpO1xuICAgIGlmICghaW50ZXJzZWN0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZHkgPSBwLnBvaW50LnkgLSBpbnRlcnNlY3Rpb24ueTtcbiAgICAvLyBUT0RPOiBzaG91bGQgSSBhZGQgZHkgdG8gaW50ZXJzZWN0aW9uLnk/XG4gICAgaWYgKGR5IDwgLUVQUykge1xuICAgICAgLy8gdGhpcyBtZWFucyBpbnRlcnNlY3Rpb24gaGFwcGVuZWQgYWZ0ZXIgdGhlIHN3ZWVwIGxpbmUuIFxuICAgICAgLy8gV2UgYWxyZWFkeSBwcm9jZXNzZWQgaXQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChNYXRoLmFicyhkeSkgPCBFUFMgJiYgaW50ZXJzZWN0aW9uLnggPD0gcC5wb2ludC54KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTmVlZCB0byBhZGp1c3QgZmxvYXRpbmcgcG9pbnQgZm9yIHRoaXMgc3BlY2lhbCBjYXNlLFxuICAgIC8vIHNpbmNlIG90aGVyd2lzZSBpdCBnaXZlcyByb3VuZGluZyBlcnJvcnM6XG4gICAgcm91bmROZWFyWmVybyhpbnRlcnNlY3Rpb24pO1xuXG4gICAgdmFyIGN1cnJlbnQgPSBldmVudFF1ZXVlLmZpbmQoaW50ZXJzZWN0aW9uKTtcblxuICAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnQuaXNSZXBvcnRlZCkge1xuICAgICAgLy8gV2UgYWxyZWFkeSByZXBvcnRlZCB0aGlzIGV2ZW50LiBObyBuZWVkIHRvIGFkZCBpdCBvbmUgbW9yZSB0aW1lXG4gICAgICAvLyBUT0RPOiBJcyB0aGlzIGNhc2UgZXZlbiBwb3NzaWJsZT9cbiAgICAgIG9uRXJyb3IoJ1dlIGFscmVhZHkgcmVwb3J0ZWQgdGhpcyBldmVudC4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgIHZhciBldmVudCA9IG5ldyBTd2VlcEV2ZW50KGludGVyc2VjdGlvbik7XG4gICAgICBldmVudFF1ZXVlLmluc2VydChldmVudCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdEludGVyc2VjdGlvblJlcG9ydGVyKHAsIHNlZ21lbnRzKSB7XG4gICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgIHBvaW50OiBwLCBcbiAgICAgIHNlZ21lbnRzOiBzZWdtZW50c1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkU2VnbWVudChzZWdtZW50KSB7XG4gICAgdmFyIGZyb20gPSBzZWdtZW50LmZyb207XG4gICAgdmFyIHRvID0gc2VnbWVudC50bztcblxuICAgIC8vIFNtYWxsIG51bWJlcnMgZ2l2ZSBtb3JlIHByZWNpc2lvbiBlcnJvcnMuIFJvdW5kaW5nIHRoZW0gdG8gMC5cbiAgICByb3VuZE5lYXJaZXJvKGZyb20pO1xuICAgIHJvdW5kTmVhclplcm8odG8pO1xuXG4gICAgdmFyIGR5ID0gZnJvbS55IC0gdG8ueTtcblxuICAgIC8vIE5vdGU6IGR5IGlzIG11Y2ggc21hbGxlciB0aGVuIEVQUyBvbiBwdXJwb3NlLiBJIGZvdW5kIHRoYXQgaGlnaGVyXG4gICAgLy8gcHJlY2lzaW9uIGhlcmUgZG9lcyBsZXNzIGdvb2QgLSBnZXR0aW5nIHdheSBtb3JlIHJvdW5kaW5nIGVycm9ycy5cbiAgICBpZiAoTWF0aC5hYnMoZHkpIDwgMWUtNSkge1xuICAgICAgZnJvbS55ID0gdG8ueTtcbiAgICAgIHNlZ21lbnQuZHkgPSAwO1xuICAgIH1cbiAgICBpZiAoKGZyb20ueSA8IHRvLnkpIHx8IChcbiAgICAgICAgKGZyb20ueSA9PT0gdG8ueSkgJiYgKGZyb20ueCA+IHRvLngpKVxuICAgICAgKSB7XG4gICAgICB2YXIgdGVtcCA9IGZyb207XG4gICAgICBmcm9tID0gc2VnbWVudC5mcm9tID0gdG87IFxuICAgICAgdG8gPSBzZWdtZW50LnRvID0gdGVtcDtcbiAgICB9XG5cbiAgICAvLyBXZSBwcmUtY29tcHV0ZSBzb21lIGltbXV0YWJsZSBwcm9wZXJ0aWVzIG9mIHRoZSBzZWdtZW50XG4gICAgLy8gVGhleSBhcmUgdXNlZCBxdWl0ZSBvZnRlbiBpbiB0aGUgdHJlZSB0cmF2ZXJzYWwsIGFuZCBwcmUtY29tcHV0YXRpb25cbiAgICAvLyBnaXZlcyBzaWduaWZpY2FudCBib29zdDpcbiAgICBzZWdtZW50LmR5ID0gZnJvbS55IC0gdG8ueTtcbiAgICBzZWdtZW50LmR4ID0gZnJvbS54IC0gdG8ueDtcbiAgICBzZWdtZW50LmFuZ2xlID0gYW5nbGUoc2VnbWVudC5keSwgc2VnbWVudC5keCk7XG5cbiAgICB2YXIgaXNQb2ludCA9IHNlZ21lbnQuZHkgPT09IHNlZ21lbnQuZHggJiYgc2VnbWVudC5keSA9PT0gMDtcbiAgICB2YXIgcHJldiA9IGV2ZW50UXVldWUuZmluZChmcm9tKTtcbiAgICBpZiAocHJldiAmJiAhaXNQb2ludCkge1xuICAgICAgLy8gdGhpcyBkZXRlY3RzIGlkZW50aWNhbCBzZWdtZW50cyBlYXJseS4gV2l0aG91dCB0aGlzIGNoZWNrXG4gICAgICAvLyB0aGUgYWxnb3JpdGhtIHdvdWxkIGJyZWFrIHNpbmNlIHN3ZWVwIGxpbmUgaGFzIG5vIG1lYW5zIHRvXG4gICAgICAvLyBkZXRlY3QgaWRlbnRpY2FsIHNlZ21lbnRzLlxuICAgICAgdmFyIHByZXZGcm9tID0gcHJldi5kYXRhLmZyb207XG4gICAgICBpZiAocHJldkZyb20pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmV2RnJvbS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBzID0gcHJldkZyb21baV07XG4gICAgICAgICAgaWYgKHNhbWVQb2ludChzLnRvLCB0bykpIHtcbiAgICAgICAgICAgIHJlcG9ydEludGVyc2VjdGlvbihzLmZyb20sIFtzLmZyb20sIHMudG9dKTtcbiAgICAgICAgICAgIHJlcG9ydEludGVyc2VjdGlvbihzLnRvLCBbcy5mcm9tLCBzLnRvXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpc1BvaW50KSB7XG4gICAgICBpZiAocHJldikge1xuICAgICAgICBpZiAocHJldi5kYXRhLmZyb20pIHsgcHJldi5kYXRhLmZyb20ucHVzaChzZWdtZW50KTsgfVxuICAgICAgICBlbHNlIHsgcHJldi5kYXRhLmZyb20gPSBbc2VnbWVudF07IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlID0gbmV3IFN3ZWVwRXZlbnQoZnJvbSwgc2VnbWVudCk7XG4gICAgICAgIGV2ZW50UXVldWUuaW5zZXJ0KGUpO1xuICAgICAgfVxuICAgICAgdmFyIGV2ZW50ID0gbmV3IFN3ZWVwRXZlbnQodG8pO1xuICAgICAgZXZlbnRRdWV1ZS5pbnNlcnQoZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXZlbnQgPSBuZXcgU3dlZXBFdmVudCh0byk7XG4gICAgICBldmVudFF1ZXVlLmluc2VydChldmVudCk7XG4gICAgfVxuICB9IFxufVxuXG5mdW5jdGlvbiByb3VuZE5lYXJaZXJvKHBvaW50KSB7XG4gIGlmIChNYXRoLmFicyhwb2ludC54KSA8IEVQUykgeyBwb2ludC54ID0gMDsgfVxuICBpZiAoTWF0aC5hYnMocG9pbnQueSkgPCBFUFMpIHsgcG9pbnQueSA9IDA7IH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdEVycm9yUmVwb3J0ZXIoZXJyb3JNZXNzYWdlKSB7XG4gIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xufVxuXG5mdW5jdGlvbiB1bmlvbihhLCBiKSB7XG4gIGlmICghYSkgeyByZXR1cm4gYjsgfVxuICBpZiAoIWIpIHsgcmV0dXJuIGE7IH1cblxuICByZXR1cm4gYS5jb25jYXQoYik7XG59XG5cbmZ1bmN0aW9uIGJ5WShhLCBiKSB7XG4gIC8vIGRlY3JlYXNpbmcgWSBcbiAgdmFyIHJlcyA9IGIueSAtIGEueTtcbiAgLy8gVE9ETzogVGhpcyBtaWdodCBtZXNzIHVwIHRoZSBzdGF0dXMgdHJlZS5cbiAgaWYgKE1hdGguYWJzKHJlcykgPCBFUFMpIHtcbiAgICAvLyBpbmNyZWFzaW5nIHguXG4gICAgcmVzID0gYS54IC0gYi54O1xuICAgIGlmIChNYXRoLmFicyhyZXMpIDwgRVBTKSB7IHJlcyA9IDA7IH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdFNlZ21lbnRzJDEoYSwgYikge1xuICAvLyBOb3RlOiB0aGlzIGlzIGFsbW9zdCB0aGUgc2FtZSBhcyBnZW9tLmludGVyc2VjdFNlZ21lbnRzKClcbiAgLy8gVGhlIG1haW4gZGlmZmVyZW5jZSBpcyB0aGF0IHdlIGRvbid0IGhhdmUgYSBwcmUtY29tcHV0ZWRcbiAgLy8gdmFsdWUgZm9yIGR4L2R5IG9uIHRoZSBzZWdtZW50cy5cbiAgLy8gIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xOTY4MzQ1LzEyNTM1MVxuICB2YXIgYVN0YXJ0ID0gYS5mcm9tLCBiU3RhcnQgPSBiLmZyb207XG4gIHZhciBwMF94ID0gYVN0YXJ0LngsIHAwX3kgPSBhU3RhcnQueSxcbiAgICAgIHAyX3ggPSBiU3RhcnQueCwgcDJfeSA9IGJTdGFydC55O1xuXG4gIHZhciBzMV94ID0gYS5mcm9tLnggLSBhLnRvLngsIHMxX3kgPSBhLmZyb20ueSAtIGEudG8ueSwgczJfeCA9IGIuZnJvbS54IC0gYi50by54LCBzMl95ID0gYi5mcm9tLnkgLSBiLnRvLnk7XG4gIHZhciBkaXYgPSBzMV94ICogczJfeSAtIHMyX3ggKiBzMV95O1xuXG4gIHZhciBzID0gKHMxX3kgKiAocDBfeCAtIHAyX3gpIC0gczFfeCAqIChwMF95IC0gcDJfeSkpIC8gZGl2O1xuICBpZiAocyA8IDAgfHwgcyA+IDEpIHsgcmV0dXJuOyB9XG5cbiAgdmFyIHQgPSAoczJfeCAqIChwMl95IC0gcDBfeSkgKyBzMl95ICogKHAwX3ggLSBwMl94KSkgLyBkaXY7XG5cbiAgaWYgKHQgPj0gMCAmJiB0IDw9IDEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcDBfeCAtICh0ICogczFfeCksXG4gICAgICB5OiBwMF95IC0gKHQgKiBzMV95KVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgYSBicnV0ZSBmb3JjZSBzb2x1dGlvbiB3aXRoIE8obl4yKSBwZXJmb3JtYW5jZS5cbiAqIChgbmAgaXMgbnVtYmVyIG9mIHNlZ21lbnRzKS5cbiAqIFxuICogVXNlIHRoaXMgd2hlbiBudW1iZXIgb2YgbGluZXMgaXMgbG93LCBhbmQgbnVtYmVyIG9mIGludGVyc2VjdGlvbnNcbiAqIGlzIGhpZ2guXG4gKi9cbmZ1bmN0aW9uIGJydXRlKGxpbmVzLCBvcHRpb25zKSB7XG4gIHZhciByZXN1bHRzID0gW107XG4gIHZhciByZXBvcnRJbnRlcnNlY3Rpb24gPSAob3B0aW9ucyAmJiBvcHRpb25zLm9uRm91bmQpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRJbnRlcnNlY3Rpb25SZXBvcnRlcjtcbiAgdmFyIGFzeW5jU3RhdGU7XG5cbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIGJydXRlIGZvcmNlIG9mIHRoZSBzZWdtZW50IGludGVyc2VjdGlvbiBzZWFyY2hcbiAgICAgKi9cbiAgICBydW46IHJ1bixcbiAgICAvKipcbiAgICAgKiBBY2Nlc3MgdG8gcmVzdWx0cyBhcnJheS4gV29ya3Mgb25seSB3aGVuIHlvdSB1c2UgZGVmYXVsdCBvbkZvdW5kKCkgaGFuZGxlclxuICAgICAqL1xuICAgIHJlc3VsdHM6IHJlc3VsdHMsXG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIHNpbmdsZSBzdGVwIGluIHRoZSBicnV0ZSBmb3JjZSBhbGdvcml0aG0gKClcbiAgICAgKi9cbiAgICBzdGVwOiBzdGVwXG4gIH1cblxuICBmdW5jdGlvbiBzdGVwKCkge1xuICAgIGlmICghYXN5bmNTdGF0ZSkge1xuICAgICAgYXN5bmNTdGF0ZSA9IHtcbiAgICAgICAgaTogMFxuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHRlc3QgPSBsaW5lc1thc3luY1N0YXRlLmldO1xuICAgIGZvciAodmFyIGogPSBhc3luY1N0YXRlLmkgKyAxOyBqIDwgbGluZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIHZhciBvdGhlciA9IGxpbmVzW2pdO1xuICAgICAgdmFyIHB0ID0gaW50ZXJzZWN0U2VnbWVudHMkMSh0ZXN0LCBvdGhlcik7XG4gICAgICBpZiAocHQpIHtcbiAgICAgICAgaWYgKHJlcG9ydEludGVyc2VjdGlvbihwdCwgW3Rlc3QsIG90aGVyXSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYXN5bmNTdGF0ZS5pICs9IDE7XG4gICAgcmV0dXJuIGFzeW5jU3RhdGUuaSA8IGxpbmVzLmxlbmd0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJ1bigpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciB0ZXN0ID0gbGluZXNbaV07XG4gICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBsaW5lcy5sZW5ndGg7ICsraikge1xuICAgICAgICB2YXIgb3RoZXIgPSBsaW5lc1tqXTtcbiAgICAgICAgdmFyIHB0ID0gaW50ZXJzZWN0U2VnbWVudHMkMSh0ZXN0LCBvdGhlcik7XG4gICAgICAgIGlmIChwdCkge1xuICAgICAgICAgIGlmIChyZXBvcnRJbnRlcnNlY3Rpb24ocHQsIFt0ZXN0LCBvdGhlcl0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdEludGVyc2VjdGlvblJlcG9ydGVyKHAsIGludGVyaW9yKSB7XG4gICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgIHBvaW50OiBwLCBcbiAgICAgIHNlZ21lbnRzOiBpbnRlcmlvclxuICAgIH0pO1xuICB9XG59XG5cbnZhciBBUlJBWV9UWVBFUyA9IFtcbiAgICBJbnQ4QXJyYXksIFVpbnQ4QXJyYXksIFVpbnQ4Q2xhbXBlZEFycmF5LCBJbnQxNkFycmF5LCBVaW50MTZBcnJheSxcbiAgICBJbnQzMkFycmF5LCBVaW50MzJBcnJheSwgRmxvYXQzMkFycmF5LCBGbG9hdDY0QXJyYXlcbl07XG5cbnZhciBWRVJTSU9OID0gMzsgLy8gc2VyaWFsaXplZCBmb3JtYXQgdmVyc2lvblxuXG52YXIgRmxhdGJ1c2ggPSBmdW5jdGlvbiBGbGF0YnVzaChudW1JdGVtcywgbm9kZVNpemUsIEFycmF5VHlwZSwgZGF0YSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKG51bUl0ZW1zID09PSB1bmRlZmluZWQpIHsgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50OiBudW1JdGVtcy4nKTsgfVxuICAgIGlmIChpc05hTihudW1JdGVtcykgfHwgbnVtSXRlbXMgPD0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoKFwiVW5wZXhwZWN0ZWQgbnVtSXRlbXMgdmFsdWU6IFwiICsgbnVtSXRlbXMgKyBcIi5cIikpOyB9XG5cbiAgICB0aGlzLm51bUl0ZW1zID0gK251bUl0ZW1zO1xuICAgIHRoaXMubm9kZVNpemUgPSBNYXRoLm1pbihNYXRoLm1heCgrbm9kZVNpemUgfHwgMTYsIDIpLCA2NTUzNSk7XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIHRvdGFsIG51bWJlciBvZiBub2RlcyBpbiB0aGUgUi10cmVlIHRvIGFsbG9jYXRlIHNwYWNlIGZvclxuICAgIC8vIGFuZCB0aGUgaW5kZXggb2YgZWFjaCB0cmVlIGxldmVsICh1c2VkIGluIHNlYXJjaCBsYXRlcilcbiAgICB2YXIgbiA9IG51bUl0ZW1zO1xuICAgIHZhciBudW1Ob2RlcyA9IG47XG4gICAgdGhpcy5fbGV2ZWxCb3VuZHMgPSBbbiAqIDRdO1xuICAgIGRvIHtcbiAgICAgICAgbiA9IE1hdGguY2VpbChuIC8gdGhpcyQxLm5vZGVTaXplKTtcbiAgICAgICAgbnVtTm9kZXMgKz0gbjtcbiAgICAgICAgdGhpcyQxLl9sZXZlbEJvdW5kcy5wdXNoKG51bU5vZGVzICogNCk7XG4gICAgfSB3aGlsZSAobiAhPT0gMSk7XG5cbiAgICB0aGlzLkFycmF5VHlwZSA9IEFycmF5VHlwZSB8fCBGbG9hdDY0QXJyYXk7XG4gICAgdGhpcy5JbmRleEFycmF5VHlwZSA9IG51bU5vZGVzIDwgMTYzODQgPyBVaW50MTZBcnJheSA6IFVpbnQzMkFycmF5O1xuXG4gICAgdmFyIGFycmF5VHlwZUluZGV4ID0gQVJSQVlfVFlQRVMuaW5kZXhPZih0aGlzLkFycmF5VHlwZSk7XG4gICAgdmFyIG5vZGVzQnl0ZVNpemUgPSBudW1Ob2RlcyAqIDQgKiB0aGlzLkFycmF5VHlwZS5CWVRFU19QRVJfRUxFTUVOVDtcblxuICAgIGlmIChhcnJheVR5cGVJbmRleCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcIlVuZXhwZWN0ZWQgdHlwZWQgYXJyYXkgY2xhc3M6IFwiICsgQXJyYXlUeXBlICsgXCIuXCIpKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YSAmJiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLl9ib3hlcyA9IG5ldyB0aGlzLkFycmF5VHlwZSh0aGlzLmRhdGEsIDgsIG51bU5vZGVzICogNCk7XG4gICAgICAgIHRoaXMuX2luZGljZXMgPSBuZXcgdGhpcy5JbmRleEFycmF5VHlwZSh0aGlzLmRhdGEsIDggKyBub2Rlc0J5dGVTaXplLCBudW1Ob2Rlcyk7XG5cbiAgICAgICAgdGhpcy5fcG9zID0gbnVtTm9kZXMgKiA0O1xuICAgICAgICB0aGlzLm1pblggPSB0aGlzLl9ib3hlc1t0aGlzLl9wb3MgLSA0XTtcbiAgICAgICAgdGhpcy5taW5ZID0gdGhpcy5fYm94ZXNbdGhpcy5fcG9zIC0gM107XG4gICAgICAgIHRoaXMubWF4WCA9IHRoaXMuX2JveGVzW3RoaXMuX3BvcyAtIDJdO1xuICAgICAgICB0aGlzLm1heFkgPSB0aGlzLl9ib3hlc1t0aGlzLl9wb3MgLSAxXTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBBcnJheUJ1ZmZlcig4ICsgbm9kZXNCeXRlU2l6ZSArIG51bU5vZGVzICogdGhpcy5JbmRleEFycmF5VHlwZS5CWVRFU19QRVJfRUxFTUVOVCk7XG4gICAgICAgIHRoaXMuX2JveGVzID0gbmV3IHRoaXMuQXJyYXlUeXBlKHRoaXMuZGF0YSwgOCwgbnVtTm9kZXMgKiA0KTtcbiAgICAgICAgdGhpcy5faW5kaWNlcyA9IG5ldyB0aGlzLkluZGV4QXJyYXlUeXBlKHRoaXMuZGF0YSwgOCArIG5vZGVzQnl0ZVNpemUsIG51bU5vZGVzKTtcbiAgICAgICAgdGhpcy5fcG9zID0gMDtcbiAgICAgICAgdGhpcy5taW5YID0gSW5maW5pdHk7XG4gICAgICAgIHRoaXMubWluWSA9IEluZmluaXR5O1xuICAgICAgICB0aGlzLm1heFggPSAtSW5maW5pdHk7XG4gICAgICAgIHRoaXMubWF4WSA9IC1JbmZpbml0eTtcblxuICAgICAgICBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEsIDAsIDIpLnNldChbMHhmYiwgKFZFUlNJT04gPDwgNCkgKyBhcnJheVR5cGVJbmRleF0pO1xuICAgICAgICBuZXcgVWludDE2QXJyYXkodGhpcy5kYXRhLCAyLCAxKVswXSA9IG5vZGVTaXplO1xuICAgICAgICBuZXcgVWludDMyQXJyYXkodGhpcy5kYXRhLCA0LCAxKVswXSA9IG51bUl0ZW1zO1xuICAgIH1cbn07XG5cbkZsYXRidXNoLmZyb20gPSBmdW5jdGlvbiBmcm9tIChkYXRhKSB7XG4gICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBBcnJheUJ1ZmZlci4nKTtcbiAgICB9XG4gICAgdmFyIHJlZiA9IG5ldyBVaW50OEFycmF5KGRhdGEsIDAsIDIpO1xuICAgICAgICB2YXIgbWFnaWMgPSByZWZbMF07XG4gICAgICAgIHZhciB2ZXJzaW9uQW5kVHlwZSA9IHJlZlsxXTtcbiAgICBpZiAobWFnaWMgIT09IDB4ZmIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGRvZXMgbm90IGFwcGVhciB0byBiZSBpbiBhIEZsYXRidXNoIGZvcm1hdC4nKTtcbiAgICB9XG4gICAgaWYgKHZlcnNpb25BbmRUeXBlID4+IDQgIT09IFZFUlNJT04pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcIkdvdCB2XCIgKyAodmVyc2lvbkFuZFR5cGUgPj4gNCkgKyBcIiBkYXRhIHdoZW4gZXhwZWN0ZWQgdlwiICsgVkVSU0lPTiArIFwiLlwiKSk7XG4gICAgfVxuICAgIHZhciByZWYkMSA9IG5ldyBVaW50MTZBcnJheShkYXRhLCAyLCAxKTtcbiAgICAgICAgdmFyIG5vZGVTaXplID0gcmVmJDFbMF07XG4gICAgdmFyIHJlZiQyID0gbmV3IFVpbnQzMkFycmF5KGRhdGEsIDQsIDEpO1xuICAgICAgICB2YXIgbnVtSXRlbXMgPSByZWYkMlswXTtcblxuICAgIHJldHVybiBuZXcgRmxhdGJ1c2gobnVtSXRlbXMsIG5vZGVTaXplLCBBUlJBWV9UWVBFU1t2ZXJzaW9uQW5kVHlwZSAmIDB4MGZdLCBkYXRhKTtcbn07XG5cbkZsYXRidXNoLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKG1pblgsIG1pblksIG1heFgsIG1heFkpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9wb3MgPj4gMjtcbiAgICB0aGlzLl9pbmRpY2VzW2luZGV4XSA9IGluZGV4O1xuICAgIHRoaXMuX2JveGVzW3RoaXMuX3BvcysrXSA9IG1pblg7XG4gICAgdGhpcy5fYm94ZXNbdGhpcy5fcG9zKytdID0gbWluWTtcbiAgICB0aGlzLl9ib3hlc1t0aGlzLl9wb3MrK10gPSBtYXhYO1xuICAgIHRoaXMuX2JveGVzW3RoaXMuX3BvcysrXSA9IG1heFk7XG5cbiAgICBpZiAobWluWCA8IHRoaXMubWluWCkgeyB0aGlzLm1pblggPSBtaW5YOyB9XG4gICAgaWYgKG1pblkgPCB0aGlzLm1pblkpIHsgdGhpcy5taW5ZID0gbWluWTsgfVxuICAgIGlmIChtYXhYID4gdGhpcy5tYXhYKSB7IHRoaXMubWF4WCA9IG1heFg7IH1cbiAgICBpZiAobWF4WSA+IHRoaXMubWF4WSkgeyB0aGlzLm1heFkgPSBtYXhZOyB9XG59O1xuXG5GbGF0YnVzaC5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gZmluaXNoICgpIHtcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5fcG9zID4+IDIgIT09IHRoaXMubnVtSXRlbXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcIkFkZGVkIFwiICsgKHRoaXMuX3BvcyA+PiAyKSArIFwiIGl0ZW1zIHdoZW4gZXhwZWN0ZWQgXCIgKyAodGhpcy5udW1JdGVtcykgKyBcIi5cIikpO1xuICAgIH1cblxuICAgIHZhciB3aWR0aCA9IHRoaXMubWF4WCAtIHRoaXMubWluWDtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5tYXhZIC0gdGhpcy5taW5ZO1xuICAgIHZhciBoaWxiZXJ0VmFsdWVzID0gbmV3IFVpbnQzMkFycmF5KHRoaXMubnVtSXRlbXMpO1xuICAgIHZhciBoaWxiZXJ0TWF4ID0gKDEgPDwgMTYpIC0gMTtcblxuICAgIC8vIG1hcCBpdGVtIGNlbnRlcnMgaW50byBIaWxiZXJ0IGNvb3JkaW5hdGUgc3BhY2UgYW5kIGNhbGN1bGF0ZSBIaWxiZXJ0IHZhbHVlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5udW1JdGVtczsgaSsrKSB7XG4gICAgICAgIHZhciBwb3MgPSA0ICogaTtcbiAgICAgICAgdmFyIG1pblggPSB0aGlzJDEuX2JveGVzW3BvcysrXTtcbiAgICAgICAgdmFyIG1pblkgPSB0aGlzJDEuX2JveGVzW3BvcysrXTtcbiAgICAgICAgdmFyIG1heFggPSB0aGlzJDEuX2JveGVzW3BvcysrXTtcbiAgICAgICAgdmFyIG1heFkgPSB0aGlzJDEuX2JveGVzW3BvcysrXTtcbiAgICAgICAgdmFyIHggPSBNYXRoLmZsb29yKGhpbGJlcnRNYXggKiAoKG1pblggKyBtYXhYKSAvIDIgLSB0aGlzJDEubWluWCkgLyB3aWR0aCk7XG4gICAgICAgIHZhciB5ID0gTWF0aC5mbG9vcihoaWxiZXJ0TWF4ICogKChtaW5ZICsgbWF4WSkgLyAyIC0gdGhpcyQxLm1pblkpIC8gaGVpZ2h0KTtcbiAgICAgICAgaGlsYmVydFZhbHVlc1tpXSA9IGhpbGJlcnQoeCwgeSk7XG4gICAgfVxuXG4gICAgLy8gc29ydCBpdGVtcyBieSB0aGVpciBIaWxiZXJ0IHZhbHVlIChmb3IgcGFja2luZyBsYXRlcilcbiAgICBzb3J0JDEoaGlsYmVydFZhbHVlcywgdGhpcy5fYm94ZXMsIHRoaXMuX2luZGljZXMsIDAsIHRoaXMubnVtSXRlbXMgLSAxKTtcblxuICAgIC8vIGdlbmVyYXRlIG5vZGVzIGF0IGVhY2ggdHJlZSBsZXZlbCwgYm90dG9tLXVwXG4gICAgZm9yICh2YXIgaSQxID0gMCwgcG9zJDEgPSAwOyBpJDEgPCB0aGlzLl9sZXZlbEJvdW5kcy5sZW5ndGggLSAxOyBpJDErKykge1xuICAgICAgICB2YXIgZW5kID0gdGhpcyQxLl9sZXZlbEJvdW5kc1tpJDFdO1xuXG4gICAgICAgIC8vIGdlbmVyYXRlIGEgcGFyZW50IG5vZGUgZm9yIGVhY2ggYmxvY2sgb2YgY29uc2VjdXRpdmUgPG5vZGVTaXplPiBub2Rlc1xuICAgICAgICB3aGlsZSAocG9zJDEgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciBub2RlTWluWCA9IEluZmluaXR5O1xuICAgICAgICAgICAgdmFyIG5vZGVNaW5ZID0gSW5maW5pdHk7XG4gICAgICAgICAgICB2YXIgbm9kZU1heFggPSAtSW5maW5pdHk7XG4gICAgICAgICAgICB2YXIgbm9kZU1heFkgPSAtSW5maW5pdHk7XG4gICAgICAgICAgICB2YXIgbm9kZUluZGV4ID0gcG9zJDE7XG5cbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBiYm94IGZvciB0aGUgbmV3IG5vZGVcbiAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHRoaXMubm9kZVNpemUgJiYgcG9zJDEgPCBlbmQ7IGkkMisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pblgkMSA9IHRoaXMkMS5fYm94ZXNbcG9zJDErK107XG4gICAgICAgICAgICAgICAgdmFyIG1pblkkMSA9IHRoaXMkMS5fYm94ZXNbcG9zJDErK107XG4gICAgICAgICAgICAgICAgdmFyIG1heFgkMSA9IHRoaXMkMS5fYm94ZXNbcG9zJDErK107XG4gICAgICAgICAgICAgICAgdmFyIG1heFkkMSA9IHRoaXMkMS5fYm94ZXNbcG9zJDErK107XG4gICAgICAgICAgICAgICAgaWYgKG1pblgkMSA8IG5vZGVNaW5YKSB7IG5vZGVNaW5YID0gbWluWCQxOyB9XG4gICAgICAgICAgICAgICAgaWYgKG1pblkkMSA8IG5vZGVNaW5ZKSB7IG5vZGVNaW5ZID0gbWluWSQxOyB9XG4gICAgICAgICAgICAgICAgaWYgKG1heFgkMSA+IG5vZGVNYXhYKSB7IG5vZGVNYXhYID0gbWF4WCQxOyB9XG4gICAgICAgICAgICAgICAgaWYgKG1heFkkMSA+IG5vZGVNYXhZKSB7IG5vZGVNYXhZID0gbWF4WSQxOyB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFkZCB0aGUgbmV3IG5vZGUgdG8gdGhlIHRyZWUgZGF0YVxuICAgICAgICAgICAgdGhpcyQxLl9pbmRpY2VzW3RoaXMkMS5fcG9zID4+IDJdID0gbm9kZUluZGV4O1xuICAgICAgICAgICAgdGhpcyQxLl9ib3hlc1t0aGlzJDEuX3BvcysrXSA9IG5vZGVNaW5YO1xuICAgICAgICAgICAgdGhpcyQxLl9ib3hlc1t0aGlzJDEuX3BvcysrXSA9IG5vZGVNaW5ZO1xuICAgICAgICAgICAgdGhpcyQxLl9ib3hlc1t0aGlzJDEuX3BvcysrXSA9IG5vZGVNYXhYO1xuICAgICAgICAgICAgdGhpcyQxLl9ib3hlc1t0aGlzJDEuX3BvcysrXSA9IG5vZGVNYXhZO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuRmxhdGJ1c2gucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaCAobWluWCwgbWluWSwgbWF4WCwgbWF4WSwgZmlsdGVyRm4pIHtcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5fcG9zICE9PSB0aGlzLl9ib3hlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIG5vdCB5ZXQgaW5kZXhlZCAtIGNhbGwgaW5kZXguZmluaXNoKCkuJyk7XG4gICAgfVxuXG4gICAgdmFyIG5vZGVJbmRleCA9IHRoaXMuX2JveGVzLmxlbmd0aCAtIDQ7XG4gICAgdmFyIGxldmVsID0gdGhpcy5fbGV2ZWxCb3VuZHMubGVuZ3RoIC0gMTtcbiAgICB2YXIgcXVldWUgPSBbXTtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgd2hpbGUgKG5vZGVJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGZpbmQgdGhlIGVuZCBpbmRleCBvZiB0aGUgbm9kZVxuICAgICAgICB2YXIgZW5kID0gTWF0aC5taW4obm9kZUluZGV4ICsgdGhpcyQxLm5vZGVTaXplICogNCwgdGhpcyQxLl9sZXZlbEJvdW5kc1tsZXZlbF0pO1xuXG4gICAgICAgIC8vIHNlYXJjaCB0aHJvdWdoIGNoaWxkIG5vZGVzXG4gICAgICAgIGZvciAodmFyIHBvcyA9IG5vZGVJbmRleDsgcG9zIDwgZW5kOyBwb3MgKz0gNCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcyQxLl9pbmRpY2VzW3BvcyA+PiAyXTtcblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgbm9kZSBiYm94IGludGVyc2VjdHMgd2l0aCBxdWVyeSBiYm94XG4gICAgICAgICAgICBpZiAobWF4WCA8IHRoaXMkMS5fYm94ZXNbcG9zXSkgeyBjb250aW51ZTsgfSAvLyBtYXhYIDwgbm9kZU1pblhcbiAgICAgICAgICAgIGlmIChtYXhZIDwgdGhpcyQxLl9ib3hlc1twb3MgKyAxXSkgeyBjb250aW51ZTsgfSAvLyBtYXhZIDwgbm9kZU1pbllcbiAgICAgICAgICAgIGlmIChtaW5YID4gdGhpcyQxLl9ib3hlc1twb3MgKyAyXSkgeyBjb250aW51ZTsgfSAvLyBtaW5YID4gbm9kZU1heFhcbiAgICAgICAgICAgIGlmIChtaW5ZID4gdGhpcyQxLl9ib3hlc1twb3MgKyAzXSkgeyBjb250aW51ZTsgfSAvLyBtaW5ZID4gbm9kZU1heFlcblxuICAgICAgICAgICAgaWYgKG5vZGVJbmRleCA8IHRoaXMkMS5udW1JdGVtcyAqIDQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyRm4gPT09IHVuZGVmaW5lZCB8fCBmaWx0ZXJGbihpbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGluZGV4KTsgLy8gbGVhZiBpdGVtXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goaW5kZXgpOyAvLyBub2RlOyBhZGQgaXQgdG8gdGhlIHNlYXJjaCBxdWV1ZVxuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2gobGV2ZWwgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldmVsID0gcXVldWUucG9wKCk7XG4gICAgICAgIG5vZGVJbmRleCA9IHF1ZXVlLnBvcCgpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gY3VzdG9tIHF1aWNrc29ydCB0aGF0IHNvcnRzIGJib3ggZGF0YSBhbG9uZ3NpZGUgdGhlIGhpbGJlcnQgdmFsdWVzXG5mdW5jdGlvbiBzb3J0JDEodmFsdWVzLCBib3hlcywgaW5kaWNlcywgbGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdCA+PSByaWdodCkgeyByZXR1cm47IH1cblxuICAgIHZhciBwaXZvdCA9IHZhbHVlc1sobGVmdCArIHJpZ2h0KSA+PiAxXTtcbiAgICB2YXIgaSA9IGxlZnQgLSAxO1xuICAgIHZhciBqID0gcmlnaHQgKyAxO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgZG8geyBpKys7IH0gd2hpbGUgKHZhbHVlc1tpXSA8IHBpdm90KTtcbiAgICAgICAgZG8geyBqLS07IH0gd2hpbGUgKHZhbHVlc1tqXSA+IHBpdm90KTtcbiAgICAgICAgaWYgKGkgPj0gaikgeyBicmVhazsgfVxuICAgICAgICBzd2FwKHZhbHVlcywgYm94ZXMsIGluZGljZXMsIGksIGopO1xuICAgIH1cblxuICAgIHNvcnQkMSh2YWx1ZXMsIGJveGVzLCBpbmRpY2VzLCBsZWZ0LCBqKTtcbiAgICBzb3J0JDEodmFsdWVzLCBib3hlcywgaW5kaWNlcywgaiArIDEsIHJpZ2h0KTtcbn1cblxuLy8gc3dhcCB0d28gdmFsdWVzIGFuZCB0d28gY29ycmVzcG9uZGluZyBib3hlc1xuZnVuY3Rpb24gc3dhcCh2YWx1ZXMsIGJveGVzLCBpbmRpY2VzLCBpLCBqKSB7XG4gICAgdmFyIHRlbXAgPSB2YWx1ZXNbaV07XG4gICAgdmFsdWVzW2ldID0gdmFsdWVzW2pdO1xuICAgIHZhbHVlc1tqXSA9IHRlbXA7XG5cbiAgICB2YXIgayA9IDQgKiBpO1xuICAgIHZhciBtID0gNCAqIGo7XG5cbiAgICB2YXIgYSA9IGJveGVzW2tdO1xuICAgIHZhciBiID0gYm94ZXNbayArIDFdO1xuICAgIHZhciBjID0gYm94ZXNbayArIDJdO1xuICAgIHZhciBkID0gYm94ZXNbayArIDNdO1xuICAgIGJveGVzW2tdID0gYm94ZXNbbV07XG4gICAgYm94ZXNbayArIDFdID0gYm94ZXNbbSArIDFdO1xuICAgIGJveGVzW2sgKyAyXSA9IGJveGVzW20gKyAyXTtcbiAgICBib3hlc1trICsgM10gPSBib3hlc1ttICsgM107XG4gICAgYm94ZXNbbV0gPSBhO1xuICAgIGJveGVzW20gKyAxXSA9IGI7XG4gICAgYm94ZXNbbSArIDJdID0gYztcbiAgICBib3hlc1ttICsgM10gPSBkO1xuXG4gICAgdmFyIGUgPSBpbmRpY2VzW2ldO1xuICAgIGluZGljZXNbaV0gPSBpbmRpY2VzW2pdO1xuICAgIGluZGljZXNbal0gPSBlO1xufVxuXG4vLyBGYXN0IEhpbGJlcnQgY3VydmUgYWxnb3JpdGhtIGJ5IGh0dHA6Ly90aHJlYWRsb2NhbG11dGV4LmNvbS9cbi8vIFBvcnRlZCBmcm9tIEMrKyBodHRwczovL2dpdGh1Yi5jb20vcmF3cnVucHJvdGVjdGVkL2hpbGJlcnRfY3VydmVzIChwdWJsaWMgZG9tYWluKVxuZnVuY3Rpb24gaGlsYmVydCh4LCB5KSB7XG4gICAgdmFyIGEgPSB4IF4geTtcbiAgICB2YXIgYiA9IDB4RkZGRiBeIGE7XG4gICAgdmFyIGMgPSAweEZGRkYgXiAoeCB8IHkpO1xuICAgIHZhciBkID0geCAmICh5IF4gMHhGRkZGKTtcblxuICAgIHZhciBBID0gYSB8IChiID4+IDEpO1xuICAgIHZhciBCID0gKGEgPj4gMSkgXiBhO1xuICAgIHZhciBDID0gKChjID4+IDEpIF4gKGIgJiAoZCA+PiAxKSkpIF4gYztcbiAgICB2YXIgRCA9ICgoYSAmIChjID4+IDEpKSBeIChkID4+IDEpKSBeIGQ7XG5cbiAgICBhID0gQTsgYiA9IEI7IGMgPSBDOyBkID0gRDtcbiAgICBBID0gKChhICYgKGEgPj4gMikpIF4gKGIgJiAoYiA+PiAyKSkpO1xuICAgIEIgPSAoKGEgJiAoYiA+PiAyKSkgXiAoYiAmICgoYSBeIGIpID4+IDIpKSk7XG4gICAgQyBePSAoKGEgJiAoYyA+PiAyKSkgXiAoYiAmIChkID4+IDIpKSk7XG4gICAgRCBePSAoKGIgJiAoYyA+PiAyKSkgXiAoKGEgXiBiKSAmIChkID4+IDIpKSk7XG5cbiAgICBhID0gQTsgYiA9IEI7IGMgPSBDOyBkID0gRDtcbiAgICBBID0gKChhICYgKGEgPj4gNCkpIF4gKGIgJiAoYiA+PiA0KSkpO1xuICAgIEIgPSAoKGEgJiAoYiA+PiA0KSkgXiAoYiAmICgoYSBeIGIpID4+IDQpKSk7XG4gICAgQyBePSAoKGEgJiAoYyA+PiA0KSkgXiAoYiAmIChkID4+IDQpKSk7XG4gICAgRCBePSAoKGIgJiAoYyA+PiA0KSkgXiAoKGEgXiBiKSAmIChkID4+IDQpKSk7XG5cbiAgICBhID0gQTsgYiA9IEI7IGMgPSBDOyBkID0gRDtcbiAgICBDIF49ICgoYSAmIChjID4+IDgpKSBeIChiICYgKGQgPj4gOCkpKTtcbiAgICBEIF49ICgoYiAmIChjID4+IDgpKSBeICgoYSBeIGIpICYgKGQgPj4gOCkpKTtcblxuICAgIGEgPSBDIF4gKEMgPj4gMSk7XG4gICAgYiA9IEQgXiAoRCA+PiAxKTtcblxuICAgIHZhciBpMCA9IHggXiB5O1xuICAgIHZhciBpMSA9IGIgfCAoMHhGRkZGIF4gKGkwIHwgYSkpO1xuXG4gICAgaTAgPSAoaTAgfCAoaTAgPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgICBpMCA9IChpMCB8IChpMCA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICAgIGkwID0gKGkwIHwgKGkwIDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gICAgaTAgPSAoaTAgfCAoaTAgPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICAgIGkxID0gKGkxIHwgKGkxIDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgaTEgPSAoaTEgfCAoaTEgPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICBpMSA9IChpMSB8IChpMSA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIGkxID0gKGkxIHwgKGkxIDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICByZXR1cm4gKChpMSA8PCAxKSB8IGkwKSA+Pj4gMDtcbn1cblxuLyoqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGluc3BpcmVkIGJ5IGRpc2N1c3Npb24gaGVyZSBcbiAqIGh0dHBzOi8vdHdpdHRlci5jb20vbW91cm5lci9zdGF0dXMvMTA0OTMyNTE5OTYxNzkyMTAyNCBhbmQgXG4gKiBoZXJlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnZha2EvaXNlY3QvaXNzdWVzLzFcbiAqIFxuICogSXQgYnVpbGRzIGFuIGluZGV4IG9mIGFsbCBzZWdtZW50cyB1c2luZyBzdGF0aWMgc3BhdGlhbCBpbmRleFxuICogYW5kIHRoZW4gZm9yIGVhY2ggc2VnbWVudCBpdCBxdWVyaWVzIG92ZXJsYXBwaW5nIHJlY3RhbmdsZXMuXG4gKi9cbmZ1bmN0aW9uIGJ1c2gobGluZXMsIG9wdGlvbnMpIHtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgdmFyIHJlcG9ydEludGVyc2VjdGlvbiA9IChvcHRpb25zICYmIG9wdGlvbnMub25Gb3VuZCkgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdEludGVyc2VjdGlvblJlcG9ydGVyO1xuICB2YXIgYXN5bmNTdGF0ZTtcblxuICB2YXIgaW5kZXggPSBuZXcgRmxhdGJ1c2gobGluZXMubGVuZ3RoKTtcbiAgbGluZXMuZm9yRWFjaChhZGRUb0luZGV4KTtcbiAgaW5kZXguZmluaXNoKCk7XG5cbiAgcmV0dXJuIHtcbiAgICBydW46IHJ1bixcbiAgICBzdGVwOiBzdGVwLFxuICAgIHJlc3VsdHM6IHJlc3VsdHMsXG5cbiAgICAvLyB1bmRvY3VtZW50ZWQsIGRvbid0IHVzZSB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nOlxuICAgIGNoZWNrSW50ZXJzZWN0aW9uOiBjaGVja0ludGVyc2VjdGlvblxuICB9XG5cbiAgZnVuY3Rpb24gcnVuKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChjaGVja0ludGVyc2VjdGlvbihsaW5lc1tpXSwgaSkpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBzdG9wIGVhcmx5XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tJbnRlcnNlY3Rpb24oY3VycmVudFNlZ21lbnQsIGN1cnJlbnRJZCkge1xuICAgIC8vIHNvcnJ5IGFib3V0IGNvZGUgZHVwbGljYXRpb24uXG4gICAgdmFyIG1pblggPSBjdXJyZW50U2VnbWVudC5mcm9tLng7IHZhciBtYXhYID0gY3VycmVudFNlZ21lbnQudG8ueDtcbiAgICB2YXIgbWluWSA9IGN1cnJlbnRTZWdtZW50LmZyb20ueTsgdmFyIG1heFkgPSBjdXJyZW50U2VnbWVudC50by55O1xuICAgIHZhciB0O1xuICAgIGlmIChtaW5YID4gbWF4WCkgeyB0ID0gbWluWDsgbWluWCA9IG1heFg7IG1heFggPSB0OyB9XG4gICAgaWYgKG1pblkgPiBtYXhZKSB7IHQgPSBtaW5ZOyBtaW5ZID0gbWF4WTsgbWF4WSA9IHQ7IH1cblxuICAgIHZhciBpZHMgPSBpbmRleC5zZWFyY2gobWluWCwgbWluWSwgbWF4WCwgbWF4WSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHNlZ21lbnRJbmRleCA9IGlkc1tpXTtcbiAgICAgIGlmIChzZWdtZW50SW5kZXggPD0gY3VycmVudElkKSB7IGNvbnRpbnVlOyB9IC8vIHdlIGhhdmUgZWl0aGVyIHJlcG9ydGVkIGl0LCBvciBpdCBpcyBjdXJyZW50LlxuXG4gICAgICB2YXIgb3RoZXJTZWdtZW50ID0gbGluZXNbc2VnbWVudEluZGV4XTtcbiAgICAgIHZhciBwb2ludCA9IGludGVyc2VjdFNlZ21lbnRzJDEob3RoZXJTZWdtZW50LCBjdXJyZW50U2VnbWVudCk7XG5cbiAgICAgIGlmIChwb2ludCkge1xuICAgICAgICBpZiAocmVwb3J0SW50ZXJzZWN0aW9uKHBvaW50LCBbY3VycmVudFNlZ21lbnQsIG90aGVyU2VnbWVudF0pKSB7XG4gICAgICAgICAgLy8gc3RvcCBlYXJseVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICBpZiAoIWFzeW5jU3RhdGUpIHtcbiAgICAgIGFzeW5jU3RhdGUgPSB7aTogMH07XG4gICAgfVxuICAgIHZhciB0ZXN0ID0gbGluZXNbYXN5bmNTdGF0ZS5pXTtcbiAgICBjaGVja0ludGVyc2VjdGlvbih0ZXN0LCBhc3luY1N0YXRlLmkpO1xuICAgIGFzeW5jU3RhdGUuaSArPSAxO1xuICAgIHJldHVybiBhc3luY1N0YXRlLmkgPCBsaW5lcy5sZW5ndGg7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGFkZFRvSW5kZXgobGluZSkge1xuICAgIHZhciBtaW5YID0gbGluZS5mcm9tLng7IHZhciBtYXhYID0gbGluZS50by54O1xuICAgIHZhciBtaW5ZID0gbGluZS5mcm9tLnk7IHZhciBtYXhZID0gbGluZS50by55O1xuICAgIHZhciB0O1xuICAgIGlmIChtaW5YID4gbWF4WCkgeyB0ID0gbWluWDsgbWluWCA9IG1heFg7IG1heFggPSB0OyB9XG4gICAgaWYgKG1pblkgPiBtYXhZKSB7IHQgPSBtaW5ZOyBtaW5ZID0gbWF4WTsgbWF4WSA9IHQ7IH1cbiAgICBpbmRleC5hZGQobWluWCwgbWluWSwgbWF4WCwgbWF4WSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0SW50ZXJzZWN0aW9uUmVwb3J0ZXIocCwgaW50ZXJpb3IpIHtcbiAgICByZXN1bHRzLnB1c2goe1xuICAgICAgcG9pbnQ6IHAsIFxuICAgICAgc2VnbWVudHM6IGludGVyaW9yXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgaXNlY3QgYXMgc3dlZXAsIGJydXRlLCBidXNoIH07XG4iLCIvKlxuKiBsb2dsZXZlbCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTMgVGltIFBlcnJ5XG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiovXG4oZnVuY3Rpb24gKHJvb3QsIGRlZmluaXRpb24pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShkZWZpbml0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QubG9nID0gZGVmaW5pdGlvbigpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gU2xpZ2h0bHkgZHViaW91cyB0cmlja3MgdG8gY3V0IGRvd24gbWluaW1pemVkIGZpbGUgc2l6ZVxuICAgIHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcbiAgICB2YXIgdW5kZWZpbmVkVHlwZSA9IFwidW5kZWZpbmVkXCI7XG4gICAgdmFyIGlzSUUgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgJiYgKHR5cGVvZiB3aW5kb3cubmF2aWdhdG9yICE9PSB1bmRlZmluZWRUeXBlKSAmJiAoXG4gICAgICAgIC9UcmlkZW50XFwvfE1TSUUgLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KVxuICAgICk7XG5cbiAgICB2YXIgbG9nTWV0aG9kcyA9IFtcbiAgICAgICAgXCJ0cmFjZVwiLFxuICAgICAgICBcImRlYnVnXCIsXG4gICAgICAgIFwiaW5mb1wiLFxuICAgICAgICBcIndhcm5cIixcbiAgICAgICAgXCJlcnJvclwiXG4gICAgXTtcblxuICAgIHZhciBfbG9nZ2Vyc0J5TmFtZSA9IHt9O1xuICAgIHZhciBkZWZhdWx0TG9nZ2VyID0gbnVsbDtcblxuICAgIC8vIENyb3NzLWJyb3dzZXIgYmluZCBlcXVpdmFsZW50IHRoYXQgd29ya3MgYXQgbGVhc3QgYmFjayB0byBJRTZcbiAgICBmdW5jdGlvbiBiaW5kTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgbWV0aG9kID0gb2JqW21ldGhvZE5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZC5iaW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmJpbmQob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwobWV0aG9kLCBvYmopO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIE1pc3NpbmcgYmluZCBzaGltIG9yIElFOCArIE1vZGVybml6ciwgZmFsbGJhY2sgdG8gd3JhcHBpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkobWV0aG9kLCBbb2JqLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVHJhY2UoKSBkb2Vzbid0IHByaW50IHRoZSBtZXNzYWdlIGluIElFLCBzbyBmb3IgdGhhdCBjYXNlIHdlIG5lZWQgdG8gd3JhcCBpdFxuICAgIGZ1bmN0aW9uIHRyYWNlRm9ySUUoKSB7XG4gICAgICAgIGlmIChjb25zb2xlLmxvZykge1xuICAgICAgICAgICAgaWYgKGNvbnNvbGUubG9nLmFwcGx5KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gb2xkIElFLCBuYXRpdmUgY29uc29sZSBtZXRob2RzIHRoZW1zZWx2ZXMgZG9uJ3QgaGF2ZSBhcHBseSgpLlxuICAgICAgICAgICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShjb25zb2xlLmxvZywgW2NvbnNvbGUsIGFyZ3VtZW50c10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zb2xlLnRyYWNlKSBjb25zb2xlLnRyYWNlKCk7XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgdGhlIGJlc3QgbG9nZ2luZyBtZXRob2QgcG9zc2libGUgZm9yIHRoaXMgZW52XG4gICAgLy8gV2hlcmV2ZXIgcG9zc2libGUgd2Ugd2FudCB0byBiaW5kLCBub3Qgd3JhcCwgdG8gcHJlc2VydmUgc3RhY2sgdHJhY2VzXG4gICAgZnVuY3Rpb24gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmIChtZXRob2ROYW1lID09PSAnZGVidWcnKSB7XG4gICAgICAgICAgICBtZXRob2ROYW1lID0gJ2xvZyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gbWV0aG9kIHBvc3NpYmxlLCBmb3Igbm93IC0gZml4ZWQgbGF0ZXIgYnkgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlc1xuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZE5hbWUgPT09ICd0cmFjZScgJiYgaXNJRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYWNlRm9ySUU7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZVttZXRob2ROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCBtZXRob2ROYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCAnbG9nJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZXNlIHByaXZhdGUgZnVuY3Rpb25zIGFsd2F5cyBuZWVkIGB0aGlzYCB0byBiZSBzZXQgcHJvcGVybHlcblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VMb2dnaW5nTWV0aG9kcygpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgdmFyIGxldmVsID0gdGhpcy5nZXRMZXZlbCgpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIGFjdHVhbCBtZXRob2RzLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ01ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gbG9nTWV0aG9kc1tpXTtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0gPSAoaSA8IGxldmVsKSA/XG4gICAgICAgICAgICAgICAgbm9vcCA6XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCB0aGlzLm5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmaW5lIGxvZy5sb2cgYXMgYW4gYWxpYXMgZm9yIGxvZy5kZWJ1Z1xuICAgICAgICB0aGlzLmxvZyA9IHRoaXMuZGVidWc7XG5cbiAgICAgICAgLy8gUmV0dXJuIGFueSBpbXBvcnRhbnQgd2FybmluZ3MuXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHRoaXMubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEluIG9sZCBJRSB2ZXJzaW9ucywgdGhlIGNvbnNvbGUgaXNuJ3QgcHJlc2VudCB1bnRpbCB5b3UgZmlyc3Qgb3BlbiBpdC5cbiAgICAvLyBXZSBidWlsZCByZWFsTWV0aG9kKCkgcmVwbGFjZW1lbnRzIGhlcmUgdGhhdCByZWdlbmVyYXRlIGxvZ2dpbmcgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHVzZSBjbG9zZWx5IGJvdW5kIHJlYWwgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZSwgYW5kXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdhaXQgZm9yIGEgY29uc29sZSB0byBhcHBlYXIsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBfbGV2ZWwsIF9sb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIHJldHVybiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHx8XG4gICAgICAgICAgICAgICBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9nZ2VyKG5hbWUsIGZhY3RvcnkpIHtcbiAgICAgIC8vIFByaXZhdGUgaW5zdGFuY2UgdmFyaWFibGVzLlxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbGV2ZWwgaW5oZXJpdGVkIGZyb20gYSBwYXJlbnQgbG9nZ2VyIChvciBhIGdsb2JhbCBkZWZhdWx0KS4gV2VcbiAgICAgICAqIGNhY2hlIHRoaXMgaGVyZSByYXRoZXIgdGhhbiBkZWxlZ2F0aW5nIHRvIHRoZSBwYXJlbnQgc28gdGhhdCBpdCBzdGF5c1xuICAgICAgICogaW4gc3luYyB3aXRoIHRoZSBhY3R1YWwgbG9nZ2luZyBtZXRob2RzIHRoYXQgd2UgaGF2ZSBpbnN0YWxsZWQgKHRoZVxuICAgICAgICogcGFyZW50IGNvdWxkIGNoYW5nZSBsZXZlbHMgYnV0IHdlIG1pZ2h0IG5vdCBoYXZlIHJlYnVpbHQgdGhlIGxvZ2dlcnNcbiAgICAgICAqIGluIHRoaXMgY2hpbGQgeWV0KS5cbiAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHZhciBpbmhlcml0ZWRMZXZlbDtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGRlZmF1bHQgbGV2ZWwgZm9yIHRoaXMgbG9nZ2VyLCBpZiBhbnkuIElmIHNldCwgdGhpcyBvdmVycmlkZXNcbiAgICAgICAqIGBpbmhlcml0ZWRMZXZlbGAuXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfG51bGx9XG4gICAgICAgKi9cbiAgICAgIHZhciBkZWZhdWx0TGV2ZWw7XG4gICAgICAvKipcbiAgICAgICAqIEEgdXNlci1zcGVjaWZpYyBsZXZlbCBmb3IgdGhpcyBsb2dnZXIuIElmIHNldCwgdGhpcyBvdmVycmlkZXNcbiAgICAgICAqIGBkZWZhdWx0TGV2ZWxgLlxuICAgICAgICogQHR5cGUge251bWJlcnxudWxsfVxuICAgICAgICovXG4gICAgICB2YXIgdXNlckxldmVsO1xuXG4gICAgICB2YXIgc3RvcmFnZUtleSA9IFwibG9nbGV2ZWxcIjtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzdG9yYWdlS2V5ICs9IFwiOlwiICsgbmFtZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgc3RvcmFnZUtleSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbE51bSkge1xuICAgICAgICAgIHZhciBsZXZlbE5hbWUgPSAobG9nTWV0aG9kc1tsZXZlbE51bV0gfHwgJ3NpbGVudCcpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldID0gbGV2ZWxOYW1lO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9XG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIgKyBsZXZlbE5hbWUgKyBcIjtcIjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFBlcnNpc3RlZExldmVsKCkge1xuICAgICAgICAgIHZhciBzdG9yZWRMZXZlbDtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlIHx8ICFzdG9yYWdlS2V5KSByZXR1cm47XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV07XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gY29va2llcyBpZiBsb2NhbCBzdG9yYWdlIGdpdmVzIHVzIG5vdGhpbmdcbiAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlZExldmVsID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29va2llID0gd2luZG93LmRvY3VtZW50LmNvb2tpZTtcbiAgICAgICAgICAgICAgICAgIHZhciBjb29raWVOYW1lID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY29va2llLmluZGV4T2YoY29va2llTmFtZSArIFwiPVwiKTtcbiAgICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IC9eKFteO10rKS8uZXhlYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2llLnNsaWNlKGxvY2F0aW9uICsgY29va2llTmFtZS5sZW5ndGggKyAxKVxuICAgICAgICAgICAgICAgICAgICAgIClbMV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGUgc3RvcmVkIGxldmVsIGlzIG5vdCB2YWxpZCwgdHJlYXQgaXQgYXMgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuICAgICAgICAgIGlmIChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3RvcmVkTGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNsZWFyUGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUgfHwgIXN0b3JhZ2VLZXkpIHJldHVybjtcblxuICAgICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JhZ2VLZXkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPVxuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPTsgZXhwaXJlcz1UaHUsIDAxIEphbiAxOTcwIDAwOjAwOjAwIFVUQ1wiO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbm9ybWFsaXplTGV2ZWwoaW5wdXQpIHtcbiAgICAgICAgICB2YXIgbGV2ZWwgPSBpbnB1dDtcbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICByZXR1cm4gbGV2ZWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6IFwiICsgaW5wdXQpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICAqXG4gICAgICAgKiBQdWJsaWMgbG9nZ2VyIEFQSSAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwgZm9yIGRldGFpbHNcbiAgICAgICAqXG4gICAgICAgKi9cblxuICAgICAgc2VsZi5uYW1lID0gbmFtZTtcblxuICAgICAgc2VsZi5sZXZlbHMgPSB7IFwiVFJBQ0VcIjogMCwgXCJERUJVR1wiOiAxLCBcIklORk9cIjogMiwgXCJXQVJOXCI6IDMsXG4gICAgICAgICAgXCJFUlJPUlwiOiA0LCBcIlNJTEVOVFwiOiA1fTtcblxuICAgICAgc2VsZi5tZXRob2RGYWN0b3J5ID0gZmFjdG9yeSB8fCBkZWZhdWx0TWV0aG9kRmFjdG9yeTtcblxuICAgICAgc2VsZi5nZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodXNlckxldmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VyTGV2ZWw7XG4gICAgICAgICAgfSBlbHNlIGlmIChkZWZhdWx0TGV2ZWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRMZXZlbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluaGVyaXRlZExldmVsO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwsIHBlcnNpc3QpIHtcbiAgICAgICAgICB1c2VyTGV2ZWwgPSBub3JtYWxpemVMZXZlbChsZXZlbCk7XG4gICAgICAgICAgaWYgKHBlcnNpc3QgIT09IGZhbHNlKSB7ICAvLyBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICAgIHBlcnNpc3RMZXZlbElmUG9zc2libGUodXNlckxldmVsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBOT1RFOiBpbiB2MiwgdGhpcyBzaG91bGQgY2FsbCByZWJ1aWxkKCksIHdoaWNoIHVwZGF0ZXMgY2hpbGRyZW4uXG4gICAgICAgICAgcmV0dXJuIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXREZWZhdWx0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICBkZWZhdWx0TGV2ZWwgPSBub3JtYWxpemVMZXZlbChsZXZlbCk7XG4gICAgICAgICAgaWYgKCFnZXRQZXJzaXN0ZWRMZXZlbCgpKSB7XG4gICAgICAgICAgICAgIHNlbGYuc2V0TGV2ZWwobGV2ZWwsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnJlc2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdXNlckxldmVsID0gbnVsbDtcbiAgICAgICAgICBjbGVhclBlcnNpc3RlZExldmVsKCk7XG4gICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZik7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmVuYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlRSQUNFLCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZGlzYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlNJTEVOVCwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnJlYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGRlZmF1bHRMb2dnZXIgIT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgaW5oZXJpdGVkTGV2ZWwgPSBub3JtYWxpemVMZXZlbChkZWZhdWx0TG9nZ2VyLmdldExldmVsKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmKTtcblxuICAgICAgICAgIGlmIChkZWZhdWx0TG9nZ2VyID09PSBzZWxmKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGNoaWxkTmFtZSBpbiBfbG9nZ2Vyc0J5TmFtZSkge1xuICAgICAgICAgICAgICAgIF9sb2dnZXJzQnlOYW1lW2NoaWxkTmFtZV0ucmVidWlsZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSBhbGwgdGhlIGludGVybmFsIGxldmVscy5cbiAgICAgIGluaGVyaXRlZExldmVsID0gbm9ybWFsaXplTGV2ZWwoXG4gICAgICAgICAgZGVmYXVsdExvZ2dlciA/IGRlZmF1bHRMb2dnZXIuZ2V0TGV2ZWwoKSA6IFwiV0FSTlwiXG4gICAgICApO1xuICAgICAgdmFyIGluaXRpYWxMZXZlbCA9IGdldFBlcnNpc3RlZExldmVsKCk7XG4gICAgICBpZiAoaW5pdGlhbExldmVsICE9IG51bGwpIHtcbiAgICAgICAgICB1c2VyTGV2ZWwgPSBub3JtYWxpemVMZXZlbChpbml0aWFsTGV2ZWwpO1xuICAgICAgfVxuICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZik7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKlxuICAgICAqIFRvcC1sZXZlbCBBUElcbiAgICAgKlxuICAgICAqL1xuXG4gICAgZGVmYXVsdExvZ2dlciA9IG5ldyBMb2dnZXIoKTtcblxuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcbiAgICAgICAgaWYgKCh0eXBlb2YgbmFtZSAhPT0gXCJzeW1ib2xcIiAmJiB0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikgfHwgbmFtZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV07XG4gICAgICAgIGlmICghbG9nZ2VyKSB7XG4gICAgICAgICAgICBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXSA9IG5ldyBMb2dnZXIoXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0TG9nZ2VyLm1ldGhvZEZhY3RvcnlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICB9O1xuXG4gICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgdmFyIF9sb2cgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgPyB3aW5kb3cubG9nIDogdW5kZWZpbmVkO1xuICAgIGRlZmF1bHRMb2dnZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJlxuICAgICAgICAgICAgICAgd2luZG93LmxvZyA9PT0gZGVmYXVsdExvZ2dlcikge1xuICAgICAgICAgICAgd2luZG93LmxvZyA9IF9sb2c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbiAgICB9O1xuXG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXJzID0gZnVuY3Rpb24gZ2V0TG9nZ2VycygpIHtcbiAgICAgICAgcmV0dXJuIF9sb2dnZXJzQnlOYW1lO1xuICAgIH07XG5cbiAgICAvLyBFUzYgZGVmYXVsdCBleHBvcnQsIGZvciBjb21wYXRpYmlsaXR5XG4gICAgZGVmYXVsdExvZ2dlclsnZGVmYXVsdCddID0gZGVmYXVsdExvZ2dlcjtcblxuICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xufSkpO1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDaGVja3MsIGlmIHBvbHlnb24gaXMgc2ltcGxlLiBQb2x5Z29uIGlzIHNpbXBsZSwgd2hlbiBpdHMgZWRnZXMgZG9uJ3QgY3Jvc3MgZWFjaCBvdGhlci5cbiAqXG4gKiBAcGFyYW0ge251bWJlcltdfSBwb2x5Z29uIFt4MSwgeTEsIHgyLCB5Mi4uLl1cbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIFBvbHlnb24gaXMgc2ltcGxlXG4gKi9cbmZ1bmN0aW9uIElzU2ltcGxlIChwb2x5Z29uKSB7XG4gIHZhciBwID0gcG9seWdvbjtcbiAgdmFyIG4gPSBwLmxlbmd0aCA+PiAxO1xuICBpZiAobiA8IDQpIHJldHVybiB0cnVlXG4gIHZhciBhMSA9IFBvaW50KCk7XG4gIHZhciBhMiA9IFBvaW50KCk7XG4gIHZhciBiMSA9IFBvaW50KCk7XG4gIHZhciBiMiA9IFBvaW50KCk7XG4gIHZhciBjID0gUG9pbnQoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIGExLnggPSBwWzIgKiBpXTtcbiAgICBhMS55ID0gcFsyICogaSArIDFdO1xuICAgIGlmIChpID09IG4gLSAxKSB7XG4gICAgICBhMi54ID0gcFswXTtcbiAgICAgIGEyLnkgPSBwWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBhMi54ID0gcFsyICogaSArIDJdO1xuICAgICAgYTIueSA9IHBbMiAqIGkgKyAzXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgaWYgKE1hdGguYWJzKGkgLSBqKSA8IDIpIGNvbnRpbnVlXG4gICAgICBpZiAoaiA9PSBuIC0gMSAmJiBpID09IDApIGNvbnRpbnVlXG4gICAgICBpZiAoaSA9PSBuIC0gMSAmJiBqID09IDApIGNvbnRpbnVlXG5cbiAgICAgIGIxLnggPSBwWzIgKiBqXTtcbiAgICAgIGIxLnkgPSBwWzIgKiBqICsgMV07XG4gICAgICBpZiAoaiA9PSBuIC0gMSkge1xuICAgICAgICBiMi54ID0gcFswXTtcbiAgICAgICAgYjIueSA9IHBbMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiMi54ID0gcFsyICogaiArIDJdO1xuICAgICAgICBiMi55ID0gcFsyICogaiArIDNdO1xuICAgICAgfVxuXG4gICAgICBpZiAoR2V0TGluZUludGVyc2VjdGlvbihhMSwgYTIsIGIxLCBiMiwgYykgIT0gbnVsbCkgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5tb2R1bGUuZXhwb3J0cy5Jc1NpbXBsZSA9IElzU2ltcGxlO1xuXG4vKipcbiAqIENoZWNrcywgaWYgcG9seWdvbiBpcyBjb252ZXguIFBvbHlnb24gaXMgY29udmV4LCB3aGVuIGVhY2ggaW5uZXIgYW5nbGUgaXMgPD0gMTgwwrAuXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gcG9seWdvbiBbeDEsIHkxLCB4MiwgeTIuLi5dXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gSXNDb252ZXggKHBvbHlnb24pIHtcbiAgdmFyIHAgPSBwb2x5Z29uO1xuICBpZiAocC5sZW5ndGggPCA2KSByZXR1cm4gdHJ1ZVxuICB2YXIgbCA9IHAubGVuZ3RoIC0gNDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpICs9IDIpIHtcbiAgICBpZiAoIWNvbnZleChwW2ldLCBwW2kgKyAxXSwgcFtpICsgMl0sIHBbaSArIDNdLCBwW2kgKyA0XSwgcFtpICsgNV0pKSByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAoIWNvbnZleChwW2xdLCBwW2wgKyAxXSwgcFtsICsgMl0sIHBbbCArIDNdLCBwWzBdLCBwWzFdKSkgcmV0dXJuIGZhbHNlXG4gIGlmICghY29udmV4KHBbbCArIDJdLCBwW2wgKyAzXSwgcFswXSwgcFsxXSwgcFsyXSwgcFszXSkpIHJldHVybiBmYWxzZVxuICByZXR1cm4gdHJ1ZVxufVxubW9kdWxlLmV4cG9ydHMuSXNDb252ZXggPSBJc0NvbnZleDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhcmVhIG9mIHBvbHlnb24uXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gcG9seWdvbiBbeDEsIHkxLCB4MiwgeTIuLi5dXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBHZXRBcmVhIChwb2x5Z29uKSB7XG4gIHZhciBwID0gcG9seWdvbjtcbiAgaWYgKHAubGVuZ3RoIDwgNikgcmV0dXJuIDBcbiAgdmFyIGwgPSBwLmxlbmd0aCAtIDI7XG4gIHZhciBzdW0gPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkgKz0gMikge1xuICAgIHN1bSArPSAocFtpICsgMl0gLSBwW2ldKSAqIChwW2kgKyAxXSArIHBbaSArIDNdKTtcbiAgfVxuICBzdW0gKz0gKHBbMF0gLSBwW2xdKSAqIChwW2wgKyAxXSArIHBbMV0pO1xuICByZXR1cm4gLXN1bSAqIDAuNVxufVxubW9kdWxlLmV4cG9ydHMuR2V0QXJlYSA9IEdldEFyZWE7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgQXhpcy1hbGlnbmVkIEJvdW5kaW5nIEJveCBvZiBwb2x5Z29uXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gcG9seWdvbiBbeDEsIHkxLCB4MiwgeTIuLi5dXG4gKiBAcmV0dXJucyB7QUFCQn1cbiAqIEBleGFtcGxlXG4gKiAvLz17eDowLCB5OjAsIHdpZHRoOjAsIGhlaWdodDowfVxuICovXG5mdW5jdGlvbiBHZXRBQUJCIChwb2x5Z29uKSB7XG4gIHZhciBwID0gcG9seWdvbjtcbiAgdmFyIG1pbnggPSBJbmZpbml0eTtcbiAgdmFyIG1pbnkgPSBJbmZpbml0eTtcbiAgdmFyIG1heHggPSAtbWlueDtcbiAgdmFyIG1heHkgPSAtbWlueTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgbWlueCA9IE1hdGgubWluKG1pbngsIHBbaV0pO1xuICAgIG1heHggPSBNYXRoLm1heChtYXh4LCBwW2ldKTtcbiAgICBtaW55ID0gTWF0aC5taW4obWlueSwgcFtpICsgMV0pO1xuICAgIG1heHkgPSBNYXRoLm1heChtYXh5LCBwW2kgKyAxXSk7XG4gIH1cbiAgcmV0dXJuIHt4OiBtaW54LCB5OiBtaW55LCB3aWR0aDogbWF4eCAtIG1pbngsIGhlaWdodDogbWF4eSAtIG1pbnl9XG59XG5tb2R1bGUuZXhwb3J0cy5HZXRBQUJCID0gR2V0QUFCQjtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgdHJpYW5ndWxhdGlvbi4gT3V0cHV0IGFycmF5IGlzIGFycmF5IG9mIHRyaWFuZ2xlcyAodHJpYW5nbGUgPSAzIGluZGljZXMgb2YgcG9seWdvbiB2ZXJ0aWNlcykuXG4gKlxuICogV29ya3Mgd2l0aCBzaW1wbGUgcG9seWdvbnMgb25seS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcltdfSBwb2x5Z29uIFt4MSwgeTEsIHgyLCB5Mi4uLl1cbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gYXJyYXkgb2YgdHJpYW5nbGVzICh0cmlhbmdsZSA9IDMgaW5kaWNlcyBvZiBwb2x5Z29uIHZlcnRpY2VzKVxuICogQGV4YW1wbGVcbiAqIHZhciBpZHMgPSBQb2x5Sy5Ucmlhbmd1bGF0ZShbMCwgMCwgMSwgMCwgMSwgMSwgMCwgMV0pO1xuICogLy89WzAsIDEsIDIsIDAsIDIsIDNdXG4gKi9cbmZ1bmN0aW9uIFRyaWFuZ3VsYXRlIChwb2x5Z29uKSB7XG4gIHZhciBwID0gcG9seWdvbjtcbiAgdmFyIG4gPSBwLmxlbmd0aCA+PiAxO1xuICBpZiAobiA8IDMpIHJldHVybiBbXVxuICB2YXIgdGdzID0gW107XG4gIHZhciBhdmwgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHsgYXZsLnB1c2goaSk7IH1cblxuICB2YXIgaSA9IDA7XG4gIHZhciBhbCA9IG47XG4gIHdoaWxlIChhbCA+IDMpIHtcbiAgICB2YXIgaTAgPSBhdmxbKGkgKyAwKSAlIGFsXTtcbiAgICB2YXIgaTEgPSBhdmxbKGkgKyAxKSAlIGFsXTtcbiAgICB2YXIgaTIgPSBhdmxbKGkgKyAyKSAlIGFsXTtcblxuICAgIHZhciBheCA9IHBbMiAqIGkwXTtcbiAgICB2YXIgYXkgPSBwWzIgKiBpMCArIDFdO1xuICAgIHZhciBieCA9IHBbMiAqIGkxXTtcbiAgICB2YXIgYnkgPSBwWzIgKiBpMSArIDFdO1xuICAgIHZhciBjeCA9IHBbMiAqIGkyXTtcbiAgICB2YXIgY3kgPSBwWzIgKiBpMiArIDFdO1xuXG4gICAgdmFyIGVhckZvdW5kID0gZmFsc2U7XG4gICAgaWYgKGNvbnZleChheCwgYXksIGJ4LCBieSwgY3gsIGN5KSkge1xuICAgICAgZWFyRm91bmQgPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhbDsgaisrKSB7XG4gICAgICAgIHZhciB2aSA9IGF2bFtqXTtcbiAgICAgICAgaWYgKHZpID09IGkwIHx8IHZpID09IGkxIHx8IHZpID09IGkyKSBjb250aW51ZVxuICAgICAgICBpZiAoUG9pbnRJblRyaWFuZ2xlKHBbMiAqIHZpXSwgcFsyICogdmkgKyAxXSwgYXgsIGF5LCBieCwgYnksIGN4LCBjeSkpIHtcbiAgICAgICAgICBlYXJGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVhckZvdW5kKSB7XG4gICAgICB0Z3MucHVzaChpMCwgaTEsIGkyKTtcbiAgICAgIGF2bC5zcGxpY2UoKGkgKyAxKSAlIGFsLCAxKTtcbiAgICAgIGFsLS07XG4gICAgICBpID0gMDtcbiAgICB9IGVsc2UgaWYgKGkrKyA+IDMgKiBhbCkgYnJlYWsgICAgLy8gbm8gY29udmV4IGFuZ2xlcyA6KFxuICB9XG4gIHRncy5wdXNoKGF2bFswXSwgYXZsWzFdLCBhdmxbMl0pO1xuICByZXR1cm4gdGdzXG59XG5tb2R1bGUuZXhwb3J0cy5Ucmlhbmd1bGF0ZSA9IFRyaWFuZ3VsYXRlO1xuXG4vKipcbiAqIFNsaWNlcyB0aGUgcG9seWdvbiB3aXRoIGxpbmUgc2VnbWVudCBBLUIsIGRlZmluZWQgYnkgW2F4LGF5XSBhbmQgW2J4LGJ5XS4gQSwgQiBtdXN0IG5vdCBsYXkgaW5zaWRlIGEgcG9seWdvbi4gUmV0dXJucyBhbiBhcnJheSBvZiBwb2x5Z29ucy5cbiAqXG4gKiBXb3JrcyB3aXRoIHNpbXBsZSBwb2x5Z29ucyBvbmx5LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyW119IHBvbHlnb24gW3gxLCB5MSwgeDIsIHkyLi4uXVxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0WCBTdGFydCBDb29yZGluYXRlIFt4XVxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0WSBTdGFydCBDb29yZGluYXRlIFt5XVxuICogQHBhcmFtIHtudW1iZXJ9IGVuZFggRW5kIENvb3JkaW5hdGUgW3hdXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kWSBFbmQgQ29vcmRpbmF0ZSBbeV1cbiAqIEByZXR1cm5zIHtudW1iZXJbXVtdfSBBcnJheSBvZiBQb2x5Z29uXG4gKi9cbmZ1bmN0aW9uIFNsaWNlIChwb2x5Z29uLCBzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSkge1xuICB2YXIgcCA9IHBvbHlnb247XG4gIHZhciBheCA9IHN0YXJ0WDtcbiAgdmFyIGF5ID0gc3RhcnRZO1xuICB2YXIgYnggPSBlbmRYO1xuICB2YXIgYnkgPSBlbmRZO1xuICBpZiAoQ29udGFpbnNQb2ludChwLCBheCwgYXkpIHx8IENvbnRhaW5zUG9pbnQocCwgYngsIGJ5KSkge1xuICAgIHJldHVybiBbcC5zbGljZSgwKV1cbiAgfVxuXG4gIHZhciBhID0gUG9pbnQoYXgsIGF5KTtcbiAgdmFyIGIgPSBQb2ludChieCwgYnkpO1xuICB2YXIgaXNjcyA9IFtdOyAgLy8gaW50ZXJzZWN0aW9uc1xuICB2YXIgcHMgPSBbXTsgIC8vIHBvaW50c1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBwcy5wdXNoKFBvaW50KHBbaV0sIHBbaSArIDFdKSk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpc2MgPSBQb2ludCgwLCAwKTtcbiAgICBpc2MgPSBHZXRMaW5lSW50ZXJzZWN0aW9uKGEsIGIsIHBzW2ldLCBwc1soaSArIDEpICUgcHMubGVuZ3RoXSwgaXNjKTtcbiAgICB2YXIgZmlzYyA9IGlzY3NbMF07XG4gICAgdmFyIGxpc2MgPSBpc2NzW2lzY3MubGVuZ3RoIC0gMV07XG4gICAgLy8gJiYgKGlzYy54IT1wc1tpXS54IHx8IGlzYy55IT1wc1tpXS55KSApXG4gICAgaWYgKGlzYyAmJiAoZmlzYyA9PSBudWxsIHx8IGRpc3RhbmNlKGlzYywgZmlzYykgPiAxZS0xMCkgJiYgKGxpc2MgPT0gbnVsbCB8fCBkaXN0YW5jZShpc2MsIGxpc2MpID4gMWUtMTApKSB7XG4gICAgICBpc2MuZmxhZyA9IHRydWU7XG4gICAgICBpc2NzLnB1c2goaXNjKTtcbiAgICAgIHBzLnNwbGljZShpICsgMSwgMCwgaXNjKTtcbiAgICAgIGkrKztcbiAgICB9XG4gIH1cblxuICBpZiAoaXNjcy5sZW5ndGggPCAyKSByZXR1cm4gW3Auc2xpY2UoMCldXG4gIHZhciBjb21wID0gZnVuY3Rpb24gKHUsIHYpIHsgcmV0dXJuIGRpc3RhbmNlKGEsIHUpIC0gZGlzdGFuY2UoYSwgdikgfTtcbiAgaXNjcy5zb3J0KGNvbXApO1xuXG4gIHZhciBwZ3MgPSBbXTtcbiAgdmFyIGRpciA9IDA7XG4gIHdoaWxlIChpc2NzLmxlbmd0aCA+IDApIHtcbiAgICAvLyB2YXIgbiA9IHBzLmxlbmd0aCAvLyBpcyBhc3NpZ25lZCBhIHZhbHVlIGJ1dCBuZXZlciB1c2VkLiAobm8tdW51c2VkLXZhcnMpXG4gICAgdmFyIGkwID0gaXNjc1swXTtcbiAgICB2YXIgaTEgPSBpc2NzWzFdO1xuICAgIC8vIGlmKGkwLng9PWkxLnggJiYgaTAueT09aTEueSkgeyBpc2NzLnNwbGljZSgwLDIpOyBjb250aW51ZTt9XG4gICAgdmFyIGluZGV4MCA9IHBzLmluZGV4T2YoaTApO1xuICAgIHZhciBpbmRleDEgPSBwcy5pbmRleE9mKGkxKTtcbiAgICB2YXIgc29sdmVkID0gZmFsc2U7XG5cbiAgICBpZiAoZmlyc3RXaXRoRmxhZyhwcywgaW5kZXgwKSA9PT0gaW5kZXgxKSB7XG4gICAgICBzb2x2ZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpMCA9IGlzY3NbMV07XG4gICAgICBpMSA9IGlzY3NbMF07XG4gICAgICBpbmRleDAgPSBwcy5pbmRleE9mKGkwKTtcbiAgICAgIGluZGV4MSA9IHBzLmluZGV4T2YoaTEpO1xuICAgICAgaWYgKGZpcnN0V2l0aEZsYWcocHMsIGluZGV4MCkgPT09IGluZGV4MSkgc29sdmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHNvbHZlZCkge1xuICAgICAgZGlyLS07XG4gICAgICB2YXIgcGduID0gZ2V0UG9pbnRzKHBzLCBpbmRleDAsIGluZGV4MSk7XG4gICAgICBwZ3MucHVzaChwZ24pO1xuICAgICAgcHMgPSBnZXRQb2ludHMocHMsIGluZGV4MSwgaW5kZXgwKTtcbiAgICAgIGkwLmZsYWcgPSBpMS5mbGFnID0gZmFsc2U7XG4gICAgICBpc2NzLnNwbGljZSgwLCAyKTtcbiAgICAgIGlmIChpc2NzLmxlbmd0aCA9PSAwKSBwZ3MucHVzaChwcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpcisrO1xuICAgICAgaXNjcy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIGlmIChkaXIgPiAxKSBicmVha1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwZ3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGcgPSBwZ3NbaV07XG4gICAgdmFyIG5wZyA9IFtdO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGcubGVuZ3RoOyBqKyspIHsgbnBnLnB1c2gocGdbal0ueCwgcGdbal0ueSk7IH1cbiAgICByZXN1bHQucHVzaChucGcpO1xuICB9XG4gIHJldHVybiByZXN1bHRcbn1cbm1vZHVsZS5leHBvcnRzLlNsaWNlID0gU2xpY2U7XG5cbi8qKlxuICogQ2hlY2tzLCBpZiBwb2x5Z29uIGNvbnRhaW5zIFt4LCB5XS5cbiAqXG4gKiBXb3JrcyB3aXRoIHNpbXBsZSBwb2x5Z29ucyBvbmx5LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyW119IHBvbHlnb24gW3gxLCB5MSwgeDIsIHkyLi4uXVxuICogQHBhcmFtIHtudW1iZXJ9IHBvaW50WCBDb29yZGluYXRlIFt4XVxuICogQHBhcmFtIHtudW1iZXJ9IHBvaW50WSBDb29yZGluYXRlIFt5XVxuICogQHJldHVybnMge2Jvb2xlYW59IGRlcHRoXG4gKi9cbmZ1bmN0aW9uIENvbnRhaW5zUG9pbnQgKHBvbHlnb24sIHBvaW50WCwgcG9pbnRZKSB7XG4gIHZhciBwID0gcG9seWdvbjtcbiAgdmFyIHB4ID0gcG9pbnRYO1xuICB2YXIgcHkgPSBwb2ludFk7XG4gIHZhciBuID0gcC5sZW5ndGggPj4gMTtcbiAgdmFyIGF4O1xuICB2YXIgYXkgPSBwWzIgKiBuIC0gM10gLSBweTtcbiAgdmFyIGJ4ID0gcFsyICogbiAtIDJdIC0gcHg7XG4gIHZhciBieSA9IHBbMiAqIG4gLSAxXSAtIHB5O1xuXG4gIC8vIHZhciBsdXAgPSBieSA+IGF5O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIGF4ID0gYng7XG4gICAgYXkgPSBieTtcbiAgICBieCA9IHBbMiAqIGldIC0gcHg7XG4gICAgYnkgPSBwWzIgKiBpICsgMV0gLSBweTtcbiAgICBpZiAoYXkgPT09IGJ5KSBjb250aW51ZVxuICAgIHZhciBsdXAgPSBieSA+IGF5O1xuICB9XG5cbiAgdmFyIGRlcHRoID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBheCA9IGJ4O1xuICAgIGF5ID0gYnk7XG4gICAgYnggPSBwWzIgKiBpXSAtIHB4O1xuICAgIGJ5ID0gcFsyICogaSArIDFdIC0gcHk7XG4gICAgaWYgKGF5IDwgMCAmJiBieSA8IDApIGNvbnRpbnVlICAvLyBib3RoIFwidXBcIiBvciBib3RoIFwiZG93blwiXG4gICAgaWYgKGF5ID4gMCAmJiBieSA+IDApIGNvbnRpbnVlICAvLyBib3RoIFwidXBcIiBvciBib3RoIFwiZG93blwiXG4gICAgaWYgKGF4IDwgMCAmJiBieCA8IDApIGNvbnRpbnVlICAgLy8gYm90aCBwb2ludHMgb24gdGhlIGxlZnRcblxuICAgIGlmIChheSA9PT0gYnkgJiYgTWF0aC5taW4oYXgsIGJ4KSA8PSAwKSByZXR1cm4gdHJ1ZVxuICAgIGlmIChheSA9PT0gYnkpIGNvbnRpbnVlXG5cbiAgICB2YXIgbHggPSBheCArIChieCAtIGF4KSAqICgtYXkpIC8gKGJ5IC0gYXkpO1xuICAgIGlmIChseCA9PT0gMCkgcmV0dXJuIHRydWUgICAgICAvLyBwb2ludCBvbiBlZGdlXG4gICAgaWYgKGx4ID4gMCkgZGVwdGgrKztcbiAgICBpZiAoYXkgPT09IDAgJiYgbHVwICYmIGJ5ID4gYXkpIGRlcHRoLS07ICAvLyBoaXQgdmVydGV4LCBib3RoIHVwXG4gICAgaWYgKGF5ID09PSAwICYmICFsdXAgJiYgYnkgPCBheSkgZGVwdGgtLTsgLy8gaGl0IHZlcnRleCwgYm90aCBkb3duXG4gICAgbHVwID0gYnkgPiBheTtcbiAgfVxuICByZXR1cm4gKGRlcHRoICYgMSkgPT09IDFcbn1cbm1vZHVsZS5leHBvcnRzLkNvbnRhaW5zUG9pbnQgPSBDb250YWluc1BvaW50O1xuXG4vKipcbiAqIEZpbmRzIHRoZSBjbG9zZXN0IHBvaW50IG9mIHBvbHlnb24sIHdoaWNoIGxheXMgb24gcmF5IGRlZmluZWQgYnkgW3gseV0gKG9yaWdpbikgYW5kIFtkeCxkeV0gKGRpcmVjdGlvbikuXG4gKlxuICogXCJkaXN0XCIgaXMgdGhlIGRpc3RhbmNlIG9mIHRoZSBwb2x5Z29uIHBvaW50LCBcImVkZ2VcIiBpcyB0aGUgbnVtYmVyIG9mIHRoZSBlZGdlLCBvbiB3aGljaCBpbnRlcnNlY3Rpb24gb2NjdXJzLCBcIm5vcm1cIiBpcyB0aGUgbm9ybWFsIGluIHRoYXQgcGxhY2UsIFwicmVmbFwiIGlzIHJlZmxlY3RlZCBkaXJlY3Rpb24uXG4gKlxuICogV29ya3Mgd2l0aCBzaW1wbGUgcG9seWdvbnMgb25seS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcltdfSBwb2x5Z29uIFt4MSwgeTEsIHgyLCB5Mi4uLl1cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcmlnaW5YIE9yaWdpbiBbeF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcmlnaW5ZIE9yaWdpbiBbeV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb25YIERpcmVjdGlvbiBbeF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb25ZIERpcmVjdGlvbiBbeV1cbiAqIEByZXR1cm5zIHtSYXljYXN0fVxuICogQGV4YW1wbGVcbiAqIC8vPXtkaXN0OjAsIGVkZ2U6MCwgbm9ybTp7eDowLCB5OjB9LCByZWZsOnt4OjAsIHk6MH19XG4gKi9cbmZ1bmN0aW9uIFJheWNhc3QgKHBvbHlnb24sIG9yaWdpblgsIG9yaWdpblksIGRpcmVjdGlvblgsIGRpcmVjdGlvblksIGlzYykge1xuICB2YXIgcCA9IHBvbHlnb247XG4gIHZhciB4ID0gb3JpZ2luWDtcbiAgdmFyIHkgPSBvcmlnaW5ZO1xuICB2YXIgZHggPSBkaXJlY3Rpb25YO1xuICB2YXIgZHkgPSBkaXJlY3Rpb25ZO1xuICB2YXIgbCA9IHAubGVuZ3RoIC0gMjtcbiAgdmFyIGVtcHR5ID0gZW1wdHlQb2ludHMoKTtcbiAgdmFyIGExID0gZW1wdHlbMF07XG4gIHZhciBhMiA9IGVtcHR5WzFdO1xuICB2YXIgYjEgPSBlbXB0eVsyXTtcbiAgdmFyIGIyID0gZW1wdHlbM107XG4gIHZhciBjID0gZW1wdHlbNF07XG4gIGExLnggPSB4O1xuICBhMS55ID0geTtcbiAgYTIueCA9IHggKyBkeDtcbiAgYTIueSA9IHkgKyBkeTtcblxuICBpZiAoaXNjID09PSBudWxsIHx8IGlzYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaXNjID0ge2Rpc3Q6IDAsIGVkZ2U6IDAsIG5vcm06IHt4OiAwLCB5OiAwfSwgcmVmbDoge3g6IDAsIHk6IDB9fTtcbiAgfVxuICBpc2MuZGlzdCA9IEluZmluaXR5O1xuXG4gIHZhciBuaXNjO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkgKz0gMikge1xuICAgIGIxLnggPSBwW2ldO1xuICAgIGIxLnkgPSBwW2kgKyAxXTtcbiAgICBiMi54ID0gcFtpICsgMl07XG4gICAgYjIueSA9IHBbaSArIDNdO1xuICAgIG5pc2MgPSBSYXlMaW5lSW50ZXJzZWN0aW9uKGExLCBhMiwgYjEsIGIyLCBjKTtcbiAgICBpZiAobmlzYykge1xuICAgICAgaXNjID0gdXBkYXRlSVNDKGR4LCBkeSwgYTEsIGIxLCBiMiwgYywgaSAvIDIsIGlzYyk7XG4gICAgfVxuICB9XG4gIGIxLnggPSBiMi54O1xuICBiMS55ID0gYjIueTtcbiAgYjIueCA9IHBbMF07XG4gIGIyLnkgPSBwWzFdO1xuICBuaXNjID0gUmF5TGluZUludGVyc2VjdGlvbihhMSwgYTIsIGIxLCBiMiwgYyk7XG4gIGlmIChuaXNjKSB7XG4gICAgaXNjID0gdXBkYXRlSVNDKGR4LCBkeSwgYTEsIGIxLCBiMiwgYywgKHAubGVuZ3RoIC8gMikgLSAxLCBpc2MpO1xuICB9XG5cbiAgcmV0dXJuIChpc2MuZGlzdCAhPT0gSW5maW5pdHkpID8gaXNjIDogbnVsbFxufVxubW9kdWxlLmV4cG9ydHMuUmF5Y2FzdCA9IFJheWNhc3Q7XG5cbi8qKlxuICogRmluZHMgdGhlIHBvaW50IG9uIHBvbHlnb24gZWRnZXMsIHdoaWNoIGlzIGNsb3Nlc3QgdG8gW3gseV0uIFJldHVybnMgYW4gb2JqZWN0IGluIHRoaXMgZm9ybWF0XG4gKlxuICogXCJkaXN0XCIgaXMgdGhlIGRpc3RhbmNlIG9mIHRoZSBwb2x5Z29uIHBvaW50LCBcImVkZ2VcIiBpcyB0aGUgbnVtYmVyIG9mIHRoZSBjbG9zZXN0IGVkZ2UsIFwicG9pbnRcIiBpcyB0aGUgY2xvc2VzdCBwb2ludCBvbiB0aGF0IGVkZ2UsIFwibm9ybVwiIGlzIHRoZSBub3JtYWwgZnJvbSBcInBvaW50XCIgdG8gW3gseV0uXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gcG9seWdvbiBbeDEsIHkxLCB4MiwgeTIuLi5dXG4gKiBAcGFyYW0ge251bWJlcn0geCBDb29yZGluYXRlIFt4XVxuICogQHBhcmFtIHtudW1iZXJ9IHkgQ29vcmRpbmF0ZSBbeV1cbiAqIEByZXR1cm5zIHtDbG9zZXN0RWRnZX1cbiAqIEBleGFtcGxlXG4gKiAvLz17ZGlzdDowLCBlZGdlOjAsIHBvaW50Ont4OjAsIHk6MH0sIG5vcm06e3g6MCwgeTowfX1cbiAqL1xuZnVuY3Rpb24gQ2xvc2VzdEVkZ2UgKHBvbHlnb24sIHgsIHksIGlzYykge1xuICB2YXIgcCA9IHBvbHlnb247XG4gIHZhciBsID0gcC5sZW5ndGggLSAyO1xuICB2YXIgZW1wdHkgPSBlbXB0eVBvaW50cygpO1xuICB2YXIgYTEgPSBlbXB0eVswXTtcbiAgdmFyIGIxID0gZW1wdHlbMl07XG4gIHZhciBiMiA9IGVtcHR5WzNdO1xuICAvLyB2YXIgYyA9IHRwWzRdIC8vIGlzIGFzc2lnbmVkIGEgdmFsdWUgYnV0IG5ldmVyIHVzZWQuXG4gIGExLnggPSB4O1xuICBhMS55ID0geTtcblxuICBpZiAoaXNjID09IG51bGwpIHtcbiAgICBpc2MgPSB7ZGlzdDogMCwgZWRnZTogMCwgcG9pbnQ6IHt4OiAwLCB5OiAwfSwgbm9ybToge3g6IDAsIHk6IDB9fTtcbiAgfVxuICBpc2MuZGlzdCA9IEluZmluaXR5O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgYjEueCA9IHBbaV07XG4gICAgYjEueSA9IHBbaSArIDFdO1xuICAgIGIyLnggPSBwW2kgKyAyXTtcbiAgICBiMi55ID0gcFtpICsgM107XG4gICAgaXNjID0gcG9pbnRMaW5lRGlzdChhMSwgYjEsIGIyLCBpID4+IDEsIGlzYyk7XG4gIH1cbiAgYjEueCA9IGIyLng7XG4gIGIxLnkgPSBiMi55O1xuICBiMi54ID0gcFswXTtcbiAgYjIueSA9IHBbMV07XG4gIGlzYyA9IHBvaW50TGluZURpc3QoYTEsIGIxLCBiMiwgbCA+PiAxLCBpc2MpO1xuXG4gIHZhciBpZHN0ID0gMSAvIGlzYy5kaXN0O1xuICBpc2Mubm9ybS54ID0gKHggLSBpc2MucG9pbnQueCkgKiBpZHN0O1xuICBpc2Mubm9ybS55ID0gKHkgLSBpc2MucG9pbnQueSkgKiBpZHN0O1xuICByZXR1cm4gaXNjXG59XG5tb2R1bGUuZXhwb3J0cy5DbG9zZXN0RWRnZSA9IENsb3Nlc3RFZGdlO1xuXG4vKipcbiAqIFJldmVyc2VcbiAqXG4gKiBAcGFyYW0ge251bWJlcltdfSBwb2x5Z29uIFt4MSwgeTEsIHgyLCB5Mi4uLl1cbiAqL1xuZnVuY3Rpb24gUmV2ZXJzZSAocG9seWdvbikge1xuICB2YXIgcCA9IHBvbHlnb247XG4gIHZhciBucCA9IFtdO1xuICBmb3IgKHZhciBqID0gcC5sZW5ndGggLSAyOyBqID49IDA7IGogLT0gMikgeyBucC5wdXNoKHBbal0sIHBbaiArIDFdKTsgfVxuICByZXR1cm4gbnBcbn1cbm1vZHVsZS5leHBvcnRzLlJldmVyc2UgPSBSZXZlcnNlO1xuXG4vKipcbiAqIFBvaW50IExpbmUgRGlzdGFuY2VcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQb2ludH0gcFxuICogQHBhcmFtIHtQb2ludH0gYVxuICogQHBhcmFtIHtQb2ludH0gYlxuICogQHBhcmFtIHs/P30gZWRnZVxuICogQHBhcmFtIHs/P30gaXNjXG4gKiBAcmV0dXJucyB7Pz99IElTQ1xuICovXG5mdW5jdGlvbiBwb2ludExpbmVEaXN0IChwLCBhLCBiLCBlZGdlLCBpc2MpIHtcbiAgdmFyIHggPSBwLng7XG4gIHZhciB5ID0gcC55O1xuICB2YXIgeDEgPSBhLng7XG4gIHZhciB5MSA9IGEueTtcbiAgdmFyIHgyID0gYi54O1xuICB2YXIgeTIgPSBiLnk7XG5cbiAgdmFyIEEgPSB4IC0geDE7XG4gIHZhciBCID0geSAtIHkxO1xuICB2YXIgQyA9IHgyIC0geDE7XG4gIHZhciBEID0geTIgLSB5MTtcblxuICB2YXIgZG90ID0gQSAqIEMgKyBCICogRDtcbiAgdmFyIGxlblNxID0gQyAqIEMgKyBEICogRDtcbiAgdmFyIHBhcmFtID0gZG90IC8gbGVuU3E7XG5cbiAgdmFyIHh4O1xuICB2YXIgeXk7XG5cbiAgaWYgKHBhcmFtIDwgMCB8fCAoeDEgPT0geDIgJiYgeTEgPT0geTIpKSB7XG4gICAgeHggPSB4MTtcbiAgICB5eSA9IHkxO1xuICB9IGVsc2UgaWYgKHBhcmFtID4gMSkge1xuICAgIHh4ID0geDI7XG4gICAgeXkgPSB5MjtcbiAgfSBlbHNlIHtcbiAgICB4eCA9IHgxICsgcGFyYW0gKiBDO1xuICAgIHl5ID0geTEgKyBwYXJhbSAqIEQ7XG4gIH1cblxuICB2YXIgZHggPSB4IC0geHg7XG4gIHZhciBkeSA9IHkgLSB5eTtcbiAgdmFyIGRzdCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIGlmIChkc3QgPCBpc2MuZGlzdCkge1xuICAgIGlzYy5kaXN0ID0gZHN0O1xuICAgIGlzYy5lZGdlID0gZWRnZTtcbiAgICBpc2MucG9pbnQueCA9IHh4O1xuICAgIGlzYy5wb2ludC55ID0geXk7XG4gIH1cbiAgcmV0dXJuIGlzY1xufVxuXG4vKipcbiAqIFVwZGF0ZSBJU0NcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGR4XG4gKiBAcGFyYW0ge251bWJlcn0gZHlcbiAqIEBwYXJhbSB7UG9pbnR9IGExXG4gKiBAcGFyYW0ge1BvaW50fSBiMVxuICogQHBhcmFtIHtQb2ludH0gYjJcbiAqIEBwYXJhbSB7UG9pbnR9IGNcbiAqIEBwYXJhbSB7Pz99IGVkZ2VcbiAqIEBwYXJhbSB7Pz99IGlzY1xuICogQHJldHVybnMgez8/fVxuICovXG5mdW5jdGlvbiB1cGRhdGVJU0MgKGR4LCBkeSwgYTEsIGIxLCBiMiwgYywgZWRnZSwgaXNjKSB7XG4gIHZhciBucmwgPSBkaXN0YW5jZShhMSwgYyk7XG4gIGlmIChucmwgPCBpc2MuZGlzdCkge1xuICAgIHZhciBpYmwgPSAxIC8gZGlzdGFuY2UoYjEsIGIyKTtcbiAgICB2YXIgbnggPSAtKGIyLnkgLSBiMS55KSAqIGlibDtcbiAgICB2YXIgbnkgPSAoYjIueCAtIGIxLngpICogaWJsO1xuICAgIHZhciBkZG90ID0gMiAqIChkeCAqIG54ICsgZHkgKiBueSk7XG4gICAgaXNjLmRpc3QgPSBucmw7XG4gICAgaXNjLm5vcm0ueCA9IG54O1xuICAgIGlzYy5ub3JtLnkgPSBueTtcbiAgICBpc2MucmVmbC54ID0gLWRkb3QgKiBueCArIGR4O1xuICAgIGlzYy5yZWZsLnkgPSAtZGRvdCAqIG55ICsgZHk7XG4gICAgaXNjLmVkZ2UgPSBlZGdlO1xuICB9XG4gIHJldHVybiBpc2Ncbn1cblxuLyoqXG4gKiBHZXQgUG9pbnRzXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyW119IHBvaW50c1xuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4MFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4MVxuICogQHJldHVybnMge251bWJlcltdfSBwb2ludHNcbiAqL1xuZnVuY3Rpb24gZ2V0UG9pbnRzIChwb2ludHMsIGluZGV4MCwgaW5kZXgxKSB7XG4gIHZhciBuID0gcG9pbnRzLmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoaW5kZXgxIDwgaW5kZXgwKSBpbmRleDEgKz0gbjtcbiAgZm9yICh2YXIgaSA9IGluZGV4MDsgaSA8PSBpbmRleDE7IGkrKykgeyByZXN1bHQucHVzaChwb2ludHNbaSAlIG5dKTsgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogRmlyc3QgV2l0aCBGbGFnXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UG9pbnRbXX0gcG9pbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGZpcnN0V2l0aEZsYWcgKHBvaW50cywgaW5kZXgpIHtcbiAgdmFyIG4gPSBwb2ludHMubGVuZ3RoO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGluZGV4ID0gKGluZGV4ICsgMSkgJSBuO1xuICAgIGlmIChwb2ludHNbaW5kZXhdLmZsYWcpIHtcbiAgICAgIHJldHVybiBpbmRleFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFBvaW50IGluIFRyaWFuZ2xlXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBweFxuICogQHBhcmFtIHtudW1iZXJ9IHB5XG4gKiBAcGFyYW0ge251bWJlcn0gYXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBheVxuICogQHBhcmFtIHtudW1iZXJ9IGJ4XG4gKiBAcGFyYW0ge251bWJlcn0gYnlcbiAqIEBwYXJhbSB7bnVtYmVyfSBjeFxuICogQHBhcmFtIHtudW1iZXJ9IGN5XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gUG9pbnRJblRyaWFuZ2xlIChweCwgcHksIGF4LCBheSwgYngsIGJ5LCBjeCwgY3kpIHtcbiAgdmFyIHYweCA9IGN4IC0gYXg7XG4gIHZhciB2MHkgPSBjeSAtIGF5O1xuICB2YXIgdjF4ID0gYnggLSBheDtcbiAgdmFyIHYxeSA9IGJ5IC0gYXk7XG4gIHZhciB2MnggPSBweCAtIGF4O1xuICB2YXIgdjJ5ID0gcHkgLSBheTtcblxuICB2YXIgZG90MDAgPSB2MHggKiB2MHggKyB2MHkgKiB2MHk7XG4gIHZhciBkb3QwMSA9IHYweCAqIHYxeCArIHYweSAqIHYxeTtcbiAgdmFyIGRvdDAyID0gdjB4ICogdjJ4ICsgdjB5ICogdjJ5O1xuICB2YXIgZG90MTEgPSB2MXggKiB2MXggKyB2MXkgKiB2MXk7XG4gIHZhciBkb3QxMiA9IHYxeCAqIHYyeCArIHYxeSAqIHYyeTtcblxuICB2YXIgaW52RGVub20gPSAxIC8gKGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxKTtcbiAgdmFyIHUgPSAoZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIpICogaW52RGVub207XG4gIHZhciB2ID0gKGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyKSAqIGludkRlbm9tO1xuXG4gIC8vIENoZWNrIGlmIHBvaW50IGlzIGluIHRyaWFuZ2xlXG4gIHJldHVybiAodSA+PSAwKSAmJiAodiA+PSAwKSAmJiAodSArIHYgPCAxKVxufVxuXG4vKipcbiAqIFJheUxpbmUgSW50ZXJzZWN0aW9uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UG9pbnR9IGExXG4gKiBAcGFyYW0ge1BvaW50fSBhMlxuICogQHBhcmFtIHtQb2ludH0gYjFcbiAqIEBwYXJhbSB7UG9pbnR9IGIyXG4gKiBAcGFyYW0ge1BvaW50fSBjXG4gKi9cbmZ1bmN0aW9uIFJheUxpbmVJbnRlcnNlY3Rpb24gKGExLCBhMiwgYjEsIGIyLCBjKSB7XG4gIHZhciBkYXggPSAoYTEueCAtIGEyLngpO1xuICB2YXIgZGJ4ID0gKGIxLnggLSBiMi54KTtcbiAgdmFyIGRheSA9IChhMS55IC0gYTIueSk7XG4gIHZhciBkYnkgPSAoYjEueSAtIGIyLnkpO1xuXG4gIHZhciBEZW4gPSBkYXggKiBkYnkgLSBkYXkgKiBkYng7XG4gIGlmIChEZW4gPT0gMCkgcmV0dXJuIG51bGwgIC8vIHBhcmFsbGVsXG5cbiAgdmFyIEEgPSAoYTEueCAqIGEyLnkgLSBhMS55ICogYTIueCk7XG4gIHZhciBCID0gKGIxLnggKiBiMi55IC0gYjEueSAqIGIyLngpO1xuXG4gIHZhciBJID0gYztcbiAgdmFyIGlEZW4gPSAxIC8gRGVuO1xuICBJLnggPSAoQSAqIGRieCAtIGRheCAqIEIpICogaURlbjtcbiAgSS55ID0gKEEgKiBkYnkgLSBkYXkgKiBCKSAqIGlEZW47XG5cbiAgaWYgKCFJblJlY3RhbmdsZShJLCBiMSwgYjIpKSByZXR1cm4gbnVsbFxuICBpZiAoKGRheSA+IDAgJiYgSS55ID4gYTEueSkgfHwgKGRheSA8IDAgJiYgSS55IDwgYTEueSkpIHJldHVybiBudWxsXG4gIGlmICgoZGF4ID4gMCAmJiBJLnggPiBhMS54KSB8fCAoZGF4IDwgMCAmJiBJLnggPCBhMS54KSkgcmV0dXJuIG51bGxcbiAgcmV0dXJuIElcbn1cblxuLyoqXG4gKiBHZXQgTGluZSBJbnRlcnNlY3Rpb25cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQb2ludH0gYTFcbiAqIEBwYXJhbSB7UG9pbnR9IGEyXG4gKiBAcGFyYW0ge1BvaW50fSBiMVxuICogQHBhcmFtIHtQb2ludH0gYjJcbiAqIEBwYXJhbSB7UG9pbnR9IGNcbiAqIEByZXR1cm5zIHtQb2ludH1cbiAqL1xuZnVuY3Rpb24gR2V0TGluZUludGVyc2VjdGlvbiAoYTEsIGEyLCBiMSwgYjIsIGMpIHtcbiAgdmFyIGRheCA9IChhMS54IC0gYTIueCk7XG4gIHZhciBkYnggPSAoYjEueCAtIGIyLngpO1xuICB2YXIgZGF5ID0gKGExLnkgLSBhMi55KTtcbiAgdmFyIGRieSA9IChiMS55IC0gYjIueSk7XG5cbiAgdmFyIERlbiA9IGRheCAqIGRieSAtIGRheSAqIGRieDtcblxuICBpZiAoRGVuID09PSAwKSB7IHJldHVybiBudWxsIH0gLy8gcGFyYWxsZWxcblxuICB2YXIgQSA9IChhMS54ICogYTIueSAtIGExLnkgKiBhMi54KTtcbiAgdmFyIEIgPSAoYjEueCAqIGIyLnkgLSBiMS55ICogYjIueCk7XG5cbiAgdmFyIEkgPSBjO1xuICBJLnggPSAoQSAqIGRieCAtIGRheCAqIEIpIC8gRGVuO1xuICBJLnkgPSAoQSAqIGRieSAtIGRheSAqIEIpIC8gRGVuO1xuXG4gIGlmIChJblJlY3RhbmdsZShJLCBhMSwgYTIpICYmIEluUmVjdGFuZ2xlKEksIGIxLCBiMikpIHtcbiAgICByZXR1cm4gSVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbi8qKlxuICogSW4gUmVjdGFuZ2xlXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UG9pbnR9IGFcbiAqIEBwYXJhbSB7UG9pbnR9IGJcbiAqIEBwYXJhbSB7UG9pbnR9IGNcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIEluUmVjdGFuZ2xlIChhLCBiLCBjKSB7XG4gIHZhciBtaW54ID0gTWF0aC5taW4oYi54LCBjLngpO1xuICB2YXIgbWF4eCA9IE1hdGgubWF4KGIueCwgYy54KTtcbiAgdmFyIG1pbnkgPSBNYXRoLm1pbihiLnksIGMueSk7XG4gIHZhciBtYXh5ID0gTWF0aC5tYXgoYi55LCBjLnkpO1xuXG4gIGlmIChtaW54ID09PSBtYXh4KSB7IHJldHVybiAobWlueSA8PSBhLnkgJiYgYS55IDw9IG1heHkpIH1cbiAgaWYgKG1pbnkgPT09IG1heHkpIHsgcmV0dXJuIChtaW54IDw9IGEueCAmJiBhLnggPD0gbWF4eCkgfVxuXG4gIC8vIHJldHVybiAobWlueCA8PSBhLnggJiYgYS54IDw9IG1heHggJiYgbWlueSA8PSBhLnkgJiYgYS55IDw9IG1heHkpXG4gIHJldHVybiAobWlueCA8PSBhLnggKyAxZS0xMCAmJiBhLnggLSAxZS0xMCA8PSBtYXh4ICYmIG1pbnkgPD0gYS55ICsgMWUtMTAgJiYgYS55IC0gMWUtMTAgPD0gbWF4eSlcbn1cblxuLyoqXG4gKiBDb252ZXhcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQb2ludH0gYXhcbiAqIEBwYXJhbSB7UG9pbnR9IGF5XG4gKiBAcGFyYW0ge1BvaW50fSBieFxuICogQHBhcmFtIHtQb2ludH0gYnlcbiAqIEBwYXJhbSB7UG9pbnR9IGN4XG4gKiBAcGFyYW0ge1BvaW50fSBjeVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbnZleCAoYXgsIGF5LCBieCwgYnksIGN4LCBjeSkge1xuICByZXR1cm4gKGF5IC0gYnkpICogKGN4IC0gYngpICsgKGJ4IC0gYXgpICogKGN5IC0gYnkpID49IDBcbn1cblxuLyoqXG4gKiBQb2ludFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEByZXR1cm5zIHtQb2ludH1cbiAqL1xuZnVuY3Rpb24gUG9pbnQgKHgsIHkpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgZmxhZzogZmFsc2UsXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdQb2ludCBbJyArIHggKyAnLCAnICsgeSArICddJyB9XG4gIH1cbn1cblxuLyoqXG4gKiBEaXN0YW5jZVxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1BvaW50fSBhXG4gKiBAcGFyYW0ge1BvaW50fSBiXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBkaXN0YW5jZSAoYSwgYikge1xuICB2YXIgZHggPSBiLnggLSBhLng7XG4gIHZhciBkeSA9IGIueSAtIGEueTtcbiAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVtcHR5IFBvaW50c1xuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gW251bT0xMF0gTnVtYmVyIG9mIHBvaW50c1xuICogQHJldHVybnMge1BvaW50W119XG4gKi9cbmZ1bmN0aW9uIGVtcHR5UG9pbnRzIChudW0pIHtcbiAgbnVtID0gbnVtIHx8IDEwO1xuICB2YXIgY29udGFpbmVyID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyBpKyspIHsgY29udGFpbmVyLnB1c2goUG9pbnQoMCwgMCkpOyB9XG4gIHJldHVybiBjb250YWluZXJcbn1cblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvbHlrLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9ZnVuY3Rpb24oZSxuKXtyZXR1cm4gdD1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24odCxlKXt0Ll9fcHJvdG9fXz1lfXx8ZnVuY3Rpb24odCxlKXtmb3IodmFyIG4gaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxuKSYmKHRbbl09ZVtuXSl9LHQoZSxuKX07ZnVuY3Rpb24gZShlLG4pe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIG4mJm51bGwhPT1uKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiK1N0cmluZyhuKStcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO2Z1bmN0aW9uIHIoKXt0aGlzLmNvbnN0cnVjdG9yPWV9dChlLG4pLGUucHJvdG90eXBlPW51bGw9PT1uP09iamVjdC5jcmVhdGUobik6KHIucHJvdG90eXBlPW4ucHJvdG90eXBlLG5ldyByKX12YXIgbj1mdW5jdGlvbigpe3JldHVybiBuPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxuPTEscj1hcmd1bWVudHMubGVuZ3RoO248cjtuKyspZm9yKHZhciBhIGluIGU9YXJndW1lbnRzW25dKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLGEpJiYodFthXT1lW2FdKTtyZXR1cm4gdH0sbi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2Z1bmN0aW9uIHIodCxlLG4pe2lmKG58fDI9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgcixhPTAscz1lLmxlbmd0aDthPHM7YSsrKSFyJiZhIGluIGV8fChyfHwocj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlLDAsYSkpLHJbYV09ZVthXSk7cmV0dXJuIHQuY29uY2F0KHJ8fEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGUpKX1mdW5jdGlvbiBhKHQsZSxuKXtpZih0JiZ0Lmxlbmd0aCl7Y29uc3RbcixhXT1lLHM9TWF0aC5QSS8xODAqbixvPU1hdGguY29zKHMpLGk9TWF0aC5zaW4ocyk7Zm9yKGNvbnN0IGUgb2YgdCl7Y29uc3RbdCxuXT1lO2VbMF09KHQtcikqby0obi1hKSppK3IsZVsxXT0odC1yKSppKyhuLWEpKm8rYX19fWZ1bmN0aW9uIHModCxlKXtyZXR1cm4gdFswXT09PWVbMF0mJnRbMV09PT1lWzFdfWZ1bmN0aW9uIG8odCxlLG4scj0xKXtjb25zdCBvPW4saT1NYXRoLm1heChlLC4xKSxoPXRbMF0mJnRbMF1bMF0mJlwibnVtYmVyXCI9PXR5cGVvZiB0WzBdWzBdP1t0XTp0LHU9WzAsMF07aWYobylmb3IoY29uc3QgdCBvZiBoKWEodCx1LG8pO2NvbnN0IHA9ZnVuY3Rpb24odCxlLG4pe2NvbnN0IHI9W107Zm9yKGNvbnN0IGUgb2YgdCl7Y29uc3QgdD1bLi4uZV07cyh0WzBdLHRbdC5sZW5ndGgtMV0pfHx0LnB1c2goW3RbMF1bMF0sdFswXVsxXV0pLHQubGVuZ3RoPjImJnIucHVzaCh0KX1jb25zdCBhPVtdO2U9TWF0aC5tYXgoZSwuMSk7Y29uc3Qgbz1bXTtmb3IoY29uc3QgdCBvZiByKWZvcihsZXQgZT0wO2U8dC5sZW5ndGgtMTtlKyspe2NvbnN0IG49dFtlXSxyPXRbZSsxXTtpZihuWzFdIT09clsxXSl7Y29uc3QgdD1NYXRoLm1pbihuWzFdLHJbMV0pO28ucHVzaCh7eW1pbjp0LHltYXg6TWF0aC5tYXgoblsxXSxyWzFdKSx4OnQ9PT1uWzFdP25bMF06clswXSxpc2xvcGU6KHJbMF0tblswXSkvKHJbMV0tblsxXSl9KX19aWYoby5zb3J0KCgodCxlKT0+dC55bWluPGUueW1pbj8tMTp0LnltaW4+ZS55bWluPzE6dC54PGUueD8tMTp0Lng+ZS54PzE6dC55bWF4PT09ZS55bWF4PzA6KHQueW1heC1lLnltYXgpL01hdGguYWJzKHQueW1heC1lLnltYXgpKSksIW8ubGVuZ3RoKXJldHVybiBhO2xldCBpPVtdLGg9b1swXS55bWluLHU9MDtmb3IoO2kubGVuZ3RofHxvLmxlbmd0aDspe2lmKG8ubGVuZ3RoKXtsZXQgdD0tMTtmb3IobGV0IGU9MDtlPG8ubGVuZ3RoJiYhKG9bZV0ueW1pbj5oKTtlKyspdD1lO28uc3BsaWNlKDAsdCsxKS5mb3JFYWNoKCh0PT57aS5wdXNoKHtzOmgsZWRnZTp0fSl9KSl9aWYoaT1pLmZpbHRlcigodD0+ISh0LmVkZ2UueW1heDw9aCkpKSxpLnNvcnQoKCh0LGUpPT50LmVkZ2UueD09PWUuZWRnZS54PzA6KHQuZWRnZS54LWUuZWRnZS54KS9NYXRoLmFicyh0LmVkZ2UueC1lLmVkZ2UueCkpKSwoMSE9PW58fHUlZT09MCkmJmkubGVuZ3RoPjEpZm9yKGxldCB0PTA7dDxpLmxlbmd0aDt0Kz0yKXtjb25zdCBlPXQrMTtpZihlPj1pLmxlbmd0aClicmVhaztjb25zdCBuPWlbdF0uZWRnZSxyPWlbZV0uZWRnZTthLnB1c2goW1tNYXRoLnJvdW5kKG4ueCksaF0sW01hdGgucm91bmQoci54KSxoXV0pfWgrPW4saS5mb3JFYWNoKCh0PT57dC5lZGdlLng9dC5lZGdlLngrbip0LmVkZ2UuaXNsb3BlfSkpLHUrK31yZXR1cm4gYX0oaCxpLHIpO2lmKG8pe2Zvcihjb25zdCB0IG9mIGgpYSh0LHUsLW8pOyFmdW5jdGlvbih0LGUsbil7Y29uc3Qgcj1bXTt0LmZvckVhY2goKHQ9PnIucHVzaCguLi50KSkpLGEocixlLG4pfShwLHUsLW8pfXJldHVybiBwfWZ1bmN0aW9uIGkodCxlKXt2YXIgbixyPWUuaGFjaHVyZUFuZ2xlKzkwLGE9ZS5oYWNodXJlR2FwO2E8MCYmKGE9NCplLnN0cm9rZVdpZHRoKSxhPU1hdGgucm91bmQoTWF0aC5tYXgoYSwuMSkpO3ZhciBzPTE7cmV0dXJuIGUucm91Z2huZXNzPj0xJiYoKG51bGw9PT0obj1lLnJhbmRvbWl6ZXIpfHx2b2lkIDA9PT1uP3ZvaWQgMDpuLm5leHQoKSl8fE1hdGgucmFuZG9tKCkpPi43JiYocz1hKSxvKHQsYSxyLHN8fDEpfVwiZnVuY3Rpb25cIj09dHlwZW9mIFN1cHByZXNzZWRFcnJvciYmU3VwcHJlc3NlZEVycm9yO3ZhciBoPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLmhlbHBlcj10fXJldHVybiB0LnByb3RvdHlwZS5maWxsUG9seWdvbnM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fZmlsbFBvbHlnb25zKHQsZSl9LHQucHJvdG90eXBlLl9maWxsUG9seWdvbnM9ZnVuY3Rpb24odCxlKXt2YXIgbj1pKHQsZSk7cmV0dXJue3R5cGU6XCJmaWxsU2tldGNoXCIsb3BzOnRoaXMucmVuZGVyTGluZXMobixlKX19LHQucHJvdG90eXBlLnJlbmRlckxpbmVzPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPVtdLHI9MCxhPXQ7cjxhLmxlbmd0aDtyKyspe3ZhciBzPWFbcl07bi5wdXNoLmFwcGx5KG4sdGhpcy5oZWxwZXIuZG91YmxlTGluZU9wcyhzWzBdWzBdLHNbMF1bMV0sc1sxXVswXSxzWzFdWzFdLGUpKX1yZXR1cm4gbn0sdH0oKTtmdW5jdGlvbiB1KHQpe3ZhciBlPXRbMF0sbj10WzFdO3JldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coZVswXS1uWzBdLDIpK01hdGgucG93KGVbMV0tblsxXSwyKSl9dmFyIHA9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbigpe3JldHVybiBudWxsIT09dCYmdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIGUobix0KSxuLnByb3RvdHlwZS5maWxsUG9seWdvbnM9ZnVuY3Rpb24odCxlKXt2YXIgbj1lLmhhY2h1cmVHYXA7bjwwJiYobj00KmUuc3Ryb2tlV2lkdGgpLG49TWF0aC5tYXgobiwuMSk7Zm9yKHZhciBhPWkodCxPYmplY3QuYXNzaWduKHt9LGUse2hhY2h1cmVHYXA6bn0pKSxzPU1hdGguUEkvMTgwKmUuaGFjaHVyZUFuZ2xlLG89W10saD0uNSpuKk1hdGguY29zKHMpLHA9LjUqbipNYXRoLnNpbihzKSxsPTAsYz1hO2w8Yy5sZW5ndGg7bCsrKXt2YXIgZj1jW2xdLGQ9ZlswXSxnPWZbMV07dShbZCxnXSkmJm8ucHVzaChbW2RbMF0taCxkWzFdK3BdLHIoW10sZywhMCldLFtbZFswXStoLGRbMV0tcF0scihbXSxnLCEwKV0pfXJldHVybnt0eXBlOlwiZmlsbFNrZXRjaFwiLG9wczp0aGlzLnJlbmRlckxpbmVzKG8sZSl9fSxufShoKSxsPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4oKXtyZXR1cm4gbnVsbCE9PXQmJnQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBlKG4sdCksbi5wcm90b3R5cGUuZmlsbFBvbHlnb25zPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5fZmlsbFBvbHlnb25zKHQsZSkscj1PYmplY3QuYXNzaWduKHt9LGUse2hhY2h1cmVBbmdsZTplLmhhY2h1cmVBbmdsZSs5MH0pLGE9dGhpcy5fZmlsbFBvbHlnb25zKHQscik7cmV0dXJuIG4ub3BzPW4ub3BzLmNvbmNhdChhLm9wcyksbn0sbn0oaCksYz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5oZWxwZXI9dH1yZXR1cm4gdC5wcm90b3R5cGUuZmlsbFBvbHlnb25zPWZ1bmN0aW9uKHQsZSl7dmFyIG49aSh0LGU9T2JqZWN0LmFzc2lnbih7fSxlLHtoYWNodXJlQW5nbGU6MH0pKTtyZXR1cm4gdGhpcy5kb3RzT25MaW5lcyhuLGUpfSx0LnByb3RvdHlwZS5kb3RzT25MaW5lcz1mdW5jdGlvbih0LGUpe3ZhciBuPVtdLHI9ZS5oYWNodXJlR2FwO3I8MCYmKHI9NCplLnN0cm9rZVdpZHRoKSxyPU1hdGgubWF4KHIsLjEpO3ZhciBhPWUuZmlsbFdlaWdodDthPDAmJihhPWUuc3Ryb2tlV2lkdGgvMik7Zm9yKHZhciBzPXIvNCxvPTAsaT10O288aS5sZW5ndGg7bysrKWZvcih2YXIgaD1pW29dLHA9dShoKSxsPXAvcixjPU1hdGguY2VpbChsKS0xLGY9cC1jKnIsZD0oaFswXVswXStoWzFdWzBdKS8yLXIvNCxnPU1hdGgubWluKGhbMF1bMV0saFsxXVsxXSkseT0wO3k8Yzt5Kyspe3ZhciB2PWcrZit5KnIsTT1kLXMrMipNYXRoLnJhbmRvbSgpKnMsaz12LXMrMipNYXRoLnJhbmRvbSgpKnMsYj10aGlzLmhlbHBlci5lbGxpcHNlKE0sayxhLGEsZSk7bi5wdXNoLmFwcGx5KG4sYi5vcHMpfXJldHVybnt0eXBlOlwiZmlsbFNrZXRjaFwiLG9wczpufX0sdH0oKSxmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLmhlbHBlcj10fXJldHVybiB0LnByb3RvdHlwZS5maWxsUG9seWdvbnM9ZnVuY3Rpb24odCxlKXt2YXIgbj1pKHQsZSk7cmV0dXJue3R5cGU6XCJmaWxsU2tldGNoXCIsb3BzOnRoaXMuZGFzaGVkTGluZShuLGUpfX0sdC5wcm90b3R5cGUuZGFzaGVkTGluZT1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMscj1lLmRhc2hPZmZzZXQ8MD9lLmhhY2h1cmVHYXA8MD80KmUuc3Ryb2tlV2lkdGg6ZS5oYWNodXJlR2FwOmUuZGFzaE9mZnNldCxhPWUuZGFzaEdhcDwwP2UuaGFjaHVyZUdhcDwwPzQqZS5zdHJva2VXaWR0aDplLmhhY2h1cmVHYXA6ZS5kYXNoR2FwLHM9W107cmV0dXJuIHQuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIG89dSh0KSxpPU1hdGguZmxvb3Ioby8ocithKSksaD0obythLWkqKHIrYSkpLzIscD10WzBdLGw9dFsxXTtwWzBdPmxbMF0mJihwPXRbMV0sbD10WzBdKTtmb3IodmFyIGM9TWF0aC5hdGFuKChsWzFdLXBbMV0pLyhsWzBdLXBbMF0pKSxmPTA7ZjxpO2YrKyl7dmFyIGQ9ZioocithKSxnPWQrcix5PVtwWzBdK2QqTWF0aC5jb3MoYykraCpNYXRoLmNvcyhjKSxwWzFdK2QqTWF0aC5zaW4oYykraCpNYXRoLnNpbihjKV0sdj1bcFswXStnKk1hdGguY29zKGMpK2gqTWF0aC5jb3MoYykscFsxXStnKk1hdGguc2luKGMpK2gqTWF0aC5zaW4oYyldO3MucHVzaC5hcHBseShzLG4uaGVscGVyLmRvdWJsZUxpbmVPcHMoeVswXSx5WzFdLHZbMF0sdlsxXSxlKSl9fSkpLHN9LHR9KCksZD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5oZWxwZXI9dH1yZXR1cm4gdC5wcm90b3R5cGUuZmlsbFBvbHlnb25zPWZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5oYWNodXJlR2FwPDA/NCplLnN0cm9rZVdpZHRoOmUuaGFjaHVyZUdhcCxyPWUuemlnemFnT2Zmc2V0PDA/bjplLnppZ3phZ09mZnNldCxhPWkodCxlPU9iamVjdC5hc3NpZ24oe30sZSx7aGFjaHVyZUdhcDpuK3J9KSk7cmV0dXJue3R5cGU6XCJmaWxsU2tldGNoXCIsb3BzOnRoaXMuemlnemFnTGluZXMoYSxyLGUpfX0sdC5wcm90b3R5cGUuemlnemFnTGluZXM9ZnVuY3Rpb24odCxlLG4pe3ZhciBhPXRoaXMscz1bXTtyZXR1cm4gdC5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgbz11KHQpLGk9TWF0aC5yb3VuZChvLygyKmUpKSxoPXRbMF0scD10WzFdO2hbMF0+cFswXSYmKGg9dFsxXSxwPXRbMF0pO2Zvcih2YXIgbD1NYXRoLmF0YW4oKHBbMV0taFsxXSkvKHBbMF0taFswXSkpLGM9MDtjPGk7YysrKXt2YXIgZj0yKmMqZSxkPTIqKGMrMSkqZSxnPU1hdGguc3FydCgyKk1hdGgucG93KGUsMikpLHk9W2hbMF0rZipNYXRoLmNvcyhsKSxoWzFdK2YqTWF0aC5zaW4obCldLHY9W2hbMF0rZCpNYXRoLmNvcyhsKSxoWzFdK2QqTWF0aC5zaW4obCldLE09W3lbMF0rZypNYXRoLmNvcyhsK01hdGguUEkvNCkseVsxXStnKk1hdGguc2luKGwrTWF0aC5QSS80KV07cy5wdXNoLmFwcGx5KHMscihyKFtdLGEuaGVscGVyLmRvdWJsZUxpbmVPcHMoeVswXSx5WzFdLE1bMF0sTVsxXSxuKSwhMSksYS5oZWxwZXIuZG91YmxlTGluZU9wcyhNWzBdLE1bMV0sdlswXSx2WzFdLG4pLCExKSl9fSkpLHN9LHR9KCksZz17fTt2YXIgeT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5zZWVkPXR9cmV0dXJuIHQucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWVkPyhNYXRoLnBvdygyLDMxKS0xJih0aGlzLnNlZWQ9TWF0aC5pbXVsKDQ4MjcxLHRoaXMuc2VlZCkpKS9NYXRoLnBvdygyLDMxKTpNYXRoLnJhbmRvbSgpfSx0fSgpO2NvbnN0IHY9MCxNPTEsaz0yLGI9e0E6NyxhOjcsQzo2LGM6NixIOjEsaDoxLEw6MixsOjIsTToyLG06MixROjQscTo0LFM6NCxzOjQsVDoyLHQ6MixWOjEsdjoxLFo6MCx6OjB9O2Z1bmN0aW9uIG0odCxlKXtyZXR1cm4gdC50eXBlPT09ZX1mdW5jdGlvbiB3KHQpe2NvbnN0IGU9W10sbj1mdW5jdGlvbih0KXtjb25zdCBlPW5ldyBBcnJheTtmb3IoO1wiXCIhPT10OylpZih0Lm1hdGNoKC9eKFsgXFx0XFxyXFxuLF0rKS8pKXQ9dC5zdWJzdHIoUmVnRXhwLiQxLmxlbmd0aCk7ZWxzZSBpZih0Lm1hdGNoKC9eKFthQWNDaEhsTG1NcVFzU3RUdlZ6Wl0pLykpZVtlLmxlbmd0aF09e3R5cGU6dix0ZXh0OlJlZ0V4cC4kMX0sdD10LnN1YnN0cihSZWdFeHAuJDEubGVuZ3RoKTtlbHNle2lmKCF0Lm1hdGNoKC9eKChbLStdP1swLTldKyhcXC5bMC05XSopP3xbLStdP1xcLlswLTldKykoW2VFXVstK10/WzAtOV0rKT8pLykpcmV0dXJuW107ZVtlLmxlbmd0aF09e3R5cGU6TSx0ZXh0OmAke3BhcnNlRmxvYXQoUmVnRXhwLiQxKX1gfSx0PXQuc3Vic3RyKFJlZ0V4cC4kMS5sZW5ndGgpfXJldHVybiBlW2UubGVuZ3RoXT17dHlwZTprLHRleHQ6XCJcIn0sZX0odCk7bGV0IHI9XCJCT0RcIixhPTAscz1uW2FdO2Zvcig7IW0ocyxrKTspe2xldCBvPTA7Y29uc3QgaT1bXTtpZihcIkJPRFwiPT09cil7aWYoXCJNXCIhPT1zLnRleHQmJlwibVwiIT09cy50ZXh0KXJldHVybiB3KFwiTTAsMFwiK3QpO2ErKyxvPWJbcy50ZXh0XSxyPXMudGV4dH1lbHNlIG0ocyxNKT9vPWJbcl06KGErKyxvPWJbcy50ZXh0XSxyPXMudGV4dCk7aWYoIShhK288bi5sZW5ndGgpKXRocm93IG5ldyBFcnJvcihcIlBhdGggZGF0YSBlbmRlZCBzaG9ydFwiKTtmb3IobGV0IHQ9YTt0PGErbzt0Kyspe2NvbnN0IGU9blt0XTtpZighbShlLE0pKXRocm93IG5ldyBFcnJvcihcIlBhcmFtIG5vdCBhIG51bWJlcjogXCIrcitcIixcIitlLnRleHQpO2lbaS5sZW5ndGhdPStlLnRleHR9aWYoXCJudW1iZXJcIiE9dHlwZW9mIGJbcl0pdGhyb3cgbmV3IEVycm9yKFwiQmFkIHNlZ21lbnQ6IFwiK3IpO3tjb25zdCB0PXtrZXk6cixkYXRhOml9O2UucHVzaCh0KSxhKz1vLHM9blthXSxcIk1cIj09PXImJihyPVwiTFwiKSxcIm1cIj09PXImJihyPVwibFwiKX19cmV0dXJuIGV9ZnVuY3Rpb24gUCh0KXtsZXQgZT0wLG49MCxyPTAsYT0wO2NvbnN0IHM9W107Zm9yKGNvbnN0e2tleTpvLGRhdGE6aX1vZiB0KXN3aXRjaChvKXtjYXNlXCJNXCI6cy5wdXNoKHtrZXk6XCJNXCIsZGF0YTpbLi4uaV19KSxbZSxuXT1pLFtyLGFdPWk7YnJlYWs7Y2FzZVwibVwiOmUrPWlbMF0sbis9aVsxXSxzLnB1c2goe2tleTpcIk1cIixkYXRhOltlLG5dfSkscj1lLGE9bjticmVhaztjYXNlXCJMXCI6cy5wdXNoKHtrZXk6XCJMXCIsZGF0YTpbLi4uaV19KSxbZSxuXT1pO2JyZWFrO2Nhc2VcImxcIjplKz1pWzBdLG4rPWlbMV0scy5wdXNoKHtrZXk6XCJMXCIsZGF0YTpbZSxuXX0pO2JyZWFrO2Nhc2VcIkNcIjpzLnB1c2goe2tleTpcIkNcIixkYXRhOlsuLi5pXX0pLGU9aVs0XSxuPWlbNV07YnJlYWs7Y2FzZVwiY1wiOntjb25zdCB0PWkubWFwKCgodCxyKT0+ciUyP3Qrbjp0K2UpKTtzLnB1c2goe2tleTpcIkNcIixkYXRhOnR9KSxlPXRbNF0sbj10WzVdO2JyZWFrfWNhc2VcIlFcIjpzLnB1c2goe2tleTpcIlFcIixkYXRhOlsuLi5pXX0pLGU9aVsyXSxuPWlbM107YnJlYWs7Y2FzZVwicVwiOntjb25zdCB0PWkubWFwKCgodCxyKT0+ciUyP3Qrbjp0K2UpKTtzLnB1c2goe2tleTpcIlFcIixkYXRhOnR9KSxlPXRbMl0sbj10WzNdO2JyZWFrfWNhc2VcIkFcIjpzLnB1c2goe2tleTpcIkFcIixkYXRhOlsuLi5pXX0pLGU9aVs1XSxuPWlbNl07YnJlYWs7Y2FzZVwiYVwiOmUrPWlbNV0sbis9aVs2XSxzLnB1c2goe2tleTpcIkFcIixkYXRhOltpWzBdLGlbMV0saVsyXSxpWzNdLGlbNF0sZSxuXX0pO2JyZWFrO2Nhc2VcIkhcIjpzLnB1c2goe2tleTpcIkhcIixkYXRhOlsuLi5pXX0pLGU9aVswXTticmVhaztjYXNlXCJoXCI6ZSs9aVswXSxzLnB1c2goe2tleTpcIkhcIixkYXRhOltlXX0pO2JyZWFrO2Nhc2VcIlZcIjpzLnB1c2goe2tleTpcIlZcIixkYXRhOlsuLi5pXX0pLG49aVswXTticmVhaztjYXNlXCJ2XCI6bis9aVswXSxzLnB1c2goe2tleTpcIlZcIixkYXRhOltuXX0pO2JyZWFrO2Nhc2VcIlNcIjpzLnB1c2goe2tleTpcIlNcIixkYXRhOlsuLi5pXX0pLGU9aVsyXSxuPWlbM107YnJlYWs7Y2FzZVwic1wiOntjb25zdCB0PWkubWFwKCgodCxyKT0+ciUyP3Qrbjp0K2UpKTtzLnB1c2goe2tleTpcIlNcIixkYXRhOnR9KSxlPXRbMl0sbj10WzNdO2JyZWFrfWNhc2VcIlRcIjpzLnB1c2goe2tleTpcIlRcIixkYXRhOlsuLi5pXX0pLGU9aVswXSxuPWlbMV07YnJlYWs7Y2FzZVwidFwiOmUrPWlbMF0sbis9aVsxXSxzLnB1c2goe2tleTpcIlRcIixkYXRhOltlLG5dfSk7YnJlYWs7Y2FzZVwiWlwiOmNhc2VcInpcIjpzLnB1c2goe2tleTpcIlpcIixkYXRhOltdfSksZT1yLG49YX1yZXR1cm4gc31mdW5jdGlvbiB4KHQpe2NvbnN0IGU9W107bGV0IG49XCJcIixyPTAsYT0wLHM9MCxvPTAsaT0wLGg9MDtmb3IoY29uc3R7a2V5OnUsZGF0YTpwfW9mIHQpe3N3aXRjaCh1KXtjYXNlXCJNXCI6ZS5wdXNoKHtrZXk6XCJNXCIsZGF0YTpbLi4ucF19KSxbcixhXT1wLFtzLG9dPXA7YnJlYWs7Y2FzZVwiQ1wiOmUucHVzaCh7a2V5OlwiQ1wiLGRhdGE6Wy4uLnBdfSkscj1wWzRdLGE9cFs1XSxpPXBbMl0saD1wWzNdO2JyZWFrO2Nhc2VcIkxcIjplLnB1c2goe2tleTpcIkxcIixkYXRhOlsuLi5wXX0pLFtyLGFdPXA7YnJlYWs7Y2FzZVwiSFwiOnI9cFswXSxlLnB1c2goe2tleTpcIkxcIixkYXRhOltyLGFdfSk7YnJlYWs7Y2FzZVwiVlwiOmE9cFswXSxlLnB1c2goe2tleTpcIkxcIixkYXRhOltyLGFdfSk7YnJlYWs7Y2FzZVwiU1wiOntsZXQgdD0wLHM9MDtcIkNcIj09PW58fFwiU1wiPT09bj8odD1yKyhyLWkpLHM9YSsoYS1oKSk6KHQ9cixzPWEpLGUucHVzaCh7a2V5OlwiQ1wiLGRhdGE6W3QscywuLi5wXX0pLGk9cFswXSxoPXBbMV0scj1wWzJdLGE9cFszXTticmVha31jYXNlXCJUXCI6e2NvbnN0W3Qsc109cDtsZXQgbz0wLHU9MDtcIlFcIj09PW58fFwiVFwiPT09bj8obz1yKyhyLWkpLHU9YSsoYS1oKSk6KG89cix1PWEpO2NvbnN0IGw9cisyKihvLXIpLzMsYz1hKzIqKHUtYSkvMyxmPXQrMiooby10KS8zLGQ9cysyKih1LXMpLzM7ZS5wdXNoKHtrZXk6XCJDXCIsZGF0YTpbbCxjLGYsZCx0LHNdfSksaT1vLGg9dSxyPXQsYT1zO2JyZWFrfWNhc2VcIlFcIjp7Y29uc3RbdCxuLHMsb109cCx1PXIrMioodC1yKS8zLGw9YSsyKihuLWEpLzMsYz1zKzIqKHQtcykvMyxmPW8rMioobi1vKS8zO2UucHVzaCh7a2V5OlwiQ1wiLGRhdGE6W3UsbCxjLGYscyxvXX0pLGk9dCxoPW4scj1zLGE9bzticmVha31jYXNlXCJBXCI6e2NvbnN0IHQ9TWF0aC5hYnMocFswXSksbj1NYXRoLmFicyhwWzFdKSxzPXBbMl0sbz1wWzNdLGk9cFs0XSxoPXBbNV0sdT1wWzZdO2lmKDA9PT10fHwwPT09billLnB1c2goe2tleTpcIkNcIixkYXRhOltyLGEsaCx1LGgsdV19KSxyPWgsYT11O2Vsc2UgaWYociE9PWh8fGEhPT11KXtPKHIsYSxoLHUsdCxuLHMsbyxpKS5mb3JFYWNoKChmdW5jdGlvbih0KXtlLnB1c2goe2tleTpcIkNcIixkYXRhOnR9KX0pKSxyPWgsYT11fWJyZWFrfWNhc2VcIlpcIjplLnB1c2goe2tleTpcIlpcIixkYXRhOltdfSkscj1zLGE9b31uPXV9cmV0dXJuIGV9ZnVuY3Rpb24gUyh0LGUsbil7cmV0dXJuW3QqTWF0aC5jb3MobiktZSpNYXRoLnNpbihuKSx0Kk1hdGguc2luKG4pK2UqTWF0aC5jb3MobildfWZ1bmN0aW9uIE8odCxlLG4scixhLHMsbyxpLGgsdSl7Y29uc3QgcD0obD1vLE1hdGguUEkqbC8xODApO3ZhciBsO2xldCBjPVtdLGY9MCxkPTAsZz0wLHk9MDtpZih1KVtmLGQsZyx5XT11O2Vsc2V7W3QsZV09Uyh0LGUsLXApLFtuLHJdPVMobixyLC1wKTtjb25zdCBvPSh0LW4pLzIsdT0oZS1yKS8yO2xldCBsPW8qby8oYSphKSt1KnUvKHMqcyk7bD4xJiYobD1NYXRoLnNxcnQobCksYSo9bCxzKj1sKTtjb25zdCBjPWEqYSx2PXMqcyxNPWMqdi1jKnUqdS12Km8qbyxrPWMqdSp1K3YqbypvLGI9KGk9PT1oPy0xOjEpKk1hdGguc3FydChNYXRoLmFicyhNL2spKTtnPWIqYSp1L3MrKHQrbikvMix5PWIqLXMqby9hKyhlK3IpLzIsZj1NYXRoLmFzaW4ocGFyc2VGbG9hdCgoKGUteSkvcykudG9GaXhlZCg5KSkpLGQ9TWF0aC5hc2luKHBhcnNlRmxvYXQoKChyLXkpL3MpLnRvRml4ZWQoOSkpKSx0PGcmJihmPU1hdGguUEktZiksbjxnJiYoZD1NYXRoLlBJLWQpLGY8MCYmKGY9MipNYXRoLlBJK2YpLGQ8MCYmKGQ9MipNYXRoLlBJK2QpLGgmJmY+ZCYmKGYtPTIqTWF0aC5QSSksIWgmJmQ+ZiYmKGQtPTIqTWF0aC5QSSl9bGV0IHY9ZC1mO2lmKE1hdGguYWJzKHYpPjEyMCpNYXRoLlBJLzE4MCl7Y29uc3QgdD1kLGU9bixpPXI7ZD1oJiZkPmY/ZisxMjAqTWF0aC5QSS8xODAqMTpmKzEyMCpNYXRoLlBJLzE4MCotMSxjPU8obj1nK2EqTWF0aC5jb3MoZCkscj15K3MqTWF0aC5zaW4oZCksZSxpLGEscyxvLDAsaCxbZCx0LGcseV0pfXY9ZC1mO2NvbnN0IE09TWF0aC5jb3MoZiksaz1NYXRoLnNpbihmKSxiPU1hdGguY29zKGQpLG09TWF0aC5zaW4oZCksdz1NYXRoLnRhbih2LzQpLFA9NC8zKmEqdyx4PTQvMypzKncsTD1bdCxlXSxUPVt0K1AqayxlLXgqTV0sXz1bbitQKm0sci14KmJdLEQ9W24scl07aWYoVFswXT0yKkxbMF0tVFswXSxUWzFdPTIqTFsxXS1UWzFdLHUpcmV0dXJuW1QsXyxEXS5jb25jYXQoYyk7e2M9W1QsXyxEXS5jb25jYXQoYyk7Y29uc3QgdD1bXTtmb3IobGV0IGU9MDtlPGMubGVuZ3RoO2UrPTMpe2NvbnN0IG49UyhjW2VdWzBdLGNbZV1bMV0scCkscj1TKGNbZSsxXVswXSxjW2UrMV1bMV0scCksYT1TKGNbZSsyXVswXSxjW2UrMl1bMV0scCk7dC5wdXNoKFtuWzBdLG5bMV0sclswXSxyWzFdLGFbMF0sYVsxXV0pfXJldHVybiB0fX12YXIgTD17cmFuZE9mZnNldDpmdW5jdGlvbih0LGUpe3JldHVybiBGKHQsZSl9LHJhbmRPZmZzZXRXaXRoUmFuZ2U6ZnVuY3Rpb24odCxlLG4pe3JldHVybiBxKHQsZSxuKX0sZWxsaXBzZTpmdW5jdGlvbih0LGUsbixyLGEpe3ZhciBzPUkobixyLGEpO3JldHVybiBDKHQsZSxhLHMpLm9wc2V0fSxkb3VibGVMaW5lT3BzOmZ1bmN0aW9uKHQsZSxuLHIsYSl7cmV0dXJuIFYodCxlLG4scixhLCEwKX19O2Z1bmN0aW9uIFQodCxlLG4scixhKXtyZXR1cm57dHlwZTpcInBhdGhcIixvcHM6Vih0LGUsbixyLGEpfX1mdW5jdGlvbiBfKHQsZSxuKXt2YXIgcj0odHx8W10pLmxlbmd0aDtpZihyPjIpe2Zvcih2YXIgYT1bXSxzPTA7czxyLTE7cysrKWEucHVzaC5hcHBseShhLFYodFtzXVswXSx0W3NdWzFdLHRbcysxXVswXSx0W3MrMV1bMV0sbikpO3JldHVybiBlJiZhLnB1c2guYXBwbHkoYSxWKHRbci0xXVswXSx0W3ItMV1bMV0sdFswXVswXSx0WzBdWzFdLG4pKSx7dHlwZTpcInBhdGhcIixvcHM6YX19cmV0dXJuIDI9PT1yP1QodFswXVswXSx0WzBdWzFdLHRbMV1bMF0sdFsxXVsxXSxuKTp7dHlwZTpcInBhdGhcIixvcHM6W119fWZ1bmN0aW9uIEQodCxlLG4scixhKXtyZXR1cm4gZnVuY3Rpb24odCxlKXtyZXR1cm4gXyh0LCEwLGUpfShbW3QsZV0sW3QrbixlXSxbdCtuLGUrcl0sW3QsZStyXV0sYSl9ZnVuY3Rpb24gQSh0LGUpe2lmKHQubGVuZ3RoKXtmb3IodmFyIG49XCJudW1iZXJcIj09dHlwZW9mIHRbMF1bMF0/W3RdOnQscj1RKG5bMF0sMSooMSsuMiplLnJvdWdobmVzcyksZSksYT1lLmRpc2FibGVNdWx0aVN0cm9rZT9bXTpRKG5bMF0sMS41KigxKy4yMiplLnJvdWdobmVzcyksUihlKSkscz0xO3M8bi5sZW5ndGg7cysrKXt2YXIgbz1uW3NdO2lmKG8ubGVuZ3RoKXtmb3IodmFyIGk9UShvLDEqKDErLjIqZS5yb3VnaG5lc3MpLGUpLGg9ZS5kaXNhYmxlTXVsdGlTdHJva2U/W106UShvLDEuNSooMSsuMjIqZS5yb3VnaG5lc3MpLFIoZSkpLHU9MCxwPWk7dTxwLmxlbmd0aDt1Kyspe1wibW92ZVwiIT09KGY9cFt1XSkub3AmJnIucHVzaChmKX1mb3IodmFyIGw9MCxjPWg7bDxjLmxlbmd0aDtsKyspe3ZhciBmO1wibW92ZVwiIT09KGY9Y1tsXSkub3AmJmEucHVzaChmKX19fXJldHVybnt0eXBlOlwicGF0aFwiLG9wczpyLmNvbmNhdChhKX19cmV0dXJue3R5cGU6XCJwYXRoXCIsb3BzOltdfX1mdW5jdGlvbiBJKHQsZSxuKXt2YXIgcj1NYXRoLnNxcnQoMipNYXRoLlBJKk1hdGguc3FydCgoTWF0aC5wb3codC8yLDIpK01hdGgucG93KGUvMiwyKSkvMikpLGE9TWF0aC5jZWlsKE1hdGgubWF4KG4uY3VydmVTdGVwQ291bnQsbi5jdXJ2ZVN0ZXBDb3VudC9NYXRoLnNxcnQoMjAwKSpyKSkscz0yKk1hdGguUEkvYSxvPU1hdGguYWJzKHQvMiksaT1NYXRoLmFicyhlLzIpLGg9MS1uLmN1cnZlRml0dGluZztyZXR1cm57aW5jcmVtZW50OnMscng6bys9RihvKmgsbikscnk6aSs9RihpKmgsbil9fWZ1bmN0aW9uIEModCxlLG4scil7dmFyIGE9JChyLmluY3JlbWVudCx0LGUsci5yeCxyLnJ5LDEsci5pbmNyZW1lbnQqcSguMSxxKC40LDEsbiksbiksbikscz1hWzBdLG89YVsxXSxpPUgocyxudWxsLG4pO2lmKCFuLmRpc2FibGVNdWx0aVN0cm9rZSYmMCE9PW4ucm91Z2huZXNzKXt2YXIgaD1IKCQoci5pbmNyZW1lbnQsdCxlLHIucngsci5yeSwxLjUsMCxuKVswXSxudWxsLG4pO2k9aS5jb25jYXQoaCl9cmV0dXJue2VzdGltYXRlZFBvaW50czpvLG9wc2V0Ont0eXBlOlwicGF0aFwiLG9wczppfX19ZnVuY3Rpb24geih0LGUsbixhLHMsbyxpLGgsdSl7dmFyIHA9dCxsPWUsYz1NYXRoLmFicyhuLzIpLGY9TWF0aC5hYnMoYS8yKTtjKz1GKC4wMSpjLHUpLGYrPUYoLjAxKmYsdSk7Zm9yKHZhciBkPXMsZz1vO2Q8MDspZCs9MipNYXRoLlBJLGcrPTIqTWF0aC5QSTtnLWQ+MipNYXRoLlBJJiYoZD0wLGc9MipNYXRoLlBJKTt2YXIgeT0yKk1hdGguUEkvdS5jdXJ2ZVN0ZXBDb3VudCx2PU1hdGgubWluKHkvMiwoZy1kKS8yKSxNPU4odixwLGwsYyxmLGQsZywxLHUpO2lmKCF1LmRpc2FibGVNdWx0aVN0cm9rZSl7dmFyIGs9Tih2LHAsbCxjLGYsZCxnLDEuNSx1KTtNLnB1c2guYXBwbHkoTSxrKX1yZXR1cm4gaSYmKGg/TS5wdXNoLmFwcGx5KE0scihyKFtdLFYocCxsLHArYypNYXRoLmNvcyhkKSxsK2YqTWF0aC5zaW4oZCksdSksITEpLFYocCxsLHArYypNYXRoLmNvcyhnKSxsK2YqTWF0aC5zaW4oZyksdSksITEpKTpNLnB1c2goe29wOlwibGluZVRvXCIsZGF0YTpbcCxsXX0se29wOlwibGluZVRvXCIsZGF0YTpbcCtjKk1hdGguY29zKGQpLGwrZipNYXRoLnNpbihkKV19KSkse3R5cGU6XCJwYXRoXCIsb3BzOk19fWZ1bmN0aW9uIFcodCxlKXtmb3IodmFyIG49W10scj1bMCwwXSxhPVswLDBdLHM9MCxvPXgoUCh3KHQpKSk7czxvLmxlbmd0aDtzKyspe3ZhciBpPW9bc10saD1pLmtleSx1PWkuZGF0YTtzd2l0Y2goaCl7Y2FzZVwiTVwiOmE9W3VbMF0sdVsxXV0scj1bdVswXSx1WzFdXTticmVhaztjYXNlXCJMXCI6bi5wdXNoLmFwcGx5KG4sVihhWzBdLGFbMV0sdVswXSx1WzFdLGUpKSxhPVt1WzBdLHVbMV1dO2JyZWFrO2Nhc2VcIkNcIjp2YXIgcD11WzBdLGw9dVsxXSxjPXVbMl0sZj11WzNdLGQ9dVs0XSxnPXVbNV07bi5wdXNoLmFwcGx5KG4sQihwLGwsYyxmLGQsZyxhLGUpKSxhPVtkLGddO2JyZWFrO2Nhc2VcIlpcIjpuLnB1c2guYXBwbHkobixWKGFbMF0sYVsxXSxyWzBdLHJbMV0sZSkpLGE9W3JbMF0sclsxXV19fXJldHVybnt0eXBlOlwicGF0aFwiLG9wczpufX1mdW5jdGlvbiBFKHQsZSl7Zm9yKHZhciBuPVtdLHI9MCxhPXQ7cjxhLmxlbmd0aDtyKyspe3ZhciBzPWFbcl07aWYocy5sZW5ndGgpe3ZhciBvPWUubWF4UmFuZG9tbmVzc09mZnNldHx8MCxpPXMubGVuZ3RoO2lmKGk+Mil7bi5wdXNoKHtvcDpcIm1vdmVcIixkYXRhOltzWzBdWzBdK0YobyxlKSxzWzBdWzFdK0YobyxlKV19KTtmb3IodmFyIGg9MTtoPGk7aCsrKW4ucHVzaCh7b3A6XCJsaW5lVG9cIixkYXRhOltzW2hdWzBdK0YobyxlKSxzW2hdWzFdK0YobyxlKV19KX19fXJldHVybnt0eXBlOlwiZmlsbFBhdGhcIixvcHM6bn19ZnVuY3Rpb24gRyh0LGUpe3JldHVybiBmdW5jdGlvbih0LGUpe3ZhciBuPXQuZmlsbFN0eWxlfHxcImhhY2h1cmVcIjtpZighZ1tuXSlzd2l0Y2gobil7Y2FzZVwiemlnemFnXCI6Z1tuXXx8KGdbbl09bmV3IHAoZSkpO2JyZWFrO2Nhc2VcImNyb3NzLWhhdGNoXCI6Z1tuXXx8KGdbbl09bmV3IGwoZSkpO2JyZWFrO2Nhc2VcImRvdHNcIjpnW25dfHwoZ1tuXT1uZXcgYyhlKSk7YnJlYWs7Y2FzZVwiZGFzaGVkXCI6Z1tuXXx8KGdbbl09bmV3IGYoZSkpO2JyZWFrO2Nhc2VcInppZ3phZy1saW5lXCI6Z1tuXXx8KGdbbl09bmV3IGQoZSkpO2JyZWFrO2RlZmF1bHQ6Z1tuPVwiaGFjaHVyZVwiXXx8KGdbbl09bmV3IGgoZSkpfXJldHVybiBnW25dfShlLEwpLmZpbGxQb2x5Z29ucyh0LGUpfWZ1bmN0aW9uIFIodCl7dmFyIGU9bih7fSx0KTtyZXR1cm4gZS5yYW5kb21pemVyPXZvaWQgMCx0LnNlZWQmJihlLnNlZWQ9dC5zZWVkKzEpLGV9ZnVuY3Rpb24gaih0KXtyZXR1cm4gdC5yYW5kb21pemVyfHwodC5yYW5kb21pemVyPW5ldyB5KHQuc2VlZHx8MCkpLHQucmFuZG9taXplci5uZXh0KCl9ZnVuY3Rpb24gcSh0LGUsbixyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9MSksbi5yb3VnaG5lc3MqciooaihuKSooZS10KSt0KX1mdW5jdGlvbiBGKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49MSkscSgtdCx0LGUsbil9ZnVuY3Rpb24gVih0LGUsbixyLGEscyl7dm9pZCAwPT09cyYmKHM9ITEpO3ZhciBvPXM/YS5kaXNhYmxlTXVsdGlTdHJva2VGaWxsOmEuZGlzYWJsZU11bHRpU3Ryb2tlLGk9Wih0LGUsbixyLGEsITAsITEpO2lmKG8pcmV0dXJuIGk7dmFyIGg9Wih0LGUsbixyLGEsITAsITApO3JldHVybiBpLmNvbmNhdChoKX1mdW5jdGlvbiBaKHQsZSxuLHIsYSxzLG8pe3ZhciBpPU1hdGgucG93KHQtbiwyKStNYXRoLnBvdyhlLXIsMiksaD1NYXRoLnNxcnQoaSksdT0xO3U9aDwyMDA/MTpoPjUwMD8uNDotLjAwMTY2NjgqaCsxLjIzMzMzNDt2YXIgcD1hLm1heFJhbmRvbW5lc3NPZmZzZXR8fDA7cCpwKjEwMD5pJiYocD1oLzEwKTt2YXIgbD1wLzIsYz0uMisuMipqKGEpLGY9YS5ib3dpbmcqYS5tYXhSYW5kb21uZXNzT2Zmc2V0KihyLWUpLzIwMCxkPWEuYm93aW5nKmEubWF4UmFuZG9tbmVzc09mZnNldCoodC1uKS8yMDA7Zj1GKGYsYSx1KSxkPUYoZCxhLHUpO3ZhciBnPVtdLHk9ZnVuY3Rpb24oKXtyZXR1cm4gRihsLGEsdSl9LHY9ZnVuY3Rpb24oKXtyZXR1cm4gRihwLGEsdSl9LE09YS5wcmVzZXJ2ZVZlcnRpY2VzO3JldHVybiBzJiYobz9nLnB1c2goe29wOlwibW92ZVwiLGRhdGE6W3QrKE0/MDp5KCkpLGUrKE0/MDp5KCkpXX0pOmcucHVzaCh7b3A6XCJtb3ZlXCIsZGF0YTpbdCsoTT8wOkYocCxhLHUpKSxlKyhNPzA6RihwLGEsdSkpXX0pKSxvP2cucHVzaCh7b3A6XCJiY3VydmVUb1wiLGRhdGE6W2YrdCsobi10KSpjK3koKSxkK2UrKHItZSkqYyt5KCksZit0KzIqKG4tdCkqYyt5KCksZCtlKzIqKHItZSkqYyt5KCksbisoTT8wOnkoKSkscisoTT8wOnkoKSldfSk6Zy5wdXNoKHtvcDpcImJjdXJ2ZVRvXCIsZGF0YTpbZit0KyhuLXQpKmMrdigpLGQrZSsoci1lKSpjK3YoKSxmK3QrMioobi10KSpjK3YoKSxkK2UrMiooci1lKSpjK3YoKSxuKyhNPzA6digpKSxyKyhNPzA6digpKV19KSxnfWZ1bmN0aW9uIFEodCxlLG4pe2lmKCF0Lmxlbmd0aClyZXR1cm5bXTt2YXIgcj1bXTtyLnB1c2goW3RbMF1bMF0rRihlLG4pLHRbMF1bMV0rRihlLG4pXSksci5wdXNoKFt0WzBdWzBdK0YoZSxuKSx0WzBdWzFdK0YoZSxuKV0pO2Zvcih2YXIgYT0xO2E8dC5sZW5ndGg7YSsrKXIucHVzaChbdFthXVswXStGKGUsbiksdFthXVsxXStGKGUsbildKSxhPT09dC5sZW5ndGgtMSYmci5wdXNoKFt0W2FdWzBdK0YoZSxuKSx0W2FdWzFdK0YoZSxuKV0pO3JldHVybiBIKHIsbnVsbCxuKX1mdW5jdGlvbiBIKHQsZSxuKXt2YXIgcj10Lmxlbmd0aCxhPVtdO2lmKHI+Myl7dmFyIHM9W10sbz0xLW4uY3VydmVUaWdodG5lc3M7YS5wdXNoKHtvcDpcIm1vdmVcIixkYXRhOlt0WzFdWzBdLHRbMV1bMV1dfSk7Zm9yKHZhciBpPTE7aSsyPHI7aSsrKXt2YXIgaD10W2ldO3NbMF09W2hbMF0saFsxXV0sc1sxXT1baFswXSsobyp0W2krMV1bMF0tbyp0W2ktMV1bMF0pLzYsaFsxXSsobyp0W2krMV1bMV0tbyp0W2ktMV1bMV0pLzZdLHNbMl09W3RbaSsxXVswXSsobyp0W2ldWzBdLW8qdFtpKzJdWzBdKS82LHRbaSsxXVsxXSsobyp0W2ldWzFdLW8qdFtpKzJdWzFdKS82XSxzWzNdPVt0W2krMV1bMF0sdFtpKzFdWzFdXSxhLnB1c2goe29wOlwiYmN1cnZlVG9cIixkYXRhOltzWzFdWzBdLHNbMV1bMV0sc1syXVswXSxzWzJdWzFdLHNbM11bMF0sc1szXVsxXV19KX1pZihlJiYyPT09ZS5sZW5ndGgpe3ZhciB1PW4ubWF4UmFuZG9tbmVzc09mZnNldDthLnB1c2goe29wOlwibGluZVRvXCIsZGF0YTpbZVswXStGKHUsbiksZVsxXStGKHUsbildfSl9fWVsc2UgMz09PXI/KGEucHVzaCh7b3A6XCJtb3ZlXCIsZGF0YTpbdFsxXVswXSx0WzFdWzFdXX0pLGEucHVzaCh7b3A6XCJiY3VydmVUb1wiLGRhdGE6W3RbMV1bMF0sdFsxXVsxXSx0WzJdWzBdLHRbMl1bMV0sdFsyXVswXSx0WzJdWzFdXX0pKToyPT09ciYmYS5wdXNoLmFwcGx5KGEsWih0WzBdWzBdLHRbMF1bMV0sdFsxXVswXSx0WzFdWzFdLG4sITAsITApKTtyZXR1cm4gYX1mdW5jdGlvbiAkKHQsZSxuLHIsYSxzLG8saSl7dmFyIGg9W10sdT1bXTtpZigwPT09aS5yb3VnaG5lc3Mpe3QvPTQsdS5wdXNoKFtlK3IqTWF0aC5jb3MoLXQpLG4rYSpNYXRoLnNpbigtdCldKTtmb3IodmFyIHA9MDtwPD0yKk1hdGguUEk7cCs9dCl7dmFyIGw9W2UrcipNYXRoLmNvcyhwKSxuK2EqTWF0aC5zaW4ocCldO2gucHVzaChsKSx1LnB1c2gobCl9dS5wdXNoKFtlK3IqTWF0aC5jb3MoMCksbithKk1hdGguc2luKDApXSksdS5wdXNoKFtlK3IqTWF0aC5jb3ModCksbithKk1hdGguc2luKHQpXSl9ZWxzZXt2YXIgYz1GKC41LGkpLU1hdGguUEkvMjt1LnB1c2goW0YocyxpKStlKy45KnIqTWF0aC5jb3MoYy10KSxGKHMsaSkrbisuOSphKk1hdGguc2luKGMtdCldKTt2YXIgZj0yKk1hdGguUEkrYy0uMDE7Zm9yKHA9YztwPGY7cCs9dCl7bD1bRihzLGkpK2UrcipNYXRoLmNvcyhwKSxGKHMsaSkrbithKk1hdGguc2luKHApXTtoLnB1c2gobCksdS5wdXNoKGwpfXUucHVzaChbRihzLGkpK2UrcipNYXRoLmNvcyhjKzIqTWF0aC5QSSsuNSpvKSxGKHMsaSkrbithKk1hdGguc2luKGMrMipNYXRoLlBJKy41Km8pXSksdS5wdXNoKFtGKHMsaSkrZSsuOTgqcipNYXRoLmNvcyhjK28pLEYocyxpKStuKy45OCphKk1hdGguc2luKGMrbyldKSx1LnB1c2goW0YocyxpKStlKy45KnIqTWF0aC5jb3MoYysuNSpvKSxGKHMsaSkrbisuOSphKk1hdGguc2luKGMrLjUqbyldKX1yZXR1cm5bdSxoXX1mdW5jdGlvbiBOKHQsZSxuLHIsYSxzLG8saSxoKXt2YXIgdT1zK0YoLjEsaCkscD1bXTtwLnB1c2goW0YoaSxoKStlKy45KnIqTWF0aC5jb3ModS10KSxGKGksaCkrbisuOSphKk1hdGguc2luKHUtdCldKTtmb3IodmFyIGw9dTtsPD1vO2wrPXQpcC5wdXNoKFtGKGksaCkrZStyKk1hdGguY29zKGwpLEYoaSxoKStuK2EqTWF0aC5zaW4obCldKTtyZXR1cm4gcC5wdXNoKFtlK3IqTWF0aC5jb3MobyksbithKk1hdGguc2luKG8pXSkscC5wdXNoKFtlK3IqTWF0aC5jb3MobyksbithKk1hdGguc2luKG8pXSksSChwLG51bGwsaCl9ZnVuY3Rpb24gQih0LGUsbixyLGEscyxvLGkpe2Zvcih2YXIgaD1bXSx1PVtpLm1heFJhbmRvbW5lc3NPZmZzZXR8fDEsKGkubWF4UmFuZG9tbmVzc09mZnNldHx8MSkrLjNdLHA9WzAsMF0sbD1pLmRpc2FibGVNdWx0aVN0cm9rZT8xOjIsYz1pLnByZXNlcnZlVmVydGljZXMsZj0wO2Y8bDtmKyspMD09PWY/aC5wdXNoKHtvcDpcIm1vdmVcIixkYXRhOltvWzBdLG9bMV1dfSk6aC5wdXNoKHtvcDpcIm1vdmVcIixkYXRhOltvWzBdKyhjPzA6Rih1WzBdLGkpKSxvWzFdKyhjPzA6Rih1WzBdLGkpKV19KSxwPWM/W2Esc106W2ErRih1W2ZdLGkpLHMrRih1W2ZdLGkpXSxoLnB1c2goe29wOlwiYmN1cnZlVG9cIixkYXRhOlt0K0YodVtmXSxpKSxlK0YodVtmXSxpKSxuK0YodVtmXSxpKSxyK0YodVtmXSxpKSxwWzBdLHBbMV1dfSk7cmV0dXJuIGh9ZnVuY3Rpb24gSih0KXtyZXR1cm5bLi4udF19ZnVuY3Rpb24gSyh0LGU9MCl7Y29uc3Qgbj10Lmxlbmd0aDtpZihuPDMpdGhyb3cgbmV3IEVycm9yKFwiQSBjdXJ2ZSBtdXN0IGhhdmUgYXQgbGVhc3QgdGhyZWUgcG9pbnRzLlwiKTtjb25zdCByPVtdO2lmKDM9PT1uKXIucHVzaChKKHRbMF0pLEoodFsxXSksSih0WzJdKSxKKHRbMl0pKTtlbHNle2NvbnN0IG49W107bi5wdXNoKHRbMF0sdFswXSk7Zm9yKGxldCBlPTE7ZTx0Lmxlbmd0aDtlKyspbi5wdXNoKHRbZV0pLGU9PT10Lmxlbmd0aC0xJiZuLnB1c2godFtlXSk7Y29uc3QgYT1bXSxzPTEtZTtyLnB1c2goSihuWzBdKSk7Zm9yKGxldCB0PTE7dCsyPG4ubGVuZ3RoO3QrKyl7Y29uc3QgZT1uW3RdO2FbMF09W2VbMF0sZVsxXV0sYVsxXT1bZVswXSsocypuW3QrMV1bMF0tcypuW3QtMV1bMF0pLzYsZVsxXSsocypuW3QrMV1bMV0tcypuW3QtMV1bMV0pLzZdLGFbMl09W25bdCsxXVswXSsocypuW3RdWzBdLXMqblt0KzJdWzBdKS82LG5bdCsxXVsxXSsocypuW3RdWzFdLXMqblt0KzJdWzFdKS82XSxhWzNdPVtuW3QrMV1bMF0sblt0KzFdWzFdXSxyLnB1c2goYVsxXSxhWzJdLGFbM10pfX1yZXR1cm4gcn1mdW5jdGlvbiBVKHQsZSl7cmV0dXJuIE1hdGgucG93KHRbMF0tZVswXSwyKStNYXRoLnBvdyh0WzFdLWVbMV0sMil9ZnVuY3Rpb24gWCh0LGUsbil7Y29uc3Qgcj1VKGUsbik7aWYoMD09PXIpcmV0dXJuIFUodCxlKTtsZXQgYT0oKHRbMF0tZVswXSkqKG5bMF0tZVswXSkrKHRbMV0tZVsxXSkqKG5bMV0tZVsxXSkpL3I7cmV0dXJuIGE9TWF0aC5tYXgoMCxNYXRoLm1pbigxLGEpKSxVKHQsWShlLG4sYSkpfWZ1bmN0aW9uIFkodCxlLG4pe3JldHVyblt0WzBdKyhlWzBdLXRbMF0pKm4sdFsxXSsoZVsxXS10WzFdKSpuXX1mdW5jdGlvbiB0dCh0LGUsbixyKXtjb25zdCBhPXJ8fFtdO2lmKGZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj10W2UrMF0scj10W2UrMV0sYT10W2UrMl0scz10W2UrM107bGV0IG89MypyWzBdLTIqblswXS1zWzBdO28qPW87bGV0IGk9MypyWzFdLTIqblsxXS1zWzFdO2kqPWk7bGV0IGg9MyphWzBdLTIqc1swXS1uWzBdO2gqPWg7bGV0IHU9MyphWzFdLTIqc1sxXS1uWzFdO3JldHVybiB1Kj11LG88aCYmKG89aCksaTx1JiYoaT11KSxvK2l9KHQsZSk8bil7Y29uc3Qgbj10W2UrMF07aWYoYS5sZW5ndGgpeyhzPWFbYS5sZW5ndGgtMV0sbz1uLE1hdGguc3FydChVKHMsbykpKT4xJiZhLnB1c2gobil9ZWxzZSBhLnB1c2gobik7YS5wdXNoKHRbZSszXSl9ZWxzZXtjb25zdCByPS41LHM9dFtlKzBdLG89dFtlKzFdLGk9dFtlKzJdLGg9dFtlKzNdLHU9WShzLG8scikscD1ZKG8saSxyKSxsPVkoaSxoLHIpLGM9WSh1LHAsciksZj1ZKHAsbCxyKSxkPVkoYyxmLHIpO3R0KFtzLHUsYyxkXSwwLG4sYSksdHQoW2QsZixsLGhdLDAsbixhKX12YXIgcyxvO3JldHVybiBhfWZ1bmN0aW9uIGV0KHQsZSl7cmV0dXJuIG50KHQsMCx0Lmxlbmd0aCxlKX1mdW5jdGlvbiBudCh0LGUsbixyLGEpe2NvbnN0IHM9YXx8W10sbz10W2VdLGk9dFtuLTFdO2xldCBoPTAsdT0xO2ZvcihsZXQgcj1lKzE7cjxuLTE7KytyKXtjb25zdCBlPVgodFtyXSxvLGkpO2U+aCYmKGg9ZSx1PXIpfXJldHVybiBNYXRoLnNxcnQoaCk+cj8obnQodCxlLHUrMSxyLHMpLG50KHQsdSxuLHIscykpOihzLmxlbmd0aHx8cy5wdXNoKG8pLHMucHVzaChpKSksc31mdW5jdGlvbiBydCh0LGU9LjE1LG4pe2NvbnN0IHI9W10sYT0odC5sZW5ndGgtMSkvMztmb3IobGV0IG49MDtuPGE7bisrKXt0dCh0LDMqbixlLHIpfXJldHVybiBuJiZuPjA/bnQociwwLHIubGVuZ3RoLG4pOnJ9dmFyIGF0PVwibm9uZVwiLHN0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLmRlZmF1bHRPcHRpb25zPXttYXhSYW5kb21uZXNzT2Zmc2V0OjIscm91Z2huZXNzOjEsYm93aW5nOjEsc3Ryb2tlOlwiIzAwMFwiLHN0cm9rZVdpZHRoOjEsY3VydmVUaWdodG5lc3M6MCxjdXJ2ZUZpdHRpbmc6Ljk1LGN1cnZlU3RlcENvdW50OjksZmlsbFN0eWxlOlwiaGFjaHVyZVwiLGZpbGxXZWlnaHQ6LTEsaGFjaHVyZUFuZ2xlOi00MSxoYWNodXJlR2FwOi0xLGRhc2hPZmZzZXQ6LTEsZGFzaEdhcDotMSx6aWd6YWdPZmZzZXQ6LTEsc2VlZDowLGRpc2FibGVNdWx0aVN0cm9rZTohMSxkaXNhYmxlTXVsdGlTdHJva2VGaWxsOiExLHByZXNlcnZlVmVydGljZXM6ITEsZmlsbFNoYXBlUm91Z2huZXNzR2FpbjouOH0sdGhpcy5jb25maWc9dHx8e30sdGhpcy5jb25maWcub3B0aW9ucyYmKHRoaXMuZGVmYXVsdE9wdGlvbnM9dGhpcy5fbyh0aGlzLmNvbmZpZy5vcHRpb25zKSl9cmV0dXJuIHQubmV3U2VlZD1mdW5jdGlvbigpe3JldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqTWF0aC5wb3coMiwzMSkpfSx0LnByb3RvdHlwZS5fbz1mdW5jdGlvbih0KXtyZXR1cm4gdD9PYmplY3QuYXNzaWduKHt9LHRoaXMuZGVmYXVsdE9wdGlvbnMsdCk6dGhpcy5kZWZhdWx0T3B0aW9uc30sdC5wcm90b3R5cGUuX2Q9ZnVuY3Rpb24odCxlLG4pe3JldHVybntzaGFwZTp0LHNldHM6ZXx8W10sb3B0aW9uczpufHx0aGlzLmRlZmF1bHRPcHRpb25zfX0sdC5wcm90b3R5cGUubGluZT1mdW5jdGlvbih0LGUsbixyLGEpe3ZhciBzPXRoaXMuX28oYSk7cmV0dXJuIHRoaXMuX2QoXCJsaW5lXCIsW1QodCxlLG4scixzKV0scyl9LHQucHJvdG90eXBlLnJlY3RhbmdsZT1mdW5jdGlvbih0LGUsbixyLGEpe3ZhciBzPXRoaXMuX28oYSksbz1bXSxpPUQodCxlLG4scixzKTtpZihzLmZpbGwpe3ZhciBoPVtbdCxlXSxbdCtuLGVdLFt0K24sZStyXSxbdCxlK3JdXTtcInNvbGlkXCI9PT1zLmZpbGxTdHlsZT9vLnB1c2goRShbaF0scykpOm8ucHVzaChHKFtoXSxzKSl9cmV0dXJuIHMuc3Ryb2tlIT09YXQmJm8ucHVzaChpKSx0aGlzLl9kKFwicmVjdGFuZ2xlXCIsbyxzKX0sdC5wcm90b3R5cGUuZWxsaXBzZT1mdW5jdGlvbih0LGUsbixyLGEpe3ZhciBzPXRoaXMuX28oYSksbz1bXSxpPUkobixyLHMpLGg9Qyh0LGUscyxpKTtpZihzLmZpbGwpaWYoXCJzb2xpZFwiPT09cy5maWxsU3R5bGUpe3ZhciB1PUModCxlLHMsaSkub3BzZXQ7dS50eXBlPVwiZmlsbFBhdGhcIixvLnB1c2godSl9ZWxzZSBvLnB1c2goRyhbaC5lc3RpbWF0ZWRQb2ludHNdLHMpKTtyZXR1cm4gcy5zdHJva2UhPT1hdCYmby5wdXNoKGgub3BzZXQpLHRoaXMuX2QoXCJlbGxpcHNlXCIsbyxzKX0sdC5wcm90b3R5cGUuY2lyY2xlPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBhPXRoaXMuZWxsaXBzZSh0LGUsbixuLHIpO3JldHVybiBhLnNoYXBlPVwiY2lyY2xlXCIsYX0sdC5wcm90b3R5cGUubGluZWFyUGF0aD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuX28oZSk7cmV0dXJuIHRoaXMuX2QoXCJsaW5lYXJQYXRoXCIsW18odCwhMSxuKV0sbil9LHQucHJvdG90eXBlLmFyYz1mdW5jdGlvbih0LGUscixhLHMsbyxpLGgpe3ZvaWQgMD09PWkmJihpPSExKTt2YXIgdT10aGlzLl9vKGgpLHA9W10sbD16KHQsZSxyLGEscyxvLGksITAsdSk7aWYoaSYmdS5maWxsKWlmKFwic29saWRcIj09PXUuZmlsbFN0eWxlKXt2YXIgYz1uKHt9LHUpO2MuZGlzYWJsZU11bHRpU3Ryb2tlPSEwO3ZhciBmPXoodCxlLHIsYSxzLG8sITAsITEsYyk7Zi50eXBlPVwiZmlsbFBhdGhcIixwLnB1c2goZil9ZWxzZSBwLnB1c2goZnVuY3Rpb24odCxlLG4scixhLHMsbyl7dmFyIGk9dCxoPWUsdT1NYXRoLmFicyhuLzIpLHA9TWF0aC5hYnMoci8yKTt1Kz1GKC4wMSp1LG8pLHArPUYoLjAxKnAsbyk7Zm9yKHZhciBsPWEsYz1zO2w8MDspbCs9MipNYXRoLlBJLGMrPTIqTWF0aC5QSTtjLWw+MipNYXRoLlBJJiYobD0wLGM9MipNYXRoLlBJKTtmb3IodmFyIGY9KGMtbCkvby5jdXJ2ZVN0ZXBDb3VudCxkPVtdLGc9bDtnPD1jO2crPWYpZC5wdXNoKFtpK3UqTWF0aC5jb3MoZyksaCtwKk1hdGguc2luKGcpXSk7cmV0dXJuIGQucHVzaChbaSt1Kk1hdGguY29zKGMpLGgrcCpNYXRoLnNpbihjKV0pLGQucHVzaChbaSxoXSksRyhbZF0sbyl9KHQsZSxyLGEscyxvLHUpKTtyZXR1cm4gdS5zdHJva2UhPT1hdCYmcC5wdXNoKGwpLHRoaXMuX2QoXCJhcmNcIixwLHUpfSx0LnByb3RvdHlwZS5jdXJ2ZT1mdW5jdGlvbih0LGUpe3ZhciByPXRoaXMuX28oZSksYT1bXSxzPUEodCxyKTtpZihyLmZpbGwmJnIuZmlsbCE9PWF0KWlmKFwic29saWRcIj09PXIuZmlsbFN0eWxlKXt2YXIgbz1BKHQsbihuKHt9LHIpLHtkaXNhYmxlTXVsdGlTdHJva2U6ITAscm91Z2huZXNzOnIucm91Z2huZXNzP3Iucm91Z2huZXNzK3IuZmlsbFNoYXBlUm91Z2huZXNzR2FpbjowfSkpO2EucHVzaCh7dHlwZTpcImZpbGxQYXRoXCIsb3BzOnRoaXMuX21lcmdlZFNoYXBlKG8ub3BzKX0pfWVsc2V7dmFyIGk9W10saD10O2lmKGgubGVuZ3RoKWZvcih2YXIgdT0wLHA9XCJudW1iZXJcIj09dHlwZW9mIGhbMF1bMF0/W2hdOmg7dTxwLmxlbmd0aDt1Kyspe3ZhciBsPXBbdV07bC5sZW5ndGg8Mz9pLnB1c2guYXBwbHkoaSxsKTozPT09bC5sZW5ndGg/aS5wdXNoLmFwcGx5KGkscnQoSyhbbFswXSxsWzBdLGxbMV0sbFsyXV0pLDEwLCgxK3Iucm91Z2huZXNzKS8yKSk6aS5wdXNoLmFwcGx5KGkscnQoSyhsKSwxMCwoMStyLnJvdWdobmVzcykvMikpfWkubGVuZ3RoJiZhLnB1c2goRyhbaV0scikpfXJldHVybiByLnN0cm9rZSE9PWF0JiZhLnB1c2gocyksdGhpcy5fZChcImN1cnZlXCIsYSxyKX0sdC5wcm90b3R5cGUucG9seWdvbj1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuX28oZSkscj1bXSxhPV8odCwhMCxuKTtyZXR1cm4gbi5maWxsJiYoXCJzb2xpZFwiPT09bi5maWxsU3R5bGU/ci5wdXNoKEUoW3RdLG4pKTpyLnB1c2goRyhbdF0sbikpKSxuLnN0cm9rZSE9PWF0JiZyLnB1c2goYSksdGhpcy5fZChcInBvbHlnb25cIixyLG4pfSx0LnByb3RvdHlwZS5wYXRoPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcy5fbyhlKSxhPVtdO2lmKCF0KXJldHVybiB0aGlzLl9kKFwicGF0aFwiLGEscik7dD0odHx8XCJcIikucmVwbGFjZSgvXFxuL2csXCIgXCIpLnJlcGxhY2UoLygtXFxzKS9nLFwiLVwiKS5yZXBsYWNlKFwiLyhzcykvZ1wiLFwiIFwiKTt2YXIgcz1yLmZpbGwmJlwidHJhbnNwYXJlbnRcIiE9PXIuZmlsbCYmci5maWxsIT09YXQsbz1yLnN0cm9rZSE9PWF0LGk9ISEoci5zaW1wbGlmaWNhdGlvbiYmci5zaW1wbGlmaWNhdGlvbjwxKSxoPWZ1bmN0aW9uKHQsZSxuKXtjb25zdCByPXgoUCh3KHQpKSksYT1bXTtsZXQgcz1bXSxvPVswLDBdLGk9W107Y29uc3QgaD0oKT0+e2kubGVuZ3RoPj00JiZzLnB1c2goLi4ucnQoaSxlKSksaT1bXX0sdT0oKT0+e2goKSxzLmxlbmd0aCYmKGEucHVzaChzKSxzPVtdKX07Zm9yKGNvbnN0e2tleTp0LGRhdGE6ZX1vZiByKXN3aXRjaCh0KXtjYXNlXCJNXCI6dSgpLG89W2VbMF0sZVsxXV0scy5wdXNoKG8pO2JyZWFrO2Nhc2VcIkxcIjpoKCkscy5wdXNoKFtlWzBdLGVbMV1dKTticmVhaztjYXNlXCJDXCI6aWYoIWkubGVuZ3RoKXtjb25zdCB0PXMubGVuZ3RoP3Nbcy5sZW5ndGgtMV06bztpLnB1c2goW3RbMF0sdFsxXV0pfWkucHVzaChbZVswXSxlWzFdXSksaS5wdXNoKFtlWzJdLGVbM11dKSxpLnB1c2goW2VbNF0sZVs1XV0pO2JyZWFrO2Nhc2VcIlpcIjpoKCkscy5wdXNoKFtvWzBdLG9bMV1dKX1pZih1KCksIW4pcmV0dXJuIGE7Y29uc3QgcD1bXTtmb3IoY29uc3QgdCBvZiBhKXtjb25zdCBlPWV0KHQsbik7ZS5sZW5ndGgmJnAucHVzaChlKX1yZXR1cm4gcH0odCwxLGk/NC00KihyLnNpbXBsaWZpY2F0aW9ufHwxKTooMStyLnJvdWdobmVzcykvMiksdT1XKHQscik7aWYocylpZihcInNvbGlkXCI9PT1yLmZpbGxTdHlsZSlpZigxPT09aC5sZW5ndGgpe3ZhciBwPVcodCxuKG4oe30scikse2Rpc2FibGVNdWx0aVN0cm9rZTohMCxyb3VnaG5lc3M6ci5yb3VnaG5lc3M/ci5yb3VnaG5lc3Mrci5maWxsU2hhcGVSb3VnaG5lc3NHYWluOjB9KSk7YS5wdXNoKHt0eXBlOlwiZmlsbFBhdGhcIixvcHM6dGhpcy5fbWVyZ2VkU2hhcGUocC5vcHMpfSl9ZWxzZSBhLnB1c2goRShoLHIpKTtlbHNlIGEucHVzaChHKGgscikpO3JldHVybiBvJiYoaT9oLmZvckVhY2goKGZ1bmN0aW9uKHQpe2EucHVzaChfKHQsITEscikpfSkpOmEucHVzaCh1KSksdGhpcy5fZChcInBhdGhcIixhLHIpfSx0LnByb3RvdHlwZS5vcHNUb1BhdGg9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49XCJcIixyPTAsYT10Lm9wcztyPGEubGVuZ3RoO3IrKyl7dmFyIHM9YVtyXSxvPVwibnVtYmVyXCI9PXR5cGVvZiBlJiZlPj0wP3MuZGF0YS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybit0LnRvRml4ZWQoZSl9KSk6cy5kYXRhO3N3aXRjaChzLm9wKXtjYXNlXCJtb3ZlXCI6bis9XCJNXCIuY29uY2F0KG9bMF0sXCIgXCIpLmNvbmNhdChvWzFdLFwiIFwiKTticmVhaztjYXNlXCJiY3VydmVUb1wiOm4rPVwiQ1wiLmNvbmNhdChvWzBdLFwiIFwiKS5jb25jYXQob1sxXSxcIiwgXCIpLmNvbmNhdChvWzJdLFwiIFwiKS5jb25jYXQob1szXSxcIiwgXCIpLmNvbmNhdChvWzRdLFwiIFwiKS5jb25jYXQob1s1XSxcIiBcIik7YnJlYWs7Y2FzZVwibGluZVRvXCI6bis9XCJMXCIuY29uY2F0KG9bMF0sXCIgXCIpLmNvbmNhdChvWzFdLFwiIFwiKX19cmV0dXJuIG4udHJpbSgpfSx0LnByb3RvdHlwZS50b1BhdGhzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LnNldHN8fFtdLG49dC5vcHRpb25zfHx0aGlzLmRlZmF1bHRPcHRpb25zLHI9W10sYT0wLHM9ZTthPHMubGVuZ3RoO2ErKyl7dmFyIG89c1thXSxpPW51bGw7c3dpdGNoKG8udHlwZSl7Y2FzZVwicGF0aFwiOmk9e2Q6dGhpcy5vcHNUb1BhdGgobyksc3Ryb2tlOm4uc3Ryb2tlLHN0cm9rZVdpZHRoOm4uc3Ryb2tlV2lkdGgsZmlsbDphdH07YnJlYWs7Y2FzZVwiZmlsbFBhdGhcIjppPXtkOnRoaXMub3BzVG9QYXRoKG8pLHN0cm9rZTphdCxzdHJva2VXaWR0aDowLGZpbGw6bi5maWxsfHxhdH07YnJlYWs7Y2FzZVwiZmlsbFNrZXRjaFwiOmk9dGhpcy5maWxsU2tldGNoKG8sbil9aSYmci5wdXNoKGkpfXJldHVybiByfSx0LnByb3RvdHlwZS5maWxsU2tldGNoPWZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5maWxsV2VpZ2h0O3JldHVybiBuPDAmJihuPWUuc3Ryb2tlV2lkdGgvMikse2Q6dGhpcy5vcHNUb1BhdGgodCksc3Ryb2tlOmUuZmlsbHx8YXQsc3Ryb2tlV2lkdGg6bixmaWxsOmF0fX0sdC5wcm90b3R5cGUuX21lcmdlZFNoYXBlPWZ1bmN0aW9uKHQpe3JldHVybiB0LmZpbHRlcigoZnVuY3Rpb24odCxlKXtyZXR1cm4gMD09PWV8fFwibW92ZVwiIT09dC5vcH0pKX0sdH0oKSxvdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXt0aGlzLmNhbnZhcz10LHRoaXMuY3R4PXRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKSx0aGlzLmdlbj1uZXcgc3QoZSl9cmV0dXJuIHQucHJvdG90eXBlLmRyYXc9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuc2V0c3x8W10sbj10Lm9wdGlvbnN8fHRoaXMuZ2V0RGVmYXVsdE9wdGlvbnMoKSxyPXRoaXMuY3R4LGE9dC5vcHRpb25zLmZpeGVkRGVjaW1hbFBsYWNlRGlnaXRzLHM9MCxvPWU7czxvLmxlbmd0aDtzKyspe3ZhciBpPW9bc107c3dpdGNoKGkudHlwZSl7Y2FzZVwicGF0aFwiOnIuc2F2ZSgpLHIuc3Ryb2tlU3R5bGU9XCJub25lXCI9PT1uLnN0cm9rZT9cInRyYW5zcGFyZW50XCI6bi5zdHJva2Usci5saW5lV2lkdGg9bi5zdHJva2VXaWR0aCxuLnN0cm9rZUxpbmVEYXNoJiZyLnNldExpbmVEYXNoKG4uc3Ryb2tlTGluZURhc2gpLG4uc3Ryb2tlTGluZURhc2hPZmZzZXQmJihyLmxpbmVEYXNoT2Zmc2V0PW4uc3Ryb2tlTGluZURhc2hPZmZzZXQpLHRoaXMuX2RyYXdUb0NvbnRleHQocixpLGEpLHIucmVzdG9yZSgpO2JyZWFrO2Nhc2VcImZpbGxQYXRoXCI6ci5zYXZlKCksci5maWxsU3R5bGU9bi5maWxsfHxcIlwiO3ZhciBoPVwiY3VydmVcIj09PXQuc2hhcGV8fFwicG9seWdvblwiPT09dC5zaGFwZXx8XCJwYXRoXCI9PT10LnNoYXBlP1wiZXZlbm9kZFwiOlwibm9uemVyb1wiO3RoaXMuX2RyYXdUb0NvbnRleHQocixpLGEsaCksci5yZXN0b3JlKCk7YnJlYWs7Y2FzZVwiZmlsbFNrZXRjaFwiOnRoaXMuZmlsbFNrZXRjaChyLGksbil9fX0sdC5wcm90b3R5cGUuZmlsbFNrZXRjaD1mdW5jdGlvbih0LGUsbil7dmFyIHI9bi5maWxsV2VpZ2h0O3I8MCYmKHI9bi5zdHJva2VXaWR0aC8yKSx0LnNhdmUoKSxuLmZpbGxMaW5lRGFzaCYmdC5zZXRMaW5lRGFzaChuLmZpbGxMaW5lRGFzaCksbi5maWxsTGluZURhc2hPZmZzZXQmJih0LmxpbmVEYXNoT2Zmc2V0PW4uZmlsbExpbmVEYXNoT2Zmc2V0KSx0LnN0cm9rZVN0eWxlPW4uZmlsbHx8XCJcIix0LmxpbmVXaWR0aD1yLHRoaXMuX2RyYXdUb0NvbnRleHQodCxlLG4uZml4ZWREZWNpbWFsUGxhY2VEaWdpdHMpLHQucmVzdG9yZSgpfSx0LnByb3RvdHlwZS5fZHJhd1RvQ29udGV4dD1mdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj1cIm5vbnplcm9cIiksdC5iZWdpblBhdGgoKTtmb3IodmFyIGE9MCxzPWUub3BzO2E8cy5sZW5ndGg7YSsrKXt2YXIgbz1zW2FdLGk9XCJudW1iZXJcIj09dHlwZW9mIG4mJm4+PTA/by5kYXRhLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuK3QudG9GaXhlZChuKX0pKTpvLmRhdGE7c3dpdGNoKG8ub3Ape2Nhc2VcIm1vdmVcIjp0Lm1vdmVUbyhpWzBdLGlbMV0pO2JyZWFrO2Nhc2VcImJjdXJ2ZVRvXCI6dC5iZXppZXJDdXJ2ZVRvKGlbMF0saVsxXSxpWzJdLGlbM10saVs0XSxpWzVdKTticmVhaztjYXNlXCJsaW5lVG9cIjp0LmxpbmVUbyhpWzBdLGlbMV0pfX1cImZpbGxQYXRoXCI9PT1lLnR5cGU/dC5maWxsKHIpOnQuc3Ryb2tlKCl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImdlbmVyYXRvclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZW59LGVudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuZ2V0RGVmYXVsdE9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZW4uZGVmYXVsdE9wdGlvbnN9LHQucHJvdG90eXBlLmxpbmU9ZnVuY3Rpb24odCxlLG4scixhKXt2YXIgcz10aGlzLmdlbi5saW5lKHQsZSxuLHIsYSk7cmV0dXJuIHRoaXMuZHJhdyhzKSxzfSx0LnByb3RvdHlwZS5yZWN0YW5nbGU9ZnVuY3Rpb24odCxlLG4scixhKXt2YXIgcz10aGlzLmdlbi5yZWN0YW5nbGUodCxlLG4scixhKTtyZXR1cm4gdGhpcy5kcmF3KHMpLHN9LHQucHJvdG90eXBlLmVsbGlwc2U9ZnVuY3Rpb24odCxlLG4scixhKXt2YXIgcz10aGlzLmdlbi5lbGxpcHNlKHQsZSxuLHIsYSk7cmV0dXJuIHRoaXMuZHJhdyhzKSxzfSx0LnByb3RvdHlwZS5jaXJjbGU9ZnVuY3Rpb24odCxlLG4scil7dmFyIGE9dGhpcy5nZW4uY2lyY2xlKHQsZSxuLHIpO3JldHVybiB0aGlzLmRyYXcoYSksYX0sdC5wcm90b3R5cGUubGluZWFyUGF0aD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2VuLmxpbmVhclBhdGgodCxlKTtyZXR1cm4gdGhpcy5kcmF3KG4pLG59LHQucHJvdG90eXBlLnBvbHlnb249ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdlbi5wb2x5Z29uKHQsZSk7cmV0dXJuIHRoaXMuZHJhdyhuKSxufSx0LnByb3RvdHlwZS5hcmM9ZnVuY3Rpb24odCxlLG4scixhLHMsbyxpKXt2b2lkIDA9PT1vJiYobz0hMSk7dmFyIGg9dGhpcy5nZW4uYXJjKHQsZSxuLHIsYSxzLG8saSk7cmV0dXJuIHRoaXMuZHJhdyhoKSxofSx0LnByb3RvdHlwZS5jdXJ2ZT1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2VuLmN1cnZlKHQsZSk7cmV0dXJuIHRoaXMuZHJhdyhuKSxufSx0LnByb3RvdHlwZS5wYXRoPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZW4ucGF0aCh0LGUpO3JldHVybiB0aGlzLmRyYXcobiksbn0sdH0oKSxpdD1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsaHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7dGhpcy5zdmc9dCx0aGlzLmdlbj1uZXcgc3QoZSl9cmV0dXJuIHQucHJvdG90eXBlLmRyYXc9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuc2V0c3x8W10sbj10Lm9wdGlvbnN8fHRoaXMuZ2V0RGVmYXVsdE9wdGlvbnMoKSxyPXRoaXMuc3ZnLm93bmVyRG9jdW1lbnR8fHdpbmRvdy5kb2N1bWVudCxhPXIuY3JlYXRlRWxlbWVudE5TKGl0LFwiZ1wiKSxzPXQub3B0aW9ucy5maXhlZERlY2ltYWxQbGFjZURpZ2l0cyxvPTAsaT1lO288aS5sZW5ndGg7bysrKXt2YXIgaD1pW29dLHU9bnVsbDtzd2l0Y2goaC50eXBlKXtjYXNlXCJwYXRoXCI6KHU9ci5jcmVhdGVFbGVtZW50TlMoaXQsXCJwYXRoXCIpKS5zZXRBdHRyaWJ1dGUoXCJkXCIsdGhpcy5vcHNUb1BhdGgoaCxzKSksdS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIixuLnN0cm9rZSksdS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIixuLnN0cm9rZVdpZHRoK1wiXCIpLHUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLFwibm9uZVwiKSxuLnN0cm9rZUxpbmVEYXNoJiZ1LnNldEF0dHJpYnV0ZShcInN0cm9rZS1kYXNoYXJyYXlcIixuLnN0cm9rZUxpbmVEYXNoLmpvaW4oXCIgXCIpLnRyaW0oKSksbi5zdHJva2VMaW5lRGFzaE9mZnNldCYmdS5zZXRBdHRyaWJ1dGUoXCJzdHJva2UtZGFzaG9mZnNldFwiLFwiXCIuY29uY2F0KG4uc3Ryb2tlTGluZURhc2hPZmZzZXQpKTticmVhaztjYXNlXCJmaWxsUGF0aFwiOih1PXIuY3JlYXRlRWxlbWVudE5TKGl0LFwicGF0aFwiKSkuc2V0QXR0cmlidXRlKFwiZFwiLHRoaXMub3BzVG9QYXRoKGgscykpLHUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsXCJub25lXCIpLHUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsXCIwXCIpLHUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLG4uZmlsbHx8XCJcIiksXCJjdXJ2ZVwiIT09dC5zaGFwZSYmXCJwb2x5Z29uXCIhPT10LnNoYXBlfHx1LnNldEF0dHJpYnV0ZShcImZpbGwtcnVsZVwiLFwiZXZlbm9kZFwiKTticmVhaztjYXNlXCJmaWxsU2tldGNoXCI6dT10aGlzLmZpbGxTa2V0Y2gocixoLG4pfXUmJmEuYXBwZW5kQ2hpbGQodSl9cmV0dXJuIGF9LHQucHJvdG90eXBlLmZpbGxTa2V0Y2g9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW4uZmlsbFdlaWdodDtyPDAmJihyPW4uc3Ryb2tlV2lkdGgvMik7dmFyIGE9dC5jcmVhdGVFbGVtZW50TlMoaXQsXCJwYXRoXCIpO3JldHVybiBhLnNldEF0dHJpYnV0ZShcImRcIix0aGlzLm9wc1RvUGF0aChlLG4uZml4ZWREZWNpbWFsUGxhY2VEaWdpdHMpKSxhLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLG4uZmlsbHx8XCJcIiksYS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIixyK1wiXCIpLGEuc2V0QXR0cmlidXRlKFwiZmlsbFwiLFwibm9uZVwiKSxuLmZpbGxMaW5lRGFzaCYmYS5zZXRBdHRyaWJ1dGUoXCJzdHJva2UtZGFzaGFycmF5XCIsbi5maWxsTGluZURhc2guam9pbihcIiBcIikudHJpbSgpKSxuLmZpbGxMaW5lRGFzaE9mZnNldCYmYS5zZXRBdHRyaWJ1dGUoXCJzdHJva2UtZGFzaG9mZnNldFwiLFwiXCIuY29uY2F0KG4uZmlsbExpbmVEYXNoT2Zmc2V0KSksYX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiZ2VuZXJhdG9yXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdlbn0sZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5nZXREZWZhdWx0T3B0aW9ucz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdlbi5kZWZhdWx0T3B0aW9uc30sdC5wcm90b3R5cGUub3BzVG9QYXRoPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZ2VuLm9wc1RvUGF0aCh0LGUpfSx0LnByb3RvdHlwZS5saW5lPWZ1bmN0aW9uKHQsZSxuLHIsYSl7dmFyIHM9dGhpcy5nZW4ubGluZSh0LGUsbixyLGEpO3JldHVybiB0aGlzLmRyYXcocyl9LHQucHJvdG90eXBlLnJlY3RhbmdsZT1mdW5jdGlvbih0LGUsbixyLGEpe3ZhciBzPXRoaXMuZ2VuLnJlY3RhbmdsZSh0LGUsbixyLGEpO3JldHVybiB0aGlzLmRyYXcocyl9LHQucHJvdG90eXBlLmVsbGlwc2U9ZnVuY3Rpb24odCxlLG4scixhKXt2YXIgcz10aGlzLmdlbi5lbGxpcHNlKHQsZSxuLHIsYSk7cmV0dXJuIHRoaXMuZHJhdyhzKX0sdC5wcm90b3R5cGUuY2lyY2xlPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBhPXRoaXMuZ2VuLmNpcmNsZSh0LGUsbixyKTtyZXR1cm4gdGhpcy5kcmF3KGEpfSx0LnByb3RvdHlwZS5saW5lYXJQYXRoPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZW4ubGluZWFyUGF0aCh0LGUpO3JldHVybiB0aGlzLmRyYXcobil9LHQucHJvdG90eXBlLnBvbHlnb249ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdlbi5wb2x5Z29uKHQsZSk7cmV0dXJuIHRoaXMuZHJhdyhuKX0sdC5wcm90b3R5cGUuYXJjPWZ1bmN0aW9uKHQsZSxuLHIsYSxzLG8saSl7dm9pZCAwPT09byYmKG89ITEpO3ZhciBoPXRoaXMuZ2VuLmFyYyh0LGUsbixyLGEscyxvLGkpO3JldHVybiB0aGlzLmRyYXcoaCl9LHQucHJvdG90eXBlLmN1cnZlPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZW4uY3VydmUodCxlKTtyZXR1cm4gdGhpcy5kcmF3KG4pfSx0LnByb3RvdHlwZS5wYXRoPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZW4ucGF0aCh0LGUpO3JldHVybiB0aGlzLmRyYXcobil9LHR9KCksdXQ9e2NhbnZhczpmdW5jdGlvbih0LGUpe3JldHVybiBuZXcgb3QodCxlKX0sc3ZnOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyBodCh0LGUpfSxnZW5lcmF0b3I6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBzdCh0KX0sbmV3U2VlZDpmdW5jdGlvbigpe3JldHVybiBzdC5uZXdTZWVkKCl9fTttb2R1bGUuZXhwb3J0cz11dDtcbiIsIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIEEgZmFzdCBqYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHNpbXBsZXggbm9pc2UgYnkgSm9uYXMgV2FnbmVyXG5cbkJhc2VkIG9uIGEgc3BlZWQtaW1wcm92ZWQgc2ltcGxleCBub2lzZSBhbGdvcml0aG0gZm9yIDJELCAzRCBhbmQgNEQgaW4gSmF2YS5cbldoaWNoIGlzIGJhc2VkIG9uIGV4YW1wbGUgY29kZSBieSBTdGVmYW4gR3VzdGF2c29uIChzdGVndUBpdG4ubGl1LnNlKS5cbldpdGggT3B0aW1pc2F0aW9ucyBieSBQZXRlciBFYXN0bWFuIChwZWFzdG1hbkBkcml6emxlLnN0YW5mb3JkLmVkdSkuXG5CZXR0ZXIgcmFuayBvcmRlcmluZyBtZXRob2QgYnkgU3RlZmFuIEd1c3RhdnNvbiBpbiAyMDEyLlxuXG4gQ29weXJpZ2h0IChjKSAyMDIyIEpvbmFzIFdhZ25lclxuXG4gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gU09GVFdBUkUuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYnVpbGRQZXJtdXRhdGlvblRhYmxlID0gZXhwb3J0cy5jcmVhdGVOb2lzZTREID0gZXhwb3J0cy5jcmVhdGVOb2lzZTNEID0gZXhwb3J0cy5jcmVhdGVOb2lzZTJEID0gdm9pZCAwO1xuLy8gdGhlc2UgI19fUFVSRV9fIGNvbW1lbnRzIGhlbHAgdWdsaWZ5anMgd2l0aCBkZWFkIGNvZGUgcmVtb3ZhbFxuLy8gXG5jb25zdCBGMiA9IC8qI19fUFVSRV9fKi8gMC41ICogKE1hdGguc3FydCgzLjApIC0gMS4wKTtcbmNvbnN0IEcyID0gLyojX19QVVJFX18qLyAoMy4wIC0gTWF0aC5zcXJ0KDMuMCkpIC8gNi4wO1xuY29uc3QgRjMgPSAxLjAgLyAzLjA7XG5jb25zdCBHMyA9IDEuMCAvIDYuMDtcbmNvbnN0IEY0ID0gLyojX19QVVJFX18qLyAoTWF0aC5zcXJ0KDUuMCkgLSAxLjApIC8gNC4wO1xuY29uc3QgRzQgPSAvKiNfX1BVUkVfXyovICg1LjAgLSBNYXRoLnNxcnQoNS4wKSkgLyAyMC4wO1xuLy8gSSdtIHJlYWxseSBub3Qgc3VyZSB3aHkgdGhpcyB8IDAgKGJhc2ljYWxseSBhIGNvZXJjaW9uIHRvIGludClcbi8vIGlzIG1ha2luZyB0aGlzIGZhc3RlciBidXQgSSBnZXQgfjUgbWlsbGlvbiBvcHMvc2VjIG1vcmUgb24gdGhlXG4vLyBiZW5jaG1hcmtzIGFjcm9zcyB0aGUgYm9hcmQgb3IgYSB+MTAlIHNwZWVkdXAuXG5jb25zdCBmYXN0Rmxvb3IgPSAoeCkgPT4gTWF0aC5mbG9vcih4KSB8IDA7XG5jb25zdCBncmFkMiA9IC8qI19fUFVSRV9fKi8gbmV3IEZsb2F0NjRBcnJheShbMSwgMSxcbiAgICAtMSwgMSxcbiAgICAxLCAtMSxcbiAgICAtMSwgLTEsXG4gICAgMSwgMCxcbiAgICAtMSwgMCxcbiAgICAxLCAwLFxuICAgIC0xLCAwLFxuICAgIDAsIDEsXG4gICAgMCwgLTEsXG4gICAgMCwgMSxcbiAgICAwLCAtMV0pO1xuLy8gZG91YmxlIHNlZW1zIHRvIGJlIGZhc3RlciB0aGFuIHNpbmdsZSBvciBpbnQnc1xuLy8gcHJvYmFibHkgYmVjYXVzZSBtb3N0IG9wZXJhdGlvbnMgYXJlIGluIGRvdWJsZSBwcmVjaXNpb25cbmNvbnN0IGdyYWQzID0gLyojX19QVVJFX18qLyBuZXcgRmxvYXQ2NEFycmF5KFsxLCAxLCAwLFxuICAgIC0xLCAxLCAwLFxuICAgIDEsIC0xLCAwLFxuICAgIC0xLCAtMSwgMCxcbiAgICAxLCAwLCAxLFxuICAgIC0xLCAwLCAxLFxuICAgIDEsIDAsIC0xLFxuICAgIC0xLCAwLCAtMSxcbiAgICAwLCAxLCAxLFxuICAgIDAsIC0xLCAxLFxuICAgIDAsIDEsIC0xLFxuICAgIDAsIC0xLCAtMV0pO1xuLy8gZG91YmxlIGlzIGEgYml0IHF1aWNrZXIgaGVyZSBhcyB3ZWxsXG5jb25zdCBncmFkNCA9IC8qI19fUFVSRV9fKi8gbmV3IEZsb2F0NjRBcnJheShbMCwgMSwgMSwgMSwgMCwgMSwgMSwgLTEsIDAsIDEsIC0xLCAxLCAwLCAxLCAtMSwgLTEsXG4gICAgMCwgLTEsIDEsIDEsIDAsIC0xLCAxLCAtMSwgMCwgLTEsIC0xLCAxLCAwLCAtMSwgLTEsIC0xLFxuICAgIDEsIDAsIDEsIDEsIDEsIDAsIDEsIC0xLCAxLCAwLCAtMSwgMSwgMSwgMCwgLTEsIC0xLFxuICAgIC0xLCAwLCAxLCAxLCAtMSwgMCwgMSwgLTEsIC0xLCAwLCAtMSwgMSwgLTEsIDAsIC0xLCAtMSxcbiAgICAxLCAxLCAwLCAxLCAxLCAxLCAwLCAtMSwgMSwgLTEsIDAsIDEsIDEsIC0xLCAwLCAtMSxcbiAgICAtMSwgMSwgMCwgMSwgLTEsIDEsIDAsIC0xLCAtMSwgLTEsIDAsIDEsIC0xLCAtMSwgMCwgLTEsXG4gICAgMSwgMSwgMSwgMCwgMSwgMSwgLTEsIDAsIDEsIC0xLCAxLCAwLCAxLCAtMSwgLTEsIDAsXG4gICAgLTEsIDEsIDEsIDAsIC0xLCAxLCAtMSwgMCwgLTEsIC0xLCAxLCAwLCAtMSwgLTEsIC0xLCAwXSk7XG4vKipcbiAqIENyZWF0ZXMgYSAyRCBub2lzZSBmdW5jdGlvblxuICogQHBhcmFtIHJhbmRvbSB0aGUgcmFuZG9tIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGJ1aWxkIHRoZSBwZXJtdXRhdGlvbiB0YWJsZVxuICogQHJldHVybnMge05vaXNlRnVuY3Rpb24yRH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTm9pc2UyRChyYW5kb20gPSBNYXRoLnJhbmRvbSkge1xuICAgIGNvbnN0IHBlcm0gPSBidWlsZFBlcm11dGF0aW9uVGFibGUocmFuZG9tKTtcbiAgICAvLyBwcmVjYWxjdWxhdGluZyB0aGlzIHlpZWxkcyBhIGxpdHRsZSB+MyUgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnQuXG4gICAgY29uc3QgcGVybUdyYWQyeCA9IG5ldyBGbG9hdDY0QXJyYXkocGVybSkubWFwKHYgPT4gZ3JhZDJbKHYgJSAxMikgKiAyXSk7XG4gICAgY29uc3QgcGVybUdyYWQyeSA9IG5ldyBGbG9hdDY0QXJyYXkocGVybSkubWFwKHYgPT4gZ3JhZDJbKHYgJSAxMikgKiAyICsgMV0pO1xuICAgIHJldHVybiBmdW5jdGlvbiBub2lzZTJEKHgsIHkpIHtcbiAgICAgICAgLy8gaWYoIWlzRmluaXRlKHgpIHx8ICFpc0Zpbml0ZSh5KSkgcmV0dXJuIDA7XG4gICAgICAgIGxldCBuMCA9IDA7IC8vIE5vaXNlIGNvbnRyaWJ1dGlvbnMgZnJvbSB0aGUgdGhyZWUgY29ybmVyc1xuICAgICAgICBsZXQgbjEgPSAwO1xuICAgICAgICBsZXQgbjIgPSAwO1xuICAgICAgICAvLyBTa2V3IHRoZSBpbnB1dCBzcGFjZSB0byBkZXRlcm1pbmUgd2hpY2ggc2ltcGxleCBjZWxsIHdlJ3JlIGluXG4gICAgICAgIGNvbnN0IHMgPSAoeCArIHkpICogRjI7IC8vIEhhaXJ5IGZhY3RvciBmb3IgMkRcbiAgICAgICAgY29uc3QgaSA9IGZhc3RGbG9vcih4ICsgcyk7XG4gICAgICAgIGNvbnN0IGogPSBmYXN0Rmxvb3IoeSArIHMpO1xuICAgICAgICBjb25zdCB0ID0gKGkgKyBqKSAqIEcyO1xuICAgICAgICBjb25zdCBYMCA9IGkgLSB0OyAvLyBVbnNrZXcgdGhlIGNlbGwgb3JpZ2luIGJhY2sgdG8gKHgseSkgc3BhY2VcbiAgICAgICAgY29uc3QgWTAgPSBqIC0gdDtcbiAgICAgICAgY29uc3QgeDAgPSB4IC0gWDA7IC8vIFRoZSB4LHkgZGlzdGFuY2VzIGZyb20gdGhlIGNlbGwgb3JpZ2luXG4gICAgICAgIGNvbnN0IHkwID0geSAtIFkwO1xuICAgICAgICAvLyBGb3IgdGhlIDJEIGNhc2UsIHRoZSBzaW1wbGV4IHNoYXBlIGlzIGFuIGVxdWlsYXRlcmFsIHRyaWFuZ2xlLlxuICAgICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggc2ltcGxleCB3ZSBhcmUgaW4uXG4gICAgICAgIGxldCBpMSwgajE7IC8vIE9mZnNldHMgZm9yIHNlY29uZCAobWlkZGxlKSBjb3JuZXIgb2Ygc2ltcGxleCBpbiAoaSxqKSBjb29yZHNcbiAgICAgICAgaWYgKHgwID4geTApIHtcbiAgICAgICAgICAgIGkxID0gMTtcbiAgICAgICAgICAgIGoxID0gMDtcbiAgICAgICAgfSAvLyBsb3dlciB0cmlhbmdsZSwgWFkgb3JkZXI6ICgwLDApLT4oMSwwKS0+KDEsMSlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpMSA9IDA7XG4gICAgICAgICAgICBqMSA9IDE7XG4gICAgICAgIH0gLy8gdXBwZXIgdHJpYW5nbGUsIFlYIG9yZGVyOiAoMCwwKS0+KDAsMSktPigxLDEpXG4gICAgICAgIC8vIEEgc3RlcCBvZiAoMSwwKSBpbiAoaSxqKSBtZWFucyBhIHN0ZXAgb2YgKDEtYywtYykgaW4gKHgseSksIGFuZFxuICAgICAgICAvLyBhIHN0ZXAgb2YgKDAsMSkgaW4gKGksaikgbWVhbnMgYSBzdGVwIG9mICgtYywxLWMpIGluICh4LHkpLCB3aGVyZVxuICAgICAgICAvLyBjID0gKDMtc3FydCgzKSkvNlxuICAgICAgICBjb25zdCB4MSA9IHgwIC0gaTEgKyBHMjsgLy8gT2Zmc2V0cyBmb3IgbWlkZGxlIGNvcm5lciBpbiAoeCx5KSB1bnNrZXdlZCBjb29yZHNcbiAgICAgICAgY29uc3QgeTEgPSB5MCAtIGoxICsgRzI7XG4gICAgICAgIGNvbnN0IHgyID0geDAgLSAxLjAgKyAyLjAgKiBHMjsgLy8gT2Zmc2V0cyBmb3IgbGFzdCBjb3JuZXIgaW4gKHgseSkgdW5za2V3ZWQgY29vcmRzXG4gICAgICAgIGNvbnN0IHkyID0geTAgLSAxLjAgKyAyLjAgKiBHMjtcbiAgICAgICAgLy8gV29yayBvdXQgdGhlIGhhc2hlZCBncmFkaWVudCBpbmRpY2VzIG9mIHRoZSB0aHJlZSBzaW1wbGV4IGNvcm5lcnNcbiAgICAgICAgY29uc3QgaWkgPSBpICYgMjU1O1xuICAgICAgICBjb25zdCBqaiA9IGogJiAyNTU7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgY29udHJpYnV0aW9uIGZyb20gdGhlIHRocmVlIGNvcm5lcnNcbiAgICAgICAgbGV0IHQwID0gMC41IC0geDAgKiB4MCAtIHkwICogeTA7XG4gICAgICAgIGlmICh0MCA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBnaTAgPSBpaSArIHBlcm1bampdO1xuICAgICAgICAgICAgY29uc3QgZzB4ID0gcGVybUdyYWQyeFtnaTBdO1xuICAgICAgICAgICAgY29uc3QgZzB5ID0gcGVybUdyYWQyeVtnaTBdO1xuICAgICAgICAgICAgdDAgKj0gdDA7XG4gICAgICAgICAgICAvLyBuMCA9IHQwICogdDAgKiAoZ3JhZDJbZ2kwXSAqIHgwICsgZ3JhZDJbZ2kwICsgMV0gKiB5MCk7IC8vICh4LHkpIG9mIGdyYWQzIHVzZWQgZm9yIDJEIGdyYWRpZW50XG4gICAgICAgICAgICBuMCA9IHQwICogdDAgKiAoZzB4ICogeDAgKyBnMHkgKiB5MCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHQxID0gMC41IC0geDEgKiB4MSAtIHkxICogeTE7XG4gICAgICAgIGlmICh0MSA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBnaTEgPSBpaSArIGkxICsgcGVybVtqaiArIGoxXTtcbiAgICAgICAgICAgIGNvbnN0IGcxeCA9IHBlcm1HcmFkMnhbZ2kxXTtcbiAgICAgICAgICAgIGNvbnN0IGcxeSA9IHBlcm1HcmFkMnlbZ2kxXTtcbiAgICAgICAgICAgIHQxICo9IHQxO1xuICAgICAgICAgICAgLy8gbjEgPSB0MSAqIHQxICogKGdyYWQyW2dpMV0gKiB4MSArIGdyYWQyW2dpMSArIDFdICogeTEpO1xuICAgICAgICAgICAgbjEgPSB0MSAqIHQxICogKGcxeCAqIHgxICsgZzF5ICogeTEpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0MiA9IDAuNSAtIHgyICogeDIgLSB5MiAqIHkyO1xuICAgICAgICBpZiAodDIgPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgZ2kyID0gaWkgKyAxICsgcGVybVtqaiArIDFdO1xuICAgICAgICAgICAgY29uc3QgZzJ4ID0gcGVybUdyYWQyeFtnaTJdO1xuICAgICAgICAgICAgY29uc3QgZzJ5ID0gcGVybUdyYWQyeVtnaTJdO1xuICAgICAgICAgICAgdDIgKj0gdDI7XG4gICAgICAgICAgICAvLyBuMiA9IHQyICogdDIgKiAoZ3JhZDJbZ2kyXSAqIHgyICsgZ3JhZDJbZ2kyICsgMV0gKiB5Mik7XG4gICAgICAgICAgICBuMiA9IHQyICogdDIgKiAoZzJ4ICogeDIgKyBnMnkgKiB5Mik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGNvbnRyaWJ1dGlvbnMgZnJvbSBlYWNoIGNvcm5lciB0byBnZXQgdGhlIGZpbmFsIG5vaXNlIHZhbHVlLlxuICAgICAgICAvLyBUaGUgcmVzdWx0IGlzIHNjYWxlZCB0byByZXR1cm4gdmFsdWVzIGluIHRoZSBpbnRlcnZhbCBbLTEsMV0uXG4gICAgICAgIHJldHVybiA3MC4wICogKG4wICsgbjEgKyBuMik7XG4gICAgfTtcbn1cbmV4cG9ydHMuY3JlYXRlTm9pc2UyRCA9IGNyZWF0ZU5vaXNlMkQ7XG4vKipcbiAqIENyZWF0ZXMgYSAzRCBub2lzZSBmdW5jdGlvblxuICogQHBhcmFtIHJhbmRvbSB0aGUgcmFuZG9tIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGJ1aWxkIHRoZSBwZXJtdXRhdGlvbiB0YWJsZVxuICogQHJldHVybnMge05vaXNlRnVuY3Rpb24zRH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTm9pc2UzRChyYW5kb20gPSBNYXRoLnJhbmRvbSkge1xuICAgIGNvbnN0IHBlcm0gPSBidWlsZFBlcm11dGF0aW9uVGFibGUocmFuZG9tKTtcbiAgICAvLyBwcmVjYWxjdWxhdGluZyB0aGVzZSBzZWVtcyB0byB5aWVsZCBhIHNwZWVkdXAgb2Ygb3ZlciAxNSVcbiAgICBjb25zdCBwZXJtR3JhZDN4ID0gbmV3IEZsb2F0NjRBcnJheShwZXJtKS5tYXAodiA9PiBncmFkM1sodiAlIDEyKSAqIDNdKTtcbiAgICBjb25zdCBwZXJtR3JhZDN5ID0gbmV3IEZsb2F0NjRBcnJheShwZXJtKS5tYXAodiA9PiBncmFkM1sodiAlIDEyKSAqIDMgKyAxXSk7XG4gICAgY29uc3QgcGVybUdyYWQzeiA9IG5ldyBGbG9hdDY0QXJyYXkocGVybSkubWFwKHYgPT4gZ3JhZDNbKHYgJSAxMikgKiAzICsgMl0pO1xuICAgIHJldHVybiBmdW5jdGlvbiBub2lzZTNEKHgsIHksIHopIHtcbiAgICAgICAgbGV0IG4wLCBuMSwgbjIsIG4zOyAvLyBOb2lzZSBjb250cmlidXRpb25zIGZyb20gdGhlIGZvdXIgY29ybmVyc1xuICAgICAgICAvLyBTa2V3IHRoZSBpbnB1dCBzcGFjZSB0byBkZXRlcm1pbmUgd2hpY2ggc2ltcGxleCBjZWxsIHdlJ3JlIGluXG4gICAgICAgIGNvbnN0IHMgPSAoeCArIHkgKyB6KSAqIEYzOyAvLyBWZXJ5IG5pY2UgYW5kIHNpbXBsZSBza2V3IGZhY3RvciBmb3IgM0RcbiAgICAgICAgY29uc3QgaSA9IGZhc3RGbG9vcih4ICsgcyk7XG4gICAgICAgIGNvbnN0IGogPSBmYXN0Rmxvb3IoeSArIHMpO1xuICAgICAgICBjb25zdCBrID0gZmFzdEZsb29yKHogKyBzKTtcbiAgICAgICAgY29uc3QgdCA9IChpICsgaiArIGspICogRzM7XG4gICAgICAgIGNvbnN0IFgwID0gaSAtIHQ7IC8vIFVuc2tldyB0aGUgY2VsbCBvcmlnaW4gYmFjayB0byAoeCx5LHopIHNwYWNlXG4gICAgICAgIGNvbnN0IFkwID0gaiAtIHQ7XG4gICAgICAgIGNvbnN0IFowID0gayAtIHQ7XG4gICAgICAgIGNvbnN0IHgwID0geCAtIFgwOyAvLyBUaGUgeCx5LHogZGlzdGFuY2VzIGZyb20gdGhlIGNlbGwgb3JpZ2luXG4gICAgICAgIGNvbnN0IHkwID0geSAtIFkwO1xuICAgICAgICBjb25zdCB6MCA9IHogLSBaMDtcbiAgICAgICAgLy8gRm9yIHRoZSAzRCBjYXNlLCB0aGUgc2ltcGxleCBzaGFwZSBpcyBhIHNsaWdodGx5IGlycmVndWxhciB0ZXRyYWhlZHJvbi5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIHNpbXBsZXggd2UgYXJlIGluLlxuICAgICAgICBsZXQgaTEsIGoxLCBrMTsgLy8gT2Zmc2V0cyBmb3Igc2Vjb25kIGNvcm5lciBvZiBzaW1wbGV4IGluIChpLGosaykgY29vcmRzXG4gICAgICAgIGxldCBpMiwgajIsIGsyOyAvLyBPZmZzZXRzIGZvciB0aGlyZCBjb3JuZXIgb2Ygc2ltcGxleCBpbiAoaSxqLGspIGNvb3Jkc1xuICAgICAgICBpZiAoeDAgPj0geTApIHtcbiAgICAgICAgICAgIGlmICh5MCA+PSB6MCkge1xuICAgICAgICAgICAgICAgIGkxID0gMTtcbiAgICAgICAgICAgICAgICBqMSA9IDA7XG4gICAgICAgICAgICAgICAgazEgPSAwO1xuICAgICAgICAgICAgICAgIGkyID0gMTtcbiAgICAgICAgICAgICAgICBqMiA9IDE7XG4gICAgICAgICAgICAgICAgazIgPSAwO1xuICAgICAgICAgICAgfSAvLyBYIFkgWiBvcmRlclxuICAgICAgICAgICAgZWxzZSBpZiAoeDAgPj0gejApIHtcbiAgICAgICAgICAgICAgICBpMSA9IDE7XG4gICAgICAgICAgICAgICAgajEgPSAwO1xuICAgICAgICAgICAgICAgIGsxID0gMDtcbiAgICAgICAgICAgICAgICBpMiA9IDE7XG4gICAgICAgICAgICAgICAgajIgPSAwO1xuICAgICAgICAgICAgICAgIGsyID0gMTtcbiAgICAgICAgICAgIH0gLy8gWCBaIFkgb3JkZXJcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGkxID0gMDtcbiAgICAgICAgICAgICAgICBqMSA9IDA7XG4gICAgICAgICAgICAgICAgazEgPSAxO1xuICAgICAgICAgICAgICAgIGkyID0gMTtcbiAgICAgICAgICAgICAgICBqMiA9IDA7XG4gICAgICAgICAgICAgICAgazIgPSAxO1xuICAgICAgICAgICAgfSAvLyBaIFggWSBvcmRlclxuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyB4MDx5MFxuICAgICAgICAgICAgaWYgKHkwIDwgejApIHtcbiAgICAgICAgICAgICAgICBpMSA9IDA7XG4gICAgICAgICAgICAgICAgajEgPSAwO1xuICAgICAgICAgICAgICAgIGsxID0gMTtcbiAgICAgICAgICAgICAgICBpMiA9IDA7XG4gICAgICAgICAgICAgICAgajIgPSAxO1xuICAgICAgICAgICAgICAgIGsyID0gMTtcbiAgICAgICAgICAgIH0gLy8gWiBZIFggb3JkZXJcbiAgICAgICAgICAgIGVsc2UgaWYgKHgwIDwgejApIHtcbiAgICAgICAgICAgICAgICBpMSA9IDA7XG4gICAgICAgICAgICAgICAgajEgPSAxO1xuICAgICAgICAgICAgICAgIGsxID0gMDtcbiAgICAgICAgICAgICAgICBpMiA9IDA7XG4gICAgICAgICAgICAgICAgajIgPSAxO1xuICAgICAgICAgICAgICAgIGsyID0gMTtcbiAgICAgICAgICAgIH0gLy8gWSBaIFggb3JkZXJcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGkxID0gMDtcbiAgICAgICAgICAgICAgICBqMSA9IDE7XG4gICAgICAgICAgICAgICAgazEgPSAwO1xuICAgICAgICAgICAgICAgIGkyID0gMTtcbiAgICAgICAgICAgICAgICBqMiA9IDE7XG4gICAgICAgICAgICAgICAgazIgPSAwO1xuICAgICAgICAgICAgfSAvLyBZIFggWiBvcmRlclxuICAgICAgICB9XG4gICAgICAgIC8vIEEgc3RlcCBvZiAoMSwwLDApIGluIChpLGosaykgbWVhbnMgYSBzdGVwIG9mICgxLWMsLWMsLWMpIGluICh4LHkseiksXG4gICAgICAgIC8vIGEgc3RlcCBvZiAoMCwxLDApIGluIChpLGosaykgbWVhbnMgYSBzdGVwIG9mICgtYywxLWMsLWMpIGluICh4LHkseiksIGFuZFxuICAgICAgICAvLyBhIHN0ZXAgb2YgKDAsMCwxKSBpbiAoaSxqLGspIG1lYW5zIGEgc3RlcCBvZiAoLWMsLWMsMS1jKSBpbiAoeCx5LHopLCB3aGVyZVxuICAgICAgICAvLyBjID0gMS82LlxuICAgICAgICBjb25zdCB4MSA9IHgwIC0gaTEgKyBHMzsgLy8gT2Zmc2V0cyBmb3Igc2Vjb25kIGNvcm5lciBpbiAoeCx5LHopIGNvb3Jkc1xuICAgICAgICBjb25zdCB5MSA9IHkwIC0gajEgKyBHMztcbiAgICAgICAgY29uc3QgejEgPSB6MCAtIGsxICsgRzM7XG4gICAgICAgIGNvbnN0IHgyID0geDAgLSBpMiArIDIuMCAqIEczOyAvLyBPZmZzZXRzIGZvciB0aGlyZCBjb3JuZXIgaW4gKHgseSx6KSBjb29yZHNcbiAgICAgICAgY29uc3QgeTIgPSB5MCAtIGoyICsgMi4wICogRzM7XG4gICAgICAgIGNvbnN0IHoyID0gejAgLSBrMiArIDIuMCAqIEczO1xuICAgICAgICBjb25zdCB4MyA9IHgwIC0gMS4wICsgMy4wICogRzM7IC8vIE9mZnNldHMgZm9yIGxhc3QgY29ybmVyIGluICh4LHkseikgY29vcmRzXG4gICAgICAgIGNvbnN0IHkzID0geTAgLSAxLjAgKyAzLjAgKiBHMztcbiAgICAgICAgY29uc3QgejMgPSB6MCAtIDEuMCArIDMuMCAqIEczO1xuICAgICAgICAvLyBXb3JrIG91dCB0aGUgaGFzaGVkIGdyYWRpZW50IGluZGljZXMgb2YgdGhlIGZvdXIgc2ltcGxleCBjb3JuZXJzXG4gICAgICAgIGNvbnN0IGlpID0gaSAmIDI1NTtcbiAgICAgICAgY29uc3QgamogPSBqICYgMjU1O1xuICAgICAgICBjb25zdCBrayA9IGsgJiAyNTU7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgY29udHJpYnV0aW9uIGZyb20gdGhlIGZvdXIgY29ybmVyc1xuICAgICAgICBsZXQgdDAgPSAwLjYgLSB4MCAqIHgwIC0geTAgKiB5MCAtIHowICogejA7XG4gICAgICAgIGlmICh0MCA8IDApXG4gICAgICAgICAgICBuMCA9IDAuMDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBnaTAgPSBpaSArIHBlcm1bamogKyBwZXJtW2trXV07XG4gICAgICAgICAgICB0MCAqPSB0MDtcbiAgICAgICAgICAgIG4wID0gdDAgKiB0MCAqIChwZXJtR3JhZDN4W2dpMF0gKiB4MCArIHBlcm1HcmFkM3lbZ2kwXSAqIHkwICsgcGVybUdyYWQzeltnaTBdICogejApO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0MSA9IDAuNiAtIHgxICogeDEgLSB5MSAqIHkxIC0gejEgKiB6MTtcbiAgICAgICAgaWYgKHQxIDwgMClcbiAgICAgICAgICAgIG4xID0gMC4wO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGdpMSA9IGlpICsgaTEgKyBwZXJtW2pqICsgajEgKyBwZXJtW2trICsgazFdXTtcbiAgICAgICAgICAgIHQxICo9IHQxO1xuICAgICAgICAgICAgbjEgPSB0MSAqIHQxICogKHBlcm1HcmFkM3hbZ2kxXSAqIHgxICsgcGVybUdyYWQzeVtnaTFdICogeTEgKyBwZXJtR3JhZDN6W2dpMV0gKiB6MSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHQyID0gMC42IC0geDIgKiB4MiAtIHkyICogeTIgLSB6MiAqIHoyO1xuICAgICAgICBpZiAodDIgPCAwKVxuICAgICAgICAgICAgbjIgPSAwLjA7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZ2kyID0gaWkgKyBpMiArIHBlcm1bamogKyBqMiArIHBlcm1ba2sgKyBrMl1dO1xuICAgICAgICAgICAgdDIgKj0gdDI7XG4gICAgICAgICAgICBuMiA9IHQyICogdDIgKiAocGVybUdyYWQzeFtnaTJdICogeDIgKyBwZXJtR3JhZDN5W2dpMl0gKiB5MiArIHBlcm1HcmFkM3pbZ2kyXSAqIHoyKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdDMgPSAwLjYgLSB4MyAqIHgzIC0geTMgKiB5MyAtIHozICogejM7XG4gICAgICAgIGlmICh0MyA8IDApXG4gICAgICAgICAgICBuMyA9IDAuMDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBnaTMgPSBpaSArIDEgKyBwZXJtW2pqICsgMSArIHBlcm1ba2sgKyAxXV07XG4gICAgICAgICAgICB0MyAqPSB0MztcbiAgICAgICAgICAgIG4zID0gdDMgKiB0MyAqIChwZXJtR3JhZDN4W2dpM10gKiB4MyArIHBlcm1HcmFkM3lbZ2kzXSAqIHkzICsgcGVybUdyYWQzeltnaTNdICogejMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBjb250cmlidXRpb25zIGZyb20gZWFjaCBjb3JuZXIgdG8gZ2V0IHRoZSBmaW5hbCBub2lzZSB2YWx1ZS5cbiAgICAgICAgLy8gVGhlIHJlc3VsdCBpcyBzY2FsZWQgdG8gc3RheSBqdXN0IGluc2lkZSBbLTEsMV1cbiAgICAgICAgcmV0dXJuIDMyLjAgKiAobjAgKyBuMSArIG4yICsgbjMpO1xuICAgIH07XG59XG5leHBvcnRzLmNyZWF0ZU5vaXNlM0QgPSBjcmVhdGVOb2lzZTNEO1xuLyoqXG4gKiBDcmVhdGVzIGEgNEQgbm9pc2UgZnVuY3Rpb25cbiAqIEBwYXJhbSByYW5kb20gdGhlIHJhbmRvbSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgdXNlZCB0byBidWlsZCB0aGUgcGVybXV0YXRpb24gdGFibGVcbiAqIEByZXR1cm5zIHtOb2lzZUZ1bmN0aW9uNER9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5vaXNlNEQocmFuZG9tID0gTWF0aC5yYW5kb20pIHtcbiAgICBjb25zdCBwZXJtID0gYnVpbGRQZXJtdXRhdGlvblRhYmxlKHJhbmRvbSk7XG4gICAgLy8gcHJlY2FsY3VsYXRpbmcgdGhlc2UgbGVhZHMgdG8gYSB+MTAlIHNwZWVkdXBcbiAgICBjb25zdCBwZXJtR3JhZDR4ID0gbmV3IEZsb2F0NjRBcnJheShwZXJtKS5tYXAodiA9PiBncmFkNFsodiAlIDMyKSAqIDRdKTtcbiAgICBjb25zdCBwZXJtR3JhZDR5ID0gbmV3IEZsb2F0NjRBcnJheShwZXJtKS5tYXAodiA9PiBncmFkNFsodiAlIDMyKSAqIDQgKyAxXSk7XG4gICAgY29uc3QgcGVybUdyYWQ0eiA9IG5ldyBGbG9hdDY0QXJyYXkocGVybSkubWFwKHYgPT4gZ3JhZDRbKHYgJSAzMikgKiA0ICsgMl0pO1xuICAgIGNvbnN0IHBlcm1HcmFkNHcgPSBuZXcgRmxvYXQ2NEFycmF5KHBlcm0pLm1hcCh2ID0+IGdyYWQ0Wyh2ICUgMzIpICogNCArIDNdKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gbm9pc2U0RCh4LCB5LCB6LCB3KSB7XG4gICAgICAgIGxldCBuMCwgbjEsIG4yLCBuMywgbjQ7IC8vIE5vaXNlIGNvbnRyaWJ1dGlvbnMgZnJvbSB0aGUgZml2ZSBjb3JuZXJzXG4gICAgICAgIC8vIFNrZXcgdGhlICh4LHkseix3KSBzcGFjZSB0byBkZXRlcm1pbmUgd2hpY2ggY2VsbCBvZiAyNCBzaW1wbGljZXMgd2UncmUgaW5cbiAgICAgICAgY29uc3QgcyA9ICh4ICsgeSArIHogKyB3KSAqIEY0OyAvLyBGYWN0b3IgZm9yIDREIHNrZXdpbmdcbiAgICAgICAgY29uc3QgaSA9IGZhc3RGbG9vcih4ICsgcyk7XG4gICAgICAgIGNvbnN0IGogPSBmYXN0Rmxvb3IoeSArIHMpO1xuICAgICAgICBjb25zdCBrID0gZmFzdEZsb29yKHogKyBzKTtcbiAgICAgICAgY29uc3QgbCA9IGZhc3RGbG9vcih3ICsgcyk7XG4gICAgICAgIGNvbnN0IHQgPSAoaSArIGogKyBrICsgbCkgKiBHNDsgLy8gRmFjdG9yIGZvciA0RCB1bnNrZXdpbmdcbiAgICAgICAgY29uc3QgWDAgPSBpIC0gdDsgLy8gVW5za2V3IHRoZSBjZWxsIG9yaWdpbiBiYWNrIHRvICh4LHkseix3KSBzcGFjZVxuICAgICAgICBjb25zdCBZMCA9IGogLSB0O1xuICAgICAgICBjb25zdCBaMCA9IGsgLSB0O1xuICAgICAgICBjb25zdCBXMCA9IGwgLSB0O1xuICAgICAgICBjb25zdCB4MCA9IHggLSBYMDsgLy8gVGhlIHgseSx6LHcgZGlzdGFuY2VzIGZyb20gdGhlIGNlbGwgb3JpZ2luXG4gICAgICAgIGNvbnN0IHkwID0geSAtIFkwO1xuICAgICAgICBjb25zdCB6MCA9IHogLSBaMDtcbiAgICAgICAgY29uc3QgdzAgPSB3IC0gVzA7XG4gICAgICAgIC8vIEZvciB0aGUgNEQgY2FzZSwgdGhlIHNpbXBsZXggaXMgYSA0RCBzaGFwZSBJIHdvbid0IGV2ZW4gdHJ5IHRvIGRlc2NyaWJlLlxuICAgICAgICAvLyBUbyBmaW5kIG91dCB3aGljaCBvZiB0aGUgMjQgcG9zc2libGUgc2ltcGxpY2VzIHdlJ3JlIGluLCB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIGRldGVybWluZSB0aGUgbWFnbml0dWRlIG9yZGVyaW5nIG9mIHgwLCB5MCwgejAgYW5kIHcwLlxuICAgICAgICAvLyBTaXggcGFpci13aXNlIGNvbXBhcmlzb25zIGFyZSBwZXJmb3JtZWQgYmV0d2VlbiBlYWNoIHBvc3NpYmxlIHBhaXJcbiAgICAgICAgLy8gb2YgdGhlIGZvdXIgY29vcmRpbmF0ZXMsIGFuZCB0aGUgcmVzdWx0cyBhcmUgdXNlZCB0byByYW5rIHRoZSBudW1iZXJzLlxuICAgICAgICBsZXQgcmFua3ggPSAwO1xuICAgICAgICBsZXQgcmFua3kgPSAwO1xuICAgICAgICBsZXQgcmFua3ogPSAwO1xuICAgICAgICBsZXQgcmFua3cgPSAwO1xuICAgICAgICBpZiAoeDAgPiB5MClcbiAgICAgICAgICAgIHJhbmt4Kys7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJhbmt5Kys7XG4gICAgICAgIGlmICh4MCA+IHowKVxuICAgICAgICAgICAgcmFua3grKztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmFua3orKztcbiAgICAgICAgaWYgKHgwID4gdzApXG4gICAgICAgICAgICByYW5reCsrO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByYW5rdysrO1xuICAgICAgICBpZiAoeTAgPiB6MClcbiAgICAgICAgICAgIHJhbmt5Kys7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJhbmt6Kys7XG4gICAgICAgIGlmICh5MCA+IHcwKVxuICAgICAgICAgICAgcmFua3krKztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmFua3crKztcbiAgICAgICAgaWYgKHowID4gdzApXG4gICAgICAgICAgICByYW5reisrO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByYW5rdysrO1xuICAgICAgICAvLyBzaW1wbGV4W2NdIGlzIGEgNC12ZWN0b3Igd2l0aCB0aGUgbnVtYmVycyAwLCAxLCAyIGFuZCAzIGluIHNvbWUgb3JkZXIuXG4gICAgICAgIC8vIE1hbnkgdmFsdWVzIG9mIGMgd2lsbCBuZXZlciBvY2N1ciwgc2luY2UgZS5nLiB4Pnk+ej53IG1ha2VzIHg8eiwgeTx3IGFuZCB4PHdcbiAgICAgICAgLy8gaW1wb3NzaWJsZS4gT25seSB0aGUgMjQgaW5kaWNlcyB3aGljaCBoYXZlIG5vbi16ZXJvIGVudHJpZXMgbWFrZSBhbnkgc2Vuc2UuXG4gICAgICAgIC8vIFdlIHVzZSBhIHRocmVzaG9sZGluZyB0byBzZXQgdGhlIGNvb3JkaW5hdGVzIGluIHR1cm4gZnJvbSB0aGUgbGFyZ2VzdCBtYWduaXR1ZGUuXG4gICAgICAgIC8vIFJhbmsgMyBkZW5vdGVzIHRoZSBsYXJnZXN0IGNvb3JkaW5hdGUuXG4gICAgICAgIC8vIFJhbmsgMiBkZW5vdGVzIHRoZSBzZWNvbmQgbGFyZ2VzdCBjb29yZGluYXRlLlxuICAgICAgICAvLyBSYW5rIDEgZGVub3RlcyB0aGUgc2Vjb25kIHNtYWxsZXN0IGNvb3JkaW5hdGUuXG4gICAgICAgIC8vIFRoZSBpbnRlZ2VyIG9mZnNldHMgZm9yIHRoZSBzZWNvbmQgc2ltcGxleCBjb3JuZXJcbiAgICAgICAgY29uc3QgaTEgPSByYW5reCA+PSAzID8gMSA6IDA7XG4gICAgICAgIGNvbnN0IGoxID0gcmFua3kgPj0gMyA/IDEgOiAwO1xuICAgICAgICBjb25zdCBrMSA9IHJhbmt6ID49IDMgPyAxIDogMDtcbiAgICAgICAgY29uc3QgbDEgPSByYW5rdyA+PSAzID8gMSA6IDA7XG4gICAgICAgIC8vIFRoZSBpbnRlZ2VyIG9mZnNldHMgZm9yIHRoZSB0aGlyZCBzaW1wbGV4IGNvcm5lclxuICAgICAgICBjb25zdCBpMiA9IHJhbmt4ID49IDIgPyAxIDogMDtcbiAgICAgICAgY29uc3QgajIgPSByYW5reSA+PSAyID8gMSA6IDA7XG4gICAgICAgIGNvbnN0IGsyID0gcmFua3ogPj0gMiA/IDEgOiAwO1xuICAgICAgICBjb25zdCBsMiA9IHJhbmt3ID49IDIgPyAxIDogMDtcbiAgICAgICAgLy8gVGhlIGludGVnZXIgb2Zmc2V0cyBmb3IgdGhlIGZvdXJ0aCBzaW1wbGV4IGNvcm5lclxuICAgICAgICBjb25zdCBpMyA9IHJhbmt4ID49IDEgPyAxIDogMDtcbiAgICAgICAgY29uc3QgajMgPSByYW5reSA+PSAxID8gMSA6IDA7XG4gICAgICAgIGNvbnN0IGszID0gcmFua3ogPj0gMSA/IDEgOiAwO1xuICAgICAgICBjb25zdCBsMyA9IHJhbmt3ID49IDEgPyAxIDogMDtcbiAgICAgICAgLy8gVGhlIGZpZnRoIGNvcm5lciBoYXMgYWxsIGNvb3JkaW5hdGUgb2Zmc2V0cyA9IDEsIHNvIG5vIG5lZWQgdG8gY29tcHV0ZSB0aGF0LlxuICAgICAgICBjb25zdCB4MSA9IHgwIC0gaTEgKyBHNDsgLy8gT2Zmc2V0cyBmb3Igc2Vjb25kIGNvcm5lciBpbiAoeCx5LHosdykgY29vcmRzXG4gICAgICAgIGNvbnN0IHkxID0geTAgLSBqMSArIEc0O1xuICAgICAgICBjb25zdCB6MSA9IHowIC0gazEgKyBHNDtcbiAgICAgICAgY29uc3QgdzEgPSB3MCAtIGwxICsgRzQ7XG4gICAgICAgIGNvbnN0IHgyID0geDAgLSBpMiArIDIuMCAqIEc0OyAvLyBPZmZzZXRzIGZvciB0aGlyZCBjb3JuZXIgaW4gKHgseSx6LHcpIGNvb3Jkc1xuICAgICAgICBjb25zdCB5MiA9IHkwIC0gajIgKyAyLjAgKiBHNDtcbiAgICAgICAgY29uc3QgejIgPSB6MCAtIGsyICsgMi4wICogRzQ7XG4gICAgICAgIGNvbnN0IHcyID0gdzAgLSBsMiArIDIuMCAqIEc0O1xuICAgICAgICBjb25zdCB4MyA9IHgwIC0gaTMgKyAzLjAgKiBHNDsgLy8gT2Zmc2V0cyBmb3IgZm91cnRoIGNvcm5lciBpbiAoeCx5LHosdykgY29vcmRzXG4gICAgICAgIGNvbnN0IHkzID0geTAgLSBqMyArIDMuMCAqIEc0O1xuICAgICAgICBjb25zdCB6MyA9IHowIC0gazMgKyAzLjAgKiBHNDtcbiAgICAgICAgY29uc3QgdzMgPSB3MCAtIGwzICsgMy4wICogRzQ7XG4gICAgICAgIGNvbnN0IHg0ID0geDAgLSAxLjAgKyA0LjAgKiBHNDsgLy8gT2Zmc2V0cyBmb3IgbGFzdCBjb3JuZXIgaW4gKHgseSx6LHcpIGNvb3Jkc1xuICAgICAgICBjb25zdCB5NCA9IHkwIC0gMS4wICsgNC4wICogRzQ7XG4gICAgICAgIGNvbnN0IHo0ID0gejAgLSAxLjAgKyA0LjAgKiBHNDtcbiAgICAgICAgY29uc3QgdzQgPSB3MCAtIDEuMCArIDQuMCAqIEc0O1xuICAgICAgICAvLyBXb3JrIG91dCB0aGUgaGFzaGVkIGdyYWRpZW50IGluZGljZXMgb2YgdGhlIGZpdmUgc2ltcGxleCBjb3JuZXJzXG4gICAgICAgIGNvbnN0IGlpID0gaSAmIDI1NTtcbiAgICAgICAgY29uc3QgamogPSBqICYgMjU1O1xuICAgICAgICBjb25zdCBrayA9IGsgJiAyNTU7XG4gICAgICAgIGNvbnN0IGxsID0gbCAmIDI1NTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBjb250cmlidXRpb24gZnJvbSB0aGUgZml2ZSBjb3JuZXJzXG4gICAgICAgIGxldCB0MCA9IDAuNiAtIHgwICogeDAgLSB5MCAqIHkwIC0gejAgKiB6MCAtIHcwICogdzA7XG4gICAgICAgIGlmICh0MCA8IDApXG4gICAgICAgICAgICBuMCA9IDAuMDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBnaTAgPSBpaSArIHBlcm1bamogKyBwZXJtW2trICsgcGVybVtsbF1dXTtcbiAgICAgICAgICAgIHQwICo9IHQwO1xuICAgICAgICAgICAgbjAgPSB0MCAqIHQwICogKHBlcm1HcmFkNHhbZ2kwXSAqIHgwICsgcGVybUdyYWQ0eVtnaTBdICogeTAgKyBwZXJtR3JhZDR6W2dpMF0gKiB6MCArIHBlcm1HcmFkNHdbZ2kwXSAqIHcwKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdDEgPSAwLjYgLSB4MSAqIHgxIC0geTEgKiB5MSAtIHoxICogejEgLSB3MSAqIHcxO1xuICAgICAgICBpZiAodDEgPCAwKVxuICAgICAgICAgICAgbjEgPSAwLjA7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZ2kxID0gaWkgKyBpMSArIHBlcm1bamogKyBqMSArIHBlcm1ba2sgKyBrMSArIHBlcm1bbGwgKyBsMV1dXTtcbiAgICAgICAgICAgIHQxICo9IHQxO1xuICAgICAgICAgICAgbjEgPSB0MSAqIHQxICogKHBlcm1HcmFkNHhbZ2kxXSAqIHgxICsgcGVybUdyYWQ0eVtnaTFdICogeTEgKyBwZXJtR3JhZDR6W2dpMV0gKiB6MSArIHBlcm1HcmFkNHdbZ2kxXSAqIHcxKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdDIgPSAwLjYgLSB4MiAqIHgyIC0geTIgKiB5MiAtIHoyICogejIgLSB3MiAqIHcyO1xuICAgICAgICBpZiAodDIgPCAwKVxuICAgICAgICAgICAgbjIgPSAwLjA7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZ2kyID0gaWkgKyBpMiArIHBlcm1bamogKyBqMiArIHBlcm1ba2sgKyBrMiArIHBlcm1bbGwgKyBsMl1dXTtcbiAgICAgICAgICAgIHQyICo9IHQyO1xuICAgICAgICAgICAgbjIgPSB0MiAqIHQyICogKHBlcm1HcmFkNHhbZ2kyXSAqIHgyICsgcGVybUdyYWQ0eVtnaTJdICogeTIgKyBwZXJtR3JhZDR6W2dpMl0gKiB6MiArIHBlcm1HcmFkNHdbZ2kyXSAqIHcyKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdDMgPSAwLjYgLSB4MyAqIHgzIC0geTMgKiB5MyAtIHozICogejMgLSB3MyAqIHczO1xuICAgICAgICBpZiAodDMgPCAwKVxuICAgICAgICAgICAgbjMgPSAwLjA7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZ2kzID0gaWkgKyBpMyArIHBlcm1bamogKyBqMyArIHBlcm1ba2sgKyBrMyArIHBlcm1bbGwgKyBsM11dXTtcbiAgICAgICAgICAgIHQzICo9IHQzO1xuICAgICAgICAgICAgbjMgPSB0MyAqIHQzICogKHBlcm1HcmFkNHhbZ2kzXSAqIHgzICsgcGVybUdyYWQ0eVtnaTNdICogeTMgKyBwZXJtR3JhZDR6W2dpM10gKiB6MyArIHBlcm1HcmFkNHdbZ2kzXSAqIHczKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdDQgPSAwLjYgLSB4NCAqIHg0IC0geTQgKiB5NCAtIHo0ICogejQgLSB3NCAqIHc0O1xuICAgICAgICBpZiAodDQgPCAwKVxuICAgICAgICAgICAgbjQgPSAwLjA7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZ2k0ID0gaWkgKyAxICsgcGVybVtqaiArIDEgKyBwZXJtW2trICsgMSArIHBlcm1bbGwgKyAxXV1dO1xuICAgICAgICAgICAgdDQgKj0gdDQ7XG4gICAgICAgICAgICBuNCA9IHQ0ICogdDQgKiAocGVybUdyYWQ0eFtnaTRdICogeDQgKyBwZXJtR3JhZDR5W2dpNF0gKiB5NCArIHBlcm1HcmFkNHpbZ2k0XSAqIHo0ICsgcGVybUdyYWQ0d1tnaTRdICogdzQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN1bSB1cCBhbmQgc2NhbGUgdGhlIHJlc3VsdCB0byBjb3ZlciB0aGUgcmFuZ2UgWy0xLDFdXG4gICAgICAgIHJldHVybiAyNy4wICogKG4wICsgbjEgKyBuMiArIG4zICsgbjQpO1xuICAgIH07XG59XG5leHBvcnRzLmNyZWF0ZU5vaXNlNEQgPSBjcmVhdGVOb2lzZTREO1xuLyoqXG4gKiBCdWlsZHMgYSByYW5kb20gcGVybXV0YXRpb24gdGFibGUuXG4gKiBUaGlzIGlzIGV4cG9ydGVkIG9ubHkgZm9yIChpbnRlcm5hbCkgdGVzdGluZyBwdXJwb3Nlcy5cbiAqIERvIG5vdCByZWx5IG9uIHRoaXMgZXhwb3J0LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYnVpbGRQZXJtdXRhdGlvblRhYmxlKHJhbmRvbSkge1xuICAgIGNvbnN0IHRhYmxlU2l6ZSA9IDUxMjtcbiAgICBjb25zdCBwID0gbmV3IFVpbnQ4QXJyYXkodGFibGVTaXplKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYmxlU2l6ZSAvIDI7IGkrKykge1xuICAgICAgICBwW2ldID0gaTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWJsZVNpemUgLyAyIC0gMTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHIgPSBpICsgfn4ocmFuZG9tKCkgKiAoMjU2IC0gaSkpO1xuICAgICAgICBjb25zdCBhdXggPSBwW2ldO1xuICAgICAgICBwW2ldID0gcFtyXTtcbiAgICAgICAgcFtyXSA9IGF1eDtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDI1NjsgaSA8IHRhYmxlU2l6ZTsgaSsrKSB7XG4gICAgICAgIHBbaV0gPSBwW2kgLSAyNTZdO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cbmV4cG9ydHMuYnVpbGRQZXJtdXRhdGlvblRhYmxlID0gYnVpbGRQZXJtdXRhdGlvblRhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2ltcGxleC1ub2lzZS5qcy5tYXAiLCIvKlxuIChjKSAyMDE3LCBWbGFkaW1pciBBZ2Fmb25raW5cbiBTaW1wbGlmeS5qcywgYSBoaWdoLXBlcmZvcm1hbmNlIEpTIHBvbHlsaW5lIHNpbXBsaWZpY2F0aW9uIGxpYnJhcnlcbiBtb3VybmVyLmdpdGh1Yi5pby9zaW1wbGlmeS1qc1xuKi9cblxuKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4vLyB0byBzdWl0IHlvdXIgcG9pbnQgZm9ybWF0LCBydW4gc2VhcmNoL3JlcGxhY2UgZm9yICcueCcgYW5kICcueSc7XG4vLyBmb3IgM0QgdmVyc2lvbiwgc2VlIDNkIGJyYW5jaCAoY29uZmlndXJhYmlsaXR5IHdvdWxkIGRyYXcgc2lnbmlmaWNhbnQgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQpXG5cbi8vIHNxdWFyZSBkaXN0YW5jZSBiZXR3ZWVuIDIgcG9pbnRzXG5mdW5jdGlvbiBnZXRTcURpc3QocDEsIHAyKSB7XG5cbiAgICB2YXIgZHggPSBwMS54IC0gcDIueCxcbiAgICAgICAgZHkgPSBwMS55IC0gcDIueTtcblxuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuLy8gc3F1YXJlIGRpc3RhbmNlIGZyb20gYSBwb2ludCB0byBhIHNlZ21lbnRcbmZ1bmN0aW9uIGdldFNxU2VnRGlzdChwLCBwMSwgcDIpIHtcblxuICAgIHZhciB4ID0gcDEueCxcbiAgICAgICAgeSA9IHAxLnksXG4gICAgICAgIGR4ID0gcDIueCAtIHgsXG4gICAgICAgIGR5ID0gcDIueSAtIHk7XG5cbiAgICBpZiAoZHggIT09IDAgfHwgZHkgIT09IDApIHtcblxuICAgICAgICB2YXIgdCA9ICgocC54IC0geCkgKiBkeCArIChwLnkgLSB5KSAqIGR5KSAvIChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICAgICAgaWYgKHQgPiAxKSB7XG4gICAgICAgICAgICB4ID0gcDIueDtcbiAgICAgICAgICAgIHkgPSBwMi55O1xuXG4gICAgICAgIH0gZWxzZSBpZiAodCA+IDApIHtcbiAgICAgICAgICAgIHggKz0gZHggKiB0O1xuICAgICAgICAgICAgeSArPSBkeSAqIHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkeCA9IHAueCAtIHg7XG4gICAgZHkgPSBwLnkgLSB5O1xuXG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuLy8gcmVzdCBvZiB0aGUgY29kZSBkb2Vzbid0IGNhcmUgYWJvdXQgcG9pbnQgZm9ybWF0XG5cbi8vIGJhc2ljIGRpc3RhbmNlLWJhc2VkIHNpbXBsaWZpY2F0aW9uXG5mdW5jdGlvbiBzaW1wbGlmeVJhZGlhbERpc3QocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xuXG4gICAgdmFyIHByZXZQb2ludCA9IHBvaW50c1swXSxcbiAgICAgICAgbmV3UG9pbnRzID0gW3ByZXZQb2ludF0sXG4gICAgICAgIHBvaW50O1xuXG4gICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwb2ludCA9IHBvaW50c1tpXTtcblxuICAgICAgICBpZiAoZ2V0U3FEaXN0KHBvaW50LCBwcmV2UG9pbnQpID4gc3FUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgIG5ld1BvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgICAgICAgIHByZXZQb2ludCA9IHBvaW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZXZQb2ludCAhPT0gcG9pbnQpIG5ld1BvaW50cy5wdXNoKHBvaW50KTtcblxuICAgIHJldHVybiBuZXdQb2ludHM7XG59XG5cbmZ1bmN0aW9uIHNpbXBsaWZ5RFBTdGVwKHBvaW50cywgZmlyc3QsIGxhc3QsIHNxVG9sZXJhbmNlLCBzaW1wbGlmaWVkKSB7XG4gICAgdmFyIG1heFNxRGlzdCA9IHNxVG9sZXJhbmNlLFxuICAgICAgICBpbmRleDtcblxuICAgIGZvciAodmFyIGkgPSBmaXJzdCArIDE7IGkgPCBsYXN0OyBpKyspIHtcbiAgICAgICAgdmFyIHNxRGlzdCA9IGdldFNxU2VnRGlzdChwb2ludHNbaV0sIHBvaW50c1tmaXJzdF0sIHBvaW50c1tsYXN0XSk7XG5cbiAgICAgICAgaWYgKHNxRGlzdCA+IG1heFNxRGlzdCkge1xuICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgbWF4U3FEaXN0ID0gc3FEaXN0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1heFNxRGlzdCA+IHNxVG9sZXJhbmNlKSB7XG4gICAgICAgIGlmIChpbmRleCAtIGZpcnN0ID4gMSkgc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBmaXJzdCwgaW5kZXgsIHNxVG9sZXJhbmNlLCBzaW1wbGlmaWVkKTtcbiAgICAgICAgc2ltcGxpZmllZC5wdXNoKHBvaW50c1tpbmRleF0pO1xuICAgICAgICBpZiAobGFzdCAtIGluZGV4ID4gMSkgc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBpbmRleCwgbGFzdCwgc3FUb2xlcmFuY2UsIHNpbXBsaWZpZWQpO1xuICAgIH1cbn1cblxuLy8gc2ltcGxpZmljYXRpb24gdXNpbmcgUmFtZXItRG91Z2xhcy1QZXVja2VyIGFsZ29yaXRobVxuZnVuY3Rpb24gc2ltcGxpZnlEb3VnbGFzUGV1Y2tlcihwb2ludHMsIHNxVG9sZXJhbmNlKSB7XG4gICAgdmFyIGxhc3QgPSBwb2ludHMubGVuZ3RoIC0gMTtcblxuICAgIHZhciBzaW1wbGlmaWVkID0gW3BvaW50c1swXV07XG4gICAgc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCAwLCBsYXN0LCBzcVRvbGVyYW5jZSwgc2ltcGxpZmllZCk7XG4gICAgc2ltcGxpZmllZC5wdXNoKHBvaW50c1tsYXN0XSk7XG5cbiAgICByZXR1cm4gc2ltcGxpZmllZDtcbn1cblxuLy8gYm90aCBhbGdvcml0aG1zIGNvbWJpbmVkIGZvciBhd2Vzb21lIHBlcmZvcm1hbmNlXG5mdW5jdGlvbiBzaW1wbGlmeShwb2ludHMsIHRvbGVyYW5jZSwgaGlnaGVzdFF1YWxpdHkpIHtcblxuICAgIGlmIChwb2ludHMubGVuZ3RoIDw9IDIpIHJldHVybiBwb2ludHM7XG5cbiAgICB2YXIgc3FUb2xlcmFuY2UgPSB0b2xlcmFuY2UgIT09IHVuZGVmaW5lZCA/IHRvbGVyYW5jZSAqIHRvbGVyYW5jZSA6IDE7XG5cbiAgICBwb2ludHMgPSBoaWdoZXN0UXVhbGl0eSA/IHBvaW50cyA6IHNpbXBsaWZ5UmFkaWFsRGlzdChwb2ludHMsIHNxVG9sZXJhbmNlKTtcbiAgICBwb2ludHMgPSBzaW1wbGlmeURvdWdsYXNQZXVja2VyKHBvaW50cywgc3FUb2xlcmFuY2UpO1xuXG4gICAgcmV0dXJuIHBvaW50cztcbn1cblxuLy8gZXhwb3J0IGFzIEFNRCBtb2R1bGUgLyBOb2RlIG1vZHVsZSAvIGJyb3dzZXIgb3Igd29ya2VyIHZhcmlhYmxlXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBzaW1wbGlmeTsgfSk7XG5lbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gc2ltcGxpZnk7XG4gICAgbW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IHNpbXBsaWZ5O1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHNlbGYuc2ltcGxpZnkgPSBzaW1wbGlmeTtcbmVsc2Ugd2luZG93LnNpbXBsaWZ5ID0gc2ltcGxpZnk7XG5cbn0pKCk7XG4iLCJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0ICogYXMgZGF0IGZyb20gJ2RhdC5ndWknO1xuaW1wb3J0IFRlbnNvckZpZWxkR1VJIGZyb20gJy4vdHMvdWkvdGVuc29yX2ZpZWxkX2d1aSc7XG5pbXBvcnQge05vaXNlUGFyYW1zfSBmcm9tICcuL3RzL2ltcGwvdGVuc29yX2ZpZWxkJztcbmltcG9ydCBNYWluR1VJIGZyb20gJy4vdHMvdWkvbWFpbl9ndWknO1xuaW1wb3J0IHtEZWZhdWx0Q2FudmFzV3JhcHBlcn0gZnJvbSAnLi90cy91aS9jYW52YXNfd3JhcHBlcic7XG5pbXBvcnQgVXRpbCBmcm9tICcuL3RzL3V0aWwnO1xuaW1wb3J0IERyYWdDb250cm9sbGVyIGZyb20gJy4vdHMvdWkvZHJhZ19jb250cm9sbGVyJztcbmltcG9ydCBEb21haW5Db250cm9sbGVyIGZyb20gJy4vdHMvdWkvZG9tYWluX2NvbnRyb2xsZXInO1xuaW1wb3J0IFN0eWxlIGZyb20gJy4vdHMvdWkvc3R5bGUnO1xuaW1wb3J0IHtDb2xvdXJTY2hlbWUsIERlZmF1bHRTdHlsZSwgUm91Z2hTdHlsZX0gZnJvbSAnLi90cy91aS9zdHlsZSc7XG5pbXBvcnQgKiBhcyBDb2xvdXJTY2hlbWVzIGZyb20gJy4vY29sb3VyX3NjaGVtZXMuanNvbic7XG5pbXBvcnQgVmVjdG9yIGZyb20gJy4vdHMvdmVjdG9yJztcbmltcG9ydCB7IFNWRyB9IGZyb20gJ0Bzdmdkb3Rqcy9zdmcuanMnO1xuaW1wb3J0IE1vZGVsR2VuZXJhdG9yIGZyb20gJy4vdHMvbW9kZWxfZ2VuZXJhdG9yJztcbmltcG9ydCB7IHNhdmVBcyB9IGZyb20gJ2ZpbGUtc2F2ZXInO1xuY2xhc3MgTWFpbiB7XG4gICAgcHVibGljIHJlYWRvbmx5IFNUQVJUSU5HX1dJRFRIID0gMTQ0MDsgIC8vIEluaXRpYWxseSB6b29tcyBpbiBpZiB3aWR0aCA+IFNUQVJUSU5HX1dJRFRIXG5cbiAgICAvLyBVSVxuICAgIHB1YmxpYyBndWk6IGRhdC5HVUkgPSBuZXcgZGF0LkdVSSh7d2lkdGg6IDMwMH0pO1xuICAgIHB1YmxpYyB0ZW5zb3JGb2xkZXI6IGRhdC5HVUk7XG4gICAgcHVibGljIHJvYWRzRm9sZGVyOiBkYXQuR1VJO1xuICAgIHB1YmxpYyBzdHlsZUZvbGRlcjogZGF0LkdVSTtcbiAgICBwdWJsaWMgb3B0aW9uc0ZvbGRlcjogZGF0LkdVSTtcbiAgICBwdWJsaWMgZG93bmxvYWRzRm9sZGVyOiBkYXQuR1VJO1xuXG4gICAgcHVibGljIGRvbWFpbkNvbnRyb2xsZXIgPSBEb21haW5Db250cm9sbGVyLmdldEluc3RhbmNlKCk7XG4gICAgcHVibGljIGRyYWdDb250cm9sbGVyID0gbmV3IERyYWdDb250cm9sbGVyKHRoaXMuZ3VpKTtcbiAgICBwdWJsaWMgdGVuc29yRmllbGQ6IFRlbnNvckZpZWxkR1VJO1xuICAgIHB1YmxpYyBtYWluR3VpOiBNYWluR1VJOyAgLy8gSW4gY2hhcmdlIG9mIGdsdWVpbmcgZXZlcnl0aGluZyB0b2dldGhlclxuXG4gICAgLy8gT3B0aW9uc1xuICAgIHB1YmxpYyBpbWFnZVNjYWxlID0gMzsgIC8vIE11bHRpcGxpZXIgZm9yIHJlcyBvZiBkb3dubG9hZGVkIGltYWdlXG4gICAgcHVibGljIGhpZ2hEUEkgPSB0cnVlOyAgLy8gSW5jcmVhc2VzIHJlc29sdXRpb24gZm9yIGhpRFBJIGRpc3BsYXlzXG5cbiAgICAvLyBTdHlsZSBvcHRpb25zXG4gICAgcHVibGljIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQ7XG4gICAgcHVibGljIHRlbnNvckNhbnZhczogRGVmYXVsdENhbnZhc1dyYXBwZXI7XG4gICAgcHVibGljIF9zdHlsZTogU3R5bGU7XG4gICAgcHVibGljIGNvbG91clNjaGVtZTogc3RyaW5nID0gXCJHb29nbGVcIjsgIC8vIFNlZSBjb2xvdXJfc2NoZW1lcy5qc29uXG4gICAgcHVibGljIHpvb21CdWlsZGluZ3M6IGJvb2xlYW4gPSBmYWxzZTsgIC8vIFNob3cgYnVpbGRpbmdzIG9ubHkgd2hlbiB6b29tZWQgaW4/XG4gICAgcHVibGljIGJ1aWxkaW5nTW9kZWxzOiBib29sZWFuID0gdHJ1ZTsgIC8vIERyYXcgcHNldWRvLTNEIGJ1aWxkaW5ncz9cbiAgICBwdWJsaWMgc2hvd0ZyYW1lOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvLyBGb3JjZSByZWRyYXcgb2Ygcm9hZHMgd2hlbiBzd2l0Y2hpbmcgZnJvbSB0ZW5zb3IgdmlzIHRvIG1hcCB2aXNcbiAgICBwdWJsaWMgcHJldmlvdXNGcmFtZURyYXdUZW5zb3IgPSB0cnVlO1xuXG4gICAgLy8gM0QgY2FtZXJhIHBvc2l0aW9uXG4gICAgcHVibGljIGNhbWVyYVggPSAwO1xuICAgIHB1YmxpYyBjYW1lcmFZID0gMDtcblxuICAgIHB1YmxpYyBmaXJzdEdlbmVyYXRlID0gdHJ1ZTsgIC8vIERvbid0IHJhbmRvbWlzZSB0ZW5zb3IgZmllbGQgb24gZmlyc3QgZ2VuZXJhdGVcbiAgICBwdWJsaWMgbW9kZWxHZW5lcmF0b3I6IE1vZGVsR2VuZXJhdG9yO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIEdVSSBTZXR1cFxuICAgICAgICBjb25zdCB6b29tQ29udHJvbGxlciA9IHRoaXMuZ3VpLmFkZCh0aGlzLmRvbWFpbkNvbnRyb2xsZXIsICd6b29tJyk7XG4gICAgICAgIHRoaXMuZG9tYWluQ29udHJvbGxlci5zZXRab29tVXBkYXRlKCgpID0+IHpvb21Db250cm9sbGVyLnVwZGF0ZURpc3BsYXkoKSk7XG4gICAgICAgIHRoaXMuZ3VpLmFkZCh0aGlzLCAnZ2VuZXJhdGUnKTtcblxuICAgICAgICB0aGlzLnRlbnNvckZvbGRlciA9IHRoaXMuZ3VpLmFkZEZvbGRlcignVGVuc29yIEZpZWxkJyk7XG4gICAgICAgIHRoaXMucm9hZHNGb2xkZXIgPSB0aGlzLmd1aS5hZGRGb2xkZXIoJ01hcCcpO1xuICAgICAgICB0aGlzLnN0eWxlRm9sZGVyID0gdGhpcy5ndWkuYWRkRm9sZGVyKCdTdHlsZScpO1xuICAgICAgICB0aGlzLm9wdGlvbnNGb2xkZXIgPSB0aGlzLmd1aS5hZGRGb2xkZXIoJ09wdGlvbnMnKTtcbiAgICAgICAgdGhpcy5kb3dubG9hZHNGb2xkZXIgPSB0aGlzLmd1aS5hZGRGb2xkZXIoJ0Rvd25sb2FkJyk7XG5cbiAgICAgICAgLy8gQ2FudmFzIHNldHVwXG4gICAgICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoVXRpbC5DQU5WQVNfSUQpIGFzIEhUTUxDYW52YXNFbGVtZW50O1xuICAgICAgICB0aGlzLnRlbnNvckNhbnZhcyA9IG5ldyBEZWZhdWx0Q2FudmFzV3JhcHBlcih0aGlzLmNhbnZhcyk7XG4gICAgICAgIFxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UncmUgbm90IHRvbyB6b29tZWQgb3V0IGZvciBsYXJnZSByZXNvbHV0aW9uc1xuICAgICAgICBjb25zdCBzY3JlZW5XaWR0aCA9IHRoaXMuZG9tYWluQ29udHJvbGxlci5zY3JlZW5EaW1lbnNpb25zLng7XG4gICAgICAgIGlmIChzY3JlZW5XaWR0aCA+IHRoaXMuU1RBUlRJTkdfV0lEVEgpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tID0gc2NyZWVuV2lkdGggLyB0aGlzLlNUQVJUSU5HX1dJRFRIO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3R5bGUgc2V0dXBcbiAgICAgICAgdGhpcy5zdHlsZUZvbGRlci5hZGQodGhpcywgJ2NvbG91clNjaGVtZScsIE9iamVjdC5rZXlzKENvbG91clNjaGVtZXMpKS5vbkNoYW5nZSgodmFsOiBzdHJpbmcpID0+IHRoaXMuY2hhbmdlQ29sb3VyU2NoZW1lKHZhbCkpO1xuXG4gICAgICAgIHRoaXMuc3R5bGVGb2xkZXIuYWRkKHRoaXMsICd6b29tQnVpbGRpbmdzJykub25DaGFuZ2UoKHZhbDogYm9vbGVhbikgPT4ge1xuICAgICAgICAgICAgLy8gRm9yY2UgcmVkcmF3XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzRnJhbWVEcmF3VGVuc29yID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlLnpvb21CdWlsZGluZ3MgPSB2YWw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc3R5bGVGb2xkZXIuYWRkKHRoaXMsICdidWlsZGluZ01vZGVscycpLm9uQ2hhbmdlKCh2YWw6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgICAgIC8vIEZvcmNlIHJlZHJhd1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c0ZyYW1lRHJhd1RlbnNvciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9zdHlsZS5zaG93QnVpbGRpbmdNb2RlbHMgPSB2YWw7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5zdHlsZUZvbGRlci5hZGQodGhpcywgJ3Nob3dGcmFtZScpLm9uQ2hhbmdlKCh2YWw6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNGcmFtZURyYXdUZW5zb3IgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fc3R5bGUuc2hvd0ZyYW1lID0gdmFsO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnN0eWxlRm9sZGVyLmFkZCh0aGlzLmRvbWFpbkNvbnRyb2xsZXIsICdvcnRob2dyYXBoaWMnKTtcbiAgICAgICAgdGhpcy5zdHlsZUZvbGRlci5hZGQodGhpcywgJ2NhbWVyYVgnLCAtMTUsIDE1KS5zdGVwKDEpLm9uQ2hhbmdlKCgpID0+IHRoaXMuc2V0Q2FtZXJhRGlyZWN0aW9uKCkpO1xuICAgICAgICB0aGlzLnN0eWxlRm9sZGVyLmFkZCh0aGlzLCAnY2FtZXJhWScsIC0xNSwgMTUpLnN0ZXAoMSkub25DaGFuZ2UoKCkgPT4gdGhpcy5zZXRDYW1lcmFEaXJlY3Rpb24oKSk7XG5cblxuICAgICAgICB2YXIgbm9pc2VQYXJhbXNQbGFjZWhvbGRlcjogTm9pc2VQYXJhbXMgPSB7ICAvLyBQbGFjZWhvbGRlciB2YWx1ZXMgZm9yIHBhcmsgKyB3YXRlciBub2lzZVxuICAgICAgICAgICAgZ2xvYmFsTm9pc2U6IGZhbHNlLFxuICAgICAgICAgICAgbm9pc2VTaXplUGFyazogMjAsXG4gICAgICAgICAgICBub2lzZUFuZ2xlUGFyazogOTAsXG4gICAgICAgICAgICBub2lzZVNpemVHbG9iYWw6IDMwLFxuICAgICAgICAgICAgbm9pc2VBbmdsZUdsb2JhbDogMjBcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnRlbnNvckZpZWxkID0gbmV3IFRlbnNvckZpZWxkR1VJKHRoaXMudGVuc29yRm9sZGVyLCB0aGlzLmRyYWdDb250cm9sbGVyLCB0cnVlLCBub2lzZVBhcmFtc1BsYWNlaG9sZGVyKTtcbiAgICAgICAgdGhpcy5tYWluR3VpID0gbmV3IE1haW5HVUkodGhpcy5yb2Fkc0ZvbGRlciwgdGhpcy50ZW5zb3JGaWVsZCwgKCkgPT4gdGhpcy50ZW5zb3JGb2xkZXIuY2xvc2UoKSk7XG5cbiAgICAgICAgdGhpcy5vcHRpb25zRm9sZGVyLmFkZCh0aGlzLnRlbnNvckZpZWxkLCAnZHJhd0NlbnRyZScpO1xuICAgICAgICB0aGlzLm9wdGlvbnNGb2xkZXIuYWRkKHRoaXMsICdoaWdoRFBJJykub25DaGFuZ2UoKGhpZ2g6IGJvb2xlYW4pID0+IHRoaXMuY2hhbmdlQ2FudmFzU2NhbGUoaGlnaCkpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5kb3dubG9hZHNGb2xkZXIuYWRkKHRoaXMsICdpbWFnZVNjYWxlJywgMSwgNSkuc3RlcCgxKTtcbiAgICAgICAgdGhpcy5kb3dubG9hZHNGb2xkZXIuYWRkKHtcIlBOR1wiOiAoKSA9PiB0aGlzLmRvd25sb2FkUG5nKCl9LCAnUE5HJyk7ICAvLyBUaGlzIGFsbG93cyBjdXN0b20gbmFtaW5nIG9mIGJ1dHRvblxuICAgICAgICB0aGlzLmRvd25sb2Fkc0ZvbGRlci5hZGQoe1wiU1ZHXCI6ICgpID0+IHRoaXMuZG93bmxvYWRTVkcoKX0sICdTVkcnKTtcbiAgICAgICAgdGhpcy5kb3dubG9hZHNGb2xkZXIuYWRkKHtcIkhlaWdodG1hcFwiOiAoKSA9PiB0aGlzLmRvd25sb2FkSGVpZ2h0bWFwKCl9LCAnSGVpZ2h0bWFwJyk7XG5cbiAgICAgICAgdGhpcy5jaGFuZ2VDb2xvdXJTY2hlbWUodGhpcy5jb2xvdXJTY2hlbWUpO1xuICAgICAgICB0aGlzLnRlbnNvckZpZWxkLnNldFJlY29tbWVuZGVkKCk7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLnVwZGF0ZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhbiBlbnRpcmUgbWFwIHdpdGggbm8gY29udHJvbCBvdmVyIHRoZSBwcm9jZXNzXG4gICAgICovXG4gICAgZ2VuZXJhdGUoKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5maXJzdEdlbmVyYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnRlbnNvckZpZWxkLnNldFJlY29tbWVuZGVkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0R2VuZXJhdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5tYWluR3VpLmdlbmVyYXRlRXZlcnl0aGluZygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzY2hlbWUgTWF0Y2hlcyBhIHNjaGVtZSBuYW1lIGluIGNvbG91cl9zY2hlbWVzLmpzb25cbiAgICAgKi9cbiAgICBjaGFuZ2VDb2xvdXJTY2hlbWUoc2NoZW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgY29sb3VyU2NoZW1lOiBDb2xvdXJTY2hlbWUgPSAoQ29sb3VyU2NoZW1lcyBhcyBhbnkpW3NjaGVtZV07XG4gICAgICAgIHRoaXMuem9vbUJ1aWxkaW5ncyA9IGNvbG91clNjaGVtZS56b29tQnVpbGRpbmdzO1xuICAgICAgICB0aGlzLmJ1aWxkaW5nTW9kZWxzID0gY29sb3VyU2NoZW1lLmJ1aWxkaW5nTW9kZWxzO1xuICAgICAgICBVdGlsLnVwZGF0ZUd1aSh0aGlzLnN0eWxlRm9sZGVyKTtcbiAgICAgICAgaWYgKHNjaGVtZS5zdGFydHNXaXRoKFwiRHJhd25cIikpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlID0gbmV3IFJvdWdoU3R5bGUodGhpcy5jYW52YXMsIHRoaXMuZHJhZ0NvbnRyb2xsZXIsIE9iamVjdC5hc3NpZ24oe30sIGNvbG91clNjaGVtZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc3R5bGUgPSBuZXcgRGVmYXVsdFN0eWxlKHRoaXMuY2FudmFzLCB0aGlzLmRyYWdDb250cm9sbGVyLCBPYmplY3QuYXNzaWduKHt9LCBjb2xvdXJTY2hlbWUpLCBzY2hlbWUuc3RhcnRzV2l0aChcIkhlaWdodG1hcFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3R5bGUuc2hvd0ZyYW1lID0gdGhpcy5zaG93RnJhbWU7XG4gICAgICAgIHRoaXMuY2hhbmdlQ2FudmFzU2NhbGUodGhpcy5oaWdoRFBJKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY2FsZSB1cCBjYW52YXMgcmVzb2x1dGlvbiBmb3IgaGlEUEkgZGlzcGxheXNcbiAgICAgKi9cbiAgICBjaGFuZ2VDYW52YXNTY2FsZShoaWdoOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaGlnaCA/IDIgOiAxO1xuICAgICAgICB0aGlzLl9zdHlsZS5jYW52YXNTY2FsZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnRlbnNvckNhbnZhcy5jYW52YXNTY2FsZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZSBjYW1lcmEgcG9zaXRpb24gZm9yIHBzZXVkbzNEIGJ1aWxkaW5nc1xuICAgICAqL1xuICAgIHNldENhbWVyYURpcmVjdGlvbigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kb21haW5Db250cm9sbGVyLmNhbWVyYURpcmVjdGlvbiA9IG5ldyBWZWN0b3IodGhpcy5jYW1lcmFYIC8gMTAsIHRoaXMuY2FtZXJhWSAvIDEwKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZG93bmxvYWRGaWxlKGZpbGVuYW1lOiBzdHJpbmcsIGZpbGU6IGFueSk6IHZvaWQge1xuICAgICAgICBzYXZlQXMoZmlsZSwgZmlsZW5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvd25sb2FkcyBpbWFnZSBvZiBtYXBcbiAgICAgKiBEcmF3cyBvbnRvIGhpZGRlbiBjYW52YXMgYXQgcmVxdWVzdGVkIHJlc29sdXRpb25cbiAgICAgKi9cbiAgICBkb3dubG9hZFBuZygpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgYyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFV0aWwuSU1HX0NBTlZBU19JRCkgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XG5cbiAgICAgICAgLy8gRHJhd1xuICAgICAgICBpZiAodGhpcy5zaG93VGVuc29yRmllbGQoKSkge1xuICAgICAgICAgICAgdGhpcy50ZW5zb3JGaWVsZC5kcmF3KG5ldyBEZWZhdWx0Q2FudmFzV3JhcHBlcihjLCB0aGlzLmltYWdlU2NhbGUsIGZhbHNlKSk7XG4gICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBpbWdDYW52YXMgPSB0aGlzLl9zdHlsZS5jcmVhdGVDYW52YXNXcmFwcGVyKGMsIHRoaXMuaW1hZ2VTY2FsZSwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5tYWluR3VpLmRyYXcodGhpcy5fc3R5bGUsIHRydWUsIGltZ0NhbnZhcyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICBsaW5rLmRvd25sb2FkID0gJ21hcC5wbmcnO1xuICAgICAgICBsaW5rLmhyZWYgPSAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoVXRpbC5JTUdfQ0FOVkFTX0lEKSBhcyBhbnkpLnRvRGF0YVVSTCgpO1xuICAgICAgICBsaW5rLmNsaWNrKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2FtZSBhcyBkb3dubG9hZFBuZyBidXQgdXNlcyBIZWlnaHRtYXAgc3R5bGVcbiAgICAgKi9cbiAgICBkb3dubG9hZEhlaWdodG1hcCgpOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgb2xkQ29sb3VyU2NoZW1lID0gdGhpcy5jb2xvdXJTY2hlbWU7XG4gICAgICAgIHRoaXMuY2hhbmdlQ29sb3VyU2NoZW1lKFwiSGVpZ2h0bWFwXCIpO1xuICAgICAgICB0aGlzLmRvd25sb2FkUG5nKCk7XG4gICAgICAgIHRoaXMuY2hhbmdlQ29sb3VyU2NoZW1lKG9sZENvbG91clNjaGVtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG93bmxvYWRzIHN2ZyBvZiBtYXBcbiAgICAgKiBEcmF3cyBvbnRvIGhpZGRlbiBzdmcgYXQgcmVxdWVzdGVkIHJlc29sdXRpb25cbiAgICAgKi9cbiAgICBkb3dubG9hZFNWRygpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgYyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFV0aWwuSU1HX0NBTlZBU19JRCkgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHN2Z0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChVdGlsLlNWR19JRCk7XG5cbiAgICAgICAgaWYgKHRoaXMuc2hvd1RlbnNvckZpZWxkKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGltZ0NhbnZhcyA9IG5ldyBEZWZhdWx0Q2FudmFzV3JhcHBlcihjLCAxLCBmYWxzZSk7XG4gICAgICAgICAgICBpbWdDYW52YXMuY3JlYXRlU1ZHKHN2Z0VsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy50ZW5zb3JGaWVsZC5kcmF3KGltZ0NhbnZhcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpbWdDYW52YXMgPSB0aGlzLl9zdHlsZS5jcmVhdGVDYW52YXNXcmFwcGVyKGMsIDEsIGZhbHNlKTtcbiAgICAgICAgICAgIGltZ0NhbnZhcy5jcmVhdGVTVkcoc3ZnRWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLm1haW5HdWkuZHJhdyh0aGlzLl9zdHlsZSwgdHJ1ZSwgaW1nQ2FudmFzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSBuZXcgWE1MU2VyaWFsaXplcigpO1xuICAgICAgICBsZXQgc291cmNlID0gc2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyhzdmdFbGVtZW50KTtcblxuICAgICAgICAvL2FkZCB4bWwgZGVjbGFyYXRpb25cbiAgICAgICAgc291cmNlID0gJzw/eG1sIHZlcnNpb249XCIxLjBcIiBzdGFuZGFsb25lPVwibm9cIj8+XFxyXFxuJyArIHNvdXJjZTtcblxuICAgICAgICAvL2NvbnZlcnQgc3ZnIHNvdXJjZSB0byBVUkkgZGF0YSBzY2hlbWUuXG4gICAgICAgIGNvbnN0IHVybCA9IFwiZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmLTgsXCIrZW5jb2RlVVJJQ29tcG9uZW50KHNvdXJjZSk7XG5cbiAgICAgICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgbGluay5kb3dubG9hZCA9ICdtYXAuc3ZnJztcbiAgICAgICAgbGluay5ocmVmID0gdXJsO1xuICAgICAgICBsaW5rLmNsaWNrKCk7XG5cbiAgICAgICAgLy8gQ2xlYXIgU1ZHXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBTVkcoc3ZnRWxlbWVudCk7XG4gICAgICAgIGVsZW1lbnQuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2hvd1RlbnNvckZpZWxkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gIXRoaXMudGVuc29yRm9sZGVyLmNsb3NlZCB8fCB0aGlzLm1haW5HdWkucm9hZHNFbXB0eSgpO1xuICAgIH1cblxuICAgIGRyYXcoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnNob3dUZW5zb3JGaWVsZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzRnJhbWVEcmF3VGVuc29yID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0NvbnRyb2xsZXIuc2V0RHJhZ0Rpc2FibGVkKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMudGVuc29yRmllbGQuZHJhdyh0aGlzLnRlbnNvckNhbnZhcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEaXNhYmxlIGZpZWxkIGRyYWcgYW5kIGRyb3BcbiAgICAgICAgICAgIHRoaXMuZHJhZ0NvbnRyb2xsZXIuc2V0RHJhZ0Rpc2FibGVkKHRydWUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2aW91c0ZyYW1lRHJhd1RlbnNvciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNGcmFtZURyYXdUZW5zb3IgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIC8vIEZvcmNlIHJlZHJhdyBpZiBzd2l0Y2hpbmcgZnJvbSB0ZW5zb3IgZmllbGRcbiAgICAgICAgICAgICAgICB0aGlzLm1haW5HdWkuZHJhdyh0aGlzLl9zdHlsZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubWFpbkd1aS5kcmF3KHRoaXMuX3N0eWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZWxHZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGxldCBjb250aW51ZVVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgd2hpbGUgKGNvbnRpbnVlVXBkYXRlICYmIHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQgPCAxMDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZVVwZGF0ZSA9IHRoaXMubW9kZWxHZW5lcmF0b3IudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zdHlsZS51cGRhdGUoKTtcbiAgICAgICAgdGhpcy5tYWluR3VpLnVwZGF0ZSgpO1xuICAgICAgICB0aGlzLmRyYXcoKTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlLmJpbmQodGhpcykpO1xuICAgIH1cbn1cblxuLy8gQWRkIGxvZyB0byB3aW5kb3cgc28gd2UgY2FuIHVzZSBsb2cuc2V0bGV2ZWwgZnJvbSB0aGUgY29uc29sZVxuKHdpbmRvdyBhcyBhbnkpLmxvZyA9IGxvZztcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCk6IHZvaWQgPT4ge1xuICAgIG5ldyBNYWluKCk7XG59KTtcbiIsImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCBUZW5zb3IgZnJvbSAnLi90ZW5zb3InO1xuaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xuXG5leHBvcnQgY29uc3QgZW51bSBGSUVMRF9UWVBFIHtcbiAgICBSYWRpYWwsXG4gICAgR3JpZCxcbn07XG5cbi8qKlxuICogR3JpZCBvciBSYWRpYWwgZmllbGQgdG8gYmUgY29tYmluZWQgd2l0aCBvdGhlcnMgdG8gY3JlYXRlIHRoZSB0ZW5zb3IgZmllbGRcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2lzRmllbGQge1xuICAgIGFic3RyYWN0IHJlYWRvbmx5IEZPTERFUl9OQU1FOiBzdHJpbmc7XG4gICAgYWJzdHJhY3QgcmVhZG9ubHkgRklFTERfVFlQRTogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBzdGF0aWMgZm9sZGVyTmFtZUluZGV4OiBudW1iZXIgPSAwO1xuICAgIHByb3RlY3RlZCBwYXJlbnRGb2xkZXI6IGRhdC5HVUk7XG4gICAgcHJvdGVjdGVkIGZvbGRlcjogZGF0LkdVSTtcbiAgICBwcm90ZWN0ZWQgX2NlbnRyZTogVmVjdG9yO1xuXG4gICAgY29uc3RydWN0b3IoY2VudHJlOiBWZWN0b3IsIHByb3RlY3RlZCBfc2l6ZTogbnVtYmVyLCBwcm90ZWN0ZWQgX2RlY2F5OiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fY2VudHJlID0gY2VudHJlLmNsb25lKCk7XG4gICAgfVxuXG4gICAgc2V0IGNlbnRyZShjZW50cmU6IFZlY3Rvcikge1xuICAgICAgICB0aGlzLl9jZW50cmUuY29weShjZW50cmUpO1xuICAgIH1cblxuICAgIGdldCBjZW50cmUoKTogVmVjdG9yIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NlbnRyZS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHNldCBkZWNheShkZWNheTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX2RlY2F5ID0gZGVjYXk7XG4gICAgfVxuXG4gICAgc2V0IHNpemUoc2l6ZTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX3NpemUgPSBzaXplO1xuICAgIH1cblxuICAgIGRyYWdTdGFydExpc3RlbmVyKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnNldEZvbGRlcigpO1xuICAgIH1cblxuICAgIGRyYWdNb3ZlTGlzdGVuZXIoZGVsdGE6IFZlY3Rvcik6IHZvaWQge1xuICAgICAgICAvLyBEZWx0YSBhc3N1bWVkIHRvIGJlIGluIHdvcmxkIHNwYWNlIChvbmx5IHJlbGV2YW50IHdoZW4gem9vbWVkKVxuICAgICAgICB0aGlzLl9jZW50cmUuYWRkKGRlbHRhKTtcbiAgICB9XG5cbiAgICBhYnN0cmFjdCBnZXRUZW5zb3IocG9pbnQ6IFZlY3Rvcik6IFRlbnNvcjtcblxuICAgIGdldFdlaWdodGVkVGVuc29yKHBvaW50OiBWZWN0b3IsIHNtb290aDogYm9vbGVhbik6IFRlbnNvciB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFRlbnNvcihwb2ludCkuc2NhbGUodGhpcy5nZXRUZW5zb3JXZWlnaHQocG9pbnQsIHNtb290aCkpO1xuICAgIH1cblxuICAgIHNldEZvbGRlcigpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50Rm9sZGVyLl9fZm9sZGVycykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBmb2xkZXJOYW1lIGluIHRoaXMucGFyZW50Rm9sZGVyLl9fZm9sZGVycykge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Rm9sZGVyLl9fZm9sZGVyc1tmb2xkZXJOYW1lXS5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mb2xkZXIub3BlbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlRm9sZGVyRnJvbVBhcmVudCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50Rm9sZGVyLl9fZm9sZGVycyAmJiBPYmplY3QudmFsdWVzKHRoaXMucGFyZW50Rm9sZGVyLl9fZm9sZGVycykuaW5kZXhPZih0aGlzLmZvbGRlcikgPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRGb2xkZXIucmVtb3ZlRm9sZGVyKHRoaXMuZm9sZGVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmb2xkZXIgYW5kIGFkZHMgaXQgdG8gdGhlIEdVSSB0byBjb250cm9sIHBhcmFtc1xuICAgICAqL1xuICAgIHNldEd1aShwYXJlbnQ6IGRhdC5HVUksIGZvbGRlcjogZGF0LkdVSSk6IHZvaWQge1xuICAgICAgICB0aGlzLnBhcmVudEZvbGRlciA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5mb2xkZXIgPSBmb2xkZXI7XG4gICAgICAgIGZvbGRlci5hZGQodGhpcy5fY2VudHJlLCAneCcpO1xuICAgICAgICBmb2xkZXIuYWRkKHRoaXMuX2NlbnRyZSwgJ3knKTtcbiAgICAgICAgZm9sZGVyLmFkZCh0aGlzLCAnX3NpemUnKTtcbiAgICAgICAgZm9sZGVyLmFkZCh0aGlzLCAnX2RlY2F5JywgLTUwLCA1MCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJwb2xhdGVzIGJldHdlZW4gKDAgYW5kIDEpXmRlY2F5XG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldFRlbnNvcldlaWdodChwb2ludDogVmVjdG9yLCBzbW9vdGg6IGJvb2xlYW4pOiBudW1iZXIge1xuICAgICAgICBjb25zdCBub3JtRGlzdGFuY2VUb0NlbnRyZSA9IHBvaW50LmNsb25lKCkuc3ViKHRoaXMuX2NlbnRyZSkubGVuZ3RoKCkgLyB0aGlzLl9zaXplO1xuICAgICAgICBpZiAoc21vb3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9ybURpc3RhbmNlVG9DZW50cmUgKiogLXRoaXMuX2RlY2F5O1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0b3AgKCoqIDApIHR1cm5pbmcgd2VpZ2h0IGludG8gMSwgZmlsbGluZyBzY3JlZW4gZXZlbiB3aGVuIG91dHNpZGUgJ3NpemUnXG4gICAgICAgIGlmICh0aGlzLl9kZWNheSA9PT0gMCAmJiBub3JtRGlzdGFuY2VUb0NlbnRyZSA+PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgKDEgLSBub3JtRGlzdGFuY2VUb0NlbnRyZSkpICoqIHRoaXMuX2RlY2F5O1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEdyaWQgZXh0ZW5kcyBCYXNpc0ZpZWxkIHtcbiAgICByZWFkb25seSBGT0xERVJfTkFNRSA9IGBHcmlkICR7R3JpZC5mb2xkZXJOYW1lSW5kZXgrK31gO1xuICAgIHJlYWRvbmx5IEZJRUxEX1RZUEUgPSBGSUVMRF9UWVBFLkdyaWQ7XG5cbiAgICBjb25zdHJ1Y3RvcihjZW50cmU6IFZlY3Rvciwgc2l6ZTogbnVtYmVyLCBkZWNheTogbnVtYmVyLCBwcml2YXRlIF90aGV0YTogbnVtYmVyKSB7XG4gICAgICAgIHN1cGVyKGNlbnRyZSwgc2l6ZSwgZGVjYXkpO1xuICAgIH1cblxuICAgIHNldCB0aGV0YSh0aGV0YTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX3RoZXRhID0gdGhldGE7XG4gICAgfVxuXG4gICAgc2V0R3VpKHBhcmVudDogZGF0LkdVSSwgZm9sZGVyOiBkYXQuR1VJKTogdm9pZCB7XG4gICAgICAgIHN1cGVyLnNldEd1aShwYXJlbnQsIGZvbGRlcik7XG5cbiAgICAgICAgLy8gR1VJIGluIGRlZ3JlZXMsIGNvbnZlcnQgdG8gcmFkc1xuICAgICAgICBjb25zdCB0aGV0YVByb3AgPSB7dGhldGE6IHRoaXMuX3RoZXRhICogMTgwIC8gTWF0aC5QSX07XG4gICAgICAgIGNvbnN0IHRoZXRhQ29udHJvbGxlciA9IGZvbGRlci5hZGQodGhldGFQcm9wLCAndGhldGEnLCAtOTAsIDkwKTtcbiAgICAgICAgdGhldGFDb250cm9sbGVyLm9uQ2hhbmdlKHRoZXRhID0+IHRoaXMuX3RoZXRhID0gdGhldGEgKiAoTWF0aC5QSSAvIDE4MCkpO1xuICAgIH1cblxuICAgIGdldFRlbnNvcihwb2ludDogVmVjdG9yKTogVGVuc29yIHtcbiAgICAgICAgY29uc3QgY29zID0gTWF0aC5jb3MoMiAqIHRoaXMuX3RoZXRhKTtcbiAgICAgICAgY29uc3Qgc2luID0gTWF0aC5zaW4oMiAqIHRoaXMuX3RoZXRhKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3IoMSwgW2Nvcywgc2luXSk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmFkaWFsIGV4dGVuZHMgQmFzaXNGaWVsZCB7XG4gICAgcmVhZG9ubHkgRk9MREVSX05BTUUgPSBgUmFkaWFsICR7UmFkaWFsLmZvbGRlck5hbWVJbmRleCsrfWA7XG4gICAgcmVhZG9ubHkgRklFTERfVFlQRSA9IEZJRUxEX1RZUEUuUmFkaWFsO1xuXG4gICAgY29uc3RydWN0b3IoY2VudHJlOiBWZWN0b3IsIHNpemU6IG51bWJlciwgZGVjYXk6IG51bWJlcikge1xuICAgICAgICBzdXBlcihjZW50cmUsIHNpemUsIGRlY2F5KTtcbiAgICB9XG5cbiAgICBnZXRUZW5zb3IocG9pbnQ6IFZlY3Rvcik6IFRlbnNvciB7XG4gICAgICAgIGNvbnN0IHQgPSBwb2ludC5jbG9uZSgpLnN1Yih0aGlzLl9jZW50cmUpO1xuICAgICAgICBjb25zdCB0MSA9IHQueSoqMiAtIHQueCoqMjtcbiAgICAgICAgY29uc3QgdDIgPSAtMiAqIHQueCAqIHQueTtcbiAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3IoMSwgW3QxLCB0Ml0pO1xuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCAqIGFzIGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgKiBhcyBpc2VjdCBmcm9tICdpc2VjdCc7XG5pbXBvcnQgKiBhcyBkMyBmcm9tICdkMy1xdWFkdHJlZSc7XG5pbXBvcnQgVmVjdG9yIGZyb20gJy4uL3ZlY3Rvcic7XG5cbmRlY2xhcmUgbW9kdWxlICdpc2VjdCcge1xuICAgIGV4cG9ydCBmdW5jdGlvbiBidXNoKGxpbmVzOiBTZWdtZW50W10pOiBEZXRlY3RJbnRlcnNlY3Rpb25zO1xufVxuXG5pbnRlcmZhY2UgRGV0ZWN0SW50ZXJzZWN0aW9ucyB7XG4gICAgcnVuOiAoKSA9PiBJbnRlcnNlY3Rpb25bXTtcbn1cblxuaW50ZXJmYWNlIFNlZ21lbnQge1xuICAgIGZyb206IFZlY3RvcjtcbiAgICB0bzogVmVjdG9yO1xufVxuXG5pbnRlcmZhY2UgSW50ZXJzZWN0aW9uIHtcbiAgICBwb2ludDogVmVjdG9yO1xuICAgIHNlZ21lbnRzOiBTZWdtZW50W107XG59XG5cbi8qKlxuICogTm9kZSBsb2NhdGVkIGFsb25nIGFueSBpbnRlcnNlY3Rpb24gb3IgcG9pbnQgYWxvbmcgdGhlIHNpbXBsaWZpZWQgcm9hZCBwb2x5bGluZXMgXG4gKi9cbmV4cG9ydCBjbGFzcyBOb2RlIHtcbiAgICBwdWJsaWMgc2VnbWVudHMgPSBuZXcgU2V0PFNlZ21lbnQ+KCk7XG4gICAgcHVibGljIGFkajogTm9kZVtdO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIHZhbHVlOiBWZWN0b3IsIHB1YmxpYyBuZWlnaGJvcnM9bmV3IFNldDxOb2RlPigpKSB7fVxuXG4gICAgYWRkU2VnbWVudChzZWdtZW50OiBTZWdtZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2VnbWVudHMuYWRkKHNlZ21lbnQpO1xuICAgIH1cblxuICAgIGFkZE5laWdoYm9yKG5vZGU6IE5vZGUpOiB2b2lkIHtcbiAgICAgICAgaWYgKG5vZGUgIT09IHRoaXMpIHtcbiAgICAgICAgICAgIHRoaXMubmVpZ2hib3JzLmFkZChub2RlKTtcbiAgICAgICAgICAgIG5vZGUubmVpZ2hib3JzLmFkZCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JhcGgge1xuICAgIHB1YmxpYyBub2RlczogTm9kZVtdO1xuICAgIHB1YmxpYyBpbnRlcnNlY3Rpb25zOiBWZWN0b3JbXTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGdyYXBoIGZyb20gYSBzZXQgb2Ygc3RyZWFtbGluZXNcbiAgICAgKiBGaW5kcyBhbGwgaW50ZXJzZWN0aW9ucywgYW5kIGNyZWF0ZXMgYSBsaXN0IG9mIE5vZGVzXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc3RyZWFtbGluZXM6IFZlY3RvcltdW10sIGRzdGVwOiBudW1iZXIsIGRlbGV0ZURhbmdsaW5nPWZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGludGVyc2VjdGlvbnMgPSBpc2VjdC5idXNoKHRoaXMuc3RyZWFtbGluZXNUb1NlZ21lbnQoc3RyZWFtbGluZXMpKS5ydW4oKTtcbiAgICAgICAgY29uc3QgcXVhZHRyZWUgPSAoZDMucXVhZHRyZWUoKSBhcyBkMy5RdWFkdHJlZTxOb2RlPikueChuID0+IG4udmFsdWUueCkueShuID0+IG4udmFsdWUueSk7XG4gICAgICAgIGNvbnN0IG5vZGVBZGRSYWRpdXMgPSAwLjAwMTtcblxuICAgICAgICAvLyBBZGQgYWxsIHNlZ21lbnQgc3RhcnQgYW5kIGVuZHBvaW50c1xuICAgICAgICBmb3IgKGNvbnN0IHN0cmVhbWxpbmUgb2Ygc3RyZWFtbGluZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyZWFtbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgTm9kZShzdHJlYW1saW5lW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hZGRTZWdtZW50KHRoaXMudmVjdG9yc1RvU2VnbWVudChzdHJlYW1saW5lW2kgLSAxXSwgc3RyZWFtbGluZVtpXSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpIDwgc3RyZWFtbGluZS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYWRkU2VnbWVudCh0aGlzLnZlY3RvcnNUb1NlZ21lbnQoc3RyZWFtbGluZVtpXSwgc3RyZWFtbGluZVtpICsgMV0pKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZ1enp5QWRkVG9RdWFkdHJlZShxdWFkdHJlZSwgbm9kZSwgbm9kZUFkZFJhZGl1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgYWxsIGludGVyc2VjdGlvbnNcbiAgICAgICAgZm9yIChjb25zdCBpbnRlcnNlY3Rpb24gb2YgaW50ZXJzZWN0aW9ucykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBOb2RlKG5ldyBWZWN0b3IoaW50ZXJzZWN0aW9uLnBvaW50LngsIGludGVyc2VjdGlvbi5wb2ludC55KSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHMgb2YgaW50ZXJzZWN0aW9uLnNlZ21lbnRzKSBub2RlLmFkZFNlZ21lbnQocyk7XG4gICAgICAgICAgICB0aGlzLmZ1enp5QWRkVG9RdWFkdHJlZShxdWFkdHJlZSwgbm9kZSwgbm9kZUFkZFJhZGl1cyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb3IgZWFjaCBzaW1wbGlmaWVkIHN0cmVhbWxpbmUsIGJ1aWxkIGxpc3Qgb2Ygbm9kZXMgaW4gb3JkZXIgYWxvbmcgc3RyZWFtbGluZVxuICAgICAgICBmb3IgKGNvbnN0IHN0cmVhbWxpbmUgb2Ygc3RyZWFtbGluZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyZWFtbGluZS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub2Rlc0Fsb25nU2VnbWVudCA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0Tm9kZXNBbG9uZ1NlZ21lbnQodGhpcy52ZWN0b3JzVG9TZWdtZW50KHN0cmVhbWxpbmVbaV0sIHN0cmVhbWxpbmVbaSArIDFdKSwgcXVhZHRyZWUsIG5vZGVBZGRSYWRpdXMsIGRzdGVwKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAobm9kZXNBbG9uZ1NlZ21lbnQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vZGVzQWxvbmdTZWdtZW50Lmxlbmd0aCAtIDE7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNBbG9uZ1NlZ21lbnRbal0uYWRkTmVpZ2hib3Iobm9kZXNBbG9uZ1NlZ21lbnRbaisxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2cuZXJyb3IoXCJFcnJvciBHcmFwaC5qczogc2VnbWVudCB3aXRoIGxlc3MgdGhhbiAyIG5vZGVzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFxuICAgICAgICBmb3IgKGNvbnN0IG4gb2YgcXVhZHRyZWUuZGF0YSgpKSB7XG4gICAgICAgICAgICBpZiAoZGVsZXRlRGFuZ2xpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZURhbmdsaW5nTm9kZXMobiwgcXVhZHRyZWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG4uYWRqID0gQXJyYXkuZnJvbShuLm5laWdoYm9ycyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5vZGVzID0gcXVhZHRyZWUuZGF0YSgpO1xuICAgICAgICB0aGlzLmludGVyc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIGludGVyc2VjdGlvbnMpIHRoaXMuaW50ZXJzZWN0aW9ucy5wdXNoKG5ldyBWZWN0b3IoaS5wb2ludC54LCBpLnBvaW50LnkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZGFuZ2xpbmcgZWRnZXMgZnJvbSBncmFwaCB0byBmYWNpbGl0YXRlIHBvbHlnb24gZmluZGluZ1xuICAgICAqL1xuICAgIHByaXZhdGUgZGVsZXRlRGFuZ2xpbmdOb2RlcyhuOiBOb2RlLCBxdWFkdHJlZTogZDMuUXVhZHRyZWU8Tm9kZT4pIHtcbiAgICAgICAgaWYgKG4ubmVpZ2hib3JzLnNpemUgPT09IDEpIHtcbiAgICAgICAgICAgIHF1YWR0cmVlLnJlbW92ZShuKTtcbiAgICAgICAgICAgIGZvciAobGV0IG5laWdoYm9yIG9mIG4ubmVpZ2hib3JzKSB7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3IubmVpZ2hib3JzLmRlbGV0ZShuKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZURhbmdsaW5nTm9kZXMobmVpZ2hib3IsIHF1YWR0cmVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgc2VnbWVudCwgc3RlcCBhbG9uZyBzZWdtZW50IGFuZCBmaW5kIGFsbCBub2RlcyBhbG9uZyBpdFxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0Tm9kZXNBbG9uZ1NlZ21lbnQoc2VnbWVudDogU2VnbWVudCwgcXVhZHRyZWU6IGQzLlF1YWR0cmVlPE5vZGU+LCByYWRpdXM6IG51bWJlciwgc3RlcDogbnVtYmVyKTogTm9kZVtdIHtcbiAgICAgICAgLy8gV2FsayBkc3RlcCBhbG9uZyBlYWNoIHN0cmVhbWxpbmUsIGFkZGluZyBub2RlcyB3aXRoaW4gZHN0ZXAvMlxuICAgICAgICAvLyBhbmQgY29ubmVjdGVkIHRvIHRoaXMgc3RyZWFtbGluZSAoZnV6enkgLSBub2RlQWRkUmFkaXVzKSB0byBsaXN0LCByZW1vdmluZyBmcm9tXG4gICAgICAgIC8vIHF1YWR0cmVlIGFuZCBhZGRpbmcgdGhlbSBhbGwgYmFjayBhdCB0aGUgZW5kXG5cbiAgICAgICAgY29uc3QgZm91bmROb2RlcyA9IFtdO1xuICAgICAgICBjb25zdCBub2Rlc0Fsb25nU2VnbWVudDogTm9kZVtdID0gW107XG5cbiAgICAgICAgY29uc3Qgc3RhcnQgPSBuZXcgVmVjdG9yKHNlZ21lbnQuZnJvbS54LCBzZWdtZW50LmZyb20ueSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IG5ldyBWZWN0b3Ioc2VnbWVudC50by54LCBzZWdtZW50LnRvLnkpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgZGlmZmVyZW5jZVZlY3RvciA9IGVuZC5jbG9uZSgpLnN1YihzdGFydCk7XG4gICAgICAgIHN0ZXAgPSBNYXRoLm1pbihzdGVwLCBkaWZmZXJlbmNlVmVjdG9yLmxlbmd0aCgpIC8gMik7ICAvLyBNaW4gb2YgMiBzdGVwIGFsb25nIHZlY3RvclxuICAgICAgICBjb25zdCBzdGVwcyA9IE1hdGguY2VpbChkaWZmZXJlbmNlVmVjdG9yLmxlbmd0aCgpIC8gc3RlcCk7XG4gICAgICAgIGNvbnN0IGRpZmZlcmVuY2VWZWN0b3JMZW5ndGggPSBkaWZmZXJlbmNlVmVjdG9yLmxlbmd0aCgpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHN0ZXBzOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50UG9pbnQgPSBzdGFydC5jbG9uZSgpLmFkZChkaWZmZXJlbmNlVmVjdG9yLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoaSAvIHN0ZXBzKSk7XG5cbiAgICAgICAgICAgIC8vIE9yZGVyIG5vZGVzLCBub3QgYnkgJ2Nsb3NlbmVzcycsIGJ1dCBieSBkb3QgcHJvZHVjdFxuICAgICAgICAgICAgbGV0IG5vZGVzVG9BZGQgPSBbXTtcbiAgICAgICAgICAgIGxldCBjbG9zZXN0Tm9kZSA9IHF1YWR0cmVlLmZpbmQoY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55LCByYWRpdXMgKyBzdGVwLzIpO1xuXG4gICAgICAgICAgICB3aGlsZSAoY2xvc2VzdE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1YWR0cmVlLnJlbW92ZShjbG9zZXN0Tm9kZSk7XG4gICAgICAgICAgICAgICAgZm91bmROb2Rlcy5wdXNoKGNsb3Nlc3ROb2RlKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBsZXQgbm9kZU9uU2VnbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHMgb2YgY2xvc2VzdE5vZGUuc2VnbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZnV6enlTZWdtZW50c0VxdWFsKHMsIHNlZ21lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlT25TZWdtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVPblNlZ21lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNUb0FkZC5wdXNoKGNsb3Nlc3ROb2RlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjbG9zZXN0Tm9kZSA9IHF1YWR0cmVlLmZpbmQoY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55LCByYWRpdXMgKyBzdGVwLzIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2Rlc1RvQWRkLnNvcnQoKGZpcnN0OiBOb2RlLCBzZWNvbmQ6IE5vZGUpID0+XG4gICAgICAgICAgICAgICAgdGhpcy5kb3RQcm9kdWN0VG9TZWdtZW50KGZpcnN0LCBzdGFydCwgZGlmZmVyZW5jZVZlY3RvcikgLSB0aGlzLmRvdFByb2R1Y3RUb1NlZ21lbnQoc2Vjb25kLCBzdGFydCwgZGlmZmVyZW5jZVZlY3RvcikpO1xuICAgICAgICAgICAgbm9kZXNBbG9uZ1NlZ21lbnQucHVzaCguLi5ub2Rlc1RvQWRkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHF1YWR0cmVlLmFkZEFsbChmb3VuZE5vZGVzKTtcbiAgICAgICAgcmV0dXJuIG5vZGVzQWxvbmdTZWdtZW50O1xuICAgIH1cblxuICAgIHByaXZhdGUgZnV6enlTZWdtZW50c0VxdWFsKHMxOiBTZWdtZW50LCBzMjogU2VnbWVudCwgdG9sZXJhbmNlPTAuMDAwMSk6IGJvb2xlYW4ge1xuICAgICAgICAvLyBGcm9tXG4gICAgICAgIGlmIChzMS5mcm9tLnggLSBzMi5mcm9tLnggPiB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzMS5mcm9tLnkgLSBzMi5mcm9tLnkgPiB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRvXG5cbiAgICAgICAgaWYgKHMxLnRvLnggLSBzMi50by54ID4gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoczEudG8ueSAtIHMyLnRvLnkgPiB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgZG90UHJvZHVjdFRvU2VnbWVudChub2RlOiBOb2RlLCBzdGFydDogVmVjdG9yLCBkaWZmZXJlbmNlVmVjdG9yOiBWZWN0b3IpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBkb3RWZWN0b3IgPSBub2RlLnZhbHVlLmNsb25lKCkuc3ViKHN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIGRpZmZlcmVuY2VWZWN0b3IuZG90KGRvdFZlY3Rvcik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBmdXp6eUFkZFRvUXVhZHRyZWUocXVhZHRyZWU6IGQzLlF1YWR0cmVlPE5vZGU+LCBub2RlOiBOb2RlLCByYWRpdXM6IG51bWJlcik6IHZvaWQge1xuICAgICAgICAvLyBPbmx5IGFkZCBpZiB0aGVyZSBpc24ndCBhIG5vZGUgd2l0aGluIHJhZGl1c1xuICAgICAgICAvLyBSZW1lbWJlciB0byBjaGVjayBmb3IgZG91YmxlIHJhZGl1cyB3aGVuIHF1ZXJ5aW5nIHRyZWUsIG9yIHBvaW50IG1pZ2h0IGJlIG1pc3NlZFxuICAgICAgICBjb25zdCBleGlzdGluZ05vZGUgPSBxdWFkdHJlZS5maW5kKG5vZGUudmFsdWUueCwgbm9kZS52YWx1ZS55LCByYWRpdXMpO1xuICAgICAgICBpZiAoZXhpc3RpbmdOb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHF1YWR0cmVlLmFkZChub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmVpZ2hib3Igb2Ygbm9kZS5uZWlnaGJvcnMpIGV4aXN0aW5nTm9kZS5hZGROZWlnaGJvcihuZWlnaGJvcik7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygbm9kZS5zZWdtZW50cykgZXhpc3RpbmdOb2RlLmFkZFNlZ21lbnQoc2VnbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0cmVhbWxpbmVzVG9TZWdtZW50KHN0cmVhbWxpbmVzOiBWZWN0b3JbXVtdKTogU2VnbWVudFtdIHtcbiAgICAgICAgY29uc3Qgb3V0OiBTZWdtZW50W10gPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIHN0cmVhbWxpbmVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2godGhpcy52ZWN0b3JzVG9TZWdtZW50KHNbaV0sIHNbaSArIDFdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIHByaXZhdGUgdmVjdG9yc1RvU2VnbWVudCh2MTogVmVjdG9yLCB2MjogVmVjdG9yKTogU2VnbWVudCB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmcm9tOiB2MSxcbiAgICAgICAgICAgIHRvOiAgIHYyXG4gICAgICAgIH07XG4gICAgfVxufVxuIiwiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0ICogYXMgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcblxuLyoqXG4gKiBDYXJ0ZXNpYW4gZ3JpZCBhY2NlbGVyYXRlZCBkYXRhIHN0cnVjdHVyZVxuICogR3JpZCBvZiBjZWxscywgZWFjaCBjb250YWluaW5nIGEgbGlzdCBvZiB2ZWN0b3JzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyaWRTdG9yYWdlIHtcblxuICAgIHByaXZhdGUgZ3JpZERpbWVuc2lvbnM6IFZlY3RvcjtcbiAgICBwcml2YXRlIGdyaWQ6IFZlY3RvcltdW11bXTtcbiAgICBwcml2YXRlIGRzZXBTcTogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogd29ybGREaW1lbnNpb25zIGFzc3VtZXMgb3JpZ2luIG9mIDAsMFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkc2VwIFNlcGFyYXRpb24gZGlzdGFuY2UgYmV0d2VlbiBzYW1wbGVzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IgKHByaXZhdGUgd29ybGREaW1lbnNpb25zOiBWZWN0b3IsIHByaXZhdGUgb3JpZ2luOiBWZWN0b3IsIHByaXZhdGUgZHNlcDogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuZHNlcFNxID0gdGhpcy5kc2VwICogdGhpcy5kc2VwO1xuICAgICAgICB0aGlzLmdyaWREaW1lbnNpb25zID0gd29ybGREaW1lbnNpb25zLmNsb25lKCkuZGl2aWRlU2NhbGFyKHRoaXMuZHNlcCk7XG4gICAgICAgIHRoaXMuZ3JpZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuZ3JpZERpbWVuc2lvbnMueDsgeCsrKSB7XG4gICAgICAgICAgICB0aGlzLmdyaWQucHVzaChbXSk7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuZ3JpZERpbWVuc2lvbnMueTsgeSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkW3hdLnB1c2goW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGFsbCBzYW1wbGVzIGZyb20gYW5vdGhlciBncmlkIHRvIHRoaXMgb25lXG4gICAgICovXG4gICAgYWRkQWxsKGdyaWRTdG9yYWdlOiBHcmlkU3RvcmFnZSk6IHZvaWQge1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiBncmlkU3RvcmFnZS5ncmlkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNlbGwgb2Ygcm93KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzYW1wbGUgb2YgY2VsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFNhbXBsZShzYW1wbGUpOyAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkUG9seWxpbmUobGluZTogVmVjdG9yW10pOiB2b2lkIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIGxpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkU2FtcGxlKHYpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBlbmZvcmNlIHNlcGFyYXRpb25cbiAgICAgKiBEb2VzIG5vdCBjbG9uZVxuICAgICAqL1xuICAgIGFkZFNhbXBsZSh2OiBWZWN0b3IsIGNvb3Jkcz86IFZlY3Rvcik6IHZvaWQge1xuICAgICAgICBpZiAoIWNvb3Jkcykge1xuICAgICAgICAgICAgY29vcmRzID0gdGhpcy5nZXRTYW1wbGVDb29yZHModik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncmlkW2Nvb3Jkcy54XVtjb29yZHMueV0ucHVzaCh2KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyB3aGV0aGVyIHYgaXMgYXQgbGVhc3QgZCBhd2F5IGZyb20gc2FtcGxlc1xuICAgICAqIFBlcmZvcm1hbmNlIHZlcnkgaW1wb3J0YW50IC0gdGhpcyBpcyBjYWxsZWQgYXQgZXZlcnkgaW50ZWdyYXRpb24gc3RlcFxuICAgICAqIEBwYXJhbSBkU3E9dGhpcy5kc2VwU3Egc3F1YXJlZCB0ZXN0IGRpc3RhbmNlXG4gICAgICogQ291bGQgYmUgZHRlc3QgaWYgd2UgYXJlIGludGVncmF0aW5nIGEgc3RyZWFtbGluZVxuICAgICAqL1xuICAgIGlzVmFsaWRTYW1wbGUodjogVmVjdG9yLCBkU3E9dGhpcy5kc2VwU3EpOiBib29sZWFuIHtcbiAgICAgICAgLy8gQ29kZSBkdXBsaWNhdGlvbiB3aXRoIHRoaXMuZ2V0TmVhcmJ5UG9pbnRzIGJ1dCBtdWNoIHNsb3dlciB3aGVuIGNhbGxpbmdcbiAgICAgICAgLy8gdGhpcy5nZXROZWFyYnlQb2ludHMgZHVlIHRvIGFycmF5IGNyZWF0aW9uIGluIHRoYXQgbWV0aG9kXG5cbiAgICAgICAgY29uc3QgY29vcmRzID0gdGhpcy5nZXRTYW1wbGVDb29yZHModik7XG5cbiAgICAgICAgLy8gQ2hlY2sgc2FtcGxlcyBpbiA5IGNlbGxzIGluIDN4MyBncmlkXG4gICAgICAgIGZvciAobGV0IHggPSAtMTsgeCA8PSAxOyB4KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAtMTsgeSA8PSAxOyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gY29vcmRzLmNsb25lKCkuYWRkKG5ldyBWZWN0b3IoeCwgeSkpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy52ZWN0b3JPdXRPZkJvdW5kcyhjZWxsLCB0aGlzLmdyaWREaW1lbnNpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMudmVjdG9yRmFyRnJvbVZlY3RvcnModiwgdGhpcy5ncmlkW2NlbGwueF1bY2VsbC55XSwgZFNxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIFRlc3Qgd2hldGhlciB2IGlzIGF0IGxlYXN0IGQgYXdheSBmcm9tIHZlY3RvcnNcbiAgICAgKiBQZXJmb3JtYW5jZSB2ZXJ5IGltcG9ydGFudCAtIHRoaXMgaXMgY2FsbGVkIGF0IGV2ZXJ5IGludGVncmF0aW9uIHN0ZXBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gICBkU3EgICAgIHNxdWFyZWQgdGVzdCBkaXN0YW5jZVxuICAgICAqL1xuICAgIHZlY3RvckZhckZyb21WZWN0b3JzKHY6IFZlY3RvciwgdmVjdG9yczogVmVjdG9yW10sIGRTcTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIGZvciAoY29uc3Qgc2FtcGxlIG9mIHZlY3RvcnMpIHtcbiAgICAgICAgICAgIGlmIChzYW1wbGUgIT09IHYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZVNxID0gc2FtcGxlLmRpc3RhbmNlVG9TcXVhcmVkKHYpO1xuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZVNxIDwgZFNxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHBvaW50cyBpbiBjZWxscyBzdXJyb3VuZGluZyB2XG4gICAgICogUmVzdWx0cyBpbmNsdWRlIHYsIGlmIGl0IGV4aXN0cyBpbiB0aGUgZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXR1cm5zIHNhbXBsZXMgKGtpbmQgb2YpIGNsb3NlciB0aGFuIGRpc3RhbmNlIC0gcmV0dXJucyBhbGwgc2FtcGxlcyBpbiBcbiAgICAgKiBjZWxscyBzbyBhcHByb3hpbWF0aW9uIChzcXVhcmUgdG8gYXBwcm94aW1hdGUgY2lyY2xlKVxuICAgICAqL1xuICAgIGdldE5lYXJieVBvaW50cyh2OiBWZWN0b3IsIGRpc3RhbmNlOiBudW1iZXIpOiBWZWN0b3JbXSB7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IE1hdGguY2VpbCgoZGlzdGFuY2UvdGhpcy5kc2VwKSAtIDAuNSk7XG4gICAgICAgIGNvbnN0IGNvb3JkcyA9IHRoaXMuZ2V0U2FtcGxlQ29vcmRzKHYpO1xuICAgICAgICBjb25zdCBvdXQ6IFZlY3RvcltdID0gW107XG4gICAgICAgIGZvciAobGV0IHggPSAtMSAqIHJhZGl1czsgeCA8PSAxICogcmFkaXVzOyB4KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAtMSAqIHJhZGl1czsgeSA8PSAxICogcmFkaXVzOyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gY29vcmRzLmNsb25lKCkuYWRkKG5ldyBWZWN0b3IoeCwgeSkpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy52ZWN0b3JPdXRPZkJvdW5kcyhjZWxsLCB0aGlzLmdyaWREaW1lbnNpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYyIG9mIHRoaXMuZ3JpZFtjZWxsLnhdW2NlbGwueV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKHYyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB3b3JsZFRvR3JpZCh2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gdi5jbG9uZSgpLnN1Yih0aGlzLm9yaWdpbik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBncmlkVG9Xb3JsZCh2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gdi5jbG9uZSgpLmFkZCh0aGlzLm9yaWdpbik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB2ZWN0b3JPdXRPZkJvdW5kcyhncmlkVjogVmVjdG9yLCBib3VuZHM6IFZlY3Rvcik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKGdyaWRWLnggPCAwIHx8IGdyaWRWLnkgPCAwIHx8XG4gICAgICAgICAgICBncmlkVi54ID49IGJvdW5kcy54IHx8IGdyaWRWLnkgPj0gYm91bmRzLnkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1ZlY3Rvcn0gICBDZWxsIGNvb3JkcyBjb3JyZXNwb25kaW5nIHRvIHZlY3RvclxuICAgICAqIFBlcmZvcm1hbmNlIGltcG9ydGFudCAtIGNhbGxlZCBhdCBldmVyeSBpbnRlZ3JhdGlvbiBzdGVwXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXRTYW1wbGVDb29yZHMod29ybGRWOiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICBjb25zdCB2ID0gdGhpcy53b3JsZFRvR3JpZCh3b3JsZFYpO1xuICAgICAgICBpZiAodGhpcy52ZWN0b3JPdXRPZkJvdW5kcyh2LCB0aGlzLndvcmxkRGltZW5zaW9ucykpIHtcbiAgICAgICAgICAgIC8vIGxvZy5lcnJvcihcIlRyaWVkIHRvIGFjY2VzcyBvdXQtb2YtYm91bmRzIHNhbXBsZSBpbiBncmlkXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFZlY3Rvci56ZXJvVmVjdG9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihcbiAgICAgICAgICAgIE1hdGguZmxvb3Iodi54IC8gdGhpcy5kc2VwKSxcbiAgICAgICAgICAgIE1hdGguZmxvb3Iodi55IC8gdGhpcy5kc2VwKVxuICAgICAgICApO1xuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCBUZW5zb3JGaWVsZCBmcm9tICcuL3RlbnNvcl9maWVsZCc7XG5pbXBvcnQgVmVjdG9yIGZyb20gJy4uL3ZlY3Rvcic7XG5pbXBvcnQge1N0cmVhbWxpbmVQYXJhbXN9IGZyb20gJy4vc3RyZWFtbGluZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBGaWVsZEludGVncmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBmaWVsZDogVGVuc29yRmllbGQpIHt9XG5cbiAgICBhYnN0cmFjdCBpbnRlZ3JhdGUocG9pbnQ6IFZlY3RvciwgbWFqb3I6IGJvb2xlYW4pOiBWZWN0b3I7XG5cbiAgICBwcm90ZWN0ZWQgc2FtcGxlRmllbGRWZWN0b3IocG9pbnQ6IFZlY3RvciwgbWFqb3I6IGJvb2xlYW4pOiBWZWN0b3Ige1xuICAgICAgICBjb25zdCB0ZW5zb3IgPSB0aGlzLmZpZWxkLnNhbXBsZVBvaW50KHBvaW50KTtcbiAgICAgICAgaWYgKG1ham9yKSByZXR1cm4gdGVuc29yLmdldE1ham9yKCk7XG4gICAgICAgIHJldHVybiB0ZW5zb3IuZ2V0TWlub3IoKTtcbiAgICB9XG5cbiAgICBvbkxhbmQocG9pbnQ6IFZlY3Rvcik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZC5vbkxhbmQocG9pbnQpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEV1bGVySW50ZWdyYXRvciBleHRlbmRzIEZpZWxkSW50ZWdyYXRvciB7XG4gICAgY29uc3RydWN0b3IoZmllbGQ6IFRlbnNvckZpZWxkLCBwcml2YXRlIHBhcmFtczogU3RyZWFtbGluZVBhcmFtcykge1xuICAgICAgICBzdXBlcihmaWVsZCk7XG4gICAgfVxuXG4gICAgaW50ZWdyYXRlKHBvaW50OiBWZWN0b3IsIG1ham9yOiBib29sZWFuKTogVmVjdG9yIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FtcGxlRmllbGRWZWN0b3IocG9pbnQsIG1ham9yKS5tdWx0aXBseVNjYWxhcih0aGlzLnBhcmFtcy5kc3RlcCk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgUks0SW50ZWdyYXRvciBleHRlbmRzIEZpZWxkSW50ZWdyYXRvciB7XG4gICAgY29uc3RydWN0b3IoZmllbGQ6IFRlbnNvckZpZWxkLCBwcml2YXRlIHBhcmFtczogU3RyZWFtbGluZVBhcmFtcykge1xuICAgICAgICBzdXBlcihmaWVsZCk7XG4gICAgfVxuXG4gICAgaW50ZWdyYXRlKHBvaW50OiBWZWN0b3IsIG1ham9yOiBib29sZWFuKTogVmVjdG9yIHtcbiAgICAgICAgY29uc3QgazEgPSB0aGlzLnNhbXBsZUZpZWxkVmVjdG9yKHBvaW50LCBtYWpvcik7XG4gICAgICAgIGNvbnN0IGsyMyA9IHRoaXMuc2FtcGxlRmllbGRWZWN0b3IocG9pbnQuY2xvbmUoKS5hZGQoVmVjdG9yLmZyb21TY2FsYXIodGhpcy5wYXJhbXMuZHN0ZXAgLyAyKSksIG1ham9yKTtcbiAgICAgICAgY29uc3QgazQgPSB0aGlzLnNhbXBsZUZpZWxkVmVjdG9yKHBvaW50LmNsb25lKCkuYWRkKFZlY3Rvci5mcm9tU2NhbGFyKHRoaXMucGFyYW1zLmRzdGVwKSksIG1ham9yKTtcblxuICAgICAgICByZXR1cm4gazEuYWRkKGsyMy5tdWx0aXBseVNjYWxhcig0KSkuYWRkKGs0KS5tdWx0aXBseVNjYWxhcih0aGlzLnBhcmFtcy5kc3RlcCAvIDYpO1xuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCAqIGFzIGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgVmVjdG9yIGZyb20gJy4uL3ZlY3Rvcic7XG5pbXBvcnQge05vZGV9IGZyb20gJy4vZ3JhcGgnO1xuaW1wb3J0IFBvbHlnb25VdGlsIGZyb20gJy4vcG9seWdvbl91dGlsJztcbmltcG9ydCBUZW5zb3JGaWVsZCBmcm9tICcuL3RlbnNvcl9maWVsZCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUG9seWdvblBhcmFtcyB7XG4gICAgbWF4TGVuZ3RoOiBudW1iZXI7XG4gICAgbWluQXJlYTogbnVtYmVyO1xuICAgIHNocmlua1NwYWNpbmc6IG51bWJlcjtcbiAgICBjaGFuY2VOb0RpdmlkZTogbnVtYmVyO1xufVxuXG4vKipcbiAqIEZpbmRzIHBvbHlnb25zIGluIGEgZ3JhcGgsIHVzZWQgZm9yIGZpbmRpbmcgbG90cyBhbmQgcGFya3NcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9seWdvbkZpbmRlciB7XG4gICAgcHJpdmF0ZSBfcG9seWdvbnM6IFZlY3RvcltdW10gPSBbXTtcbiAgICBwcml2YXRlIF9zaHJ1bmtQb2x5Z29uczogVmVjdG9yW11bXSA9IFtdO1xuICAgIHByaXZhdGUgX2RpdmlkZWRQb2x5Z29uczogVmVjdG9yW11bXSA9IFtdO1xuICAgIHByaXZhdGUgdG9TaHJpbms6IFZlY3RvcltdW10gPSBbXTtcbiAgICBwcml2YXRlIHJlc29sdmVTaHJpbms6ICgpID0+IHZvaWQ7XG4gICAgcHJpdmF0ZSB0b0RpdmlkZTogVmVjdG9yW11bXSA9IFtdO1xuICAgIHByaXZhdGUgcmVzb2x2ZURpdmlkZTogKCkgPT4gdm9pZDtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgbm9kZXM6IE5vZGVbXSwgcHJpdmF0ZSBwYXJhbXM6IFBvbHlnb25QYXJhbXMsIHByaXZhdGUgdGVuc29yRmllbGQ6IFRlbnNvckZpZWxkKSB7fVxuXG4gICAgZ2V0IHBvbHlnb25zKCk6IFZlY3RvcltdW10ge1xuICAgICAgICBpZiAodGhpcy5fZGl2aWRlZFBvbHlnb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXZpZGVkUG9seWdvbnM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fc2hydW5rUG9seWdvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NocnVua1BvbHlnb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbHlnb25zO1xuICAgIH1cblxuICAgIHJlc2V0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLnRvU2hyaW5rID0gW107XG4gICAgICAgIHRoaXMudG9EaXZpZGUgPSBbXTtcbiAgICAgICAgdGhpcy5fcG9seWdvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5fc2hydW5rUG9seWdvbnMgPSBbXVxuICAgICAgICB0aGlzLl9kaXZpZGVkUG9seWdvbnMgPSBbXTtcbiAgICB9XG5cbiAgICB1cGRhdGUoKTogYm9vbGVhbiB7XG4gICAgICAgIGxldCBjaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMudG9TaHJpbmsubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZSA9IHRoaXMudG9TaHJpbmsubGVuZ3RoID09PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RlcFNocmluayh0aGlzLnRvU2hyaW5rLnBvcCgpKSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChyZXNvbHZlKSB0aGlzLnJlc29sdmVTaHJpbmsoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnRvRGl2aWRlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmUgPSB0aGlzLnRvRGl2aWRlLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0ZXBEaXZpZGUodGhpcy50b0RpdmlkZS5wb3AoKSkpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVzb2x2ZSkgdGhpcy5yZXNvbHZlRGl2aWRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJseSBzaHJpbmsgcG9seWdvbiBzbyB0aGUgZWRnZXMgYXJlIGFsbCB0aGUgc2FtZSBkaXN0YW5jZSBmcm9tIHRoZSByb2FkXG4gICAgICovXG4gICAgYXN5bmMgc2hyaW5rKGFuaW1hdGU9ZmFsc2UpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BvbHlnb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmluZFBvbHlnb25zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChhbmltYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3BvbHlnb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnRvU2hyaW5rID0gdGhpcy5fcG9seWdvbnMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVTaHJpbmsgPSByZXNvbHZlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaHJ1bmtQb2x5Z29ucyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBvZiB0aGlzLl9wb2x5Z29ucykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0ZXBTaHJpbmsocCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGVwU2hyaW5rKHBvbHlnb246IFZlY3RvcltdKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IHNocnVuayA9IFBvbHlnb25VdGlsLnJlc2l6ZUdlb21ldHJ5KHBvbHlnb24sIC10aGlzLnBhcmFtcy5zaHJpbmtTcGFjaW5nKTtcbiAgICAgICAgaWYgKHNocnVuay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9zaHJ1bmtQb2x5Z29ucy5wdXNoKHNocnVuaylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBhc3luYyBkaXZpZGUoYW5pbWF0ZT1mYWxzZSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4ocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcG9seWdvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5kUG9seWdvbnMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHBvbHlnb25zID0gdGhpcy5fcG9seWdvbnM7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2hydW5rUG9seWdvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHBvbHlnb25zID0gdGhpcy5fc2hydW5rUG9seWdvbnM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhbmltYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvbHlnb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnRvRGl2aWRlID0gcG9seWdvbnMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVEaXZpZGUgPSByZXNvbHZlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXZpZGVkUG9seWdvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgcG9seWdvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGVwRGl2aWRlKHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RlcERpdmlkZShwb2x5Z29uOiBWZWN0b3JbXSk6IGJvb2xlYW4ge1xuICAgICAgICAvLyBUT0RPIG5lZWQgdG8gZmlsdGVyIHNocnVuayBwb2x5Z29ucyB1c2luZyBhc3BlY3QgcmF0aW8sIGFyZWEgXG4gICAgICAgIC8vIHRoaXMgc2tpcHMgdGhlIGZpbHRlciBpbiBQb2x5Z29uVXRpbC5zdWJkaXZpZGVQb2x5Z29uXG4gICAgICAgIGlmICh0aGlzLnBhcmFtcy5jaGFuY2VOb0RpdmlkZSA+IDAgJiYgTWF0aC5yYW5kb20oKSA8IHRoaXMucGFyYW1zLmNoYW5jZU5vRGl2aWRlKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXZpZGVkUG9seWdvbnMucHVzaChwb2x5Z29uKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpdmlkZWQgPSBQb2x5Z29uVXRpbC5zdWJkaXZpZGVQb2x5Z29uKHBvbHlnb24sIHRoaXMucGFyYW1zLm1pbkFyZWEpO1xuICAgICAgICBpZiAoZGl2aWRlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXZpZGVkUG9seWdvbnMucHVzaCguLi5kaXZpZGVkKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmaW5kUG9seWdvbnMoKTogdm9pZCB7XG4gICAgICAgIC8vIE5vZGVcbiAgICAgICAgLy8geCwgeSwgdmFsdWUgKFZlY3RvcjIpLCBhZGogKGxpc3Qgb2Ygbm9kZSByZWZzKVxuICAgICAgICAvLyBHb25uYSBlZGl0IGFkaiBmb3Igbm93XG5cbiAgICAgICAgLy8gV2FsayBhIGNsb2Nrd2lzZSBwYXRoIHVudGlsIHBvbHlnb24gZm91bmQgb3IgbGltaXQgcmVhY2hlZFxuICAgICAgICAvLyBXaGVuIHdlIGZpbmQgYSBwb2x5Z29uLCBtYXJrIGFsbCBlZGdlcyBhcyB0cmF2ZXJzZWQgKGluIHBhcnRpY3VsYXIgZGlyZWN0aW9uKVxuICAgICAgICAvLyBFYWNoIGVkZ2Ugc2VwYXJhdGVzIHR3byBwb2x5Z29uc1xuICAgICAgICAvLyBJZiBlZGdlIGFscmVhZHkgdHJhdmVyc2VkIGluIHRoaXMgZGlyZWN0aW9uLCB0aGlzIHBvbHlnb24gaGFzIGFscmVhZHkgYmVlbiBmb3VuZFxuICAgICAgICB0aGlzLl9zaHJ1bmtQb2x5Z29ucyA9IFtdO1xuICAgICAgICB0aGlzLl9kaXZpZGVkUG9seWdvbnMgPSBbXTtcbiAgICAgICAgY29uc3QgcG9seWdvbnMgPSBbXTtcblxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5ub2Rlcykge1xuICAgICAgICAgICAgaWYgKG5vZGUuYWRqLmxlbmd0aCA8IDIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBuZXh0Tm9kZSBvZiBub2RlLmFkaikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvbHlnb24gPSB0aGlzLnJlY3Vyc2l2ZVdhbGsoW25vZGUsIG5leHROb2RlXSk7XG4gICAgICAgICAgICAgICAgaWYgKHBvbHlnb24gIT09IG51bGwgJiYgcG9seWdvbi5sZW5ndGggPCB0aGlzLnBhcmFtcy5tYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVQb2x5Z29uQWRqYWNlbmNpZXMocG9seWdvbik7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25zLnB1c2gocG9seWdvbi5tYXAobiA9PiBuLnZhbHVlLmNsb25lKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wb2x5Z29ucyA9IHRoaXMuZmlsdGVyUG9seWdvbnNCeVdhdGVyKHBvbHlnb25zKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGZpbHRlclBvbHlnb25zQnlXYXRlcihwb2x5Z29uczogVmVjdG9yW11bXSk6IFZlY3RvcltdW10ge1xuICAgICAgICBjb25zdCBvdXQ6IFZlY3RvcltdW10gPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHBvbHlnb25zKSB7XG4gICAgICAgICAgICBjb25zdCBhdmVyYWdlUG9pbnQgPSBQb2x5Z29uVXRpbC5hdmVyYWdlUG9pbnQocCk7XG4gICAgICAgICAgICBpZiAodGhpcy50ZW5zb3JGaWVsZC5vbkxhbmQoYXZlcmFnZVBvaW50KSAmJiAhdGhpcy50ZW5zb3JGaWVsZC5pblBhcmtzKGF2ZXJhZ2VQb2ludCkpIG91dC5wdXNoKHApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZW1vdmVQb2x5Z29uQWRqYWNlbmNpZXMocG9seWdvbjogTm9kZVtdKTogdm9pZCB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9seWdvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHBvbHlnb25baV07XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gcG9seWdvblsoaSArIDEpICUgcG9seWdvbi5sZW5ndGhdO1xuXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGN1cnJlbnQuYWRqLmluZGV4T2YobmV4dCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQuYWRqLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZy5lcnJvcihcIlBvbHlnb25GaW5kZXIgLSBub2RlIG5vdCBpbiBhZGpcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHJlY3Vyc2l2ZVdhbGsodmlzaXRlZDogTm9kZVtdLCBjb3VudD0wKTogTm9kZVtdIHtcbiAgICAgICAgaWYgKGNvdW50ID49IHRoaXMucGFyYW1zLm1heExlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgICAgIC8vIFRPRE8gYmFja3RyYWNraW5nIHRvIGZpbmQgcG9seWdvbnMgd2l0aCBkZWFkIGVuZCByb2FkcyBpbnNpZGUgdGhlbVxuICAgICAgICBjb25zdCBuZXh0Tm9kZSA9IHRoaXMuZ2V0UmlnaHRtb3N0Tm9kZSh2aXNpdGVkW3Zpc2l0ZWQubGVuZ3RoIC0gMl0sIHZpc2l0ZWRbdmlzaXRlZC5sZW5ndGggLSAxXSk7XG4gICAgICAgIGlmIChuZXh0Tm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7ICAvLyBDdXJyZW50bHkgaWdub3JlcyBwb2x5Z29ucyB3aXRoIGRlYWQgZW5kIGluc2lkZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdmlzaXRlZEluZGV4ID0gdmlzaXRlZC5pbmRleE9mKG5leHROb2RlKTtcbiAgICAgICAgaWYgKHZpc2l0ZWRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRlZC5zbGljZSh2aXNpdGVkSW5kZXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlzaXRlZC5wdXNoKG5leHROb2RlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlY3Vyc2l2ZVdhbGsodmlzaXRlZCwgY291bnQrKyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFJpZ2h0bW9zdE5vZGUobm9kZUZyb206IE5vZGUsIG5vZGVUbzogTm9kZSk6IE5vZGUge1xuICAgICAgICAvLyBXZSB3YW50IHRvIHR1cm4gcmlnaHQgYXQgZXZlcnkganVuY3Rpb25cbiAgICAgICAgaWYgKG5vZGVUby5hZGoubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBjb25zdCBiYWNrd2FyZHNEaWZmZXJlbmNlVmVjdG9yID0gbm9kZUZyb20udmFsdWUuY2xvbmUoKS5zdWIobm9kZVRvLnZhbHVlKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtQW5nbGUgPSBNYXRoLmF0YW4yKGJhY2t3YXJkc0RpZmZlcmVuY2VWZWN0b3IueSwgYmFja3dhcmRzRGlmZmVyZW5jZVZlY3Rvci54KTtcblxuICAgICAgICBsZXQgcmlnaHRtb3N0Tm9kZSA9IG51bGw7XG4gICAgICAgIGxldCBzbWFsbGVzdFRoZXRhID0gTWF0aC5QSSAqIDI7XG5cbiAgICAgICAgZm9yIChjb25zdCBuZXh0Tm9kZSBvZiBub2RlVG8uYWRqKSB7XG4gICAgICAgICAgICBpZiAobmV4dE5vZGUgIT09IG5vZGVGcm9tKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFZlY3RvciA9IG5leHROb2RlLnZhbHVlLmNsb25lKCkuc3ViKG5vZGVUby52YWx1ZSk7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRBbmdsZSA9IE1hdGguYXRhbjIobmV4dFZlY3Rvci55LCBuZXh0VmVjdG9yLngpIC0gdHJhbnNmb3JtQW5nbGU7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRBbmdsZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dEFuZ2xlICs9IE1hdGguUEkgKiAyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChuZXh0QW5nbGUgPCBzbWFsbGVzdFRoZXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHNtYWxsZXN0VGhldGEgPSBuZXh0QW5nbGU7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0bW9zdE5vZGUgPSBuZXh0Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmlnaHRtb3N0Tm9kZTtcbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0ICogYXMgUG9seUsgZnJvbSAncG9seWsnO1xuaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xuaW1wb3J0ICogYXMgIGdlb20gZnJvbSAnanN0cy9vcmcvbG9jYXRpb250ZWNoL2p0cy9nZW9tLmpzJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvbHlnb25VdGlsIHtcbiAgICBwcml2YXRlIHN0YXRpYyBnZW9tZXRyeUZhY3RvcnkgPSBuZXcganN0cy5nZW9tLkdlb21ldHJ5RmFjdG9yeSgpO1xuICAgIC8qKlxuICAgICAqIFNsaWNlcyByZWN0YW5nbGUgYnkgbGluZSwgcmV0dXJuaW5nIHNtYWxsZXN0IHBvbHlnb25cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHNsaWNlUmVjdGFuZ2xlKG9yaWdpbjogVmVjdG9yLCB3b3JsZERpbWVuc2lvbnM6IFZlY3RvciwgcDE6IFZlY3RvciwgcDI6IFZlY3Rvcik6IFZlY3RvcltdIHtcbiAgICAgICAgY29uc3QgcmVjdGFuZ2xlID0gW1xuICAgICAgICAgICAgb3JpZ2luLngsIG9yaWdpbi55LFxuICAgICAgICAgICAgb3JpZ2luLnggKyB3b3JsZERpbWVuc2lvbnMueCwgb3JpZ2luLnksXG4gICAgICAgICAgICBvcmlnaW4ueCArIHdvcmxkRGltZW5zaW9ucy54LCBvcmlnaW4ueSArIHdvcmxkRGltZW5zaW9ucy55LFxuICAgICAgICAgICAgb3JpZ2luLngsIG9yaWdpbi55ICsgd29ybGREaW1lbnNpb25zLnksXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHNsaWNlZCA9IFBvbHlLLlNsaWNlKHJlY3RhbmdsZSwgcDEueCwgcDEueSwgcDIueCwgcDIueSkubWFwKHAgPT4gUG9seWdvblV0aWwucG9seWdvbkFycmF5VG9Qb2x5Z29uKHApKTtcbiAgICAgICAgY29uc3QgbWluQXJlYSA9IFBvbHlnb25VdGlsLmNhbGNQb2x5Z29uQXJlYShzbGljZWRbMF0pO1xuXG4gICAgICAgIGlmIChzbGljZWQubGVuZ3RoID4gMSAmJiBQb2x5Z29uVXRpbC5jYWxjUG9seWdvbkFyZWEoc2xpY2VkWzFdKSA8IG1pbkFyZWEpIHtcbiAgICAgICAgICAgIHJldHVybiBzbGljZWRbMV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2xpY2VkWzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gY3JlYXRlIHNlYSBwb2x5Z29uXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBsaW5lUmVjdGFuZ2xlUG9seWdvbkludGVyc2VjdGlvbihvcmlnaW46IFZlY3Rvciwgd29ybGREaW1lbnNpb25zOiBWZWN0b3IsIGxpbmU6IFZlY3RvcltdKTogVmVjdG9yW10ge1xuICAgICAgICBjb25zdCBqc3RzTGluZSA9IFBvbHlnb25VdGlsLmxpbmVUb0p0cyhsaW5lKTtcbiAgICAgICAgY29uc3QgYm91bmRzID0gW1xuICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgbmV3IFZlY3RvcihvcmlnaW4ueCArIHdvcmxkRGltZW5zaW9ucy54LCBvcmlnaW4ueSksXG4gICAgICAgICAgICBuZXcgVmVjdG9yKG9yaWdpbi54ICsgd29ybGREaW1lbnNpb25zLngsIG9yaWdpbi55ICsgd29ybGREaW1lbnNpb25zLnkpLFxuICAgICAgICAgICAgbmV3IFZlY3RvcihvcmlnaW4ueCwgb3JpZ2luLnkgKyB3b3JsZERpbWVuc2lvbnMueSksXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGJvdW5kaW5nUG9seSA9IFBvbHlnb25VdGlsLnBvbHlnb25Ub0p0cyhib3VuZHMpO1xuICAgICAgICBjb25zdCB1bmlvbiA9IGJvdW5kaW5nUG9seS5nZXRFeHRlcmlvclJpbmcoKS51bmlvbihqc3RzTGluZSk7XG4gICAgICAgIGNvbnN0IHBvbHlnb25pemVyID0gbmV3IChqc3RzLm9wZXJhdGlvbiBhcyBhbnkpLnBvbHlnb25pemUuUG9seWdvbml6ZXIoKTtcbiAgICAgICAgcG9seWdvbml6ZXIuYWRkKHVuaW9uKTtcbiAgICAgICAgY29uc3QgcG9seWdvbnMgPSBwb2x5Z29uaXplci5nZXRQb2x5Z29ucygpO1xuXG4gICAgICAgIGxldCBzbWFsbGVzdEFyZWEgPSBJbmZpbml0eTtcbiAgICAgICAgbGV0IHNtYWxsZXN0UG9seTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvbHlnb25zLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgICAgICAgY29uc3QgcG9seWdvbiA9IGkubmV4dCgpO1xuICAgICAgICAgICAgY29uc3QgYXJlYSA9IHBvbHlnb24uZ2V0QXJlYSgpO1xuICAgICAgICAgICAgaWYgKGFyZWEgPCBzbWFsbGVzdEFyZWEpIHtcbiAgICAgICAgICAgICAgICBzbWFsbGVzdEFyZWEgPSBhcmVhO1xuICAgICAgICAgICAgICAgIHNtYWxsZXN0UG9seSA9IHBvbHlnb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNtYWxsZXN0UG9seSkgcmV0dXJuIFtdO1xuICAgICAgICByZXR1cm4gc21hbGxlc3RQb2x5LmdldENvb3JkaW5hdGVzKCkubWFwKChjOiBhbnkpID0+IG5ldyBWZWN0b3IoYy54LCBjLnkpKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGNhbGNQb2x5Z29uQXJlYShwb2x5Z29uOiBWZWN0b3JbXSk6IG51bWJlciB7XG4gICAgICAgIGxldCB0b3RhbCA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2x5Z29uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgYWRkWCA9IHBvbHlnb25baV0ueDtcbiAgICAgICAgICBjb25zdCBhZGRZID0gcG9seWdvbltpID09IHBvbHlnb24ubGVuZ3RoIC0gMSA/IDAgOiBpICsgMV0ueTtcbiAgICAgICAgICBjb25zdCBzdWJYID0gcG9seWdvbltpID09IHBvbHlnb24ubGVuZ3RoIC0gMSA/IDAgOiBpICsgMV0ueDtcbiAgICAgICAgICBjb25zdCBzdWJZID0gcG9seWdvbltpXS55O1xuXG4gICAgICAgICAgdG90YWwgKz0gKGFkZFggKiBhZGRZICogMC41KTtcbiAgICAgICAgICB0b3RhbCAtPSAoc3ViWCAqIHN1YlkgKiAwLjUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRvdGFsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBkaXZpZGUgYSBwb2x5Z29uIGJ5IGl0cyBsb25nZXN0IHNpZGUgdW50aWwgdGhlIG1pbkFyZWEgc3RvcHBpbmcgY29uZGl0aW9uIGlzIG1ldFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgc3ViZGl2aWRlUG9seWdvbihwOiBWZWN0b3JbXSwgbWluQXJlYTogbnVtYmVyKTogVmVjdG9yW11bXSB7XG4gICAgICAgIGNvbnN0IGFyZWEgPSBQb2x5Z29uVXRpbC5jYWxjUG9seWdvbkFyZWEocCk7XG4gICAgICAgIGlmIChhcmVhIDwgMC41ICogbWluQXJlYSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpdmlkZWQ6IFZlY3RvcltdW10gPSBbXTsgIC8vIEFycmF5IG9mIHBvbHlnb25zXG5cbiAgICAgICAgbGV0IGxvbmdlc3RTaWRlTGVuZ3RoID0gMDtcbiAgICAgICAgbGV0IGxvbmdlc3RTaWRlID0gW3BbMF0sIHBbMV1dO1xuXG4gICAgICAgIGxldCBwZXJpbWV0ZXIgPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lkZUxlbmd0aCA9IHBbaV0uY2xvbmUoKS5zdWIocFsoaSsxKSAlIHAubGVuZ3RoXSkubGVuZ3RoKCk7XG4gICAgICAgICAgICBwZXJpbWV0ZXIgKz0gc2lkZUxlbmd0aDtcbiAgICAgICAgICAgIGlmIChzaWRlTGVuZ3RoID4gbG9uZ2VzdFNpZGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsb25nZXN0U2lkZUxlbmd0aCA9IHNpZGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgbG9uZ2VzdFNpZGUgPSBbcFtpXSwgcFsoaSsxKSAlIHAubGVuZ3RoXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaGFwZSBpbmRleFxuICAgICAgICAvLyBVc2luZyByZWN0YW5nbGUgcmF0aW8gb2YgMTo0IGFzIGxpbWl0XG4gICAgICAgIC8vIGlmIChhcmVhIC8gcGVyaW1ldGVyICogcGVyaW1ldGVyIDwgMC4wNCkge1xuICAgICAgICBpZiAoYXJlYSAvIChwZXJpbWV0ZXIgKiBwZXJpbWV0ZXIpIDwgMC4wNCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFyZWEgPCAyICogbWluQXJlYSkge1xuICAgICAgICAgICAgcmV0dXJuIFtwXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJldHdlZW4gMC40IGFuZCAwLjZcbiAgICAgICAgY29uc3QgZGV2aWF0aW9uID0gKE1hdGgucmFuZG9tKCkgKiAwLjIpICsgMC40O1xuXG4gICAgICAgIGNvbnN0IGF2ZXJhZ2VQb2ludCA9IGxvbmdlc3RTaWRlWzBdLmNsb25lKCkuYWRkKGxvbmdlc3RTaWRlWzFdKS5tdWx0aXBseVNjYWxhcihkZXZpYXRpb24pO1xuICAgICAgICBjb25zdCBkaWZmZXJlbmNlVmVjdG9yID0gbG9uZ2VzdFNpZGVbMF0uY2xvbmUoKS5zdWIobG9uZ2VzdFNpZGVbMV0pO1xuICAgICAgICBjb25zdCBwZXJwVmVjdG9yID0gKG5ldyBWZWN0b3IoZGlmZmVyZW5jZVZlY3Rvci55LCAtMSAqIGRpZmZlcmVuY2VWZWN0b3IueCkpXG4gICAgICAgICAgICAubm9ybWFsaXplKClcbiAgICAgICAgICAgIC5tdWx0aXBseVNjYWxhcigxMDApO1xuXG4gICAgICAgIGNvbnN0IGJpc2VjdCA9IFthdmVyYWdlUG9pbnQuY2xvbmUoKS5hZGQocGVycFZlY3RvciksIGF2ZXJhZ2VQb2ludC5jbG9uZSgpLnN1YihwZXJwVmVjdG9yKV07XG5cbiAgICAgICAgLy8gQXJyYXkgb2YgcG9seWdvbnNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNsaWNlZCA9IFBvbHlLLlNsaWNlKFBvbHlnb25VdGlsLnBvbHlnb25Ub1BvbHlnb25BcnJheShwKSwgYmlzZWN0WzBdLngsIGJpc2VjdFswXS55LCBiaXNlY3RbMV0ueCwgYmlzZWN0WzFdLnkpO1xuICAgICAgICAgICAgLy8gUmVjdXJzaXZlIGNhbGxcbiAgICAgICAgICAgIGZvciAoY29uc3QgcyBvZiBzbGljZWQpIHtcbiAgICAgICAgICAgICAgICBkaXZpZGVkLnB1c2goLi4uUG9seWdvblV0aWwuc3ViZGl2aWRlUG9seWdvbihQb2x5Z29uVXRpbC5wb2x5Z29uQXJyYXlUb1BvbHlnb24ocyksIG1pbkFyZWEpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRpdmlkZWQ7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2cuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hyaW5rIG9yIGV4cGFuZCBwb2x5Z29uXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyByZXNpemVHZW9tZXRyeShnZW9tZXRyeTogVmVjdG9yW10sIHNwYWNpbmc6IG51bWJlciwgaXNQb2x5Z29uPXRydWUpOiBWZWN0b3JbXSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBqc3RzR2VvbWV0cnkgPSBpc1BvbHlnb24/IFBvbHlnb25VdGlsLnBvbHlnb25Ub0p0cyhnZW9tZXRyeSkgOiBQb2x5Z29uVXRpbC5saW5lVG9KdHMoZ2VvbWV0cnkpO1xuICAgICAgICAgICAgY29uc3QgcmVzaXplZCA9IGpzdHNHZW9tZXRyeS5idWZmZXIoc3BhY2luZywgdW5kZWZpbmVkLCAoanN0cyBhcyBhbnkpLm9wZXJhdGlvbi5idWZmZXIuQnVmZmVyUGFyYW1ldGVycy5DQVBfRkxBVCk7XG4gICAgICAgICAgICBpZiAoIXJlc2l6ZWQuaXNTaW1wbGUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNpemVkLmdldENvb3JkaW5hdGVzKCkubWFwKGMgPT4gbmV3IFZlY3RvcihjLngsIGMueSkpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgYXZlcmFnZVBvaW50KHBvbHlnb246IFZlY3RvcltdKTogVmVjdG9yIHtcbiAgICAgICAgaWYgKHBvbHlnb24ubGVuZ3RoID09PSAwKSByZXR1cm4gVmVjdG9yLnplcm9WZWN0b3IoKTtcbiAgICAgICAgY29uc3Qgc3VtID0gVmVjdG9yLnplcm9WZWN0b3IoKTtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIHBvbHlnb24pIHtcbiAgICAgICAgICAgIHN1bS5hZGQodik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bS5kaXZpZGVTY2FsYXIocG9seWdvbi5sZW5ndGgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgaW5zaWRlUG9seWdvbihwb2ludDogVmVjdG9yLCBwb2x5Z29uOiBWZWN0b3JbXSk6IGJvb2xlYW4ge1xuICAgICAgICAvLyByYXktY2FzdGluZyBhbGdvcml0aG0gYmFzZWQgb25cbiAgICAgICAgLy8gaHR0cDovL3d3dy5lY3NlLnJwaS5lZHUvSG9tZXBhZ2VzL3dyZi9SZXNlYXJjaC9TaG9ydF9Ob3Rlcy9wbnBvbHkuaHRtbFxuXG4gICAgICAgIGlmIChwb2x5Z29uLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGluc2lkZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IHBvbHlnb24ubGVuZ3RoIC0gMTsgaSA8IHBvbHlnb24ubGVuZ3RoOyBqID0gaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB4aSA9IHBvbHlnb25baV0ueCwgeWkgPSBwb2x5Z29uW2ldLnk7XG4gICAgICAgICAgICBjb25zdCB4aiA9IHBvbHlnb25bal0ueCwgeWogPSBwb2x5Z29uW2pdLnk7XG5cbiAgICAgICAgICAgIGNvbnN0IGludGVyc2VjdCA9ICgoeWkgPiBwb2ludC55KSAhPSAoeWogPiBwb2ludC55KSlcbiAgICAgICAgICAgICAgICAmJiAocG9pbnQueCA8ICh4aiAtIHhpKSAqIChwb2ludC55IC0geWkpIC8gKHlqIC0geWkpICsgeGkpO1xuICAgICAgICAgICAgaWYgKGludGVyc2VjdCkgaW5zaWRlID0gIWluc2lkZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBwb2ludEluUmVjdGFuZ2xlKHBvaW50OiBWZWN0b3IsIG9yaWdpbjogVmVjdG9yLCBkaW1lbnNpb25zOiBWZWN0b3IpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHBvaW50LnggPj0gb3JpZ2luLnggJiYgcG9pbnQueSA+PSBvcmlnaW4ueSAmJiBwb2ludC54IDw9IGRpbWVuc2lvbnMueCAmJiBwb2ludC55IDw9IGRpbWVuc2lvbnMueTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBsaW5lVG9KdHMobGluZTogVmVjdG9yW10pOiBqc3RzLmdlb20uTGluZVN0cmluZyB7XG4gICAgICAgIGNvbnN0IGNvb3JkcyA9IGxpbmUubWFwKHYgPT4gbmV3IGpzdHMuZ2VvbS5Db29yZGluYXRlKHYueCwgdi55KSk7XG4gICAgICAgIHJldHVybiBQb2x5Z29uVXRpbC5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhjb29yZHMpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIHBvbHlnb25Ub0p0cyhwb2x5Z29uOiBWZWN0b3JbXSk6IGpzdHMuZ2VvbS5Qb2x5Z29uIHtcbiAgICAgICAgY29uc3QgZ2VvSW5wdXQgPSBwb2x5Z29uLm1hcCh2ID0+IG5ldyBqc3RzLmdlb20uQ29vcmRpbmF0ZSh2LngsIHYueSkpO1xuICAgICAgICBnZW9JbnB1dC5wdXNoKGdlb0lucHV0WzBdKTsgIC8vIENyZWF0ZSBsb29wXG4gICAgICAgIHJldHVybiBQb2x5Z29uVXRpbC5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9seWdvbihQb2x5Z29uVXRpbC5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhnZW9JbnB1dCksIFtdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBbIHYueCwgdi55LCB2LngsIHYueSBdLi4uXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgcG9seWdvblRvUG9seWdvbkFycmF5KHA6IFZlY3RvcltdKTogbnVtYmVyW10ge1xuICAgICAgICBjb25zdCBvdXRQOiBudW1iZXJbXSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgcCkge1xuICAgICAgICAgICAgb3V0UC5wdXNoKHYueCk7XG4gICAgICAgICAgICBvdXRQLnB1c2godi55KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0UDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBbIHYueCwgdi55LCB2LngsIHYueSBdLi4uXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgcG9seWdvbkFycmF5VG9Qb2x5Z29uKHA6IG51bWJlcltdKTogVmVjdG9yW10ge1xuICAgICAgICBjb25zdCBvdXRQID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcC5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgICAgIG91dFAucHVzaChuZXcgVmVjdG9yKHBbMippXSwgcFsyKmkgKyAxXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRQO1xuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCAqIGFzIGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgKiBhcyBzaW1wbGlmeSBmcm9tICdzaW1wbGlmeS1qcyc7XG5pbXBvcnQgVmVjdG9yIGZyb20gJy4uL3ZlY3Rvcic7XG5pbXBvcnQgR3JpZFN0b3JhZ2UgZnJvbSAnLi9ncmlkX3N0b3JhZ2UnO1xuaW1wb3J0IEZpZWxkSW50ZWdyYXRvciBmcm9tICcuL2ludGVncmF0b3InO1xuXG5pbnRlcmZhY2UgU3RyZWFtbGluZUludGVncmF0aW9uIHtcbiAgICBzZWVkOiBWZWN0b3I7XG4gICAgb3JpZ2luYWxEaXI6IFZlY3RvcjtcbiAgICBzdHJlYW1saW5lOiBWZWN0b3JbXTtcbiAgICBwcmV2aW91c0RpcmVjdGlvbjogVmVjdG9yO1xuICAgIHByZXZpb3VzUG9pbnQ6IFZlY3RvcjtcbiAgICB2YWxpZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdHJlYW1saW5lUGFyYW1zIHtcbiAgICBba2V5OiBzdHJpbmddOiBhbnk7XG4gICAgZHNlcDogbnVtYmVyOyAgLy8gU3RyZWFtbGluZSBzZWVkIHNlcGFyYXRpbmcgZGlzdGFuY2VcbiAgICBkdGVzdDogbnVtYmVyOyAgLy8gU3RyZWFtbGluZSBpbnRlZ3JhdGlvbiBzZXBhcmF0aW5nIGRpc3RhbmNlXG4gICAgZHN0ZXA6IG51bWJlcjsgIC8vIFN0ZXAgc2l6ZVxuICAgIGRjaXJjbGVqb2luOiBudW1iZXI7ICAvLyBIb3cgZmFyIHRvIGxvb2sgdG8gam9pbiBjaXJjbGVzIC0gKGUuZy4gMiB4IGRzdGVwKVxuICAgIGRsb29rYWhlYWQ6IG51bWJlcjsgIC8vIEhvdyBmYXIgdG8gbG9vayBhaGVhZCB0byBqb2luIHVwIGRhbmdsaW5nXG4gICAgam9pbmFuZ2xlOiBudW1iZXI7ICAvLyBBbmdsZSB0byBqb2luIHJvYWRzIGluIHJhZGlhbnNcbiAgICBwYXRoSXRlcmF0aW9uczogbnVtYmVyOyAgLy8gUGF0aCBpbnRlZ3JhdGlvbiBpdGVyYXRpb24gbGltaXRcbiAgICBzZWVkVHJpZXM6IG51bWJlcjsgIC8vIE1heCBmYWlsZWQgc2VlZHNcbiAgICBzaW1wbGlmeVRvbGVyYW5jZTogbnVtYmVyO1xuICAgIGNvbGxpZGVFYXJseTogbnVtYmVyOyAgLy8gQ2hhbmNlIG9mIGVhcmx5IGNvbGxpc2lvbiAwLTFcbn1cblxuLyoqXG4gKiBDcmVhdGVzIHBvbHlsaW5lcyB0aGF0IG1ha2UgdXAgdGhlIHJvYWRzIGJ5IGludGVncmF0aW5nIHRoZSB0ZW5zb3IgZmllbGRcbiAqIFNlZSB0aGUgcGFwZXIgJ0ludGVyYWN0aXZlIFByb2NlZHVyYWwgU3RyZWV0IE1vZGVsaW5nJyBmb3IgYSB0aG9yb3VnaCBleHBsYW5hdGlvblxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdHJlYW1saW5lR2VuZXJhdG9yIHtcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgU0VFRF9BVF9FTkRQT0lOVFMgPSBmYWxzZTtcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgTkVBUl9FREdFID0gMzsgIC8vIFNhbXBsZSBuZWFyIGVkZ2VcblxuICAgIHByb3RlY3RlZCBtYWpvckdyaWQ6IEdyaWRTdG9yYWdlO1xuICAgIHByb3RlY3RlZCBtaW5vckdyaWQ6IEdyaWRTdG9yYWdlO1xuICAgIHByb3RlY3RlZCBwYXJhbXNTcTogU3RyZWFtbGluZVBhcmFtcztcblxuICAgIC8vIEhvdyBtYW55IHNhbXBsZXMgdG8gc2tpcCB3aGVuIGNoZWNraW5nIHN0cmVhbWxpbmUgY29sbGlzaW9uIHdpdGggaXRzZWxmXG4gICAgcHJvdGVjdGVkIG5TdHJlYW1saW5lU3RlcDogbnVtYmVyO1xuICAgIC8vIEhvdyBtYW55IHNhbXBsZXMgdG8gaWdub3JlIGJhY2t3YXJkcyB3aGVuIGNoZWNraW5nIHN0cmVhbWxpbmUgY29sbGlzaW9uIHdpdGggaXRzZWxmXG4gICAgcHJvdGVjdGVkIG5TdHJlYW1saW5lTG9va0JhY2s6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgZGNvbGxpZGVzZWxmU3E6IG51bWJlcjtcblxuICAgIHByb3RlY3RlZCBjYW5kaWRhdGVTZWVkc01ham9yOiBWZWN0b3JbXSA9IFtdO1xuICAgIHByb3RlY3RlZCBjYW5kaWRhdGVTZWVkc01pbm9yOiBWZWN0b3JbXSA9IFtdO1xuXG4gICAgcHJvdGVjdGVkIHN0cmVhbWxpbmVzRG9uZSA9IHRydWU7XG4gICAgcHJvdGVjdGVkIHJlc29sdmU6ICgpID0+IHZvaWQ7XG4gICAgcHJvdGVjdGVkIGxhc3RTdHJlYW1saW5lTWFqb3IgPSB0cnVlO1xuXG4gICAgcHVibGljIGFsbFN0cmVhbWxpbmVzOiBWZWN0b3JbXVtdID0gW107XG4gICAgcHVibGljIHN0cmVhbWxpbmVzTWFqb3I6IFZlY3RvcltdW10gPSBbXTtcbiAgICBwdWJsaWMgc3RyZWFtbGluZXNNaW5vcjogVmVjdG9yW11bXSA9IFtdO1xuICAgIHB1YmxpYyBhbGxTdHJlYW1saW5lc1NpbXBsZTogVmVjdG9yW11bXSA9IFtdOyAgLy8gUmVkdWNlZCB2ZXJ0ZXggY291bnRcblxuICAgIC8qKlxuICAgICAqIFVzZXMgd29ybGQtc3BhY2UgY29vcmRpbmF0ZXNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgaW50ZWdyYXRvcjogRmllbGRJbnRlZ3JhdG9yLFxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBvcmlnaW46IFZlY3RvcixcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgd29ybGREaW1lbnNpb25zOiBWZWN0b3IsXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmFtczogU3RyZWFtbGluZVBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLmRzdGVwID4gcGFyYW1zLmRzZXApIHtcbiAgICAgICAgICAgIGxvZy5lcnJvcihcIlNUUkVBTUxJTkUgU0FNUExFIERJU1RBTkNFIEJJR0dFUiBUSEFOIERTRVBcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbmZvcmNlIHRlc3QgPCBzZXBcbiAgICAgICAgcGFyYW1zLmR0ZXN0ID0gTWF0aC5taW4ocGFyYW1zLmR0ZXN0LCBwYXJhbXMuZHNlcCk7XG5cbiAgICAgICAgLy8gTmVlZHMgdG8gYmUgbGVzcyB0aGFuIGNpcmNsZWpvaW5cbiAgICAgICAgdGhpcy5kY29sbGlkZXNlbGZTcSA9IChwYXJhbXMuZGNpcmNsZWpvaW4gLyAyKSAqKiAyO1xuICAgICAgICB0aGlzLm5TdHJlYW1saW5lU3RlcCA9IE1hdGguZmxvb3IocGFyYW1zLmRjaXJjbGVqb2luIC8gcGFyYW1zLmRzdGVwKTtcbiAgICAgICAgdGhpcy5uU3RyZWFtbGluZUxvb2tCYWNrID0gMiAqIHRoaXMublN0cmVhbWxpbmVTdGVwO1xuXG4gICAgICAgIHRoaXMubWFqb3JHcmlkID0gbmV3IEdyaWRTdG9yYWdlKHRoaXMud29ybGREaW1lbnNpb25zLCB0aGlzLm9yaWdpbiwgcGFyYW1zLmRzZXApO1xuICAgICAgICB0aGlzLm1pbm9yR3JpZCA9IG5ldyBHcmlkU3RvcmFnZSh0aGlzLndvcmxkRGltZW5zaW9ucywgdGhpcy5vcmlnaW4sIHBhcmFtcy5kc2VwKTtcblxuICAgICAgICB0aGlzLnNldFBhcmFtc1NxKCk7XG4gICAgfVxuXG4gICAgY2xlYXJTdHJlYW1saW5lcygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5hbGxTdHJlYW1saW5lc1NpbXBsZSA9IFtdO1xuICAgICAgICB0aGlzLnN0cmVhbWxpbmVzTWFqb3IgPSBbXTtcbiAgICAgICAgdGhpcy5zdHJlYW1saW5lc01pbm9yID0gW107XG4gICAgICAgIHRoaXMuYWxsU3RyZWFtbGluZXMgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFZGl0cyBzdHJlYW1saW5lc1xuICAgICAqL1xuICAgIGpvaW5EYW5nbGluZ1N0cmVhbWxpbmVzKCk6IHZvaWQge1xuICAgICAgICAvLyBUT0RPIGRvIGluIHVwZGF0ZSBtZXRob2RcbiAgICAgICAgZm9yIChjb25zdCBtYWpvciBvZiBbdHJ1ZSwgZmFsc2VdKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN0cmVhbWxpbmUgb2YgdGhpcy5zdHJlYW1saW5lcyhtYWpvcikpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgY2lyY2xlc1xuICAgICAgICAgICAgICAgIGlmIChzdHJlYW1saW5lWzBdLmVxdWFscyhzdHJlYW1saW5lW3N0cmVhbWxpbmUubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1N0YXJ0ID0gdGhpcy5nZXRCZXN0TmV4dFBvaW50KHN0cmVhbWxpbmVbMF0sIHN0cmVhbWxpbmVbNF0sIHN0cmVhbWxpbmUpXG4gICAgICAgICAgICAgICAgaWYgKG5ld1N0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBvZiB0aGlzLnBvaW50c0JldHdlZW4oc3RyZWFtbGluZVswXSwgbmV3U3RhcnQsIHRoaXMucGFyYW1zLmRzdGVwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtbGluZS51bnNoaWZ0KHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmlkKG1ham9yKS5hZGRTYW1wbGUocCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdFbmQgPSB0aGlzLmdldEJlc3ROZXh0UG9pbnQoc3RyZWFtbGluZVtzdHJlYW1saW5lLmxlbmd0aCAtIDFdLCBzdHJlYW1saW5lW3N0cmVhbWxpbmUubGVuZ3RoIC0gNF0sIHN0cmVhbWxpbmUpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdFbmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMucG9pbnRzQmV0d2VlbihzdHJlYW1saW5lW3N0cmVhbWxpbmUubGVuZ3RoIC0gMV0sIG5ld0VuZCwgdGhpcy5wYXJhbXMuZHN0ZXApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1saW5lLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdyaWQobWFqb3IpLmFkZFNhbXBsZShwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc2V0IHNpbXBsaWZpZWQgc3RyZWFtbGluZXNcbiAgICAgICAgdGhpcy5hbGxTdHJlYW1saW5lc1NpbXBsZSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHMgb2YgdGhpcy5hbGxTdHJlYW1saW5lcykge1xuICAgICAgICAgICAgdGhpcy5hbGxTdHJlYW1saW5lc1NpbXBsZS5wdXNoKHRoaXMuc2ltcGxpZnlTdHJlYW1saW5lKHMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYXJyYXkgb2YgcG9pbnRzIGZyb20gdjEgdG8gdjIgc3VjaCB0aGF0IHRoZXkgYXJlIHNlcGFyYXRlZCBieSBhdCBtb3N0IGRzZXBcbiAgICAgKiBub3QgaW5jbHVkaW5nIHYxXG4gICAgICovXG4gICAgcG9pbnRzQmV0d2Vlbih2MTogVmVjdG9yLCB2MjogVmVjdG9yLCBkc3RlcDogbnVtYmVyKTogVmVjdG9yW10ge1xuICAgICAgICBjb25zdCBkID0gdjEuZGlzdGFuY2VUbyh2Mik7XG4gICAgICAgIGNvbnN0IG5Qb2ludHMgPSBNYXRoLmZsb29yKGQgLyBkc3RlcCk7XG4gICAgICAgIGlmIChuUG9pbnRzID09PSAwKSByZXR1cm4gW107XG5cbiAgICAgICAgY29uc3Qgc3RlcFZlY3RvciA9IHYyLmNsb25lKCkuc3ViKHYxKTtcblxuICAgICAgICBjb25zdCBvdXQgPSBbXTtcbiAgICAgICAgbGV0IGkgPSAxO1xuICAgICAgICBsZXQgbmV4dCA9IHYxLmNsb25lKCkuYWRkKHN0ZXBWZWN0b3IuY2xvbmUoKS5tdWx0aXBseVNjYWxhcihpIC8gblBvaW50cykpO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IG5Qb2ludHM7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW50ZWdyYXRvci5pbnRlZ3JhdGUobmV4dCwgdHJ1ZSkubGVuZ3RoU3EoKSA+IDAuMDAxKSB7ICAvLyBUZXN0IGZvciBkZWdlbmVyYXRlIHBvaW50XG4gICAgICAgICAgICAgICAgb3V0LnB1c2gobmV4dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0ID0gdjEuY2xvbmUoKS5hZGQoc3RlcFZlY3Rvci5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKGkgLyBuUG9pbnRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEdldHMgbmV4dCBiZXN0IHBvaW50IHRvIGpvaW4gc3RyZWFtbGluZVxuICAgICAqIHJldHVybnMgbnVsbCBpZiB0aGVyZSBhcmUgbm8gZ29vZCBjYW5kaWRhdGVzXG4gICAgICovXG4gICAgZ2V0QmVzdE5leHRQb2ludChwb2ludDogVmVjdG9yLCBwcmV2aW91c1BvaW50OiBWZWN0b3IsIHN0cmVhbWxpbmU6IFZlY3RvcltdKTogVmVjdG9yIHtcbiAgICAgICAgY29uc3QgbmVhcmJ5UG9pbnRzID0gdGhpcy5tYWpvckdyaWQuZ2V0TmVhcmJ5UG9pbnRzKHBvaW50LCB0aGlzLnBhcmFtcy5kbG9va2FoZWFkKTtcbiAgICAgICAgbmVhcmJ5UG9pbnRzLnB1c2goLi4udGhpcy5taW5vckdyaWQuZ2V0TmVhcmJ5UG9pbnRzKHBvaW50LCB0aGlzLnBhcmFtcy5kbG9va2FoZWFkKSk7XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHBvaW50LmNsb25lKCkuc3ViKHByZXZpb3VzUG9pbnQpO1xuXG4gICAgICAgIGxldCBjbG9zZXN0U2FtcGxlID0gbnVsbDtcbiAgICAgICAgbGV0IGNsb3Nlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuXG4gICAgICAgIGZvciAoY29uc3Qgc2FtcGxlIG9mIG5lYXJieVBvaW50cykge1xuICAgICAgICAgICAgaWYgKCFzYW1wbGUuZXF1YWxzKHBvaW50KSAmJiAhc2FtcGxlLmVxdWFscyhwcmV2aW91c1BvaW50KSkgey8vICYmICFzdHJlYW1saW5lLmluY2x1ZGVzKHNhbXBsZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaWZmZXJlbmNlVmVjdG9yID0gc2FtcGxlLmNsb25lKCkuc3ViKHBvaW50KTtcbiAgICAgICAgICAgICAgICBpZiAoZGlmZmVyZW5jZVZlY3Rvci5kb3QoZGlyZWN0aW9uKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQmFja3dhcmRzXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBBY3V0ZSBhbmdsZSBiZXR3ZWVuIHZlY3RvcnMgKGFnbm9zdGljIG9mIENXLCBBQ1cpXG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2VUb1NhbXBsZSA9IHBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKHNhbXBsZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlVG9TYW1wbGUgPCAyICogdGhpcy5wYXJhbXNTcS5kc3RlcCkge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0U2FtcGxlID0gc2FtcGxlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYW5nbGVCZXR3ZWVuID0gTWF0aC5hYnMoVmVjdG9yLmFuZ2xlQmV0d2VlbihkaXJlY3Rpb24sIGRpZmZlcmVuY2VWZWN0b3IpKTtcblxuICAgICAgICAgICAgICAgIC8vIEZpbHRlciBieSBhbmdsZVxuICAgICAgICAgICAgICAgIGlmIChhbmdsZUJldHdlZW4gPCB0aGlzLnBhcmFtcy5qb2luYW5nbGUgJiYgZGlzdGFuY2VUb1NhbXBsZSA8IGNsb3Nlc3REaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0RGlzdGFuY2UgPSBkaXN0YW5jZVRvU2FtcGxlO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0U2FtcGxlID0gc2FtcGxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE8gaXMgcmVpbXBsZW1lbnQgc2ltcGxpZnktanMgdG8gcHJlc2VydmUgaW50ZXJzZWN0aW9uIHBvaW50c1xuICAgICAgICAvLyAgLSB0aGlzIGlzIHRoZSBwcmltYXJ5IHJlYXNvbiBwb2x5Z29ucyBhcmVuJ3QgZm91bmRcbiAgICAgICAgLy8gSWYgdHJ5aW5nIHRvIGZpbmQgaW50ZXJzZWN0aW9ucyBpbiB0aGUgc2ltcGxpZmllZCBncmFwaFxuICAgICAgICAvLyBwcmV2ZW50IGVuZHMgZ2V0dGluZyBwdWxsZWQgYXdheSBmcm9tIHNpbXBsaWZpZWQgbGluZXNcbiAgICAgICAgaWYgKGNsb3Nlc3RTYW1wbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNsb3Nlc3RTYW1wbGUgPSBjbG9zZXN0U2FtcGxlLmNsb25lKCkuYWRkKGRpcmVjdGlvbi5zZXRMZW5ndGgodGhpcy5wYXJhbXMuc2ltcGxpZnlUb2xlcmFuY2UgKiA0KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xvc2VzdFNhbXBsZTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEFzc3VtZXMgcyBoYXMgYWxyZWFkeSBnZW5lcmF0ZWRcbiAgICAgKi9cbiAgICBhZGRFeGlzdGluZ1N0cmVhbWxpbmVzKHM6IFN0cmVhbWxpbmVHZW5lcmF0b3IpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tYWpvckdyaWQuYWRkQWxsKHMubWFqb3JHcmlkKTtcbiAgICAgICAgdGhpcy5taW5vckdyaWQuYWRkQWxsKHMubWlub3JHcmlkKTtcbiAgICB9XG5cbiAgICBzZXRHcmlkKHM6IFN0cmVhbWxpbmVHZW5lcmF0b3IpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tYWpvckdyaWQgPSBzLm1ham9yR3JpZDtcbiAgICAgICAgdGhpcy5taW5vckdyaWQgPSBzLm1pbm9yR3JpZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRydWUgaWYgc3RhdGUgdXBkYXRlc1xuICAgICAqL1xuICAgIHVwZGF0ZSgpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0cmVhbWxpbmVzRG9uZSkge1xuICAgICAgICAgICAgdGhpcy5sYXN0U3RyZWFtbGluZU1ham9yID0gIXRoaXMubGFzdFN0cmVhbWxpbmVNYWpvcjtcbiAgICAgICAgICAgIGlmICghdGhpcy5jcmVhdGVTdHJlYW1saW5lKHRoaXMubGFzdFN0cmVhbWxpbmVNYWpvcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbWxpbmVzRG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGwgYXQgb25jZSAtIHdpbGwgZnJlZXplIGlmIGRzZXAgc21hbGxcbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVBbGxTdHJlYW1saW5lcyhhbmltYXRlPWZhbHNlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPihyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmVcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtbGluZXNEb25lID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICghYW5pbWF0ZSkge1xuICAgICAgICAgICAgICAgIGxldCBtYWpvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuY3JlYXRlU3RyZWFtbGluZShtYWpvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFqb3IgPSAhbWFqb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KS50aGVuKCgpID0+IHRoaXMuam9pbkRhbmdsaW5nU3RyZWFtbGluZXMoKSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHNpbXBsaWZ5U3RyZWFtbGluZShzdHJlYW1saW5lOiBWZWN0b3JbXSk6IFZlY3RvcltdIHtcbiAgICAgICAgY29uc3Qgc2ltcGxpZmllZCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIHNpbXBsaWZ5KHN0cmVhbWxpbmUsIHRoaXMucGFyYW1zLnNpbXBsaWZ5VG9sZXJhbmNlKSkge1xuICAgICAgICAgICAgc2ltcGxpZmllZC5wdXNoKG5ldyBWZWN0b3IocG9pbnQueCwgcG9pbnQueSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaW1wbGlmaWVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHNlZWQgYW5kIGNyZWF0ZXMgYSBzdHJlYW1saW5lIGZyb20gdGhhdCBwb2ludFxuICAgICAqIFB1c2hlcyBuZXcgY2FuZGlkYXRlIHNlZWRzIHRvIHF1ZXVlXG4gICAgICogQHJldHVybiB7VmVjdG9yW119IHJldHVybnMgZmFsc2UgaWYgc2VlZCBpc24ndCBmb3VuZCB3aXRoaW4gcGFyYW1zLnNlZWRUcmllc1xuICAgICAqL1xuICAgIHByb3RlY3RlZCBjcmVhdGVTdHJlYW1saW5lKG1ham9yOiBib29sZWFuKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IHNlZWQgPSB0aGlzLmdldFNlZWQobWFqb3IpO1xuICAgICAgICBpZiAoc2VlZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cmVhbWxpbmUgPSB0aGlzLmludGVncmF0ZVN0cmVhbWxpbmUoc2VlZCwgbWFqb3IpO1xuICAgICAgICBpZiAodGhpcy52YWxpZFN0cmVhbWxpbmUoc3RyZWFtbGluZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZChtYWpvcikuYWRkUG9seWxpbmUoc3RyZWFtbGluZSk7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbWxpbmVzKG1ham9yKS5wdXNoKHN0cmVhbWxpbmUpO1xuICAgICAgICAgICAgdGhpcy5hbGxTdHJlYW1saW5lcy5wdXNoKHN0cmVhbWxpbmUpO1xuXG4gICAgICAgICAgICB0aGlzLmFsbFN0cmVhbWxpbmVzU2ltcGxlLnB1c2godGhpcy5zaW1wbGlmeVN0cmVhbWxpbmUoc3RyZWFtbGluZSkpO1xuXG4gICAgICAgICAgICAvLyBBZGQgY2FuZGlkYXRlIHNlZWRzXG4gICAgICAgICAgICBpZiAoIXN0cmVhbWxpbmVbMF0uZXF1YWxzKHN0cmVhbWxpbmVbc3RyZWFtbGluZS5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmRpZGF0ZVNlZWRzKCFtYWpvcikucHVzaChzdHJlYW1saW5lWzBdKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmRpZGF0ZVNlZWRzKCFtYWpvcikucHVzaChzdHJlYW1saW5lW3N0cmVhbWxpbmUubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHZhbGlkU3RyZWFtbGluZShzOiBWZWN0b3JbXSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gcy5sZW5ndGggPiA1O1xuICAgIH0gXG5cbiAgICBwcm90ZWN0ZWQgc2V0UGFyYW1zU3EoKTogdm9pZCB7XG4gICAgICAgIHRoaXMucGFyYW1zU3EgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnBhcmFtcyk7XG4gICAgICAgIGZvciAoY29uc3QgcCBpbiB0aGlzLnBhcmFtc1NxKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucGFyYW1zU3FbcF0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmFtc1NxW3BdICo9IHRoaXMucGFyYW1zU3FbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc2FtcGxlUG9pbnQoKTogVmVjdG9yIHtcbiAgICAgICAgLy8gVE9ETyBiZXR0ZXIgc2VlZGluZyBzY2hlbWVcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoXG4gICAgICAgICAgICBNYXRoLnJhbmRvbSgpICogdGhpcy53b3JsZERpbWVuc2lvbnMueCxcbiAgICAgICAgICAgIE1hdGgucmFuZG9tKCkgKiB0aGlzLndvcmxkRGltZW5zaW9ucy55KVxuICAgICAgICAgICAgLmFkZCh0aGlzLm9yaWdpbik7XG4gICAgfVxuIFxuICAgIC8qKlxuICAgICAqIFRyaWVzIHRoaXMuY2FuZGlkYXRlU2VlZHMgZmlyc3QsIHRoZW4gc2FtcGxlcyB1c2luZyB0aGlzLnNhbXBsZVBvaW50XG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldFNlZWQobWFqb3I6IGJvb2xlYW4pOiBWZWN0b3Ige1xuICAgICAgICAvLyBDYW5kaWRhdGUgc2VlZHMgZmlyc3RcbiAgICAgICAgaWYgKHRoaXMuU0VFRF9BVF9FTkRQT0lOVFMgJiYgdGhpcy5jYW5kaWRhdGVTZWVkcyhtYWpvcikubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuY2FuZGlkYXRlU2VlZHMobWFqb3IpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWVkID0gdGhpcy5jYW5kaWRhdGVTZWVkcyhtYWpvcikucG9wKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZFNhbXBsZShtYWpvciwgc2VlZCwgdGhpcy5wYXJhbXNTcS5kc2VwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc2VlZCA9IHRoaXMuc2FtcGxlUG9pbnQoKTtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB3aGlsZSAoIXRoaXMuaXNWYWxpZFNhbXBsZShtYWpvciwgc2VlZCwgdGhpcy5wYXJhbXNTcS5kc2VwKSkge1xuICAgICAgICAgICAgaWYgKGkgPj0gdGhpcy5wYXJhbXMuc2VlZFRyaWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWVkID0gdGhpcy5zYW1wbGVQb2ludCgpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlZWQ7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGlzVmFsaWRTYW1wbGUobWFqb3I6IGJvb2xlYW4sIHBvaW50OiBWZWN0b3IsIGRTcTogbnVtYmVyLCBib3RoR3JpZHM9ZmFsc2UpOiBib29sZWFuIHtcbiAgICAgICAgLy8gZFNxID0gZFNxICogcG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoVmVjdG9yLnplcm9WZWN0b3IoKSk7XG4gICAgICAgIGxldCBncmlkVmFsaWQgPSB0aGlzLmdyaWQobWFqb3IpLmlzVmFsaWRTYW1wbGUocG9pbnQsIGRTcSk7XG4gICAgICAgIGlmIChib3RoR3JpZHMpIHtcbiAgICAgICAgICAgIGdyaWRWYWxpZCA9IGdyaWRWYWxpZCAmJiB0aGlzLmdyaWQoIW1ham9yKS5pc1ZhbGlkU2FtcGxlKHBvaW50LCBkU3EpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmludGVncmF0b3Iub25MYW5kKHBvaW50KSAmJiBncmlkVmFsaWQ7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGNhbmRpZGF0ZVNlZWRzKG1ham9yOiBib29sZWFuKTogVmVjdG9yW10ge1xuICAgICAgICByZXR1cm4gbWFqb3IgPyB0aGlzLmNhbmRpZGF0ZVNlZWRzTWFqb3IgOiB0aGlzLmNhbmRpZGF0ZVNlZWRzTWlub3I7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHN0cmVhbWxpbmVzKG1ham9yOiBib29sZWFuKTogVmVjdG9yW11bXSB7XG4gICAgICAgIHJldHVybiBtYWpvciA/IHRoaXMuc3RyZWFtbGluZXNNYWpvciA6IHRoaXMuc3RyZWFtbGluZXNNaW5vcjtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ3JpZChtYWpvcjogYm9vbGVhbik6IEdyaWRTdG9yYWdlIHtcbiAgICAgICAgcmV0dXJuIG1ham9yID8gdGhpcy5tYWpvckdyaWQgOiB0aGlzLm1pbm9yR3JpZDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcG9pbnRJbkJvdW5kcyh2OiBWZWN0b3IpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICh2LnggPj0gdGhpcy5vcmlnaW4ueFxuICAgICAgICAgICAgJiYgdi55ID49IHRoaXMub3JpZ2luLnlcbiAgICAgICAgICAgICYmIHYueCA8IHRoaXMud29ybGREaW1lbnNpb25zLnggKyB0aGlzLm9yaWdpbi54XG4gICAgICAgICAgICAmJiB2LnkgPCB0aGlzLndvcmxkRGltZW5zaW9ucy55ICsgdGhpcy5vcmlnaW4ueVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpZG4ndCBlbmQgdXAgdXNpbmcgLSBiaXQgZXhwZW5zaXZlLCB1c2VkIHN0cmVhbWxpbmVUdXJuZWQgaW5zdGVhZFxuICAgICAqIFN0b3BzIHNwaXJhbHMgZnJvbSBmb3JtaW5nXG4gICAgICogdXNlcyAwLjUgZGNpcmNsZWpvaW4gc28gdGhhdCBjaXJjbGVzIGFyZSBzdGlsbCBqb2luZWQgdXBcbiAgICAgKiB0ZXN0U2FtcGxlIGlzIGNhbmRpZGF0ZSB0byBwdXNoZWQgb24gZW5kIG9mIHN0cmVhbWxpbmVGb3J3YXJkc1xuICAgICAqIHJldHVybnMgdHJ1ZSBpZiBzdHJlYW1saW5lIGNvbGxpZGVzIHdpdGggaXRzZWxmXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRvZXNTdHJlYW1saW5lQ29sbGlkZVNlbGYodGVzdFNhbXBsZTogVmVjdG9yLCBzdHJlYW1saW5lRm9yd2FyZHM6IFZlY3RvcltdLCBzdHJlYW1saW5lQmFja3dhcmRzOiBWZWN0b3JbXSk6IGJvb2xlYW4ge1xuICAgICAgICAvLyBTdHJlYW1saW5lIGxvbmcgZW5vdWdoXG4gICAgICAgIGlmIChzdHJlYW1saW5lRm9yd2FyZHMubGVuZ3RoID4gdGhpcy5uU3RyZWFtbGluZUxvb2tCYWNrKSB7XG4gICAgICAgICAgICAvLyBGb3J3YXJkcyBjaGVja1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJlYW1saW5lRm9yd2FyZHMubGVuZ3RoIC0gdGhpcy5uU3RyZWFtbGluZUxvb2tCYWNrOyBpICs9IHRoaXMublN0cmVhbWxpbmVTdGVwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRlc3RTYW1wbGUuZGlzdGFuY2VUb1NxdWFyZWQoc3RyZWFtbGluZUZvcndhcmRzW2ldKSA8IHRoaXMuZGNvbGxpZGVzZWxmU3EpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCYWNrd2FyZHMgY2hlY2tcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyZWFtbGluZUJhY2t3YXJkcy5sZW5ndGg7IGkgKz0gdGhpcy5uU3RyZWFtbGluZVN0ZXApIHtcbiAgICAgICAgICAgICAgICBpZiAodGVzdFNhbXBsZS5kaXN0YW5jZVRvU3F1YXJlZChzdHJlYW1saW5lQmFja3dhcmRzW2ldKSA8IHRoaXMuZGNvbGxpZGVzZWxmU3EpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3RzIHdoZXRoZXIgc3RyZWFtbGluZSBoYXMgdHVybmVkIHRocm91Z2ggZ3JlYXRlciB0aGFuIDE4MCBkZWdyZWVzXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHN0cmVhbWxpbmVUdXJuZWQoc2VlZDogVmVjdG9yLCBvcmlnaW5hbERpcjogVmVjdG9yLCBwb2ludDogVmVjdG9yLCBkaXJlY3Rpb246IFZlY3Rvcik6IGJvb2xlYW4ge1xuICAgICAgICBpZiAob3JpZ2luYWxEaXIuZG90KGRpcmVjdGlvbikgPCAwKSB7XG4gICAgICAgICAgICAvLyBUT0RPIG9wdGltaXNlXG4gICAgICAgICAgICBjb25zdCBwZXJwZW5kaWN1bGFyVmVjdG9yID0gbmV3IFZlY3RvcihvcmlnaW5hbERpci55LCAtb3JpZ2luYWxEaXIueCk7XG4gICAgICAgICAgICBjb25zdCBpc0xlZnQgPSBwb2ludC5jbG9uZSgpLnN1YihzZWVkKS5kb3QocGVycGVuZGljdWxhclZlY3RvcikgPCAwO1xuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uVXAgPSBkaXJlY3Rpb24uZG90KHBlcnBlbmRpY3VsYXJWZWN0b3IpID4gMDtcbiAgICAgICAgICAgIHJldHVybiBpc0xlZnQgPT09IGRpcmVjdGlvblVwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIC8vIFRPRE8gdGhpcyBkb2Vzbid0IHdvcmsgd2VsbCAtIGNvbnNpZGVyIHNvbWV0aGluZyBkaXNhbGxvd2luZyBvbmUgZGlyZWN0aW9uIChGL0IpIHRvIHR1cm4gbW9yZSB0aGFuIDE4MCBkZWdcbiAgICAgKiBPbmUgc3RlcCBvZiB0aGUgc3RyZWFtbGluZSBpbnRlZ3JhdGlvbiBwcm9jZXNzXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHN0cmVhbWxpbmVJbnRlZ3JhdGlvblN0ZXAocGFyYW1zOiBTdHJlYW1saW5lSW50ZWdyYXRpb24sIG1ham9yOiBib29sZWFuLCBjb2xsaWRlQm90aDogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICBpZiAocGFyYW1zLnZhbGlkKSB7XG4gICAgICAgICAgICBwYXJhbXMuc3RyZWFtbGluZS5wdXNoKHBhcmFtcy5wcmV2aW91c1BvaW50KTtcbiAgICAgICAgICAgIGNvbnN0IG5leHREaXJlY3Rpb24gPSB0aGlzLmludGVncmF0b3IuaW50ZWdyYXRlKHBhcmFtcy5wcmV2aW91c1BvaW50LCBtYWpvcik7XG5cbiAgICAgICAgICAgIC8vIFN0b3AgYXQgZGVnZW5lcmF0ZSBwb2ludFxuICAgICAgICAgICAgaWYgKG5leHREaXJlY3Rpb24ubGVuZ3RoU3EoKSA8IDAuMDEpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMudmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSB0cmF2ZWwgaW4gdGhlIHNhbWUgZGlyZWN0aW9uXG4gICAgICAgICAgICBpZiAobmV4dERpcmVjdGlvbi5kb3QocGFyYW1zLnByZXZpb3VzRGlyZWN0aW9uKSA8IDApIHtcbiAgICAgICAgICAgICAgICBuZXh0RGlyZWN0aW9uLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBuZXh0UG9pbnQgPSBwYXJhbXMucHJldmlvdXNQb2ludC5jbG9uZSgpLmFkZChuZXh0RGlyZWN0aW9uKTtcblxuICAgICAgICAgICAgLy8gVmlzdWFsaXNlIHN0b3BwaW5nIHBvaW50c1xuICAgICAgICAgICAgLy8gaWYgKHRoaXMuc3RyZWFtbGluZVR1cm5lZChwYXJhbXMuc2VlZCwgcGFyYW1zLm9yaWdpbmFsRGlyLCBuZXh0UG9pbnQsIG5leHREaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICAvLyAgICAgcGFyYW1zLnZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAvLyAgICAgcGFyYW1zLnN0cmVhbWxpbmUucHVzaChWZWN0b3IuemVyb1ZlY3RvcigpKTtcbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMucG9pbnRJbkJvdW5kcyhuZXh0UG9pbnQpXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5pc1ZhbGlkU2FtcGxlKG1ham9yLCBuZXh0UG9pbnQsIHRoaXMucGFyYW1zU3EuZHRlc3QsIGNvbGxpZGVCb3RoKVxuICAgICAgICAgICAgICAgICYmICF0aGlzLnN0cmVhbWxpbmVUdXJuZWQocGFyYW1zLnNlZWQsIHBhcmFtcy5vcmlnaW5hbERpciwgbmV4dFBvaW50LCBuZXh0RGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5wcmV2aW91c1BvaW50ID0gbmV4dFBvaW50O1xuICAgICAgICAgICAgICAgIHBhcmFtcy5wcmV2aW91c0RpcmVjdGlvbiA9IG5leHREaXJlY3Rpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE9uZSBtb3JlIHN0ZXBcbiAgICAgICAgICAgICAgICBwYXJhbXMuc3RyZWFtbGluZS5wdXNoKG5leHRQb2ludCk7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCeSBzaW11bHRhbmVvdXNseSBpbnRlZ3JhdGluZyBpbiBib3RoIGRpcmVjdGlvbnMgd2UgcmVkdWNlIHRoZSBpbXBhY3Qgb2YgY2lyY2xlcyBub3Qgam9pbmluZ1xuICAgICAqIHVwIGFzIHRoZSBlcnJvciBtYXRjaGVzIGF0IHRoZSBqb2luXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGludGVncmF0ZVN0cmVhbWxpbmUoc2VlZDogVmVjdG9yLCBtYWpvcjogYm9vbGVhbik6IFZlY3RvcltdIHtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgbGV0IHBvaW50c0VzY2FwZWQgPSBmYWxzZTsgIC8vIFRydWUgb25jZSB0d28gaW50ZWdyYXRpb24gZnJvbnRzIGhhdmUgbW92ZWQgZGxvb2thaGVhZCBhd2F5XG5cbiAgICAgICAgLy8gV2hldGhlciBvciBub3QgdG8gdGVzdCB2YWxpZGl0eSB1c2luZyBib3RoIGdyaWQgc3RvcmFnZXNcbiAgICAgICAgLy8gKENvbGxpZGUgd2l0aCBib3RoIG1ham9yIGFuZCBtaW5vcilcbiAgICAgICAgY29uc3QgY29sbGlkZUJvdGggPSBNYXRoLnJhbmRvbSgpIDwgdGhpcy5wYXJhbXMuY29sbGlkZUVhcmx5O1xuXG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLmludGVncmF0b3IuaW50ZWdyYXRlKHNlZWQsIG1ham9yKTtcblxuICAgICAgICBjb25zdCBmb3J3YXJkUGFyYW1zOiBTdHJlYW1saW5lSW50ZWdyYXRpb24gPSB7XG4gICAgICAgICAgICBzZWVkOiBzZWVkLFxuICAgICAgICAgICAgb3JpZ2luYWxEaXI6IGQsXG4gICAgICAgICAgICBzdHJlYW1saW5lOiBbc2VlZF0sXG4gICAgICAgICAgICBwcmV2aW91c0RpcmVjdGlvbjogZCxcbiAgICAgICAgICAgIHByZXZpb3VzUG9pbnQ6IHNlZWQuY2xvbmUoKS5hZGQoZCksXG4gICAgICAgICAgICB2YWxpZDogdHJ1ZSxcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcndhcmRQYXJhbXMudmFsaWQgPSB0aGlzLnBvaW50SW5Cb3VuZHMoZm9yd2FyZFBhcmFtcy5wcmV2aW91c1BvaW50KTtcblxuICAgICAgICBjb25zdCBuZWdEID0gZC5jbG9uZSgpLm5lZ2F0ZSgpO1xuICAgICAgICBjb25zdCBiYWNrd2FyZFBhcmFtczogU3RyZWFtbGluZUludGVncmF0aW9uID0ge1xuICAgICAgICAgICAgc2VlZDogc2VlZCxcbiAgICAgICAgICAgIG9yaWdpbmFsRGlyOiBuZWdELFxuICAgICAgICAgICAgc3RyZWFtbGluZTogW10sXG4gICAgICAgICAgICBwcmV2aW91c0RpcmVjdGlvbjogbmVnRCxcbiAgICAgICAgICAgIHByZXZpb3VzUG9pbnQ6IHNlZWQuY2xvbmUoKS5hZGQobmVnRCksXG4gICAgICAgICAgICB2YWxpZDogdHJ1ZSxcbiAgICAgICAgfVxuXG4gICAgICAgIGJhY2t3YXJkUGFyYW1zLnZhbGlkID0gdGhpcy5wb2ludEluQm91bmRzKGJhY2t3YXJkUGFyYW1zLnByZXZpb3VzUG9pbnQpO1xuXG4gICAgICAgIHdoaWxlIChjb3VudCA8IHRoaXMucGFyYW1zLnBhdGhJdGVyYXRpb25zICYmIChmb3J3YXJkUGFyYW1zLnZhbGlkIHx8IGJhY2t3YXJkUGFyYW1zLnZhbGlkKSkge1xuICAgICAgICAgICAgdGhpcy5zdHJlYW1saW5lSW50ZWdyYXRpb25TdGVwKGZvcndhcmRQYXJhbXMsIG1ham9yLCBjb2xsaWRlQm90aCk7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbWxpbmVJbnRlZ3JhdGlvblN0ZXAoYmFja3dhcmRQYXJhbXMsIG1ham9yLCBjb2xsaWRlQm90aCk7XG5cbiAgICAgICAgICAgIC8vIEpvaW4gdXAgY2lyY2xlc1xuICAgICAgICAgICAgY29uc3Qgc3FEaXN0YW5jZUJldHdlZW5Qb2ludHMgPSBmb3J3YXJkUGFyYW1zLnByZXZpb3VzUG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoYmFja3dhcmRQYXJhbXMucHJldmlvdXNQb2ludCk7XG5cbiAgICAgICAgICAgIGlmICghcG9pbnRzRXNjYXBlZCAmJiBzcURpc3RhbmNlQmV0d2VlblBvaW50cyA+IHRoaXMucGFyYW1zU3EuZGNpcmNsZWpvaW4pIHtcbiAgICAgICAgICAgICAgICBwb2ludHNFc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBvaW50c0VzY2FwZWQgJiYgc3FEaXN0YW5jZUJldHdlZW5Qb2ludHMgPD0gdGhpcy5wYXJhbXNTcS5kY2lyY2xlam9pbikge1xuICAgICAgICAgICAgICAgIGZvcndhcmRQYXJhbXMuc3RyZWFtbGluZS5wdXNoKGZvcndhcmRQYXJhbXMucHJldmlvdXNQb2ludCk7XG4gICAgICAgICAgICAgICAgZm9yd2FyZFBhcmFtcy5zdHJlYW1saW5lLnB1c2goYmFja3dhcmRQYXJhbXMucHJldmlvdXNQb2ludCk7XG4gICAgICAgICAgICAgICAgYmFja3dhcmRQYXJhbXMuc3RyZWFtbGluZS5wdXNoKGJhY2t3YXJkUGFyYW1zLnByZXZpb3VzUG9pbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgYmFja3dhcmRQYXJhbXMuc3RyZWFtbGluZS5yZXZlcnNlKCkucHVzaCguLi5mb3J3YXJkUGFyYW1zLnN0cmVhbWxpbmUpO1xuICAgICAgICByZXR1cm4gYmFja3dhcmRQYXJhbXMuc3RyZWFtbGluZTtcbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgVmVjdG9yIGZyb20gJy4uL3ZlY3Rvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlbnNvciB7XG4gICAgcHJpdmF0ZSBvbGRUaGV0YTogYm9vbGVhbjtcbiAgICBwcml2YXRlIF90aGV0YTogbnVtYmVyO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByOiBudW1iZXIsIHByaXZhdGUgbWF0cml4OiBudW1iZXJbXSkge1xuICAgICAgICAvLyBSZXByZXNlbnQgdGhlIG1hdHJpeCBhcyBhIDIgZWxlbWVudCBsaXN0XG4gICAgICAgIC8vIFsgMCwgMVxuICAgICAgICAvLyAgIDEsIC0wIF1cbiAgICAgICAgdGhpcy5vbGRUaGV0YSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl90aGV0YSA9IHRoaXMuY2FsY3VsYXRlVGhldGEoKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbUFuZ2xlKGFuZ2xlOiBudW1iZXIpOiBUZW5zb3Ige1xuICAgICAgICByZXR1cm4gbmV3IFRlbnNvcigxLCBbTWF0aC5jb3MoYW5nbGUgKiA0KSwgTWF0aC5zaW4oYW5nbGUgKiA0KV0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBmcm9tVmVjdG9yKHZlY3RvcjogVmVjdG9yKTogVGVuc29yIHtcbiAgICAgICAgY29uc3QgdDEgPSB2ZWN0b3IueCAqKiAyIC0gdmVjdG9yLnkgKiogMjtcbiAgICAgICAgY29uc3QgdDIgPSAyICogdmVjdG9yLnggKiB2ZWN0b3IueTtcbiAgICAgICAgY29uc3QgdDMgPSB0MSAqKiAyIC0gdDIgKiogMjtcbiAgICAgICAgY29uc3QgdDQgPSAyICogdDEgKiB0MjtcbiAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3IoMSwgW3QzLCB0NF0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgemVybygpOiBUZW5zb3Ige1xuICAgICAgICByZXR1cm4gbmV3IFRlbnNvcigwLCBbMCwgMF0pO1xuICAgIH1cblxuICAgIGdldCB0aGV0YSgpOiBudW1iZXIge1xuICAgICAgICBpZiAodGhpcy5vbGRUaGV0YSkge1xuICAgICAgICAgICAgdGhpcy5fdGhldGEgPSB0aGlzLmNhbGN1bGF0ZVRoZXRhKCk7XG4gICAgICAgICAgICB0aGlzLm9sZFRoZXRhID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fdGhldGE7XG4gICAgfVxuXG4gICAgYWRkKHRlbnNvcjogVGVuc29yLCBzbW9vdGg6IGJvb2xlYW4pOiBUZW5zb3Ige1xuICAgICAgICB0aGlzLm1hdHJpeCA9IHRoaXMubWF0cml4Lm1hcCgodiwgaSkgPT4gdiAqIHRoaXMuciArIHRlbnNvci5tYXRyaXhbaV0gKiB0ZW5zb3Iucik7XG5cbiAgICAgICAgaWYgKHNtb290aCkge1xuICAgICAgICAgICAgdGhpcy5yID0gTWF0aC5oeXBvdCguLi50aGlzLm1hdHJpeCk7XG4gICAgICAgICAgICB0aGlzLm1hdHJpeCA9IHRoaXMubWF0cml4Lm1hcCh2ID0+IHYgLyB0aGlzLnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yID0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub2xkVGhldGEgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzY2FsZShzOiBudW1iZXIpOiBUZW5zb3Ige1xuICAgICAgICB0aGlzLnIgKj0gcztcbiAgICAgICAgdGhpcy5vbGRUaGV0YSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIFJhZGlhbnNcbiAgICByb3RhdGUodGhldGE6IG51bWJlcik6IFRlbnNvciB7XG4gICAgICAgIGlmICh0aGV0YSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld1RoZXRhID0gdGhpcy50aGV0YSArIHRoZXRhO1xuICAgICAgICBpZiAobmV3VGhldGEgPCBNYXRoLlBJKSB7XG4gICAgICAgICAgICBuZXdUaGV0YSArPSBNYXRoLlBJO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld1RoZXRhID49IE1hdGguUEkpIHtcbiAgICAgICAgICAgIG5ld1RoZXRhIC09IE1hdGguUEk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1hdHJpeFswXSA9IE1hdGguY29zKDIgKiBuZXdUaGV0YSkgKiB0aGlzLnI7XG4gICAgICAgIHRoaXMubWF0cml4WzFdID0gTWF0aC5zaW4oMiAqIG5ld1RoZXRhKSAqIHRoaXMucjtcbiAgICAgICAgdGhpcy5fdGhldGEgPSBuZXdUaGV0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0TWFqb3IoKTogVmVjdG9yIHtcbiAgICAgICAgLy8gRGVnZW5lcmF0ZSBjYXNlXG4gICAgICAgIGlmICh0aGlzLnIgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBWZWN0b3IuemVyb1ZlY3RvcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKE1hdGguY29zKHRoaXMudGhldGEpLCBNYXRoLnNpbih0aGlzLnRoZXRhKSk7XG4gICAgfVxuXG4gICAgZ2V0TWlub3IoKTogVmVjdG9yIHtcbiAgICAgICAgLy8gRGVnZW5lcmF0ZSBjYXNlXG4gICAgICAgIGlmICh0aGlzLnIgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBWZWN0b3IuemVyb1ZlY3RvcigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gdGhpcy50aGV0YSArIE1hdGguUEkgLyAyO1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihNYXRoLmNvcyhhbmdsZSksIE1hdGguc2luKGFuZ2xlKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjYWxjdWxhdGVUaGV0YSgpOiBudW1iZXIge1xuICAgICAgICBpZiAodGhpcy5yID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLm1hdHJpeFsxXSAvIHRoaXMuciwgdGhpcy5tYXRyaXhbMF0gLyB0aGlzLnIpIC8gMjtcbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IG5vaXNlIGZyb20gJ25vaXNlanMnO1xuaW1wb3J0IFNpbXBsZXhOb2lzZSBmcm9tICdzaW1wbGV4LW5vaXNlJztcbmltcG9ydCB7IGNyZWF0ZU5vaXNlMkQgfSBmcm9tICdzaW1wbGV4LW5vaXNlJztcbmltcG9ydCBUZW5zb3IgZnJvbSAnLi90ZW5zb3InO1xuaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xuaW1wb3J0IHtHcmlkLCBSYWRpYWwsIEJhc2lzRmllbGR9IGZyb20gJy4vYmFzaXNfZmllbGQnO1xuaW1wb3J0IFBvbHlnb25VdGlsIGZyb20gJy4vcG9seWdvbl91dGlsJztcblxuZXhwb3J0IGludGVyZmFjZSBOb2lzZVBhcmFtcyB7XG4gICAgZ2xvYmFsTm9pc2U6IGJvb2xlYW47XG4gICAgbm9pc2VTaXplUGFyazogbnVtYmVyO1xuICAgIG5vaXNlQW5nbGVQYXJrOiBudW1iZXI7ICAvLyBEZWdyZWVzXG4gICAgbm9pc2VTaXplR2xvYmFsOiBudW1iZXI7XG4gICAgbm9pc2VBbmdsZUdsb2JhbDogbnVtYmVyO1xufVxuXG4vKiBDb21iaW5lcyBiYXNpcyBmaWVsZHMgTm9pc2UgYWRkZWQgd2hlbiBzYW1wbGluZyBhIHBvaW50IGluIGEgcGFyayAqL1xuXG4gZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVuc29yRmllbGQge1xuICAgIHB1YmxpYyBiYXNpc0ZpZWxkczogQmFzaXNGaWVsZFtdPVtdO1xuICAgIHB1YmxpYyBub2lzZTp0eXBlb2YgU2ltcGxleE5vaXNlO1xuICAgIHB1YmxpYyBwYXJrczogVmVjdG9yW11bXT1bXTtcbiAgICBwdWJsaWMgc2VhOiBWZWN0b3JbXT1bXTtcbiAgICBwdWJsaWMgcml2ZXI6IFZlY3RvcltdPVtdO1xuICAgIHB1YmxpYyBpZ25vcmVSaXZlciA9IGZhbHNlO1xuICAgIHB1YmxpYyBzbW9vdGggPSBmYWxzZTtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgbm9pc2VQYXJhbXM6IE5vaXNlUGFyYW1zKXt0aGlzLm5vaXNlO31cblxuICAgIC8qIFVzZWQgd2hlbiBpbnRlZ3JhdGluZyBjb2FzdGxpbmUgYW5kIHJpdmVyICovXG5cbiAgICBlbmFibGVHbG9iYWxOb2lzZShhbmdsZTogbnVtYmVyLCBzaXplOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5ub2lzZVBhcmFtcy5nbG9iYWxOb2lzZSA9IHRydWU7XG4gICAgICAgIHRoaXMubm9pc2VQYXJhbXMubm9pc2VBbmdsZUdsb2JhbCA9IGFuZ2xlO1xuICAgICAgICB0aGlzLm5vaXNlUGFyYW1zLm5vaXNlU2l6ZUdsb2JhbCA9IHNpemU7XG4gICAgfVxuXG4gICAgZGlzYWJsZUdsb2JhbE5vaXNlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLm5vaXNlUGFyYW1zLmdsb2JhbE5vaXNlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgYWRkR3JpZChjZW50cmU6IFZlY3Rvciwgc2l6ZTogbnVtYmVyLCBkZWNheTogbnVtYmVyLCB0aGV0YTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGdyaWQgPSBuZXcgR3JpZChjZW50cmUsIHNpemUsIGRlY2F5LCB0aGV0YSk7XG4gICAgICAgIHRoaXMuYWRkRmllbGQoZ3JpZCk7XG4gICAgfVxuXG4gICAgYWRkUmFkaWFsKGNlbnRyZTogVmVjdG9yLCBzaXplOiBudW1iZXIsIGRlY2F5OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgcmFkaWFsID0gbmV3IFJhZGlhbChjZW50cmUsIHNpemUsIGRlY2F5KTtcbiAgICAgICAgdGhpcy5hZGRGaWVsZChyYWRpYWwpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBhZGRGaWVsZChmaWVsZDogQmFzaXNGaWVsZCk6IHZvaWQge1xuICAgICAgICB0aGlzLmJhc2lzRmllbGRzLnB1c2goZmllbGQpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCByZW1vdmVGaWVsZChmaWVsZDogQmFzaXNGaWVsZCk6IHZvaWQge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuYmFzaXNGaWVsZHMuaW5kZXhPZihmaWVsZCk7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2lzRmllbGRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5iYXNpc0ZpZWxkcyA9IFtdO1xuICAgICAgICB0aGlzLnBhcmtzID0gW107XG4gICAgICAgIHRoaXMuc2VhID0gW107XG4gICAgICAgIHRoaXMucml2ZXIgPSBbXTtcbiAgICB9XG5cbiAgICBnZXRDZW50cmVQb2ludHMoKTogVmVjdG9yW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNpc0ZpZWxkcy5tYXAoZmllbGQgPT4gZmllbGQuY2VudHJlKTtcbiAgICB9XG5cbiAgICBnZXRCYXNpc0ZpZWxkcygpOiBCYXNpc0ZpZWxkW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNpc0ZpZWxkcztcbiAgICB9XG5cbiAgICBzYW1wbGVQb2ludChwb2ludDogVmVjdG9yKTogVGVuc29yIHtcbiAgICAgICAgaWYgKCF0aGlzLm9uTGFuZChwb2ludCkpIHtcbiAgICAgICAgICAgIC8vIERlZ2VuZXJhdGUgcG9pbnRcbiAgICAgICAgICAgIHJldHVybiBUZW5zb3IuemVybztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHQgZmllbGQgaXMgYSBncmlkXG4gICAgICAgIGlmICh0aGlzLmJhc2lzRmllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3IoMSwgWzAsIDBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRlbnNvckFjYyA9IFRlbnNvci56ZXJvO1xuICAgICAgICB0aGlzLmJhc2lzRmllbGRzLmZvckVhY2goZmllbGQgPT4gdGVuc29yQWNjLmFkZChmaWVsZC5nZXRXZWlnaHRlZFRlbnNvcihwb2ludCwgdGhpcy5zbW9vdGgpLCB0aGlzLnNtb290aCkpO1xuXG4gICAgICAgIC8vIEFkZCByb3RhdGlvbmFsIG5vaXNlIGZvciBwYXJrcyAtIHJhbmdlIC1waS8yIHRvIHBpLzJcbiAgICAgICAgaWYgKHRoaXMucGFya3Muc29tZShwID0+IFBvbHlnb25VdGlsLmluc2lkZVBvbHlnb24ocG9pbnQsIHApKSkge1xuICAgICAgICAgICAgLy8gVE9ETyBvcHRpbWlzZSBpbnNpZGVQb2x5Z29uIGUuZy4gZGlzdGFuY2VcbiAgICAgICAgICAgIHRlbnNvckFjYy5yb3RhdGUodGhpcy5nZXRSb3RhdGlvbmFsTm9pc2UocG9pbnQsIHRoaXMubm9pc2VQYXJhbXMubm9pc2VTaXplUGFyaywgdGhpcy5ub2lzZVBhcmFtcy5ub2lzZUFuZ2xlUGFyaykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubm9pc2VQYXJhbXMuZ2xvYmFsTm9pc2UpIHtcbiAgICAgICAgICAgIHRlbnNvckFjYy5yb3RhdGUodGhpcy5nZXRSb3RhdGlvbmFsTm9pc2UocG9pbnQsIHRoaXMubm9pc2VQYXJhbXMubm9pc2VTaXplR2xvYmFsLCB0aGlzLm5vaXNlUGFyYW1zLm5vaXNlQW5nbGVHbG9iYWwpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZW5zb3JBY2M7XG4gICAgfVxuXG4gICAgLyogTm9pc2UgQW5nbGUgaXMgaW4gZGVncmVlcyAqL1xuICAgIGdldFJvdGF0aW9uYWxOb2lzZShwb2ludDogVmVjdG9yLCBub2lzZVNpemU6IG51bWJlciwgbm9pc2VBbmdsZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgIGNvbnN0IG5vaXNlMkQgPSBjcmVhdGVOb2lzZTJEKCk7XG4gICAgICByZXR1cm4gbm9pc2UyRChwb2ludC54IC8gbm9pc2VTaXplLCBwb2ludC55IC8gbm9pc2VTaXplKSAqIG5vaXNlQW5nbGUgKiBNYXRoLlBJIC8gMTgwO1xuICAgIH1cblxuICAgIG9uTGFuZChwb2ludDogVmVjdG9yKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGluU2VhID0gUG9seWdvblV0aWwuaW5zaWRlUG9seWdvbihwb2ludCwgdGhpcy5zZWEpO1xuICAgICAgICBpZiAodGhpcy5pZ25vcmVSaXZlcikge1xuICAgICAgICAgICAgcmV0dXJuICFpblNlYTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhaW5TZWEgJiYgIVBvbHlnb25VdGlsLmluc2lkZVBvbHlnb24ocG9pbnQsIHRoaXMucml2ZXIpO1xuICAgIH1cblxuICAgIGluUGFya3MocG9pbnQ6IFZlY3Rvcik6IGJvb2xlYW4ge1xuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5wYXJrcykge1xuICAgICAgICAgICAgaWYgKFBvbHlnb25VdGlsLmluc2lkZVBvbHlnb24ocG9pbnQsIHApKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuIiwiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0ICogYXMgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcbmltcG9ydCBGaWVsZEludGVncmF0b3IgZnJvbSAnLi9pbnRlZ3JhdG9yJztcbmltcG9ydCBTdHJlYW1saW5lR2VuZXJhdG9yIGZyb20gJy4vc3RyZWFtbGluZXMnO1xuaW1wb3J0IHtTdHJlYW1saW5lUGFyYW1zfSBmcm9tICcuL3N0cmVhbWxpbmVzJztcbmltcG9ydCBUZW5zb3JGaWVsZCBmcm9tICcuL3RlbnNvcl9maWVsZCc7XG5pbXBvcnQgUG9seWdvblV0aWwgZnJvbSAnLi9wb2x5Z29uX3V0aWwnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFdhdGVyUGFyYW1zIGV4dGVuZHMgU3RyZWFtbGluZVBhcmFtcyB7XG4gICAgY29hc3ROb2lzZTogTm9pc2VTdHJlYW1saW5lUGFyYW1zO1xuICAgIHJpdmVyTm9pc2U6IE5vaXNlU3RyZWFtbGluZVBhcmFtcztcbiAgICByaXZlckJhbmtTaXplOiBudW1iZXI7XG4gICAgcml2ZXJTaXplOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm9pc2VTdHJlYW1saW5lUGFyYW1zIHtcbiAgICBub2lzZUVuYWJsZWQ6IGJvb2xlYW47XG4gICAgbm9pc2VTaXplOiBudW1iZXI7XG4gICAgbm9pc2VBbmdsZTogbnVtYmVyO1xufVxuXG4vKipcbiAqIEludGVncmF0ZXMgcG9seWxpbmVzIHRvIGNyZWF0ZSBjb2FzdGxpbmUgYW5kIHJpdmVyLCB3aXRoIGNvbnRyb2xsYWJsZSBub2lzZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXYXRlckdlbmVyYXRvciBleHRlbmRzIFN0cmVhbWxpbmVHZW5lcmF0b3Ige1xuICAgIHByaXZhdGUgcmVhZG9ubHkgVFJJRVMgPSAxMDA7XG4gICAgcHJpdmF0ZSBjb2FzdGxpbmVNYWpvciA9IHRydWU7XG4gICAgcHJpdmF0ZSBfY29hc3RsaW5lOiBWZWN0b3JbXSA9IFtdOyAgLy8gTm9pc3kgbGluZVxuICAgIHByaXZhdGUgX3NlYVBvbHlnb246IFZlY3RvcltdID0gW107ICAvLyBVc2VzIHNjcmVlbiByZWN0YW5nbGUgYW5kIHNpbXBsaWZpZWQgcm9hZFxuICAgIHByaXZhdGUgX3JpdmVyUG9seWdvbjogVmVjdG9yW10gPSBbXTsgLy8gU2ltcGxpZmllZFxuICAgIHByaXZhdGUgX3JpdmVyU2Vjb25kYXJ5Um9hZDogVmVjdG9yW10gPSBbXTtcblxuICAgIGNvbnN0cnVjdG9yKGludGVncmF0b3I6IEZpZWxkSW50ZWdyYXRvcixcbiAgICAgICAgICAgICAgICBvcmlnaW46IFZlY3RvcixcbiAgICAgICAgICAgICAgICB3b3JsZERpbWVuc2lvbnM6IFZlY3RvcixcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyYW1zOiBXYXRlclBhcmFtcyxcbiAgICAgICAgICAgICAgICBwcml2YXRlIHRlbnNvckZpZWxkOiBUZW5zb3JGaWVsZCkge1xuICAgICAgICBzdXBlcihpbnRlZ3JhdG9yLCBvcmlnaW4sIHdvcmxkRGltZW5zaW9ucywgcGFyYW1zKTtcbiAgICB9XG5cbiAgICBnZXQgY29hc3RsaW5lKCk6IFZlY3RvcltdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvYXN0bGluZTtcbiAgICB9XG5cbiAgICBnZXQgc2VhUG9seWdvbigpOiBWZWN0b3JbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWFQb2x5Z29uO1xuICAgIH1cblxuICAgIGdldCByaXZlclBvbHlnb24oKTogVmVjdG9yW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcml2ZXJQb2x5Z29uO1xuICAgIH1cblxuICAgIGdldCByaXZlclNlY29uZGFyeVJvYWQoKTogVmVjdG9yW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcml2ZXJTZWNvbmRhcnlSb2FkO1xuICAgIH1cblxuICAgIGNyZWF0ZUNvYXN0KCk6IHZvaWQge1xuICAgICAgICBsZXQgY29hc3RTdHJlYW1saW5lO1xuICAgICAgICBsZXQgc2VlZDtcbiAgICAgICAgbGV0IG1ham9yO1xuXG4gICAgICAgIGlmICh0aGlzLnBhcmFtcy5jb2FzdE5vaXNlLm5vaXNlRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy50ZW5zb3JGaWVsZC5lbmFibGVHbG9iYWxOb2lzZSh0aGlzLnBhcmFtcy5jb2FzdE5vaXNlLm5vaXNlQW5nbGUsIHRoaXMucGFyYW1zLmNvYXN0Tm9pc2Uubm9pc2VTaXplKTsgICAgXG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLlRSSUVTOyBpKyspIHtcbiAgICAgICAgICAgIG1ham9yID0gTWF0aC5yYW5kb20oKSA8IDAuNTtcbiAgICAgICAgICAgIHNlZWQgPSB0aGlzLmdldFNlZWQobWFqb3IpO1xuICAgICAgICAgICAgY29hc3RTdHJlYW1saW5lID0gdGhpcy5leHRlbmRTdHJlYW1saW5lKHRoaXMuaW50ZWdyYXRlU3RyZWFtbGluZShzZWVkLCBtYWpvcikpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5yZWFjaGVzRWRnZXMoY29hc3RTdHJlYW1saW5lKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudGVuc29yRmllbGQuZGlzYWJsZUdsb2JhbE5vaXNlKCk7XG5cbiAgICAgICAgdGhpcy5fY29hc3RsaW5lID0gY29hc3RTdHJlYW1saW5lO1xuICAgICAgICB0aGlzLmNvYXN0bGluZU1ham9yID0gbWFqb3I7XG5cbiAgICAgICAgY29uc3Qgcm9hZCA9IHRoaXMuc2ltcGxpZnlTdHJlYW1saW5lKGNvYXN0U3RyZWFtbGluZSk7XG4gICAgICAgIHRoaXMuX3NlYVBvbHlnb24gPSB0aGlzLmdldFNlYVBvbHlnb24ocm9hZCk7XG4gICAgICAgIHRoaXMuYWxsU3RyZWFtbGluZXNTaW1wbGUucHVzaChyb2FkKTtcbiAgICAgICAgdGhpcy50ZW5zb3JGaWVsZC5zZWEgPSAodGhpcy5fc2VhUG9seWdvbik7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGludGVybWVkaWF0ZSBzYW1wbGVzXG4gICAgICAgIGNvbnN0IGNvbXBsZXggPSB0aGlzLmNvbXBsZXhpZnlTdHJlYW1saW5lKHJvYWQpO1xuICAgICAgICB0aGlzLmdyaWQobWFqb3IpLmFkZFBvbHlsaW5lKGNvbXBsZXgpO1xuICAgICAgICB0aGlzLnN0cmVhbWxpbmVzKG1ham9yKS5wdXNoKGNvbXBsZXgpO1xuICAgICAgICB0aGlzLmFsbFN0cmVhbWxpbmVzLnB1c2goY29tcGxleCk7XG4gICAgfVxuXG4gICAgY3JlYXRlUml2ZXIoKTogdm9pZCB7XG4gICAgICAgIGxldCByaXZlclN0cmVhbWxpbmU7XG4gICAgICAgIGxldCBzZWVkO1xuXG4gICAgICAgIC8vIE5lZWQgdG8gaWdub3JlIHNlYSB3aGVuIGludGVncmF0aW5nIGZvciBlZGdlIGNoZWNrXG4gICAgICAgIGNvbnN0IG9sZFNlYSA9IHRoaXMudGVuc29yRmllbGQuc2VhO1xuICAgICAgICB0aGlzLnRlbnNvckZpZWxkLnNlYSA9IFtdO1xuICAgICAgICBpZiAodGhpcy5wYXJhbXMucml2ZXJOb2lzZS5ub2lzZUVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudGVuc29yRmllbGQuZW5hYmxlR2xvYmFsTm9pc2UodGhpcy5wYXJhbXMucml2ZXJOb2lzZS5ub2lzZUFuZ2xlLCB0aGlzLnBhcmFtcy5yaXZlck5vaXNlLm5vaXNlU2l6ZSk7ICAgIFxuICAgICAgICB9ICAgICAgICBcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLlRSSUVTOyBpKyspIHtcbiAgICAgICAgICAgIHNlZWQgPSB0aGlzLmdldFNlZWQoIXRoaXMuY29hc3RsaW5lTWFqb3IpO1xuICAgICAgICAgICAgcml2ZXJTdHJlYW1saW5lID0gdGhpcy5leHRlbmRTdHJlYW1saW5lKHRoaXMuaW50ZWdyYXRlU3RyZWFtbGluZShzZWVkLCAhdGhpcy5jb2FzdGxpbmVNYWpvcikpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5yZWFjaGVzRWRnZXMocml2ZXJTdHJlYW1saW5lKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpID09PSB0aGlzLlRSSUVTIC0gMSkge1xuICAgICAgICAgICAgICAgIGxvZy5lcnJvcignRmFpbGVkIHRvIGZpbmQgcml2ZXIgcmVhY2hpbmcgZWRnZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudGVuc29yRmllbGQuc2VhID0gb2xkU2VhO1xuICAgICAgICB0aGlzLnRlbnNvckZpZWxkLmRpc2FibGVHbG9iYWxOb2lzZSgpO1xuXG4gICAgICAgIC8vIENyZWF0ZSByaXZlciByb2Fkc1xuICAgICAgICBjb25zdCBleHBhbmRlZE5vaXN5ID0gdGhpcy5jb21wbGV4aWZ5U3RyZWFtbGluZShQb2x5Z29uVXRpbC5yZXNpemVHZW9tZXRyeShyaXZlclN0cmVhbWxpbmUsIHRoaXMucGFyYW1zLnJpdmVyU2l6ZSwgZmFsc2UpKTtcbiAgICAgICAgdGhpcy5fcml2ZXJQb2x5Z29uID0gUG9seWdvblV0aWwucmVzaXplR2VvbWV0cnkocml2ZXJTdHJlYW1saW5lLCB0aGlzLnBhcmFtcy5yaXZlclNpemUgLSB0aGlzLnBhcmFtcy5yaXZlckJhbmtTaXplLCBmYWxzZSk7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSByaXZlclBvbHlnb25bMF0gaXMgb2ZmIHNjcmVlblxuICAgICAgICBjb25zdCBmaXJzdE9mZlNjcmVlbiA9IGV4cGFuZGVkTm9pc3kuZmluZEluZGV4KHYgPT4gdGhpcy52ZWN0b3JPZmZTY3JlZW4odikpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpcnN0T2ZmU2NyZWVuOyBpKyspIHtcbiAgICAgICAgICAgIGV4cGFuZGVkTm9pc3kucHVzaChleHBhbmRlZE5vaXN5LnNoaWZ0KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIHJpdmVyIHJvYWRzXG4gICAgICAgIGNvbnN0IHJpdmVyU3BsaXRQb2x5ID0gdGhpcy5nZXRTZWFQb2x5Z29uKHJpdmVyU3RyZWFtbGluZSk7XG4gICAgICAgIGNvbnN0IHJvYWQxID0gZXhwYW5kZWROb2lzeS5maWx0ZXIodiA9PlxuICAgICAgICAgICAgIVBvbHlnb25VdGlsLmluc2lkZVBvbHlnb24odiwgdGhpcy5fc2VhUG9seWdvbilcbiAgICAgICAgICAgICYmICF0aGlzLnZlY3Rvck9mZlNjcmVlbih2KVxuICAgICAgICAgICAgJiYgUG9seWdvblV0aWwuaW5zaWRlUG9seWdvbih2LCByaXZlclNwbGl0UG9seSkpO1xuICAgICAgICBjb25zdCByb2FkMVNpbXBsZSA9IHRoaXMuc2ltcGxpZnlTdHJlYW1saW5lKHJvYWQxKTtcbiAgICAgICAgY29uc3Qgcm9hZDIgPSBleHBhbmRlZE5vaXN5LmZpbHRlcih2ID0+XG4gICAgICAgICAgICAhUG9seWdvblV0aWwuaW5zaWRlUG9seWdvbih2LCB0aGlzLl9zZWFQb2x5Z29uKVxuICAgICAgICAgICAgJiYgIXRoaXMudmVjdG9yT2ZmU2NyZWVuKHYpXG4gICAgICAgICAgICAmJiAhUG9seWdvblV0aWwuaW5zaWRlUG9seWdvbih2LCByaXZlclNwbGl0UG9seSkpO1xuICAgICAgICBjb25zdCByb2FkMlNpbXBsZSA9IHRoaXMuc2ltcGxpZnlTdHJlYW1saW5lKHJvYWQyKTtcblxuICAgICAgICBpZiAocm9hZDEubGVuZ3RoID09PSAwIHx8IHJvYWQyLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICAgIGlmIChyb2FkMVswXS5kaXN0YW5jZVRvU3F1YXJlZChyb2FkMlswXSkgPCByb2FkMVswXS5kaXN0YW5jZVRvU3F1YXJlZChyb2FkMltyb2FkMi5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgICAgIHJvYWQyU2ltcGxlLnJldmVyc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGVuc29yRmllbGQucml2ZXIgPSByb2FkMVNpbXBsZS5jb25jYXQocm9hZDJTaW1wbGUpO1xuXG4gICAgICAgIC8vIFJvYWQgMVxuICAgICAgICB0aGlzLmFsbFN0cmVhbWxpbmVzU2ltcGxlLnB1c2gocm9hZDFTaW1wbGUpO1xuICAgICAgICB0aGlzLl9yaXZlclNlY29uZGFyeVJvYWQgPSByb2FkMlNpbXBsZTtcblxuICAgICAgICB0aGlzLmdyaWQoIXRoaXMuY29hc3RsaW5lTWFqb3IpLmFkZFBvbHlsaW5lKHJvYWQxKTtcbiAgICAgICAgdGhpcy5ncmlkKCF0aGlzLmNvYXN0bGluZU1ham9yKS5hZGRQb2x5bGluZShyb2FkMik7XG4gICAgICAgIHRoaXMuc3RyZWFtbGluZXMoIXRoaXMuY29hc3RsaW5lTWFqb3IpLnB1c2gocm9hZDEpO1xuICAgICAgICB0aGlzLnN0cmVhbWxpbmVzKCF0aGlzLmNvYXN0bGluZU1ham9yKS5wdXNoKHJvYWQyKTtcbiAgICAgICAgdGhpcy5hbGxTdHJlYW1saW5lcy5wdXNoKHJvYWQxKTtcbiAgICAgICAgdGhpcy5hbGxTdHJlYW1saW5lcy5wdXNoKHJvYWQyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3N1bWVzIHNpbXBsaWZpZWRcbiAgICAgKiBVc2VkIGZvciBhZGRpbmcgcml2ZXIgcm9hZHNcbiAgICAgKi9cbiAgICBwcml2YXRlIG1hbnVhbGx5QWRkU3RyZWFtbGluZShzOiBWZWN0b3JbXSwgbWFqb3I6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5hbGxTdHJlYW1saW5lc1NpbXBsZS5wdXNoKHMpO1xuICAgICAgICAvLyBDcmVhdGUgaW50ZXJtZWRpYXRlIHNhbXBsZXNcbiAgICAgICAgY29uc3QgY29tcGxleCA9IHRoaXMuY29tcGxleGlmeVN0cmVhbWxpbmUocyk7XG4gICAgICAgIHRoaXMuZ3JpZChtYWpvcikuYWRkUG9seWxpbmUoY29tcGxleCk7XG4gICAgICAgIHRoaXMuc3RyZWFtbGluZXMobWFqb3IpLnB1c2goY29tcGxleCk7XG4gICAgICAgIHRoaXMuYWxsU3RyZWFtbGluZXMucHVzaChjb21wbGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNaWdodCByZXZlcnNlIGlucHV0IGFycmF5XG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXRTZWFQb2x5Z29uKHBvbHlsaW5lOiBWZWN0b3JbXSk6IFZlY3RvcltdIHtcbiAgICAgICAgLy8gY29uc3Qgc2VhUG9seWdvbiA9IFBvbHlnb25VdGlsLnNsaWNlUmVjdGFuZ2xlKHRoaXMub3JpZ2luLCB0aGlzLndvcmxkRGltZW5zaW9ucyxcbiAgICAgICAgLy8gICAgIHBvbHlsaW5lWzBdLCBwb2x5bGluZVtwb2x5bGluZS5sZW5ndGggLSAxXSk7XG5cbiAgICAgICAgLy8gLy8gUmVwbGFjZSB0aGUgbG9uZ2VzdCBzaWRlIHdpdGggY29hc3RsaW5lXG4gICAgICAgIC8vIGxldCBsb25nZXN0SW5kZXggPSAwO1xuICAgICAgICAvLyBsZXQgbG9uZ2VzdExlbmd0aCA9IDA7XG4gICAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgc2VhUG9seWdvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyAgICAgY29uc3QgbmV4dCA9IChpICsgMSkgJSBzZWFQb2x5Z29uLmxlbmd0aDtcbiAgICAgICAgLy8gICAgIGNvbnN0IGQgPSBzZWFQb2x5Z29uW2ldLmRpc3RhbmNlVG9TcXVhcmVkKHNlYVBvbHlnb25bbmV4dF0pO1xuICAgICAgICAvLyAgICAgaWYgKGQgPiBsb25nZXN0TGVuZ3RoKSB7XG4gICAgICAgIC8vICAgICAgICAgbG9uZ2VzdExlbmd0aCA9IGQ7XG4gICAgICAgIC8vICAgICAgICAgbG9uZ2VzdEluZGV4ID0gaTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIGNvbnN0IGluc2VydEJhY2t3YXJkcyA9IHNlYVBvbHlnb25bbG9uZ2VzdEluZGV4XS5kaXN0YW5jZVRvU3F1YXJlZChwb2x5bGluZVswXSkgPiBzZWFQb2x5Z29uW2xvbmdlc3RJbmRleF0uZGlzdGFuY2VUb1NxdWFyZWQocG9seWxpbmVbcG9seWxpbmUubGVuZ3RoIC0gMV0pO1xuICAgICAgICAvLyBpZiAoaW5zZXJ0QmFja3dhcmRzKSB7XG4gICAgICAgIC8vICAgICBwb2x5bGluZS5yZXZlcnNlKCk7XG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyBzZWFQb2x5Z29uLnNwbGljZSgobG9uZ2VzdEluZGV4ICsgMSkgJSBzZWFQb2x5Z29uLmxlbmd0aCwgMCwgLi4ucG9seWxpbmUpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIFBvbHlnb25VdGlsLmxpbmVSZWN0YW5nbGVQb2x5Z29uSW50ZXJzZWN0aW9uKHRoaXMub3JpZ2luLCB0aGlzLndvcmxkRGltZW5zaW9ucywgcG9seWxpbmUpO1xuXG4gICAgICAgIC8vIHJldHVybiBQb2x5Z29uVXRpbC5ib3VuZFBvbHlUb1NjcmVlbih0aGlzLm9yaWdpbiwgdGhpcy53b3JsZERpbWVuc2lvbnMsIHNlYVBvbHlnb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydCBzYW1wbGVzIGluIHN0cmVhbWxpbmUgdW50aWwgc2VwYXJhdGVkIGJ5IGRzdGVwXG4gICAgICovXG4gICAgcHJpdmF0ZSBjb21wbGV4aWZ5U3RyZWFtbGluZShzOiBWZWN0b3JbXSk6IFZlY3RvcltdIHtcbiAgICAgICAgY29uc3Qgb3V0OiBWZWN0b3JbXSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBvdXQucHVzaCguLi50aGlzLmNvbXBsZXhpZnlTdHJlYW1saW5lUmVjdXJzaXZlKHNbaV0sIHNbaSsxXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjb21wbGV4aWZ5U3RyZWFtbGluZVJlY3Vyc2l2ZSh2MTogVmVjdG9yLCB2MjogVmVjdG9yKTogVmVjdG9yW10ge1xuICAgICAgICBpZiAodjEuZGlzdGFuY2VUb1NxdWFyZWQodjIpIDw9IHRoaXMucGFyYW1zU3EuZHN0ZXApIHtcbiAgICAgICAgICAgIHJldHVybiBbdjEsIHYyXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkID0gdjIuY2xvbmUoKS5zdWIodjEpO1xuICAgICAgICBjb25zdCBoYWxmd2F5ID0gdjEuY2xvbmUoKS5hZGQoZC5tdWx0aXBseVNjYWxhcigwLjUpKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGNvbXBsZXggPSB0aGlzLmNvbXBsZXhpZnlTdHJlYW1saW5lUmVjdXJzaXZlKHYxLCBoYWxmd2F5KTtcbiAgICAgICAgY29tcGxleC5wdXNoKC4uLnRoaXMuY29tcGxleGlmeVN0cmVhbWxpbmVSZWN1cnNpdmUoaGFsZndheSwgdjIpKTtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTXV0YXRlcyBzdHJlYW1saW5lXG4gICAgICovXG4gICAgcHJpdmF0ZSBleHRlbmRTdHJlYW1saW5lKHN0cmVhbWxpbmU6IFZlY3RvcltdKTogVmVjdG9yW10ge1xuICAgICAgICAgICAgc3RyZWFtbGluZS51bnNoaWZ0KHN0cmVhbWxpbmVbMF0uY2xvbmUoKS5hZGQoXG4gICAgICAgICAgICAgICAgc3RyZWFtbGluZVswXS5jbG9uZSgpLnN1YihzdHJlYW1saW5lWzFdKS5zZXRMZW5ndGgodGhpcy5wYXJhbXMuZHN0ZXAgKiA1KSkpO1xuICAgICAgICAgICAgc3RyZWFtbGluZS5wdXNoKHN0cmVhbWxpbmVbc3RyZWFtbGluZS5sZW5ndGggLSAxXS5jbG9uZSgpLmFkZChcbiAgICAgICAgICAgICAgICBzdHJlYW1saW5lW3N0cmVhbWxpbmUubGVuZ3RoIC0gMV0uY2xvbmUoKS5zdWIoc3RyZWFtbGluZVtzdHJlYW1saW5lLmxlbmd0aCAtIDJdKS5zZXRMZW5ndGgodGhpcy5wYXJhbXMuZHN0ZXAgKiA1KSkpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cmVhbWxpbmU7XG4gICAgICAgIH1cblxuICAgIHByaXZhdGUgcmVhY2hlc0VkZ2VzKHN0cmVhbWxpbmU6IFZlY3RvcltdKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnZlY3Rvck9mZlNjcmVlbihzdHJlYW1saW5lWzBdKSAmJiB0aGlzLnZlY3Rvck9mZlNjcmVlbihzdHJlYW1saW5lW3N0cmVhbWxpbmUubGVuZ3RoIC0gMV0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgdmVjdG9yT2ZmU2NyZWVuKHY6IFZlY3Rvcik6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCB0b09yaWdpbiA9IHYuY2xvbmUoKS5zdWIodGhpcy5vcmlnaW4pO1xuICAgICAgICByZXR1cm4gdG9PcmlnaW4ueCA8PSAwIHx8IHRvT3JpZ2luLnkgPD0gMCB8fFxuICAgICAgICAgICAgdG9PcmlnaW4ueCA+PSB0aGlzLndvcmxkRGltZW5zaW9ucy54IHx8IHRvT3JpZ2luLnkgPj0gdGhpcy53b3JsZERpbWVuc2lvbnMueTtcbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IERvbWFpbkNvbnRyb2xsZXIgZnJvbSAnLi9kb21haW5fY29udHJvbGxlcic7XG5pbXBvcnQgVGVuc29yRmllbGQgZnJvbSAnLi4vaW1wbC90ZW5zb3JfZmllbGQnO1xuaW1wb3J0IEdyYXBoIGZyb20gJy4uL2ltcGwvZ3JhcGgnO1xuaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xuaW1wb3J0IFBvbHlnb25GaW5kZXIgZnJvbSAnLi4vaW1wbC9wb2x5Z29uX2ZpbmRlcic7XG5pbXBvcnQge1BvbHlnb25QYXJhbXN9IGZyb20gJy4uL2ltcGwvcG9seWdvbl9maW5kZXInO1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgQnVpbGRpbmdNb2RlbCB7XG4gICAgaGVpZ2h0OiBudW1iZXI7XG4gICAgbG90V29ybGQ6IFZlY3RvcltdOyAvLyBJbiB3b3JsZCBzcGFjZVxuICAgIGxvdFNjcmVlbjogVmVjdG9yW107IC8vIEluIHNjcmVlbiBzcGFjZVxuICAgIHJvb2Y6IFZlY3RvcltdOyAvLyBJbiBzY3JlZW4gc3BhY2VcbiAgICBzaWRlczogVmVjdG9yW11bXTsgLy8gSW4gc2NyZWVuIHNwYWNlXG59XG5cbi8qKlxuICogUHNldWRvIDNEIGJ1aWxkaW5ncyAvL2h0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9aDZjeU5QZTVrWmdcbiAqL1xuY2xhc3MgQnVpbGRpbmdNb2RlbHMge1xuICAgIHByaXZhdGUgZG9tYWluQ29udHJvbGxlciA9IERvbWFpbkNvbnRyb2xsZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICBwcml2YXRlIF9idWlsZGluZ01vZGVsczogQnVpbGRpbmdNb2RlbFtdID0gW107XG5cbiAgICBjb25zdHJ1Y3Rvcihsb3RzOiBWZWN0b3JbXVtdKSB7ICAvLyBMb3RzIGluIHdvcmxkIHNwYWNlXG4gICAgICAgIGZvciAoY29uc3QgbG90IG9mIGxvdHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1aWxkaW5nTW9kZWxzLnB1c2goe1xuICAgICAgICAgICAgICAgIGhlaWdodDogTWF0aC5yYW5kb20oKSAqIDIwICsgMjAsXG4gICAgICAgICAgICAgICAgbG90V29ybGQ6IGxvdCxcbiAgICAgICAgICAgICAgICBsb3RTY3JlZW46IFtdLFxuICAgICAgICAgICAgICAgIHJvb2Y6IFtdLFxuICAgICAgICAgICAgICAgIHNpZGVzOiBbXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYnVpbGRpbmdNb2RlbHMuc29ydCgoYSwgYikgPT4gYS5oZWlnaHQgLSBiLmhlaWdodCk7XG4gICAgfVxuXG4gICAgZ2V0IGJ1aWxkaW5nTW9kZWxzKCk6IEJ1aWxkaW5nTW9kZWxbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWlsZGluZ01vZGVscztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWNhbGN1bGF0ZWQgd2hlbiB0aGUgY2FtZXJhIG1vdmVzXG4gICAgICovXG4gICAgc2V0QnVpbGRpbmdQcm9qZWN0aW9ucygpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZCA9IDEwMDAgLyB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbTtcbiAgICAgICAgY29uc3QgY2FtZXJhUG9zID0gdGhpcy5kb21haW5Db250cm9sbGVyLmdldENhbWVyYVBvc2l0aW9uKCk7XG4gICAgICAgIGZvciAoY29uc3QgYiBvZiB0aGlzLl9idWlsZGluZ01vZGVscykge1xuICAgICAgICAgICAgYi5sb3RTY3JlZW4gPSBiLmxvdFdvcmxkLm1hcCh2ID0+IHRoaXMuZG9tYWluQ29udHJvbGxlci53b3JsZFRvU2NyZWVuKHYuY2xvbmUoKSkpO1xuICAgICAgICAgICAgYi5yb29mID0gYi5sb3RTY3JlZW4ubWFwKHYgPT4gdGhpcy5oZWlnaHRWZWN0b3JUb1NjcmVlbih2LCBiLmhlaWdodCwgZCwgY2FtZXJhUG9zKSk7XG4gICAgICAgICAgICBiLnNpZGVzID0gdGhpcy5nZXRCdWlsZGluZ1NpZGVzKGIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoZWlnaHRWZWN0b3JUb1NjcmVlbih2OiBWZWN0b3IsIGg6IG51bWJlciwgZDogbnVtYmVyLCBjYW1lcmE6IFZlY3Rvcik6IFZlY3RvciB7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gKGQgLyAoZCAtIGgpKTsgLy8gMC4xXG4gICAgICAgIGlmICh0aGlzLmRvbWFpbkNvbnRyb2xsZXIub3J0aG9ncmFwaGljKSB7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gdGhpcy5kb21haW5Db250cm9sbGVyLmNhbWVyYURpcmVjdGlvbi5tdWx0aXBseVNjYWxhcigtaCAqIHNjYWxlKTtcbiAgICAgICAgICAgIHJldHVybiB2LmNsb25lKCkuYWRkKGRpZmYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHYuY2xvbmUoKS5zdWIoY2FtZXJhKS5tdWx0aXBseVNjYWxhcihzY2FsZSkuYWRkKGNhbWVyYSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgc2lkZXMgb2YgYnVpbGRpbmdzIGJ5IGpvaW5pbmcgY29ycmVzcG9uZGluZyBlZGdlcyBiZXR3ZWVuIHRoZSByb29mIGFuZCBncm91bmRcbiAgICAgKi9cbiAgICBwcml2YXRlIGdldEJ1aWxkaW5nU2lkZXMoYjogQnVpbGRpbmdNb2RlbCk6IFZlY3RvcltdW10ge1xuICAgICAgICBjb25zdCBwb2x5Z29uczogVmVjdG9yW11bXSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGIubG90U2NyZWVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gKGkgKyAxKSAlIGIubG90U2NyZWVuLmxlbmd0aDtcbiAgICAgICAgICAgIHBvbHlnb25zLnB1c2goW2IubG90U2NyZWVuW2ldLCBiLmxvdFNjcmVlbltuZXh0XSwgYi5yb29mW25leHRdLCBiLnJvb2ZbaV1dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9seWdvbnM7XG4gICAgfVxufVxuXG4vKipcbiAqIEZpbmRzIGJ1aWxkaW5nIGxvdHMgYW5kIG9wdGlvbmFsbHkgcHNldWRvM0QgYnVpbGRpbmdzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJ1aWxkaW5ncyB7XG4gICAgcHJpdmF0ZSBwb2x5Z29uRmluZGVyOiBQb2x5Z29uRmluZGVyO1xuICAgIHByaXZhdGUgYWxsU3RyZWFtbGluZXM6IFZlY3RvcltdW10gPSBbXTtcbiAgICBwcml2YXRlIGRvbWFpbkNvbnRyb2xsZXIgPSBEb21haW5Db250cm9sbGVyLmdldEluc3RhbmNlKCk7XG4gICAgcHJpdmF0ZSBwcmVHZW5lcmF0ZUNhbGxiYWNrOiAoKSA9PiBhbnkgPSAoKSA9PiB7fTtcbiAgICBwcml2YXRlIHBvc3RHZW5lcmF0ZUNhbGxiYWNrOiAoKSA9PiBhbnkgPSAoKSA9PiB7fTtcbiAgICBwcml2YXRlIF9tb2RlbHM6IEJ1aWxkaW5nTW9kZWxzID0gbmV3IEJ1aWxkaW5nTW9kZWxzKFtdKTtcbiAgICBwcml2YXRlIF9ibG9ja3M6IFZlY3RvcltdW10gPSBbXTtcblxuICAgIHByaXZhdGUgYnVpbGRpbmdQYXJhbXM6IFBvbHlnb25QYXJhbXMgPSB7XG4gICAgICAgIG1heExlbmd0aDogMjAsXG4gICAgICAgIG1pbkFyZWE6IDUwLFxuICAgICAgICBzaHJpbmtTcGFjaW5nOiA0LFxuICAgICAgICBjaGFuY2VOb0RpdmlkZTogMC4wNSxcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSB0ZW5zb3JGaWVsZDogVGVuc29yRmllbGQsXG4gICAgICAgICAgICAgICAgZm9sZGVyOiBkYXQuR1VJLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgcmVkcmF3OiAoKSA9PiB2b2lkLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgZHN0ZXA6IG51bWJlcixcbiAgICAgICAgICAgICAgICBwcml2YXRlIF9hbmltYXRlOiBib29sZWFuKSB7XG4gICAgICAgIGZvbGRlci5hZGQoeydBZGRCdWlsZGluZ3MnOiAoKSA9PiB0aGlzLmdlbmVyYXRlKHRoaXMuX2FuaW1hdGUpfSwgJ0FkZEJ1aWxkaW5ncycpO1xuICAgICAgICBmb2xkZXIuYWRkKHRoaXMuYnVpbGRpbmdQYXJhbXMsICdtaW5BcmVhJyk7XG4gICAgICAgIGZvbGRlci5hZGQodGhpcy5idWlsZGluZ1BhcmFtcywgJ3Nocmlua1NwYWNpbmcnKTtcbiAgICAgICAgZm9sZGVyLmFkZCh0aGlzLmJ1aWxkaW5nUGFyYW1zLCAnY2hhbmNlTm9EaXZpZGUnKTtcbiAgICAgICAgdGhpcy5wb2x5Z29uRmluZGVyID0gbmV3IFBvbHlnb25GaW5kZXIoW10sIHRoaXMuYnVpbGRpbmdQYXJhbXMsIHRoaXMudGVuc29yRmllbGQpO1xuICAgIH1cblxuICAgIHNldCBhbmltYXRlKHY6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZSA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IGxvdHMoKTogVmVjdG9yW11bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvbHlnb25GaW5kZXIucG9seWdvbnMubWFwKHAgPT4gcC5tYXAodiA9PiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGRUb1NjcmVlbih2LmNsb25lKCkpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT25seSB1c2VkIHdoZW4gY3JlYXRpbmcgdGhlIDNEIG1vZGVsIHRvICdmYWtlJyB0aGUgcm9hZHNcbiAgICAgKi9cbiAgICBnZXRCbG9ja3MoKTogUHJvbWlzZTxWZWN0b3JbXVtdPiB7XG4gICAgICAgIGNvbnN0IGcgPSBuZXcgR3JhcGgodGhpcy5hbGxTdHJlYW1saW5lcywgdGhpcy5kc3RlcCwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IGJsb2NrUGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5idWlsZGluZ1BhcmFtcyk7XG4gICAgICAgIGJsb2NrUGFyYW1zLnNocmlua1NwYWNpbmcgPSBibG9ja1BhcmFtcy5zaHJpbmtTcGFjaW5nLzI7XG4gICAgICAgIGNvbnN0IHBvbHlnb25GaW5kZXIgPSBuZXcgUG9seWdvbkZpbmRlcihnLm5vZGVzLCBibG9ja1BhcmFtcywgdGhpcy50ZW5zb3JGaWVsZCk7XG4gICAgICAgIHBvbHlnb25GaW5kZXIuZmluZFBvbHlnb25zKCk7XG4gICAgICAgIHJldHVybiBwb2x5Z29uRmluZGVyLnNocmluayhmYWxzZSkudGhlbigoKSA9PiBwb2x5Z29uRmluZGVyLnBvbHlnb25zLm1hcChwID0+IHAubWFwKHYgPT4gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkVG9TY3JlZW4odi5jbG9uZSgpKSkpKTtcbiAgICB9XG5cbiAgICBnZXQgbW9kZWxzKCk6IEJ1aWxkaW5nTW9kZWxbXSB7XG4gICAgICAgIHRoaXMuX21vZGVscy5zZXRCdWlsZGluZ1Byb2plY3Rpb25zKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb2RlbHMuYnVpbGRpbmdNb2RlbHM7XG4gICAgfVxuXG4gICAgc2V0QWxsU3RyZWFtbGluZXMoczogVmVjdG9yW11bXSk6IHZvaWQge1xuICAgICAgICB0aGlzLmFsbFN0cmVhbWxpbmVzID0gcztcbiAgICB9XG5cbiAgICByZXNldCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5wb2x5Z29uRmluZGVyLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuX21vZGVscyA9IG5ldyBCdWlsZGluZ01vZGVscyhbXSk7XG4gICAgfVxuXG4gICAgdXBkYXRlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5wb2x5Z29uRmluZGVyLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIGJsb2Nrcywgc2hyaW5rcyBhbmQgZGl2aWRlcyB0aGVtIHRvIGNyZWF0ZSBidWlsZGluZyBsb3RzXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGUoYW5pbWF0ZTogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICB0aGlzLnByZUdlbmVyYXRlQ2FsbGJhY2soKTtcbiAgICAgICAgdGhpcy5fbW9kZWxzID0gbmV3IEJ1aWxkaW5nTW9kZWxzKFtdKTtcbiAgICAgICAgY29uc3QgZyA9IG5ldyBHcmFwaCh0aGlzLmFsbFN0cmVhbWxpbmVzLCB0aGlzLmRzdGVwLCB0cnVlKTtcblxuICAgICAgICB0aGlzLnBvbHlnb25GaW5kZXIgPSBuZXcgUG9seWdvbkZpbmRlcihnLm5vZGVzLCB0aGlzLmJ1aWxkaW5nUGFyYW1zLCB0aGlzLnRlbnNvckZpZWxkKTtcbiAgICAgICAgdGhpcy5wb2x5Z29uRmluZGVyLmZpbmRQb2x5Z29ucygpO1xuICAgICAgICBhd2FpdCB0aGlzLnBvbHlnb25GaW5kZXIuc2hyaW5rKGFuaW1hdGUpO1xuICAgICAgICBhd2FpdCB0aGlzLnBvbHlnb25GaW5kZXIuZGl2aWRlKGFuaW1hdGUpO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgICAgICB0aGlzLl9tb2RlbHMgPSBuZXcgQnVpbGRpbmdNb2RlbHModGhpcy5wb2x5Z29uRmluZGVyLnBvbHlnb25zKTtcblxuICAgICAgICB0aGlzLnBvc3RHZW5lcmF0ZUNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgc2V0UHJlR2VuZXJhdGVDYWxsYmFjayhjYWxsYmFjazogKCkgPT4gYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMucHJlR2VuZXJhdGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIHNldFBvc3RHZW5lcmF0ZUNhbGxiYWNrKGNhbGxiYWNrOiAoKSA9PiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5wb3N0R2VuZXJhdGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCAqIGFzIGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgVmVjdG9yIGZyb20gJy4uL3ZlY3Rvcic7XG5pbXBvcnQgeyBTVkcgfSBmcm9tICdAc3ZnZG90anMvc3ZnLmpzJztcbmltcG9ydCBVdGlsIGZyb20gJy4uL3V0aWwnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJvdWdoT3B0aW9ucyB7XG4gICAgcm91Z2huZXNzPzogbnVtYmVyO1xuICAgIGJvd2luZz86IG51bWJlcjtcbiAgICBzZWVkPzogbnVtYmVyO1xuICAgIHN0cm9rZT86IHN0cmluZztcbiAgICBzdHJva2VXaWR0aD86IG51bWJlcjtcbiAgICBmaWxsPzogc3RyaW5nO1xuICAgIGZpbGxTdHlsZT86IHN0cmluZztcbiAgICBmaWxsV2VpZ2h0PzogbnVtYmVyO1xuICAgIGhhY2h1cmVBbmdsZT86IG51bWJlcjtcbiAgICBoYWNodXJlR2FwPzogbnVtYmVyO1xuICAgIGRhc2hPZmZzZXQ/OiBudW1iZXI7XG4gICAgZGFzaEdhcD86IG51bWJlcjtcbiAgICB6aWd6YWdPZmZzZXQ/OiBudW1iZXI7XG59XG5cbi8qKlxuICogVGhpbiB3cmFwcGVyIGFyb3VuZCBIVE1MIGNhbnZhcywgYWJzdHJhY3RzIGRyYXdpbmcgZnVuY3Rpb25zIHNvIHdlIGNhbiB1c2UgdGhlIFJvdWdoSlMgY2FudmFzIG9yIHRoZSBkZWZhdWx0IG9uZVxuICovXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBDYW52YXNXcmFwcGVyIHtcbiAgICBwcm90ZWN0ZWQgc3ZnTm9kZTogYW55O1xuICAgIHByb3RlY3RlZCBfd2lkdGg6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgX2hlaWdodDogbnVtYmVyO1xuICAgIHB1YmxpYyBuZWVkc1VwZGF0ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCBwcm90ZWN0ZWQgX3NjYWxlPTEsIHJlc2l6ZVRvV2luZG93PXRydWUpIHtcbiAgICAgICAgdGhpcy5zZXREaW1lbnNpb25zKCk7XG4gICAgICAgIHRoaXMucmVzaXplQ2FudmFzKCk7XG4gICAgICAgIGlmIChyZXNpemVUb1dpbmRvdykge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsICgpOiB2b2lkID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldERpbWVuc2lvbnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZUNhbnZhcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgYXBwZW5kU3ZnTm9kZShub2RlOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuc3ZnTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5zdmdOb2RlLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3JlYXRlU1ZHKHN2Z0VsZW1lbnQ6IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLnN2Z05vZGUgPSBzdmdFbGVtZW50O1xuICAgIH1cblxuICAgIGFic3RyYWN0IGRyYXdGcmFtZShsZWZ0OiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIHVwOiBudW1iZXIsIGRvd246IG51bWJlcik6IHZvaWQ7XG5cbiAgICBzZXREaW1lbnNpb25zKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl93aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoICogdGhpcy5fc2NhbGU7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAqIHRoaXMuX3NjYWxlO1xuICAgIH1cblxuICAgIGdldCB3aWR0aCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gICAgfVxuXG4gICAgZ2V0IGhlaWdodCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICAgIH1cblxuICAgIGdldCBjYW52YXNTY2FsZSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGU7XG4gICAgfVxuXG4gICAgc2V0IGNhbnZhc1NjYWxlKHM6IG51bWJlcikge1xuICAgICAgICB0aGlzLl9zY2FsZSA9IHM7XG4gICAgICAgIHRoaXMuc2V0RGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLnJlc2l6ZUNhbnZhcygpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCB6b29tVmVjdG9ycyh2czogVmVjdG9yW10pOiBWZWN0b3JbXSB7XG4gICAgICAgIGlmICh0aGlzLl9zY2FsZSA9PT0gMSkgcmV0dXJuIHZzO1xuICAgICAgICByZXR1cm4gdnMubWFwKHYgPT4gdi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKHRoaXMuX3NjYWxlKSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHJlc2l6ZUNhbnZhcygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBEZWZhdWx0Q2FudmFzV3JhcHBlciBleHRlbmRzIENhbnZhc1dyYXBwZXIge1xuICAgIHByaXZhdGUgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG4gICAgcHJpdmF0ZSBzdmc6IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHNjYWxlPTEsIHJlc2l6ZVRvV2luZG93PXRydWUpIHtcbiAgICAgICAgc3VwZXIoY2FudmFzLCBzY2FsZSwgcmVzaXplVG9XaW5kb3cpO1xuICAgICAgICB0aGlzLmN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9ICdibGFjayc7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KDAsIDAsIHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIH1cblxuICAgIGNyZWF0ZVNWRyhzdmdFbGVtZW50OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgc3VwZXIuY3JlYXRlU1ZHKHN2Z0VsZW1lbnQpO1xuICAgICAgICB0aGlzLnN2ZyA9IFNWRyhzdmdFbGVtZW50KTtcbiAgICB9XG5cbiAgICBzZXRGaWxsU3R5bGUoY29sb3VyOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gY29sb3VyO1xuICAgIH1cblxuICAgIGNsZWFyQ2FudmFzKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5zdmdOb2RlKSB7XG4gICAgICAgICAgICAvLyBFeHBhbmRlZCB0byBjb3ZlciB3aG9sZSBkcmF3biBhcmVhXG4gICAgICAgICAgICBjb25zdCBzdGFydFcgPSB3aW5kb3cuaW5uZXJXaWR0aCAqIChVdGlsLkRSQVdfSU5GTEFURV9BTU9VTlQgLSAxKSAvIDI7XG4gICAgICAgICAgICBjb25zdCBzdGFydEggPSB3aW5kb3cuaW5uZXJIZWlnaHQgKiAoVXRpbC5EUkFXX0lORkxBVEVfQU1PVU5UIC0gMSkgLyAyO1xuICAgICAgICAgICAgdGhpcy5kcmF3UmVjdGFuZ2xlKC1zdGFydFcsIC1zdGFydEgsIHdpbmRvdy5pbm5lcldpZHRoICogVXRpbC5EUkFXX0lORkxBVEVfQU1PVU5ULCB3aW5kb3cuaW5uZXJIZWlnaHQgKiBVdGlsLkRSQVdfSU5GTEFURV9BTU9VTlQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kcmF3UmVjdGFuZ2xlKDAsIDAsIHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZHJhd0ZyYW1lKGxlZnQ6IG51bWJlciwgcmlnaHQ6IG51bWJlciwgdXA6IG51bWJlciwgZG93bjogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZHJhd1JlY3RhbmdsZSgwLCAwLCB0aGlzLl93aWR0aC90aGlzLl9zY2FsZSwgdXApO1xuICAgICAgICB0aGlzLmRyYXdSZWN0YW5nbGUoMCwgMCwgbGVmdCwgdGhpcy5faGVpZ2h0L3RoaXMuX3NjYWxlKTtcbiAgICAgICAgdGhpcy5kcmF3UmVjdGFuZ2xlKHRoaXMuX3dpZHRoL3RoaXMuX3NjYWxlIC0gcmlnaHQsIDAsIHJpZ2h0LCB0aGlzLl9oZWlnaHQvdGhpcy5fc2NhbGUpO1xuICAgICAgICB0aGlzLmRyYXdSZWN0YW5nbGUoMCwgdGhpcy5faGVpZ2h0L3RoaXMuX3NjYWxlIC0gZG93biwgdGhpcy5fd2lkdGgvdGhpcy5fc2NhbGUsIGRvd24pO1xuICAgIH1cblxuICAgIGRyYXdDaXR5TmFtZSgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZm9udFNpemUgPSA1MCAqIHRoaXMuX3NjYWxlO1xuICAgICAgICB0aGlzLmN0eC5mb250ID0gYHNtYWxsLWNhcHMgJHtmb250U2l6ZX1weCBWZXJkYW5hYDtcbiAgICAgICAgdGhpcy5jdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgdGhpcy5jdHguZmlsbFRleHQoXCJzYW4gZnJhbmNpc2NvXCIsIHRoaXMuX3dpZHRoLzIsIHRoaXMuX2hlaWdodCAtICg4MCAqIHRoaXMuX3NjYWxlIC0gZm9udFNpemUpKTtcbiAgICB9XG5cbiAgICBkcmF3UmVjdGFuZ2xlKHg6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fc2NhbGUgIT09IDEpIHtcbiAgICAgICAgICAgIHggKj0gdGhpcy5fc2NhbGU7XG4gICAgICAgICAgICB5ICo9IHRoaXMuX3NjYWxlO1xuICAgICAgICAgICAgd2lkdGggKj0gdGhpcy5fc2NhbGU7XG4gICAgICAgICAgICBoZWlnaHQgKj0gdGhpcy5fc2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdHguZmlsbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgaWYgKHRoaXMuc3ZnKSB7XG4gICAgICAgICAgICB0aGlzLnN2Zy5yZWN0KHtcbiAgICAgICAgICAgICAgICBmaWxsOiB0aGlzLmN0eC5maWxsU3R5bGUsXG4gICAgICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiB0aGlzLmN0eC5zdHJva2VTdHlsZSxcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogdGhpcy5jdHgubGluZVdpZHRoLFxuICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRyYXdQb2x5Z29uKHBvbHlnb246IFZlY3RvcltdKTogdm9pZCB7XG4gICAgICAgIGlmIChwb2x5Z29uLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBvbHlnb24gPSB0aGlzLnpvb21WZWN0b3JzKHBvbHlnb24pO1xuXG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLmN0eC5tb3ZlVG8ocG9seWdvblswXS54LCBwb2x5Z29uWzBdLnkpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcG9seWdvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jdHgubGluZVRvKHBvbHlnb25baV0ueCwgcG9seWdvbltpXS55KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN0eC5saW5lVG8ocG9seWdvblswXS54LCBwb2x5Z29uWzBdLnkpO1xuXG4gICAgICAgIHRoaXMuY3R4LmZpbGwoKTtcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuc3ZnKSB7XG4gICAgICAgICAgICBjb25zdCB2ZWN0b3JBcnJheSA9IHBvbHlnb24ubWFwKHYgPT4gW3YueCwgdi55XSk7XG4gICAgICAgICAgICB2ZWN0b3JBcnJheS5wdXNoKHZlY3RvckFycmF5WzBdKTtcbiAgICAgICAgICAgIHRoaXMuc3ZnLnBvbHlsaW5lKHZlY3RvckFycmF5KS5hdHRyKHtcbiAgICAgICAgICAgICAgICBmaWxsOiB0aGlzLmN0eC5maWxsU3R5bGUsXG4gICAgICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiB0aGlzLmN0eC5zdHJva2VTdHlsZSxcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogdGhpcy5jdHgubGluZVdpZHRoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkcmF3Q2lyY2xlKGNlbnRyZTogVmVjdG9yLCByYWRpdXM6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBjb25zdCBUQVUgPSAyICogTWF0aC5QSTtcbiAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuY3R4LmFyYyhjZW50cmUueCwgY2VudHJlLnksIHJhZGl1cywgMCwgVEFVKTtcbiAgICAgICAgdGhpcy5jdHguZmlsbCgpO1xuICAgIH1cblxuICAgIGRyYXdTcXVhcmUoY2VudHJlOiBWZWN0b3IsIHJhZGl1czogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZHJhd1JlY3RhbmdsZShjZW50cmUueCAtIHJhZGl1cywgY2VudHJlLnkgLSByYWRpdXMsIDIgKiByYWRpdXMsIDIgKiByYWRpdXMpO1xuICAgIH1cblxuICAgIHNldExpbmVXaWR0aCh3aWR0aDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl9zY2FsZSAhPT0gMSkge1xuICAgICAgICAgICAgd2lkdGggKj0gdGhpcy5fc2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdHgubGluZVdpZHRoID0gd2lkdGg7XG4gICAgfVxuXG4gICAgc2V0U3Ryb2tlU3R5bGUoY29sb3VyOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSBjb2xvdXI7XG4gICAgfVxuXG4gICAgZHJhd1BvbHlsaW5lKGxpbmU6IFZlY3RvcltdKTogdm9pZCB7XG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmUgPSB0aGlzLnpvb21WZWN0b3JzKGxpbmUpO1xuXG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLmN0eC5tb3ZlVG8obGluZVswXS54LCBsaW5lWzBdLnkpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jdHgubGluZVRvKGxpbmVbaV0ueCwgbGluZVtpXS55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLnN2Zykge1xuICAgICAgICAgICAgY29uc3QgdmVjdG9yQXJyYXkgPSBsaW5lLm1hcCh2ID0+IFt2LngsIHYueV0pO1xuICAgICAgICAgICAgdGhpcy5zdmcucG9seWxpbmUodmVjdG9yQXJyYXkpLmF0dHIoe1xuICAgICAgICAgICAgICAgICdmaWxsLW9wYWNpdHknOiAwLFxuICAgICAgICAgICAgICAgIHN0cm9rZTogdGhpcy5jdHguc3Ryb2tlU3R5bGUsXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHRoaXMuY3R4LmxpbmVXaWR0aCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgUm91Z2hDYW52YXNXcmFwcGVyIGV4dGVuZHMgQ2FudmFzV3JhcHBlciB7XG4gICAgcHJpdmF0ZSByID0gcmVxdWlyZSgncm91Z2hqcy9idW5kbGVkL3JvdWdoLmNqcycpO1xuICAgIHByaXZhdGUgcmM6IGFueTtcbiAgICAgICAgXG4gICAgcHJpdmF0ZSBvcHRpb25zOiBSb3VnaE9wdGlvbnMgPSB7XG4gICAgICAgIHJvdWdobmVzczogMSxcbiAgICAgICAgYm93aW5nOiAxLFxuICAgICAgICBzdHJva2U6ICcjMDAwMDAwJyxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgIGZpbGw6ICcjMDAwMDAwJyxcbiAgICAgICAgZmlsbFN0eWxlOiAnc29saWQnLFxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3RvcihjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCBzY2FsZT0xLCByZXNpemVUb1dpbmRvdz10cnVlKSB7XG4gICAgICAgIHN1cGVyKGNhbnZhcywgc2NhbGUsIHJlc2l6ZVRvV2luZG93KTtcbiAgICAgICAgdGhpcy5yYyA9IHRoaXMuci5jYW52YXMoY2FudmFzKTtcbiAgICB9XG5cbiAgICBjcmVhdGVTVkcoc3ZnRWxlbWVudDogYW55KTogdm9pZCB7XG4gICAgICAgIHN1cGVyLmNyZWF0ZVNWRyhzdmdFbGVtZW50KTtcbiAgICAgICAgdGhpcy5yYyA9IHRoaXMuci5zdmcodGhpcy5zdmdOb2RlKTtcbiAgICB9XG5cbiAgICBkcmF3RnJhbWUobGVmdDogbnVtYmVyLCByaWdodDogbnVtYmVyLCB1cDogbnVtYmVyLCBkb3duOiBudW1iZXIpOiB2b2lkIHtcblxuICAgIH1cblxuICAgIHNldE9wdGlvbnMob3B0aW9uczogUm91Z2hPcHRpb25zKTogdm9pZCB7XG4gICAgICAgIGlmIChvcHRpb25zLnN0cm9rZVdpZHRoKSB7XG4gICAgICAgICAgICBvcHRpb25zLnN0cm9rZVdpZHRoICo9IHRoaXMuX3NjYWxlO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBjbGVhckNhbnZhcygpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuc3ZnTm9kZSkge1xuICAgICAgICAgICAgLy8gRXhwYW5kZWQgdG8gY292ZXIgd2hvbGUgZHJhd24gYXJlYVxuICAgICAgICAgICAgY29uc3Qgc3RhcnRXID0gd2luZG93LmlubmVyV2lkdGggKiAoVXRpbC5EUkFXX0lORkxBVEVfQU1PVU5UIC0gMSkgLyAyO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRIID0gd2luZG93LmlubmVySGVpZ2h0ICogKFV0aWwuRFJBV19JTkZMQVRFX0FNT1VOVCAtIDEpIC8gMjtcbiAgICAgICAgICAgIHRoaXMuZHJhd1JlY3RhbmdsZSgtc3RhcnRXLCAtc3RhcnRILCB3aW5kb3cuaW5uZXJXaWR0aCAqIFV0aWwuRFJBV19JTkZMQVRFX0FNT1VOVCwgd2luZG93LmlubmVySGVpZ2h0ICogVXRpbC5EUkFXX0lORkxBVEVfQU1PVU5UKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1JlY3RhbmdsZSgwLCAwLCB3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRyYXdSZWN0YW5nbGUoeDogbnVtYmVyLCB5OiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl9zY2FsZSAhPT0gMSkge1xuICAgICAgICAgICAgeCAqPSB0aGlzLl9zY2FsZTtcbiAgICAgICAgICAgIHkgKj0gdGhpcy5fc2NhbGU7XG4gICAgICAgICAgICB3aWR0aCAqPSB0aGlzLl9zY2FsZTtcbiAgICAgICAgICAgIGhlaWdodCAqPSB0aGlzLl9zY2FsZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwcGVuZFN2Z05vZGUodGhpcy5yYy5yZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgdGhpcy5vcHRpb25zKSk7XG4gICAgfVxuXG4gICAgZHJhd1BvbHlnb24ocG9seWdvbjogVmVjdG9yW10pOiB2b2lkIHtcbiAgICAgICAgaWYgKHBvbHlnb24ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fc2NhbGUgIT09IDEpIHtcbiAgICAgICAgICAgIHBvbHlnb24gPSBwb2x5Z29uLm1hcCh2ID0+IHYuY2xvbmUoKS5tdWx0aXBseVNjYWxhcih0aGlzLl9zY2FsZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hcHBlbmRTdmdOb2RlKHRoaXMucmMucG9seWdvbihwb2x5Z29uLm1hcCh2ID0+IFt2LngsIHYueV0pLCB0aGlzLm9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICBkcmF3U3F1YXJlKGNlbnRyZTogVmVjdG9yLCByYWRpdXM6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBjb25zdCBwcmV2U3Ryb2tlID0gdGhpcy5vcHRpb25zLnN0cm9rZTtcbiAgICAgICAgdGhpcy5vcHRpb25zLnN0cm9rZSA9ICdub25lJztcbiAgICAgICAgdGhpcy5kcmF3UmVjdGFuZ2xlKGNlbnRyZS54IC0gcmFkaXVzLCBjZW50cmUueSAtIHJhZGl1cywgMiAqIHJhZGl1cywgMiAqIHJhZGl1cyk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zdHJva2UgPSBwcmV2U3Ryb2tlO1xuICAgIH1cblxuICAgIGRyYXdQb2x5bGluZShsaW5lOiBWZWN0b3JbXSk6IHZvaWQge1xuICAgICAgICBpZiAobGluZS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fc2NhbGUgIT09IDEpIHtcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLm1hcCh2ID0+IHYuY2xvbmUoKS5tdWx0aXBseVNjYWxhcih0aGlzLl9zY2FsZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hcHBlbmRTdmdOb2RlKHRoaXMucmMubGluZWFyUGF0aChsaW5lLm1hcCh2ID0+IFt2LngsIHYueV0pLCB0aGlzLm9wdGlvbnMpKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xuaW1wb3J0IFV0aWwgZnJvbSAnLi4vdXRpbCc7XG5cbi8qKlxuICogU2luZ2xldG9uXG4gKiBDb250cm9scyBwYW5uaW5nIGFuZCB6b29taW5nXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvbWFpbkNvbnRyb2xsZXIge1xuICAgIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBEb21haW5Db250cm9sbGVyO1xuXG4gICAgcHJpdmF0ZSByZWFkb25seSBaT09NX1NQRUVEID0gMC45NjtcbiAgICBwcml2YXRlIHJlYWRvbmx5IFNDUk9MTF9ERUxBWSA9IDEwMDtcblxuICAgIC8vIExvY2F0aW9uIG9mIHNjcmVlbiBvcmlnaW4gaW4gd29ybGQgc3BhY2VcbiAgICBwcml2YXRlIF9vcmlnaW46IFZlY3RvciA9IFZlY3Rvci56ZXJvVmVjdG9yKCk7XG4gICAgXG4gICAgLy8gU2NyZWVuLXNwYWNlIHdpZHRoIGFuZCBoZWlnaHRcbiAgICBwcml2YXRlIF9zY3JlZW5EaW1lbnNpb25zID0gVmVjdG9yLnplcm9WZWN0b3IoKTtcblxuICAgIC8vIFJhdGlvIG9mIHNjcmVlbiBwaXhlbHMgdG8gd29ybGQgcGl4ZWxzXG4gICAgcHJpdmF0ZSBfem9vbTogbnVtYmVyID0gMTtcbiAgICBwcml2YXRlIHpvb21DYWxsYmFjazogKCkgPT4gYW55ID0gKCkgPT4ge307XG4gICAgcHJpdmF0ZSBsYXN0U2Nyb2xsdGltZSA9IC10aGlzLlNDUk9MTF9ERUxBWTtcbiAgICBwcml2YXRlIHJlZnJlc2hlZEFmdGVyU2Nyb2xsID0gZmFsc2U7XG5cbiAgICBwcml2YXRlIF9jYW1lcmFEaXJlY3Rpb24gPSBWZWN0b3IuemVyb1ZlY3RvcigpO1xuICAgIHByaXZhdGUgX29ydGhvZ3JhcGhpYyA9IGZhbHNlO1xuXG4gICAgLy8gU2V0IGFmdGVyIHBhbiBvciB6b29tXG4gICAgcHVibGljIG1vdmVkID0gZmFsc2U7XG5cblxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2V0U2NyZWVuRGltZW5zaW9ucygpO1xuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCAoKTogdm9pZCA9PiB0aGlzLnNldFNjcmVlbkRpbWVuc2lvbnMoKSk7XG5cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgKGU6IGFueSk6IHZvaWQgPT4ge1xuICAgICAgICAgICAgaWYgKGUudGFyZ2V0LmlkID09PSBVdGlsLkNBTlZBU19JRCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdFNjcm9sbHRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaGVkQWZ0ZXJTY3JvbGwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWx0YTogbnVtYmVyID0gZS5kZWx0YVk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBzY2FsZSBieSB2YWx1ZSBvZiBkZWx0YVxuICAgICAgICAgICAgICAgIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy56b29tID0gdGhpcy5fem9vbSAqIHRoaXMuWk9PTV9TUEVFRDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnpvb20gPSB0aGlzLl96b29tIC8gdGhpcy5aT09NX1NQRUVEO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHN0b3AgZHJhd2luZyBidWlsZGluZ3Mgd2hpbGUgc2Nyb2xsaW5nIGZvciBjZXJ0YWluIHN0eWxlc1xuICAgICAqIHRvIGtlZXAgdGhlIGZyYW1lcmF0ZSB1cFxuICAgICAqL1xuICAgIGdldCBpc1Njcm9sbGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLSB0aGlzLmxhc3RTY3JvbGx0aW1lIDwgdGhpcy5TQ1JPTExfREVMQVk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRTY3JlZW5EaW1lbnNpb25zKCk6IHZvaWQge1xuICAgICAgICB0aGlzLm1vdmVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2NyZWVuRGltZW5zaW9ucy5zZXRYKHdpbmRvdy5pbm5lcldpZHRoKTtcbiAgICAgICAgdGhpcy5fc2NyZWVuRGltZW5zaW9ucy5zZXRZKHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBEb21haW5Db250cm9sbGVyIHtcbiAgICAgICAgaWYgKCFEb21haW5Db250cm9sbGVyLmluc3RhbmNlKSB7XG4gICAgICAgICAgICBEb21haW5Db250cm9sbGVyLmluc3RhbmNlID0gbmV3IERvbWFpbkNvbnRyb2xsZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRG9tYWluQ29udHJvbGxlci5pbnN0YW5jZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1ZlY3Rvcn0gZGVsdGEgaW4gd29ybGQgc3BhY2VcbiAgICAgKi9cbiAgICBwYW4oZGVsdGE6IFZlY3Rvcikge1xuICAgICAgICB0aGlzLm1vdmVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fb3JpZ2luLnN1YihkZWx0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2NyZWVuIG9yaWdpbiBpbiB3b3JsZCBzcGFjZVxuICAgICAqL1xuICAgIGdldCBvcmlnaW4oKTogVmVjdG9yIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yaWdpbi5jbG9uZSgpO1xuICAgIH1cblxuICAgIGdldCB6b29tKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl96b29tO1xuICAgIH1cblxuICAgIGdldCBzY3JlZW5EaW1lbnNpb25zKCk6IFZlY3RvciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY3JlZW5EaW1lbnNpb25zLmNsb25lKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7VmVjdG9yfSB3b3JsZC1zcGFjZSB3L2ggdmlzaWJsZSBvbiBzY3JlZW5cbiAgICAgKi9cbiAgICBnZXQgd29ybGREaW1lbnNpb25zKCk6IFZlY3RvciB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlbkRpbWVuc2lvbnMuZGl2aWRlU2NhbGFyKHRoaXMuX3pvb20pO1xuICAgIH1cblxuICAgIHNldCBzY3JlZW5EaW1lbnNpb25zKHY6IFZlY3Rvcikge1xuICAgICAgICB0aGlzLm1vdmVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2NyZWVuRGltZW5zaW9ucy5jb3B5KHYpO1xuICAgIH1cblxuICAgIHNldCB6b29tKHo6IG51bWJlcikge1xuICAgICAgICBpZiAoeiA+PSAwLjMgJiYgeiA8PSAyMCkge1xuICAgICAgICAgICAgdGhpcy5tb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBvbGRXb3JsZFNwYWNlTWlkcG9pbnQgPSB0aGlzLm9yaWdpbi5hZGQodGhpcy53b3JsZERpbWVuc2lvbnMuZGl2aWRlU2NhbGFyKDIpKTtcbiAgICAgICAgICAgIHRoaXMuX3pvb20gPSB6O1xuICAgICAgICAgICAgY29uc3QgbmV3V29ybGRTcGFjZU1pZHBvaW50ID0gdGhpcy5vcmlnaW4uYWRkKHRoaXMud29ybGREaW1lbnNpb25zLmRpdmlkZVNjYWxhcigyKSk7XG4gICAgICAgICAgICB0aGlzLnBhbihuZXdXb3JsZFNwYWNlTWlkcG9pbnQuc3ViKG9sZFdvcmxkU3BhY2VNaWRwb2ludCkpO1xuICAgICAgICAgICAgdGhpcy56b29tQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uU2NyZWVuKHY6IFZlY3Rvcik6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBzY3JlZW5TcGFjZSA9IHRoaXMud29ybGRUb1NjcmVlbih2LmNsb25lKCkpO1xuICAgICAgICByZXR1cm4gc2NyZWVuU3BhY2UueCA+PSAwICYmIHNjcmVlblNwYWNlLnkgPj0gMFxuICAgICAgICAgICAgJiYgc2NyZWVuU3BhY2UueCA8PSB0aGlzLnNjcmVlbkRpbWVuc2lvbnMueCAmJiBzY3JlZW5TcGFjZS55IDw9IHRoaXMuc2NyZWVuRGltZW5zaW9ucy55O1xuICAgIH1cblxuICAgIHNldCBvcnRob2dyYXBoaWModjogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9vcnRob2dyYXBoaWMgPSB2O1xuICAgICAgICB0aGlzLm1vdmVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBnZXQgb3J0aG9ncmFwaGljKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3J0aG9ncmFwaGljO1xuICAgIH1cblxuICAgIHNldCBjYW1lcmFEaXJlY3Rpb24odjogVmVjdG9yKSB7XG4gICAgICAgIHRoaXMuX2NhbWVyYURpcmVjdGlvbiA9IHY7XG4gICAgICAgIC8vIFNjcmVlbiB1cGRhdGVcbiAgICAgICAgdGhpcy5tb3ZlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgZ2V0IGNhbWVyYURpcmVjdGlvbigpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FtZXJhRGlyZWN0aW9uLmNsb25lKCk7XG4gICAgfVxuXG4gICAgZ2V0Q2FtZXJhUG9zaXRpb24oKTogVmVjdG9yIHtcbiAgICAgICAgY29uc3QgY2VudHJlID0gbmV3IFZlY3Rvcih0aGlzLl9zY3JlZW5EaW1lbnNpb25zLnggLyAyLCB0aGlzLl9zY3JlZW5EaW1lbnNpb25zLnkgLyAyKTtcbiAgICAgICAgaWYgKHRoaXMuX29ydGhvZ3JhcGhpYykge1xuICAgICAgICAgICAgcmV0dXJuIGNlbnRyZS5hZGQoY2VudHJlLmNsb25lKCkubXVsdGlwbHkodGhpcy5fY2FtZXJhRGlyZWN0aW9uKS5tdWx0aXBseVNjYWxhcigxMDApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2VudHJlLmFkZChjZW50cmUuY2xvbmUoKS5tdWx0aXBseSh0aGlzLl9jYW1lcmFEaXJlY3Rpb24pKTtcbiAgICAgICAgLy8gdGhpcy5zY3JlZW5EaW1lbnNpb25zLmRpdmlkZVNjYWxhcigyKTtcbiAgICB9XG5cbiAgICBzZXRab29tVXBkYXRlKGNhbGxiYWNrOiAoKSA9PiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy56b29tQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFZGl0cyB2ZWN0b3JcbiAgICAgKi9cbiAgICB6b29tVG9Xb3JsZCh2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gdi5kaXZpZGVTY2FsYXIodGhpcy5fem9vbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRWRpdHMgdmVjdG9yXG4gICAgICovXG4gICAgem9vbVRvU2NyZWVuKHY6IFZlY3Rvcik6IFZlY3RvciB7XG4gICAgICAgIHJldHVybiB2Lm11bHRpcGx5U2NhbGFyKHRoaXMuX3pvb20pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVkaXRzIHZlY3RvclxuICAgICAqL1xuICAgIHNjcmVlblRvV29ybGQodjogVmVjdG9yKTogVmVjdG9yIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuem9vbVRvV29ybGQodikuYWRkKHRoaXMuX29yaWdpbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRWRpdHMgdmVjdG9yXG4gICAgICovXG4gICAgd29ybGRUb1NjcmVlbih2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gdGhpcy56b29tVG9TY3JlZW4odi5zdWIodGhpcy5fb3JpZ2luKSk7XG4gICAgfVxufVxuIiwiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0ICogYXMgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCBpbnRlcmFjdCBmcm9tICdpbnRlcmFjdGpzJztcbmltcG9ydCBVdGlsIGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xuaW1wb3J0IERvbWFpbkNvbnRyb2xsZXIgZnJvbSAnLi9kb21haW5fY29udHJvbGxlcic7XG5cbmludGVyZmFjZSBEcmFnZ2FibGUge1xuICAgIGdldENlbnRyZTogKCgpID0+IFZlY3Rvcik7XG4gICAgc3RhcnRMaXN0ZW5lcjogKCgpID0+IHZvaWQpO1xuICAgIG1vdmVMaXN0ZW5lcjogKCh2OiBWZWN0b3IpID0+IHZvaWQpO1xufVxuXG4vKipcbiogUmVnaXN0ZXIgbXVsdGlwbGUgY2VudHJlIHBvaW50c1xuKiBDbG9zZXN0IG9uZSB0byBtb3VzZSBjbGljayB3aWxsIGJlIHNlbGVjdGVkIHRvIGRyYWdcbiogVXAgdG8gY2FsbGVyIHRvIGFjdHVhbGx5IG1vdmUgdGhlaXIgY2VudHJlIHBvaW50IHZpYSBjYWxsYmFja1xuKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERyYWdDb250cm9sbGVyIHtcbiAgICAvLyBIb3cgY2xvc2UgdG8gZHJhZyBoYW5kbGUgcG9pbnRlciBuZWVkcyB0byBiZVxuICAgIHByaXZhdGUgcmVhZG9ubHkgTUlOX0RSQUdfRElTVEFOQ0UgPSA1MDtcblxuICAgIHByaXZhdGUgZHJhZ2dhYmxlczogRHJhZ2dhYmxlW10gPSBbXTtcbiAgICBwcml2YXRlIGN1cnJlbnRseURyYWdnaW5nOiBEcmFnZ2FibGUgPSBudWxsOyAgLy8gVGVuc29yIGZpZWxkXG4gICAgcHJpdmF0ZSBfaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgIHByaXZhdGUgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIGRvbWFpbkNvbnRyb2xsZXIgPSBEb21haW5Db250cm9sbGVyLmdldEluc3RhbmNlKCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGd1aTogZGF0LkdVSSkge1xuICAgICAgICBpbnRlcmFjdChgIyR7VXRpbC5DQU5WQVNfSUR9YCkuZHJhZ2dhYmxlKHtcbiAgICAgICAgICAgIG9uc3RhcnQ6IHRoaXMuZHJhZ1N0YXJ0LmJpbmQodGhpcyksXG4gICAgICAgICAgICBvbm1vdmU6IHRoaXMuZHJhZ01vdmUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIG9uZW5kOiB0aGlzLmRyYWdFbmQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGN1cnNvckNoZWNrZXI6IHRoaXMuZ2V0Q3Vyc29yLmJpbmQodGhpcyksXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNldERyYWdEaXNhYmxlZChkaXNhYmxlOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBkaXNhYmxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZSBjdXJzb3Igc3R5bGVcbiAgICAgKi9cbiAgICBnZXRDdXJzb3IoYWN0aW9uOiBhbnksIGludGVyYWN0YWJsZTogYW55LCBlbGVtZW50OiBhbnksIGludGVyYWN0aW5nOiBib29sZWFuKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKGludGVyYWN0aW5nKSByZXR1cm4gJ2dyYWJiaW5nJztcbiAgICAgICAgcmV0dXJuICdncmFiJztcbiAgICB9XG5cbiAgICBkcmFnU3RhcnQoZXZlbnQ6IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgLy8gVHJhbnNmb3JtIHNjcmVlbiBzcGFjZSB0byB3b3JsZCBzcGFjZVxuICAgICAgICBjb25zdCBvcmlnaW4gPSB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuc2NyZWVuVG9Xb3JsZChuZXcgVmVjdG9yKGV2ZW50LngwLCBldmVudC55MCkpO1xuICAgICAgICBcbiAgICAgICAgbGV0IGNsb3Nlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuICAgICAgICB0aGlzLmRyYWdnYWJsZXMuZm9yRWFjaChkcmFnZ2FibGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgZCA9IGRyYWdnYWJsZS5nZXRDZW50cmUoKS5kaXN0YW5jZVRvKG9yaWdpbik7XG4gICAgICAgICAgICBpZiAoZCA8IGNsb3Nlc3REaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGNsb3Nlc3REaXN0YW5jZSA9IGQ7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50bHlEcmFnZ2luZyA9IGRyYWdnYWJsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gWm9vbSBzY3JlZW4gc2l6ZSB0byB3b3JsZCBzaXplIGZvciBjb25zaXN0ZW50IGRyYWcgZGlzdGFuY2Ugd2hpbGUgem9vbWVkIGluXG4gICAgICAgIGNvbnN0IHNjYWxlZERyYWdEaXN0YW5jZSA9IHRoaXMuTUlOX0RSQUdfRElTVEFOQ0UgLyB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbTtcblxuICAgICAgICBpZiAoY2xvc2VzdERpc3RhbmNlID4gc2NhbGVkRHJhZ0Rpc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRseURyYWdnaW5nID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudGx5RHJhZ2dpbmcuc3RhcnRMaXN0ZW5lcigpO1xuICAgICAgICB9XG5cblxuICAgIH1cblxuICAgIGRyYWdNb3ZlKGV2ZW50OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBuZXcgVmVjdG9yKGV2ZW50LmRlbHRhLngsIGV2ZW50LmRlbHRhLnkpO1xuICAgICAgICB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbVRvV29ybGQoZGVsdGEpO1xuXG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCAmJiB0aGlzLmN1cnJlbnRseURyYWdnaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBEcmFnIGZpZWxkXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRseURyYWdnaW5nLm1vdmVMaXN0ZW5lcihkZWx0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBNb3ZlIG1hcFxuICAgICAgICAgICAgdGhpcy5kb21haW5Db250cm9sbGVyLnBhbihkZWx0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkcmFnRW5kKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZG9tYWluQ29udHJvbGxlci5wYW4oVmVjdG9yLnplcm9WZWN0b3IoKSk7ICAvLyBUcmlnZ2VycyBjYW52YXMgdXBkYXRlXG4gICAgICAgIHRoaXMuY3VycmVudGx5RHJhZ2dpbmcgPSBudWxsO1xuICAgICAgICBVdGlsLnVwZGF0ZUd1aSh0aGlzLmd1aSk7XG4gICAgfVxuXG4gICAgZ2V0IGlzRHJhZ2dpbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RyYWdnaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7KCgpID0+IFZlY3Rvcil9IEdldHMgY2VudHJlIHBvaW50XG4gICAgICogQHBhcmFtIHsoKHY6IFZlY3RvcikgPT4gdm9pZCl9IENhbGxlZCBvbiBtb3ZlIHdpdGggZGVsdGEgdmVjdG9yXG4gICAgICogQHBhcmFtIHsoKCkgPT4gdm9pZCl9IENhbGxlZCBvbiBzdGFydFxuICAgICAqIEByZXR1cm5zIHsoKCkgPT4gdm9pZCl9IEZ1bmN0aW9uIHRvIGRlcmVnaXN0ZXIgY2FsbGJhY2tcbiAgICAgKi9cbiAgICByZWdpc3RlcihnZXRDZW50cmU6ICgoKSA9PiBWZWN0b3IpLFxuICAgICAgICAgICAgIG9uTW92ZTogKCh2OiBWZWN0b3IpID0+IHZvaWQpLFxuICAgICAgICAgICAgIG9uU3RhcnQ6ICgoKSA9PiB2b2lkKSxcbiAgICAgICAgICAgICApOiAoKCkgPT4gdm9pZCkge1xuICAgICAgICBjb25zdCBkcmFnZ2FibGU6IERyYWdnYWJsZSA9IHtcbiAgICAgICAgICAgIGdldENlbnRyZTogZ2V0Q2VudHJlLFxuICAgICAgICAgICAgbW92ZUxpc3RlbmVyOiBvbk1vdmUsXG4gICAgICAgICAgICBzdGFydExpc3RlbmVyOiBvblN0YXJ0LFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZHJhZ2dhYmxlcy5wdXNoKGRyYWdnYWJsZSk7XG4gICAgICAgIHJldHVybiAoKCk6IHZvaWQgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmRyYWdnYWJsZXMuaW5kZXhPZihkcmFnZ2FibGUpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnYWJsZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuYmluZCh0aGlzKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IERvbWFpbkNvbnRyb2xsZXIgZnJvbSAnLi9kb21haW5fY29udHJvbGxlcic7XG5pbXBvcnQgVGVuc29yRmllbGQgZnJvbSAnLi4vaW1wbC90ZW5zb3JfZmllbGQnO1xuaW1wb3J0IHtSSzRJbnRlZ3JhdG9yfSBmcm9tICcuLi9pbXBsL2ludGVncmF0b3InO1xuaW1wb3J0IEZpZWxkSW50ZWdyYXRvciBmcm9tICcuLi9pbXBsL2ludGVncmF0b3InO1xuaW1wb3J0IHtTdHJlYW1saW5lUGFyYW1zfSBmcm9tICcuLi9pbXBsL3N0cmVhbWxpbmVzJztcbmltcG9ydCB7V2F0ZXJQYXJhbXN9IGZyb20gJy4uL2ltcGwvd2F0ZXJfZ2VuZXJhdG9yJztcbmltcG9ydCBHcmFwaCBmcm9tICcuLi9pbXBsL2dyYXBoJztcbmltcG9ydCBSb2FkR1VJIGZyb20gJy4vcm9hZF9ndWknO1xuaW1wb3J0IFdhdGVyR1VJIGZyb20gJy4vd2F0ZXJfZ3VpJztcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcbmltcG9ydCBQb2x5Z29uRmluZGVyIGZyb20gJy4uL2ltcGwvcG9seWdvbl9maW5kZXInO1xuaW1wb3J0IHtQb2x5Z29uUGFyYW1zfSBmcm9tICcuLi9pbXBsL3BvbHlnb25fZmluZGVyJztcbmltcG9ydCBTdHJlYW1saW5lR2VuZXJhdG9yIGZyb20gJy4uL2ltcGwvc3RyZWFtbGluZXMnO1xuaW1wb3J0IFdhdGVyR2VuZXJhdG9yIGZyb20gJy4uL2ltcGwvd2F0ZXJfZ2VuZXJhdG9yJztcbmltcG9ydCBTdHlsZSBmcm9tICcuL3N0eWxlJztcbmltcG9ydCB7RGVmYXVsdFN0eWxlLCBSb3VnaFN0eWxlfSBmcm9tICcuL3N0eWxlJztcbmltcG9ydCBDYW52YXNXcmFwcGVyIGZyb20gJy4vY2FudmFzX3dyYXBwZXInO1xuaW1wb3J0IEJ1aWxkaW5ncywge0J1aWxkaW5nTW9kZWx9IGZyb20gJy4vYnVpbGRpbmdzJztcbmltcG9ydCBQb2x5Z29uVXRpbCBmcm9tICcuLi9pbXBsL3BvbHlnb25fdXRpbCc7XG5cbi8qKlxuICogSGFuZGxlcyBNYXAgZm9sZGVyLCBnbHVlcyB0b2dldGhlciBpbXBsXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1haW5HVUkge1xuICAgIG51bUJpZ1BhcmtzOiBudW1iZXIgPSAyMDtcbiAgICBudW1TbWFsbFBhcmtzOiBudW1iZXIgPSAxMDtcbiAgICBjbHVzdGVyQmlnUGFya3M6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgZG9tYWluQ29udHJvbGxlciA9IERvbWFpbkNvbnRyb2xsZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICBpbnRlcnNlY3Rpb25zOiBWZWN0b3JbXSA9IFtdO1xuICAgIGJpZ1BhcmtzOiBWZWN0b3JbXVtdID0gW107XG4gICAgc21hbGxQYXJrczogVmVjdG9yW11bXSA9IFtdO1xuICAgIGFuaW1hdGU6IGJvb2xlYW4gPSB0cnVlO1xuICAgIGFuaW1hdGlvblNwZWVkOiBudW1iZXIgPSAzMDtcblxuICAgIGNvYXN0bGluZTogV2F0ZXJHVUk7XG4gICAgbWFpblJvYWRzOiBSb2FkR1VJO1xuICAgIG1ham9yUm9hZHM6IFJvYWRHVUk7XG4gICAgbWlub3JSb2FkczogUm9hZEdVSTtcbiAgICBidWlsZGluZ3M6IEJ1aWxkaW5ncztcblxuICAgIC8vIFBhcmFtc1xuICAgIGNvYXN0bGluZVBhcmFtczogV2F0ZXJQYXJhbXM7XG4gICAgbWFpblBhcmFtczogU3RyZWFtbGluZVBhcmFtcztcbiAgICBtYWpvclBhcmFtczogU3RyZWFtbGluZVBhcmFtcztcbiAgICBtaW5vclBhcmFtczogU3RyZWFtbGluZVBhcmFtcyA9IHtcbiAgICAgICAgZHNlcDogMjAsXG4gICAgICAgIGR0ZXN0OiAxNSxcbiAgICAgICAgZHN0ZXA6IDEsXG4gICAgICAgIGRsb29rYWhlYWQ6IDQwLFxuICAgICAgICBkY2lyY2xlam9pbjogNSxcbiAgICAgICAgam9pbmFuZ2xlOiAwLjEsICAvLyBhcHByb3ggMzBkZWdcbiAgICAgICAgcGF0aEl0ZXJhdGlvbnM6IDEwMDAsXG4gICAgICAgIHNlZWRUcmllczogMzAwLFxuICAgICAgICBzaW1wbGlmeVRvbGVyYW5jZTogMC41LFxuICAgICAgICBjb2xsaWRlRWFybHk6IDAsXG4gICAgfTtcblxuICAgIHJlZHJhdzogYm9vbGVhbiA9IHRydWU7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGd1aUZvbGRlcjogZGF0LkdVSSwgcHJvdGVjdGVkIHRlbnNvckZpZWxkOiBUZW5zb3JGaWVsZCwgcHJvdGVjdGVkIGNsb3NlVGVuc29yRm9sZGVyOiAoKSA9PiB2b2lkKSB7XG4gICAgICAgIGd1aUZvbGRlci5hZGQodGhpcywgJ2dlbmVyYXRlRXZlcnl0aGluZycpO1xuICAgICAgICAvLyBndWlGb2xkZXIuYWRkKHRoaXMsICdzaW1wbGVCZW5jaE1hcmsnKTtcbiAgICAgICAgY29uc3QgYW5pbWF0ZUNvbnRyb2xsZXIgPSBndWlGb2xkZXIuYWRkKHRoaXMsICdhbmltYXRlJyk7XG4gICAgICAgIGd1aUZvbGRlci5hZGQodGhpcywgJ2FuaW1hdGlvblNwZWVkJyk7XG5cbiAgICAgICAgdGhpcy5jb2FzdGxpbmVQYXJhbXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGNvYXN0Tm9pc2U6IHtcbiAgICAgICAgICAgICAgICBub2lzZUVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgbm9pc2VTaXplOiAzMCxcbiAgICAgICAgICAgICAgICBub2lzZUFuZ2xlOiAyMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByaXZlck5vaXNlOiB7XG4gICAgICAgICAgICAgICAgbm9pc2VFbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIG5vaXNlU2l6ZTogMzAsXG4gICAgICAgICAgICAgICAgbm9pc2VBbmdsZTogMjAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcml2ZXJCYW5rU2l6ZTogMTAsXG4gICAgICAgICAgICByaXZlclNpemU6IDMwLFxuICAgICAgICB9LCB0aGlzLm1pbm9yUGFyYW1zKTtcbiAgICAgICAgdGhpcy5jb2FzdGxpbmVQYXJhbXMucGF0aEl0ZXJhdGlvbnMgPSAxMDAwMDtcbiAgICAgICAgdGhpcy5jb2FzdGxpbmVQYXJhbXMuc2ltcGxpZnlUb2xlcmFuY2UgPSAxMDtcblxuICAgICAgICB0aGlzLm1ham9yUGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5taW5vclBhcmFtcyk7XG4gICAgICAgIHRoaXMubWFqb3JQYXJhbXMuZHNlcCA9IDEwMDtcbiAgICAgICAgdGhpcy5tYWpvclBhcmFtcy5kdGVzdCA9IDMwO1xuICAgICAgICB0aGlzLm1ham9yUGFyYW1zLmRsb29rYWhlYWQgPSAyMDA7XG4gICAgICAgIHRoaXMubWFqb3JQYXJhbXMuY29sbGlkZUVhcmx5ID0gMDtcblxuICAgICAgICB0aGlzLm1haW5QYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm1pbm9yUGFyYW1zKTtcbiAgICAgICAgdGhpcy5tYWluUGFyYW1zLmRzZXAgPSA0MDA7XG4gICAgICAgIHRoaXMubWFpblBhcmFtcy5kdGVzdCA9IDIwMDtcbiAgICAgICAgdGhpcy5tYWluUGFyYW1zLmRsb29rYWhlYWQgPSA1MDA7XG4gICAgICAgIHRoaXMubWFpblBhcmFtcy5jb2xsaWRlRWFybHkgPSAwO1xuXG4gICAgICAgIGNvbnN0IGludGVncmF0b3IgPSBuZXcgUks0SW50ZWdyYXRvcih0ZW5zb3JGaWVsZCwgdGhpcy5taW5vclBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlZHJhdyA9ICgpID0+IHRoaXMucmVkcmF3ID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmNvYXN0bGluZSA9IG5ldyBXYXRlckdVSSh0ZW5zb3JGaWVsZCwgdGhpcy5jb2FzdGxpbmVQYXJhbXMsIGludGVncmF0b3IsXG4gICAgICAgICAgICB0aGlzLmd1aUZvbGRlciwgY2xvc2VUZW5zb3JGb2xkZXIsICdXYXRlcicsIHJlZHJhdykuaW5pdEZvbGRlcigpO1xuICAgICAgICB0aGlzLm1haW5Sb2FkcyA9IG5ldyBSb2FkR1VJKHRoaXMubWFpblBhcmFtcywgaW50ZWdyYXRvciwgdGhpcy5ndWlGb2xkZXIsIGNsb3NlVGVuc29yRm9sZGVyLCAnTWFpbicsIHJlZHJhdykuaW5pdEZvbGRlcigpO1xuICAgICAgICB0aGlzLm1ham9yUm9hZHMgPSBuZXcgUm9hZEdVSSh0aGlzLm1ham9yUGFyYW1zLCBpbnRlZ3JhdG9yLCB0aGlzLmd1aUZvbGRlciwgY2xvc2VUZW5zb3JGb2xkZXIsICdNYWpvcicsIHJlZHJhdywgdGhpcy5hbmltYXRlKS5pbml0Rm9sZGVyKCk7XG4gICAgICAgIHRoaXMubWlub3JSb2FkcyA9IG5ldyBSb2FkR1VJKHRoaXMubWlub3JQYXJhbXMsIGludGVncmF0b3IsIHRoaXMuZ3VpRm9sZGVyLCBjbG9zZVRlbnNvckZvbGRlciwgJ01pbm9yJywgcmVkcmF3LCB0aGlzLmFuaW1hdGUpLmluaXRGb2xkZXIoKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHBhcmtzID0gZ3VpRm9sZGVyLmFkZEZvbGRlcignUGFya3MnKTtcbiAgICAgICAgcGFya3MuYWRkKHtHZW5lcmF0ZTogKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5idWlsZGluZ3MucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuYWRkUGFya3MoKTtcbiAgICAgICAgICAgIHRoaXMucmVkcmF3ID0gdHJ1ZTtcbiAgICAgICAgfX0sICdHZW5lcmF0ZScpO1xuICAgICAgICBwYXJrcy5hZGQodGhpcywgJ2NsdXN0ZXJCaWdQYXJrcycpO1xuICAgICAgICBwYXJrcy5hZGQodGhpcywgJ251bUJpZ1BhcmtzJyk7XG4gICAgICAgIHBhcmtzLmFkZCh0aGlzLCAnbnVtU21hbGxQYXJrcycpO1xuXG4gICAgICAgIGNvbnN0IGJ1aWxkaW5nc0ZvbGRlciA9IGd1aUZvbGRlci5hZGRGb2xkZXIoJ0J1aWxkaW5ncycpO1xuICAgICAgICB0aGlzLmJ1aWxkaW5ncyA9IG5ldyBCdWlsZGluZ3ModGVuc29yRmllbGQsIGJ1aWxkaW5nc0ZvbGRlciwgcmVkcmF3LCB0aGlzLm1pbm9yUGFyYW1zLmRzdGVwLCB0aGlzLmFuaW1hdGUpO1xuICAgICAgICB0aGlzLmJ1aWxkaW5ncy5zZXRQcmVHZW5lcmF0ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFsbFN0cmVhbWxpbmVzID0gW107XG4gICAgICAgICAgICBhbGxTdHJlYW1saW5lcy5wdXNoKC4uLnRoaXMubWFpblJvYWRzLmFsbFN0cmVhbWxpbmVzKTtcbiAgICAgICAgICAgIGFsbFN0cmVhbWxpbmVzLnB1c2goLi4udGhpcy5tYWpvclJvYWRzLmFsbFN0cmVhbWxpbmVzKTtcbiAgICAgICAgICAgIGFsbFN0cmVhbWxpbmVzLnB1c2goLi4udGhpcy5taW5vclJvYWRzLmFsbFN0cmVhbWxpbmVzKTtcbiAgICAgICAgICAgIGFsbFN0cmVhbWxpbmVzLnB1c2goLi4udGhpcy5jb2FzdGxpbmUuc3RyZWFtbGluZXNXaXRoU2Vjb25kYXJ5Um9hZCk7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkaW5ncy5zZXRBbGxTdHJlYW1saW5lcyhhbGxTdHJlYW1saW5lcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFuaW1hdGVDb250cm9sbGVyLm9uQ2hhbmdlKChiOiBib29sZWFuKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1ham9yUm9hZHMuYW5pbWF0ZSA9IGI7XG4gICAgICAgICAgICB0aGlzLm1pbm9yUm9hZHMuYW5pbWF0ZSA9IGI7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkaW5ncy5hbmltYXRlID0gYjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5taW5vclJvYWRzLnNldEV4aXN0aW5nU3RyZWFtbGluZXMoW3RoaXMuY29hc3RsaW5lLCB0aGlzLm1haW5Sb2FkcywgdGhpcy5tYWpvclJvYWRzXSk7XG4gICAgICAgIHRoaXMubWFqb3JSb2Fkcy5zZXRFeGlzdGluZ1N0cmVhbWxpbmVzKFt0aGlzLmNvYXN0bGluZSwgdGhpcy5tYWluUm9hZHNdKTtcbiAgICAgICAgdGhpcy5tYWluUm9hZHMuc2V0RXhpc3RpbmdTdHJlYW1saW5lcyhbdGhpcy5jb2FzdGxpbmVdKTtcblxuICAgICAgICB0aGlzLmNvYXN0bGluZS5zZXRQcmVHZW5lcmF0ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWFpblJvYWRzLmNsZWFyU3RyZWFtbGluZXMoKTtcbiAgICAgICAgICAgIHRoaXMubWFqb3JSb2Fkcy5jbGVhclN0cmVhbWxpbmVzKCk7XG4gICAgICAgICAgICB0aGlzLm1pbm9yUm9hZHMuY2xlYXJTdHJlYW1saW5lcygpO1xuICAgICAgICAgICAgdGhpcy5iaWdQYXJrcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zbWFsbFBhcmtzID0gW107XG4gICAgICAgICAgICB0aGlzLmJ1aWxkaW5ncy5yZXNldCgpO1xuICAgICAgICAgICAgdGVuc29yRmllbGQucGFya3MgPSBbXTtcbiAgICAgICAgICAgIHRlbnNvckZpZWxkLnNlYSA9IFtdO1xuICAgICAgICAgICAgdGVuc29yRmllbGQucml2ZXIgPSBbXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5tYWluUm9hZHMuc2V0UHJlR2VuZXJhdGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1ham9yUm9hZHMuY2xlYXJTdHJlYW1saW5lcygpO1xuICAgICAgICAgICAgdGhpcy5taW5vclJvYWRzLmNsZWFyU3RyZWFtbGluZXMoKTtcbiAgICAgICAgICAgIHRoaXMuYmlnUGFya3MgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc21hbGxQYXJrcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5idWlsZGluZ3MucmVzZXQoKTtcbiAgICAgICAgICAgIHRlbnNvckZpZWxkLnBhcmtzID0gW107XG4gICAgICAgICAgICB0ZW5zb3JGaWVsZC5pZ25vcmVSaXZlciA9IHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubWFpblJvYWRzLnNldFBvc3RHZW5lcmF0ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIHRlbnNvckZpZWxkLmlnbm9yZVJpdmVyID0gZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubWFqb3JSb2Fkcy5zZXRQcmVHZW5lcmF0ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWlub3JSb2Fkcy5jbGVhclN0cmVhbWxpbmVzKCk7XG4gICAgICAgICAgICB0aGlzLmJpZ1BhcmtzID0gW107XG4gICAgICAgICAgICB0aGlzLnNtYWxsUGFya3MgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRpbmdzLnJlc2V0KCk7XG4gICAgICAgICAgICB0ZW5zb3JGaWVsZC5wYXJrcyA9IFtdO1xuICAgICAgICAgICAgdGVuc29yRmllbGQuaWdub3JlUml2ZXIgPSB0cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm1ham9yUm9hZHMuc2V0UG9zdEdlbmVyYXRlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgdGVuc29yRmllbGQuaWdub3JlUml2ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYWRkUGFya3MoKTtcbiAgICAgICAgICAgIHRoaXMucmVkcmF3ID0gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5taW5vclJvYWRzLnNldFByZUdlbmVyYXRlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5idWlsZGluZ3MucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuc21hbGxQYXJrcyA9IFtdO1xuICAgICAgICAgICAgdGVuc29yRmllbGQucGFya3MgPSB0aGlzLmJpZ1BhcmtzO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm1pbm9yUm9hZHMuc2V0UG9zdEdlbmVyYXRlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGRQYXJrcygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhZGRQYXJrcygpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZyA9IG5ldyBHcmFwaCh0aGlzLm1ham9yUm9hZHMuYWxsU3RyZWFtbGluZXNcbiAgICAgICAgICAgIC5jb25jYXQodGhpcy5tYWluUm9hZHMuYWxsU3RyZWFtbGluZXMpXG4gICAgICAgICAgICAuY29uY2F0KHRoaXMubWlub3JSb2Fkcy5hbGxTdHJlYW1saW5lcyksIHRoaXMubWlub3JQYXJhbXMuZHN0ZXApO1xuICAgICAgICB0aGlzLmludGVyc2VjdGlvbnMgPSBnLmludGVyc2VjdGlvbnM7XG5cbiAgICAgICAgY29uc3QgcCA9IG5ldyBQb2x5Z29uRmluZGVyKGcubm9kZXMsIHtcbiAgICAgICAgICAgICAgICBtYXhMZW5ndGg6IDIwLFxuICAgICAgICAgICAgICAgIG1pbkFyZWE6IDgwLFxuICAgICAgICAgICAgICAgIHNocmlua1NwYWNpbmc6IDQsXG4gICAgICAgICAgICAgICAgY2hhbmNlTm9EaXZpZGU6IDEsXG4gICAgICAgICAgICB9LCB0aGlzLnRlbnNvckZpZWxkKTtcbiAgICAgICAgcC5maW5kUG9seWdvbnMoKTtcbiAgICAgICAgY29uc3QgcG9seWdvbnMgPSBwLnBvbHlnb25zO1xuXG4gICAgICAgIGlmICh0aGlzLm1pbm9yUm9hZHMuYWxsU3RyZWFtbGluZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBCaWcgcGFya3NcbiAgICAgICAgICAgIHRoaXMuYmlnUGFya3MgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc21hbGxQYXJrcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHBvbHlnb25zLmxlbmd0aCA+IHRoaXMubnVtQmlnUGFya3MpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jbHVzdGVyQmlnUGFya3MpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR3JvdXAgaW4gYWRqYWNlbnQgcG9seWdvbnMgXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmtJbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChwb2x5Z29ucy5sZW5ndGggLSB0aGlzLm51bUJpZ1BhcmtzKSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBwYXJrSW5kZXg7IGkgPCBwYXJrSW5kZXggKyB0aGlzLm51bUJpZ1BhcmtzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmlnUGFya3MucHVzaChwb2x5Z29uc1tpXSk7ICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm51bUJpZ1BhcmtzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmtJbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBvbHlnb25zLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJpZ1BhcmtzLnB1c2gocG9seWdvbnNbcGFya0luZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYmlnUGFya3MucHVzaCguLi5wb2x5Z29ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTbWFsbCBwYXJrc1xuICAgICAgICAgICAgdGhpcy5zbWFsbFBhcmtzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubnVtU21hbGxQYXJrczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFya0luZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcG9seWdvbnMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNtYWxsUGFya3MucHVzaChwb2x5Z29uc1twYXJrSW5kZXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGVuc29yRmllbGQucGFya3MgPSBbXTtcbiAgICAgICAgdGhpcy50ZW5zb3JGaWVsZC5wYXJrcy5wdXNoKC4uLnRoaXMuYmlnUGFya3MpO1xuICAgICAgICB0aGlzLnRlbnNvckZpZWxkLnBhcmtzLnB1c2goLi4udGhpcy5zbWFsbFBhcmtzKTtcbiAgICB9XG5cbiAgICBhc3luYyBnZW5lcmF0ZUV2ZXJ5dGhpbmcoKSB7XG4gICAgICAgIHRoaXMuY29hc3RsaW5lLmdlbmVyYXRlUm9hZHMoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5tYWluUm9hZHMuZ2VuZXJhdGVSb2FkcygpO1xuICAgICAgICBhd2FpdCB0aGlzLm1ham9yUm9hZHMuZ2VuZXJhdGVSb2Fkcyh0aGlzLmFuaW1hdGUpO1xuICAgICAgICBhd2FpdCB0aGlzLm1pbm9yUm9hZHMuZ2VuZXJhdGVSb2Fkcyh0aGlzLmFuaW1hdGUpO1xuICAgICAgICB0aGlzLnJlZHJhdyA9IHRydWU7XG4gICAgICAgIGF3YWl0IHRoaXMuYnVpbGRpbmdzLmdlbmVyYXRlKHRoaXMuYW5pbWF0ZSk7XG4gICAgfVxuXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBsZXQgY29udGludWVVcGRhdGUgPSB0cnVlO1xuICAgICAgICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB3aGlsZSAoY29udGludWVVcGRhdGUgJiYgcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCA8IHRoaXMuYW5pbWF0aW9uU3BlZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pbm9yQ2hhbmdlZCA9IHRoaXMubWlub3JSb2Fkcy51cGRhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IG1ham9yQ2hhbmdlZCA9IHRoaXMubWFqb3JSb2Fkcy51cGRhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IG1haW5DaGFuZ2VkID0gdGhpcy5tYWluUm9hZHMudXBkYXRlKCk7XG4gICAgICAgICAgICBjb25zdCBidWlsZGluZ3NDaGFuZ2VkID0gdGhpcy5idWlsZGluZ3MudXBkYXRlKCk7XG4gICAgICAgICAgICBjb250aW51ZVVwZGF0ZSA9IG1pbm9yQ2hhbmdlZCB8fCBtYWpvckNoYW5nZWQgfHwgbWFpbkNoYW5nZWQgfHwgYnVpbGRpbmdzQ2hhbmdlZDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5yZWRyYXcgPSB0aGlzLnJlZHJhdyB8fCBjb250aW51ZVVwZGF0ZTtcbiAgICB9XG5cbiAgICBkcmF3KHN0eWxlOiBTdHlsZSwgZm9yY2VEcmF3PWZhbHNlLCBjdXN0b21DYW52YXM/OiBDYW52YXNXcmFwcGVyKTogdm9pZCB7XG4gICAgICAgIGlmICghc3R5bGUubmVlZHNVcGRhdGUgJiYgIWZvcmNlRHJhdyAmJiAhdGhpcy5yZWRyYXcgJiYgIXRoaXMuZG9tYWluQ29udHJvbGxlci5tb3ZlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3R5bGUubmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kb21haW5Db250cm9sbGVyLm1vdmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVkcmF3ID0gZmFsc2U7XG5cbiAgICAgICAgc3R5bGUuc2VhUG9seWdvbiA9IHRoaXMuY29hc3RsaW5lLnNlYVBvbHlnb247XG4gICAgICAgIHN0eWxlLmNvYXN0bGluZSA9IHRoaXMuY29hc3RsaW5lLmNvYXN0bGluZTtcbiAgICAgICAgc3R5bGUucml2ZXIgPSB0aGlzLmNvYXN0bGluZS5yaXZlcjtcbiAgICAgICAgc3R5bGUubG90cyA9IHRoaXMuYnVpbGRpbmdzLmxvdHM7XG5cbiAgICAgICAgaWYgKHN0eWxlIGluc3RhbmNlb2YgRGVmYXVsdFN0eWxlICYmIHN0eWxlLnNob3dCdWlsZGluZ01vZGVscyB8fCBzdHlsZSBpbnN0YW5jZW9mIFJvdWdoU3R5bGUpIHtcbiAgICAgICAgICAgIHN0eWxlLmJ1aWxkaW5nTW9kZWxzID0gdGhpcy5idWlsZGluZ3MubW9kZWxzOyAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIHN0eWxlLnBhcmtzID0gW107XG4gICAgICAgIHN0eWxlLnBhcmtzLnB1c2goLi4udGhpcy5iaWdQYXJrcy5tYXAocCA9PiBwLm1hcCh2ID0+IHRoaXMuZG9tYWluQ29udHJvbGxlci53b3JsZFRvU2NyZWVuKHYuY2xvbmUoKSkpKSk7XG4gICAgICAgIHN0eWxlLnBhcmtzLnB1c2goLi4udGhpcy5zbWFsbFBhcmtzLm1hcChwID0+IHAubWFwKHYgPT4gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkVG9TY3JlZW4odi5jbG9uZSgpKSkpKTtcbiAgICAgICAgc3R5bGUubWlub3JSb2FkcyA9IHRoaXMubWlub3JSb2Fkcy5yb2FkcztcbiAgICAgICAgc3R5bGUubWFqb3JSb2FkcyA9IHRoaXMubWFqb3JSb2Fkcy5yb2FkcztcbiAgICAgICAgc3R5bGUubWFpblJvYWRzID0gdGhpcy5tYWluUm9hZHMucm9hZHM7XG4gICAgICAgIHN0eWxlLmNvYXN0bGluZVJvYWRzID0gdGhpcy5jb2FzdGxpbmUucm9hZHM7XG4gICAgICAgIHN0eWxlLnNlY29uZGFyeVJpdmVyID0gdGhpcy5jb2FzdGxpbmUuc2Vjb25kYXJ5Uml2ZXI7XG4gICAgICAgIHN0eWxlLmRyYXcoY3VzdG9tQ2FudmFzKTtcbiAgICB9XG5cbiAgICByb2Fkc0VtcHR5KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5tYWpvclJvYWRzLnJvYWRzRW1wdHkoKVxuICAgICAgICAgICAgJiYgdGhpcy5taW5vclJvYWRzLnJvYWRzRW1wdHkoKVxuICAgICAgICAgICAgJiYgdGhpcy5tYWluUm9hZHMucm9hZHNFbXB0eSgpXG4gICAgICAgICAgICAmJiB0aGlzLmNvYXN0bGluZS5yb2Fkc0VtcHR5KCk7XG4gICAgfVxuXG4gICAgLy8gT0JKIEV4cG9ydCBtZXRob2RzXG5cbiAgICBwdWJsaWMgZ2V0IHNlYVBvbHlnb24oKTogVmVjdG9yW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2FzdGxpbmUuc2VhUG9seWdvbjtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHJpdmVyUG9seWdvbigpOiBWZWN0b3JbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvYXN0bGluZS5yaXZlcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGJ1aWxkaW5nTW9kZWxzKCk6IEJ1aWxkaW5nTW9kZWxbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkaW5ncy5tb2RlbHM7XG4gICAgfVxuXG4gICAgcHVibGljIGdldEJsb2NrcygpOiBQcm9taXNlPFZlY3RvcltdW10+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRpbmdzLmdldEJsb2NrcygpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgbWlub3JSb2FkUG9seWdvbnMoKTogVmVjdG9yW11bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbm9yUm9hZHMucm9hZHMubWFwKHIgPT4gUG9seWdvblV0aWwucmVzaXplR2VvbWV0cnkociwgMSAqIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tLCBmYWxzZSkpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgbWFqb3JSb2FkUG9seWdvbnMoKTogVmVjdG9yW11bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ham9yUm9hZHMucm9hZHMuY29uY2F0KFt0aGlzLmNvYXN0bGluZS5zZWNvbmRhcnlSaXZlcl0pLm1hcChyID0+IFBvbHlnb25VdGlsLnJlc2l6ZUdlb21ldHJ5KHIsIDIgKiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSwgZmFsc2UpKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IG1haW5Sb2FkUG9seWdvbnMoKTogVmVjdG9yW11bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1haW5Sb2Fkcy5yb2Fkcy5jb25jYXQodGhpcy5jb2FzdGxpbmUucm9hZHMpLm1hcChyID0+IFBvbHlnb25VdGlsLnJlc2l6ZUdlb21ldHJ5KHIsIDIuNSAqIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tLCBmYWxzZSkpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgY29hc3RsaW5lUG9seWdvbigpOiBWZWN0b3JbXSB7XG4gICAgICAgIHJldHVybiBQb2x5Z29uVXRpbC5yZXNpemVHZW9tZXRyeSh0aGlzLmNvYXN0bGluZS5jb2FzdGxpbmUsIDE1ICogdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20sIGZhbHNlKTtcbiAgICB9XG4gICAgXG59XG4iLCJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IENhbnZhc1dyYXBwZXIgZnJvbSAnLi9jYW52YXNfd3JhcHBlcic7XG5pbXBvcnQgRG9tYWluQ29udHJvbGxlciBmcm9tICcuL2RvbWFpbl9jb250cm9sbGVyJztcbmltcG9ydCBVdGlsIGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IEZpZWxkSW50ZWdyYXRvciBmcm9tICcuLi9pbXBsL2ludGVncmF0b3InO1xuaW1wb3J0IHtTdHJlYW1saW5lUGFyYW1zfSBmcm9tICcuLi9pbXBsL3N0cmVhbWxpbmVzJztcbmltcG9ydCBTdHJlYW1saW5lR2VuZXJhdG9yIGZyb20gJy4uL2ltcGwvc3RyZWFtbGluZXMnO1xuaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xuXG4vKipcbiAqIEhhbmRsZXMgY3JlYXRpb24gb2Ygcm9hZHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUm9hZEdVSSB7XG4gICAgcHJvdGVjdGVkIHN0cmVhbWxpbmVzOiBTdHJlYW1saW5lR2VuZXJhdG9yO1xuICAgIHByaXZhdGUgZXhpc3RpbmdTdHJlYW1saW5lczogUm9hZEdVSVtdID0gW107XG4gICAgcHJvdGVjdGVkIGRvbWFpbkNvbnRyb2xsZXIgPSBEb21haW5Db250cm9sbGVyLmdldEluc3RhbmNlKCk7XG4gICAgcHJvdGVjdGVkIHByZUdlbmVyYXRlQ2FsbGJhY2s6ICgpID0+IGFueSA9ICgpID0+IHt9O1xuICAgIHByb3RlY3RlZCBwb3N0R2VuZXJhdGVDYWxsYmFjazogKCkgPT4gYW55ID0gKCkgPT4ge307XG5cbiAgICBwcml2YXRlIHN0cmVhbWxpbmVzSW5Qcm9ncmVzczogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIHBhcmFtczogU3RyZWFtbGluZVBhcmFtcyxcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgaW50ZWdyYXRvcjogRmllbGRJbnRlZ3JhdG9yLFxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBndWlGb2xkZXI6IGRhdC5HVUksXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIGNsb3NlVGVuc29yRm9sZGVyOiAoKSA9PiB2b2lkLFxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBmb2xkZXJOYW1lOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHJlZHJhdzogKCkgPT4gdm9pZCxcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgX2FuaW1hdGU9ZmFsc2UpIHtcbiAgICAgICAgdGhpcy5zdHJlYW1saW5lcyA9IG5ldyBTdHJlYW1saW5lR2VuZXJhdG9yKFxuICAgICAgICAgICAgdGhpcy5pbnRlZ3JhdG9yLCB0aGlzLmRvbWFpbkNvbnRyb2xsZXIub3JpZ2luLFxuICAgICAgICAgICAgdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkRGltZW5zaW9ucywgdGhpcy5wYXJhbXMpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBwYXRoIGl0ZXJhdGlvbnMgYmFzZWQgb24gd2luZG93IHNpemVcbiAgICAgICAgdGhpcy5zZXRQYXRoSXRlcmF0aW9ucygpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgKCk6IHZvaWQgPT4gdGhpcy5zZXRQYXRoSXRlcmF0aW9ucygpKTtcbiAgICB9XG5cbiAgICBpbml0Rm9sZGVyKCk6IFJvYWRHVUkge1xuICAgICAgICBjb25zdCByb2FkR1VJID0ge1xuICAgICAgICAgICAgR2VuZXJhdGU6ICgpID0+IHRoaXMuZ2VuZXJhdGVSb2Fkcyh0aGlzLl9hbmltYXRlKS50aGVuKCgpID0+IHRoaXMucmVkcmF3KCkpLFxuICAgICAgICAgICAgSm9pbkRhbmdsaW5nOiAoKTogdm9pZCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1saW5lcy5qb2luRGFuZ2xpbmdTdHJlYW1saW5lcygpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGZvbGRlciA9IHRoaXMuZ3VpRm9sZGVyLmFkZEZvbGRlcih0aGlzLmZvbGRlck5hbWUpO1xuICAgICAgICBmb2xkZXIuYWRkKHJvYWRHVUksICdHZW5lcmF0ZScpO1xuICAgICAgICAvLyBmb2xkZXIuYWRkKHJvYWRHVUksICdKb2luRGFuZ2xpbmcnKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHBhcmFtc0ZvbGRlciA9IGZvbGRlci5hZGRGb2xkZXIoJ1BhcmFtcycpO1xuICAgICAgICBwYXJhbXNGb2xkZXIuYWRkKHRoaXMucGFyYW1zLCAnZHNlcCcpO1xuICAgICAgICBwYXJhbXNGb2xkZXIuYWRkKHRoaXMucGFyYW1zLCAnZHRlc3QnKTtcblxuICAgICAgICBjb25zdCBkZXZQYXJhbXNGb2xkZXIgPSBwYXJhbXNGb2xkZXIuYWRkRm9sZGVyKCdEZXYnKTtcbiAgICAgICAgdGhpcy5hZGREZXZQYXJhbXNUb0ZvbGRlcih0aGlzLnBhcmFtcywgZGV2UGFyYW1zRm9sZGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0IGFuaW1hdGUoYjogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9hbmltYXRlID0gYjtcbiAgICB9XG5cbiAgICBnZXQgYWxsU3RyZWFtbGluZXMoKTogVmVjdG9yW11bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbWxpbmVzLmFsbFN0cmVhbWxpbmVzU2ltcGxlO1xuICAgIH1cblxuICAgIGdldCByb2FkcygpOiBWZWN0b3JbXVtdIHtcbiAgICAgICAgLy8gRm9yIGRyYXdpbmcgbm90IGdlbmVyYXRpb24sIHByb2JhYmx5IGZpbmUgdG8gbGVhdmUgbWFwXG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbWxpbmVzLmFsbFN0cmVhbWxpbmVzU2ltcGxlLm1hcChzID0+XG4gICAgICAgICAgICBzLm1hcCh2ID0+IHRoaXMuZG9tYWluQ29udHJvbGxlci53b3JsZFRvU2NyZWVuKHYuY2xvbmUoKSkpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcm9hZHNFbXB0eSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtbGluZXMuYWxsU3RyZWFtbGluZXNTaW1wbGUubGVuZ3RoID09PSAwO1xuICAgIH1cblxuICAgIHNldEV4aXN0aW5nU3RyZWFtbGluZXMoZXhpc3RpbmdTdHJlYW1saW5lczogUm9hZEdVSVtdKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZXhpc3RpbmdTdHJlYW1saW5lcyA9IGV4aXN0aW5nU3RyZWFtbGluZXM7XG4gICAgfVxuXG4gICAgc2V0UHJlR2VuZXJhdGVDYWxsYmFjayhjYWxsYmFjazogKCkgPT4gYW55KSB7XG4gICAgICAgIHRoaXMucHJlR2VuZXJhdGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIHNldFBvc3RHZW5lcmF0ZUNhbGxiYWNrKGNhbGxiYWNrOiAoKSA9PiBhbnkpIHtcbiAgICAgICAgdGhpcy5wb3N0R2VuZXJhdGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGNsZWFyU3RyZWFtbGluZXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc3RyZWFtbGluZXMuY2xlYXJTdHJlYW1saW5lcygpO1xuICAgIH1cblxuICAgIGFzeW5jIGdlbmVyYXRlUm9hZHMoYW5pbWF0ZT1mYWxzZSk6IFByb21pc2U8dW5rbm93bj4ge1xuICAgICAgICB0aGlzLnByZUdlbmVyYXRlQ2FsbGJhY2soKTtcblxuICAgICAgICB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSA9IHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tIC8gVXRpbC5EUkFXX0lORkxBVEVfQU1PVU5UO1xuICAgICAgICB0aGlzLnN0cmVhbWxpbmVzID0gbmV3IFN0cmVhbWxpbmVHZW5lcmF0b3IoXG4gICAgICAgICAgICB0aGlzLmludGVncmF0b3IsIHRoaXMuZG9tYWluQ29udHJvbGxlci5vcmlnaW4sXG4gICAgICAgICAgICB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGREaW1lbnNpb25zLCBPYmplY3QuYXNzaWduKHt9LHRoaXMucGFyYW1zKSk7XG4gICAgICAgIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tID0gdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20gKiBVdGlsLkRSQVdfSU5GTEFURV9BTU9VTlQ7XG5cbiAgICAgICAgZm9yIChjb25zdCBzIG9mIHRoaXMuZXhpc3RpbmdTdHJlYW1saW5lcykge1xuICAgICAgICAgICAgdGhpcy5zdHJlYW1saW5lcy5hZGRFeGlzdGluZ1N0cmVhbWxpbmVzKHMuc3RyZWFtbGluZXMpICAgXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNsb3NlVGVuc29yRm9sZGVyKCk7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1saW5lcy5jcmVhdGVBbGxTdHJlYW1saW5lcyhhbmltYXRlKS50aGVuKCgpID0+IHRoaXMucG9zdEdlbmVyYXRlQ2FsbGJhY2soKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHN0cmVhbWxpbmVzIGNoYW5nZXNcbiAgICAgKi9cbiAgICB1cGRhdGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbWxpbmVzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBhZGREZXZQYXJhbXNUb0ZvbGRlcihwYXJhbXM6IFN0cmVhbWxpbmVQYXJhbXMsIGZvbGRlcjogZGF0LkdVSSk6IHZvaWQge1xuICAgICAgICBmb2xkZXIuYWRkKHBhcmFtcywgJ3BhdGhJdGVyYXRpb25zJyk7XG4gICAgICAgIGZvbGRlci5hZGQocGFyYW1zLCAnc2VlZFRyaWVzJyk7XG4gICAgICAgIGZvbGRlci5hZGQocGFyYW1zLCAnZHN0ZXAnKTtcbiAgICAgICAgZm9sZGVyLmFkZChwYXJhbXMsICdkbG9va2FoZWFkJyk7XG4gICAgICAgIGZvbGRlci5hZGQocGFyYW1zLCAnZGNpcmNsZWpvaW4nKTtcbiAgICAgICAgZm9sZGVyLmFkZChwYXJhbXMsICdqb2luYW5nbGUnKTtcbiAgICAgICAgZm9sZGVyLmFkZChwYXJhbXMsICdzaW1wbGlmeVRvbGVyYW5jZScpO1xuICAgICAgICBmb2xkZXIuYWRkKHBhcmFtcywgJ2NvbGxpZGVFYXJseScpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgcGF0aCBpdGVyYXRpb25zIHNvIHRoYXQgYSByb2FkIGNhbiBjb3ZlciB0aGUgc2NyZWVuXG4gICAgICovXG4gICAgcHJpdmF0ZSBzZXRQYXRoSXRlcmF0aW9ucygpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbWF4ID0gMS41ICogTWF0aC5tYXgod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICAgIHRoaXMucGFyYW1zLnBhdGhJdGVyYXRpb25zID0gbWF4L3RoaXMucGFyYW1zLmRzdGVwO1xuICAgICAgICBVdGlsLnVwZGF0ZUd1aSh0aGlzLmd1aUZvbGRlcik7XG4gICAgfVxufVxuIiwiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0ICogYXMgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCAqIGFzIGRhdCBmcm9tICdkYXQuZ3VpJztcbmltcG9ydCBUZW5zb3JGaWVsZEdVSSBmcm9tICcuL3RlbnNvcl9maWVsZF9ndWknO1xuaW1wb3J0IHtOb2lzZVBhcmFtc30gZnJvbSAnLi4vaW1wbC90ZW5zb3JfZmllbGQnO1xuaW1wb3J0IENhbnZhc1dyYXBwZXIgZnJvbSAnLi9jYW52YXNfd3JhcHBlcic7XG5pbXBvcnQge0RlZmF1bHRDYW52YXNXcmFwcGVyLCBSb3VnaENhbnZhc1dyYXBwZXJ9IGZyb20gJy4vY2FudmFzX3dyYXBwZXInO1xuaW1wb3J0IFV0aWwgZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgUG9seWdvblV0aWwgZnJvbSAnLi4vaW1wbC9wb2x5Z29uX3V0aWwnO1xuaW1wb3J0IERyYWdDb250cm9sbGVyIGZyb20gJy4vZHJhZ19jb250cm9sbGVyJztcbmltcG9ydCBEb21haW5Db250cm9sbGVyIGZyb20gJy4vZG9tYWluX2NvbnRyb2xsZXInO1xuaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xuaW1wb3J0IHtCdWlsZGluZ01vZGVsfSBmcm9tICcuL2J1aWxkaW5ncyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29sb3VyU2NoZW1lIHtcbiAgICBiZ0NvbG91cjogc3RyaW5nO1xuICAgIGJnQ29sb3VySW4/OiBzdHJpbmc7XG4gICAgYnVpbGRpbmdDb2xvdXI/OiBzdHJpbmc7XG4gICAgYnVpbGRpbmdTaWRlQ29sb3VyPzogc3RyaW5nO1xuICAgIGJ1aWxkaW5nU3Ryb2tlPzogc3RyaW5nO1xuICAgIHNlYUNvbG91cjogc3RyaW5nO1xuICAgIGdyYXNzQ29sb3VyPzogc3RyaW5nO1xuICAgIG1pbm9yUm9hZENvbG91cjogc3RyaW5nO1xuICAgIG1pbm9yUm9hZE91dGxpbmU/OiBzdHJpbmc7XG4gICAgbWFqb3JSb2FkQ29sb3VyPzogc3RyaW5nO1xuICAgIG1ham9yUm9hZE91dGxpbmU/OiBzdHJpbmc7XG4gICAgbWFpblJvYWRDb2xvdXI/OiBzdHJpbmc7XG4gICAgbWFpblJvYWRPdXRsaW5lPzogc3RyaW5nO1xuICAgIG91dGxpbmVTaXplPzogbnVtYmVyO1xuICAgIG1pbm9yV2lkdGg/OiBudW1iZXI7XG4gICAgbWFqb3JXaWR0aD86IG51bWJlcjtcbiAgICBtYWluV2lkdGg/OiBudW1iZXI7XG4gICAgem9vbUJ1aWxkaW5ncz86IGJvb2xlYW47XG4gICAgYnVpbGRpbmdNb2RlbHM/OiBib29sZWFuO1xuICAgIGZyYW1lQ29sb3VyPzogc3RyaW5nO1xuICAgIGZyYW1lVGV4dENvbG91cj86IHN0cmluZztcbn1cblxuLyoqXG4gKiBDb250cm9scyBob3cgc2NyZWVuLXNwYWNlIGRhdGEgaXMgZHJhd25cbiAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgU3R5bGUge1xuICAgIGNhbnZhczogQ2FudmFzV3JhcHBlcjtcbiAgICBkb21haW5Db250cm9sbGVyOiBEb21haW5Db250cm9sbGVyID0gRG9tYWluQ29udHJvbGxlci5nZXRJbnN0YW5jZSgpO1xuICAgIGFic3RyYWN0IGNyZWF0ZUNhbnZhc1dyYXBwZXIoYzogSFRNTENhbnZhc0VsZW1lbnQsIHNjYWxlOiBudW1iZXIsIHJlc2l6ZVRvV2luZG93OiBib29sZWFuKTogQ2FudmFzV3JhcHBlcjtcbiAgICBhYnN0cmFjdCBkcmF3KGNhbnZhcz86IENhbnZhc1dyYXBwZXIpOiB2b2lkO1xuXG4gICAgdXBkYXRlKCk6IHZvaWQge31cblxuICAgIC8vIFBvbHlnb25zXG4gICAgc2VhUG9seWdvbjogVmVjdG9yW10gPSBbXTtcbiAgICBsb3RzOiBWZWN0b3JbXVtdID0gW107XG4gICAgYnVpbGRpbmdNb2RlbHM6IEJ1aWxkaW5nTW9kZWxbXSA9IFtdO1xuICAgIHBhcmtzOiBWZWN0b3JbXVtdID0gW107XG5cbiAgICAvLyBQb2x5bGluZXNcbiAgICBjb2FzdGxpbmU6IFZlY3RvcltdID0gW107XG4gICAgcml2ZXI6IFZlY3RvcltdID0gW107XG4gICAgc2Vjb25kYXJ5Uml2ZXI6IFZlY3RvcltdID0gW107XG4gICAgbWlub3JSb2FkczogVmVjdG9yW11bXSA9IFtdO1xuICAgIG1ham9yUm9hZHM6IFZlY3RvcltdW10gPSBbXTtcbiAgICBtYWluUm9hZHM6IFZlY3RvcltdW10gPSBbXTtcbiAgICBjb2FzdGxpbmVSb2FkczogVmVjdG9yW11bXSA9IFtdO1xuICAgIHNob3dGcmFtZTogYm9vbGVhbjtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBkcmFnQ29udHJvbGxlcjogRHJhZ0NvbnRyb2xsZXIsIHByb3RlY3RlZCBjb2xvdXJTY2hlbWU6IENvbG91clNjaGVtZSkge1xuICAgICAgICBpZiAoIWNvbG91clNjaGVtZS5iZ0NvbG91cikgbG9nLmVycm9yKFwiQ29sb3VyU2NoZW1lIEVycm9yIC0gYmdDb2xvdXIgbm90IGRlZmluZWRcIik7XG4gICAgICAgIGlmICghY29sb3VyU2NoZW1lLnNlYUNvbG91cikgbG9nLmVycm9yKFwiQ29sb3VyU2NoZW1lIEVycm9yIC0gc2VhQ29sb3VyIG5vdCBkZWZpbmVkXCIpO1xuICAgICAgICBpZiAoIWNvbG91clNjaGVtZS5taW5vclJvYWRDb2xvdXIpIGxvZy5lcnJvcihcIkNvbG91clNjaGVtZSBFcnJvciAtIG1pbm9yUm9hZENvbG91ciBub3QgZGVmaW5lZFwiKTtcblxuICAgICAgICAvLyBEZWZhdWx0IGNvbG91cnNjaGVtZSBjYXNjYWRlXG4gICAgICAgIGlmICghY29sb3VyU2NoZW1lLmJnQ29sb3VySW4pIGNvbG91clNjaGVtZS5iZ0NvbG91ckluID0gY29sb3VyU2NoZW1lLmJnQ29sb3VyO1xuICAgICAgICBpZiAoIWNvbG91clNjaGVtZS5idWlsZGluZ0NvbG91cikgY29sb3VyU2NoZW1lLmJ1aWxkaW5nQ29sb3VyID0gY29sb3VyU2NoZW1lLmJnQ29sb3VyO1xuICAgICAgICBpZiAoIWNvbG91clNjaGVtZS5idWlsZGluZ1N0cm9rZSkgY29sb3VyU2NoZW1lLmJ1aWxkaW5nU3Ryb2tlID0gY29sb3VyU2NoZW1lLmJnQ29sb3VyO1xuICAgICAgICBpZiAoIWNvbG91clNjaGVtZS5ncmFzc0NvbG91cikgY29sb3VyU2NoZW1lLmdyYXNzQ29sb3VyID0gY29sb3VyU2NoZW1lLmJnQ29sb3VyO1xuICAgICAgICBpZiAoIWNvbG91clNjaGVtZS5taW5vclJvYWRPdXRsaW5lKSBjb2xvdXJTY2hlbWUubWlub3JSb2FkT3V0bGluZSA9IGNvbG91clNjaGVtZS5taW5vclJvYWRDb2xvdXI7XG4gICAgICAgIGlmICghY29sb3VyU2NoZW1lLm1ham9yUm9hZENvbG91cikgY29sb3VyU2NoZW1lLm1ham9yUm9hZENvbG91ciA9IGNvbG91clNjaGVtZS5taW5vclJvYWRDb2xvdXI7XG4gICAgICAgIGlmICghY29sb3VyU2NoZW1lLm1ham9yUm9hZE91dGxpbmUpIGNvbG91clNjaGVtZS5tYWpvclJvYWRPdXRsaW5lID0gY29sb3VyU2NoZW1lLm1pbm9yUm9hZE91dGxpbmU7XG4gICAgICAgIGlmICghY29sb3VyU2NoZW1lLm1haW5Sb2FkQ29sb3VyKSBjb2xvdXJTY2hlbWUubWFpblJvYWRDb2xvdXIgPSBjb2xvdXJTY2hlbWUubWFqb3JSb2FkQ29sb3VyO1xuICAgICAgICBpZiAoIWNvbG91clNjaGVtZS5tYWluUm9hZE91dGxpbmUpIGNvbG91clNjaGVtZS5tYWluUm9hZE91dGxpbmUgPSBjb2xvdXJTY2hlbWUubWFqb3JSb2FkT3V0bGluZTtcbiAgICAgICAgaWYgKCFjb2xvdXJTY2hlbWUub3V0bGluZVNpemUpIGNvbG91clNjaGVtZS5vdXRsaW5lU2l6ZSA9IDE7XG4gICAgICAgIGlmICghY29sb3VyU2NoZW1lLnpvb21CdWlsZGluZ3MpIGNvbG91clNjaGVtZS56b29tQnVpbGRpbmdzID0gZmFsc2U7XG4gICAgICAgIGlmICghY29sb3VyU2NoZW1lLmJ1aWxkaW5nTW9kZWxzKSBjb2xvdXJTY2hlbWUuYnVpbGRpbmdNb2RlbHMgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFjb2xvdXJTY2hlbWUubWlub3JXaWR0aCkgY29sb3VyU2NoZW1lLm1pbm9yV2lkdGggPSAyO1xuICAgICAgICBpZiAoIWNvbG91clNjaGVtZS5tYWpvcldpZHRoKSBjb2xvdXJTY2hlbWUubWFqb3JXaWR0aCA9IDQ7XG4gICAgICAgIGlmICghY29sb3VyU2NoZW1lLm1haW5XaWR0aCkgY29sb3VyU2NoZW1lLm1haW5XaWR0aCA9IDU7XG4gICAgICAgIGlmICghY29sb3VyU2NoZW1lLm1haW5XaWR0aCkgY29sb3VyU2NoZW1lLm1haW5XaWR0aCA9IDU7XG4gICAgICAgIGlmICghY29sb3VyU2NoZW1lLmZyYW1lQ29sb3VyKSBjb2xvdXJTY2hlbWUuZnJhbWVDb2xvdXIgPSBjb2xvdXJTY2hlbWUuYmdDb2xvdXI7XG4gICAgICAgIGlmICghY29sb3VyU2NoZW1lLmZyYW1lVGV4dENvbG91cikgY29sb3VyU2NoZW1lLmZyYW1lVGV4dENvbG91ciA9IGNvbG91clNjaGVtZS5taW5vclJvYWRPdXRsaW5lO1xuXG4gICAgICAgIGlmICghY29sb3VyU2NoZW1lLmJ1aWxkaW5nU2lkZUNvbG91cikge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkUmdiID0gVXRpbC5wYXJzZUNTU0NvbG9yKGNvbG91clNjaGVtZS5idWlsZGluZ0NvbG91cikubWFwKHYgPT4gTWF0aC5tYXgoMCwgdiAtIDQwKSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkUmdiKSB7XG4gICAgICAgICAgICAgICAgY29sb3VyU2NoZW1lLmJ1aWxkaW5nU2lkZUNvbG91ciA9IGByZ2IoJHtwYXJzZWRSZ2JbMF19LCR7cGFyc2VkUmdiWzFdfSwke3BhcnNlZFJnYlsyXX0pYDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29sb3VyU2NoZW1lLmJ1aWxkaW5nU2lkZUNvbG91ciA9IGNvbG91clNjaGVtZS5idWlsZGluZ0NvbG91cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldCB6b29tQnVpbGRpbmdzKGI6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5jb2xvdXJTY2hlbWUuem9vbUJ1aWxkaW5ncyA9IGI7XG4gICAgfVxuXG4gICAgc2V0IHNob3dCdWlsZGluZ01vZGVscyhiOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuY29sb3VyU2NoZW1lLmJ1aWxkaW5nTW9kZWxzID0gYjtcbiAgICB9XG5cbiAgICBnZXQgc2hvd0J1aWxkaW5nTW9kZWxzKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xvdXJTY2hlbWUuYnVpbGRpbmdNb2RlbHM7XG4gICAgfVxuXG4gICAgc2V0IGNhbnZhc1NjYWxlKHNjYWxlOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuY2FudmFzU2NhbGUgPSBzY2FsZTtcbiAgICB9XG5cbiAgICBnZXQgbmVlZHNVcGRhdGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5uZWVkc1VwZGF0ZTtcbiAgICB9XG5cbiAgICBzZXQgbmVlZHNVcGRhdGUobjogYm9vbGVhbikge1xuICAgICAgICB0aGlzLmNhbnZhcy5uZWVkc1VwZGF0ZSA9IG47XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgRGVmYXVsdFN0eWxlIGV4dGVuZHMgU3R5bGUge1xuICAgIGNvbnN0cnVjdG9yKGM6IEhUTUxDYW52YXNFbGVtZW50LCBkcmFnQ29udHJvbGxlcjogRHJhZ0NvbnRyb2xsZXIsIGNvbG91clNjaGVtZTogQ29sb3VyU2NoZW1lLCBwcml2YXRlIGhlaWdodG1hcD10cnVlKSB7XG4gICAgICAgIHN1cGVyKGRyYWdDb250cm9sbGVyLCBjb2xvdXJTY2hlbWUpO1xuICAgICAgICB0aGlzLmNhbnZhcyA9IHRoaXMuY3JlYXRlQ2FudmFzV3JhcHBlcihjLCAxLCB0cnVlKTtcbiAgICB9XG5cbiAgICBjcmVhdGVDYW52YXNXcmFwcGVyKGM6IEhUTUxDYW52YXNFbGVtZW50LCBzY2FsZT0xLCByZXNpemVUb1dpbmRvdz10cnVlKTogQ2FudmFzV3JhcHBlciB7XG4gICAgICAgIHJldHVybiBuZXcgRGVmYXVsdENhbnZhc1dyYXBwZXIoYywgc2NhbGUsIHJlc2l6ZVRvV2luZG93KTtcbiAgICB9XG5cbiAgICBkcmF3KGNhbnZhcz10aGlzLmNhbnZhcyBhcyBEZWZhdWx0Q2FudmFzV3JhcHBlcik6IHZvaWQge1xuICAgICAgICBsZXQgYmdDb2xvdXI7XG4gICAgICAgIGlmICh0aGlzLmNvbG91clNjaGVtZS56b29tQnVpbGRpbmdzKSB7XG4gICAgICAgICAgICBiZ0NvbG91ciA9IHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tID49IDIgPyB0aGlzLmNvbG91clNjaGVtZS5iZ0NvbG91ckluIDogdGhpcy5jb2xvdXJTY2hlbWUuYmdDb2xvdXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiZ0NvbG91ciA9IHRoaXMuY29sb3VyU2NoZW1lLmJnQ29sb3VyO1xuICAgICAgICB9XG4gICAgICAgIFxuXG4gICAgICAgIGNhbnZhcy5zZXRGaWxsU3R5bGUoYmdDb2xvdXIpO1xuICAgICAgICBjYW52YXMuY2xlYXJDYW52YXMoKTtcblxuICAgICAgICAvLyBTZWFcbiAgICAgICAgY2FudmFzLnNldEZpbGxTdHlsZSh0aGlzLmNvbG91clNjaGVtZS5zZWFDb2xvdXIpO1xuICAgICAgICBjYW52YXMuc2V0U3Ryb2tlU3R5bGUodGhpcy5jb2xvdXJTY2hlbWUuc2VhQ29sb3VyKTtcbiAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCgwLjEpO1xuICAgICAgICBjYW52YXMuZHJhd1BvbHlnb24odGhpcy5zZWFQb2x5Z29uKTtcblxuICAgICAgICAvLyBDb2FzdGxpbmVcbiAgICAgICAgY2FudmFzLnNldFN0cm9rZVN0eWxlKGJnQ29sb3VyKTtcbiAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCgzMCAqIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tKTtcbiAgICAgICAgY2FudmFzLmRyYXdQb2x5bGluZSh0aGlzLmNvYXN0bGluZSk7XG5cbiAgICAgICAgLy8gUGFya3NcbiAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCgxKTtcbiAgICAgICAgY2FudmFzLnNldEZpbGxTdHlsZSh0aGlzLmNvbG91clNjaGVtZS5ncmFzc0NvbG91cik7XG4gICAgICAgIGZvciAoY29uc3QgcCBvZiB0aGlzLnBhcmtzKSBjYW52YXMuZHJhd1BvbHlnb24ocCk7XG5cbiAgICAgICAgLy8gUml2ZXJcbiAgICAgICAgY2FudmFzLnNldEZpbGxTdHlsZSh0aGlzLmNvbG91clNjaGVtZS5zZWFDb2xvdXIpO1xuICAgICAgICBjYW52YXMuc2V0U3Ryb2tlU3R5bGUodGhpcy5jb2xvdXJTY2hlbWUuc2VhQ29sb3VyKTtcbiAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCgxKTtcbiAgICAgICAgY2FudmFzLmRyYXdQb2x5Z29uKHRoaXMucml2ZXIpO1xuXG4gICAgICAgIC8vIFJvYWQgb3V0bGluZVxuICAgICAgICBjYW52YXMuc2V0U3Ryb2tlU3R5bGUodGhpcy5jb2xvdXJTY2hlbWUubWlub3JSb2FkT3V0bGluZSk7XG4gICAgICAgIGNhbnZhcy5zZXRMaW5lV2lkdGgodGhpcy5jb2xvdXJTY2hlbWUub3V0bGluZVNpemUgKyB0aGlzLmNvbG91clNjaGVtZS5taW5vcldpZHRoICogdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20pO1xuICAgICAgICBmb3IgKGNvbnN0IHMgb2YgdGhpcy5taW5vclJvYWRzKSBjYW52YXMuZHJhd1BvbHlsaW5lKHMpO1xuXG4gICAgICAgIGNhbnZhcy5zZXRTdHJva2VTdHlsZSh0aGlzLmNvbG91clNjaGVtZS5tYWpvclJvYWRPdXRsaW5lKTtcbiAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCh0aGlzLmNvbG91clNjaGVtZS5vdXRsaW5lU2l6ZSArIHRoaXMuY29sb3VyU2NoZW1lLm1ham9yV2lkdGggKiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSk7XG4gICAgICAgIGZvciAoY29uc3QgcyBvZiB0aGlzLm1ham9yUm9hZHMpIGNhbnZhcy5kcmF3UG9seWxpbmUocyk7XG4gICAgICAgIGNhbnZhcy5kcmF3UG9seWxpbmUodGhpcy5zZWNvbmRhcnlSaXZlcik7XG5cbiAgICAgICAgY2FudmFzLnNldFN0cm9rZVN0eWxlKHRoaXMuY29sb3VyU2NoZW1lLm1haW5Sb2FkT3V0bGluZSk7XG4gICAgICAgIGNhbnZhcy5zZXRMaW5lV2lkdGgodGhpcy5jb2xvdXJTY2hlbWUub3V0bGluZVNpemUgKyB0aGlzLmNvbG91clNjaGVtZS5tYWluV2lkdGggKiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSk7XG4gICAgICAgIGZvciAoY29uc3QgcyBvZiB0aGlzLm1haW5Sb2FkcykgY2FudmFzLmRyYXdQb2x5bGluZShzKTtcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIHRoaXMuY29hc3RsaW5lUm9hZHMpIGNhbnZhcy5kcmF3UG9seWxpbmUocyk7XG5cbiAgICAgICAgLy8gUm9hZCBpbmxpbmVcbiAgICAgICAgY2FudmFzLnNldFN0cm9rZVN0eWxlKHRoaXMuY29sb3VyU2NoZW1lLm1pbm9yUm9hZENvbG91cik7XG4gICAgICAgIGNhbnZhcy5zZXRMaW5lV2lkdGgodGhpcy5jb2xvdXJTY2hlbWUubWlub3JXaWR0aCAqIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tKTtcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIHRoaXMubWlub3JSb2FkcykgY2FudmFzLmRyYXdQb2x5bGluZShzKTtcblxuICAgICAgICBjYW52YXMuc2V0U3Ryb2tlU3R5bGUodGhpcy5jb2xvdXJTY2hlbWUubWFqb3JSb2FkQ29sb3VyKTtcbiAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCh0aGlzLmNvbG91clNjaGVtZS5tYWpvcldpZHRoICogdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20pO1xuICAgICAgICBmb3IgKGNvbnN0IHMgb2YgdGhpcy5tYWpvclJvYWRzKSBjYW52YXMuZHJhd1BvbHlsaW5lKHMpO1xuICAgICAgICBjYW52YXMuZHJhd1BvbHlsaW5lKHRoaXMuc2Vjb25kYXJ5Uml2ZXIpO1xuXG4gICAgICAgIGNhbnZhcy5zZXRTdHJva2VTdHlsZSh0aGlzLmNvbG91clNjaGVtZS5tYWluUm9hZENvbG91cik7XG4gICAgICAgIGNhbnZhcy5zZXRMaW5lV2lkdGgodGhpcy5jb2xvdXJTY2hlbWUubWFpbldpZHRoICogdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20pO1xuICAgICAgICBmb3IgKGNvbnN0IHMgb2YgdGhpcy5tYWluUm9hZHMpIGNhbnZhcy5kcmF3UG9seWxpbmUocyk7XG4gICAgICAgIGZvciAoY29uc3QgcyBvZiB0aGlzLmNvYXN0bGluZVJvYWRzKSBjYW52YXMuZHJhd1BvbHlsaW5lKHMpO1xuXG5cbiAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCgxKTtcblxuICAgICAgICBpZiAodGhpcy5oZWlnaHRtYXApIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYiBvZiB0aGlzLmJ1aWxkaW5nTW9kZWxzKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29sb3VyIGJhc2VkIG9uIGhlaWdodFxuXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkUmdiID0gVXRpbC5wYXJzZUNTU0NvbG9yKHRoaXMuY29sb3VyU2NoZW1lLmJnQ29sb3VyKS5tYXAodiA9PiBNYXRoLm1pbigyNTUsIHYgKyAoYi5oZWlnaHQgKiAzLjUpKSk7XG4gICAgICAgICAgICAgICAgY2FudmFzLnNldEZpbGxTdHlsZShgcmdiKCR7cGFyc2VkUmdiWzBdfSwke3BhcnNlZFJnYlsxXX0sJHtwYXJzZWRSZ2JbMl19KWApO1xuICAgICAgICAgICAgICAgIGNhbnZhcy5zZXRTdHJva2VTdHlsZShgcmdiKCR7cGFyc2VkUmdiWzBdfSwke3BhcnNlZFJnYlsxXX0sJHtwYXJzZWRSZ2JbMl19KWApO1xuICAgICAgICAgICAgICAgIGNhbnZhcy5kcmF3UG9seWdvbihiLmxvdFNjcmVlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBCdWlsZGluZ3NcbiAgICAgICAgICAgIGlmICghdGhpcy5jb2xvdXJTY2hlbWUuem9vbUJ1aWxkaW5ncyB8fCB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSA+PSAyKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzLnNldEZpbGxTdHlsZSh0aGlzLmNvbG91clNjaGVtZS5idWlsZGluZ0NvbG91cik7XG4gICAgICAgICAgICAgICAgY2FudmFzLnNldFN0cm9rZVN0eWxlKHRoaXMuY29sb3VyU2NoZW1lLmJ1aWxkaW5nU3Ryb2tlKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGIgb2YgdGhpcy5sb3RzKSBjYW52YXMuZHJhd1BvbHlnb24oYik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFBzZXVkby0zRFxuICAgICAgICAgICAgaWYgKHRoaXMuY29sb3VyU2NoZW1lLmJ1aWxkaW5nTW9kZWxzICYmICghdGhpcy5jb2xvdXJTY2hlbWUuem9vbUJ1aWxkaW5ncyB8fCB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSA+PSAyLjUpKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzLnNldEZpbGxTdHlsZSh0aGlzLmNvbG91clNjaGVtZS5idWlsZGluZ1NpZGVDb2xvdXIpO1xuICAgICAgICAgICAgICAgIGNhbnZhcy5zZXRTdHJva2VTdHlsZSh0aGlzLmNvbG91clNjaGVtZS5idWlsZGluZ1NpZGVDb2xvdXIpO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGNoZWFwIGFwcHJveGltYXRpb24gdGhhdCBvZnRlbiBjcmVhdGVzIHZpc3VhbCBhcnRlZmFjdHNcbiAgICAgICAgICAgICAgICAvLyBEcmF3cyBidWlsZGluZyBzaWRlcywgdGhlbiByb292ZXMgaW5zdGVhZCBvZiBwcm9wZXJseSBjbGlwcGluZyBwb2x5Z29ucyBldGMuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBiIG9mIHRoaXMuYnVpbGRpbmdNb2RlbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzIG9mIGIuc2lkZXMpIGNhbnZhcy5kcmF3UG9seWdvbihzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FudmFzLnNldEZpbGxTdHlsZSh0aGlzLmNvbG91clNjaGVtZS5idWlsZGluZ0NvbG91cik7XG4gICAgICAgICAgICAgICAgY2FudmFzLnNldFN0cm9rZVN0eWxlKHRoaXMuY29sb3VyU2NoZW1lLmJ1aWxkaW5nU3Ryb2tlKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGIgb2YgdGhpcy5idWlsZGluZ01vZGVscykgY2FudmFzLmRyYXdQb2x5Z29uKGIucm9vZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zaG93RnJhbWUpIHtcbiAgICAgICAgICAgIGNhbnZhcy5zZXRGaWxsU3R5bGUodGhpcy5jb2xvdXJTY2hlbWUuZnJhbWVDb2xvdXIpO1xuICAgICAgICAgICAgY2FudmFzLnNldFN0cm9rZVN0eWxlKHRoaXMuY29sb3VyU2NoZW1lLmZyYW1lQ29sb3VyKTtcbiAgICAgICAgICAgIGNhbnZhcy5kcmF3RnJhbWUoMzAsIDMwLCAzMCwgMzApO1xuXG4gICAgICAgICAgICAvLyBjYW52YXMuc2V0RmlsbFN0eWxlKHRoaXMuY29sb3VyU2NoZW1lLmZyYW1lVGV4dENvbG91cik7XG4gICAgICAgICAgICAvLyBjYW52YXMuZHJhd0NpdHlOYW1lKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBSb3VnaFN0eWxlIGV4dGVuZHMgU3R5bGUge1xuICAgIGRyYWdnaW5nID0gZmFsc2U7XG5cbiAgICBjb25zdHJ1Y3RvcihjOiBIVE1MQ2FudmFzRWxlbWVudCwgZHJhZ0NvbnRyb2xsZXI6IERyYWdDb250cm9sbGVyLCBjb2xvdXJTY2hlbWU6IENvbG91clNjaGVtZSkge1xuICAgICAgICBzdXBlcihkcmFnQ29udHJvbGxlciwgY29sb3VyU2NoZW1lKTtcbiAgICAgICAgdGhpcy5jYW52YXMgPSB0aGlzLmNyZWF0ZUNhbnZhc1dyYXBwZXIoYywgMSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgY3JlYXRlQ2FudmFzV3JhcHBlcihjOiBIVE1MQ2FudmFzRWxlbWVudCwgc2NhbGU9MSwgcmVzaXplVG9XaW5kb3c9dHJ1ZSk6IENhbnZhc1dyYXBwZXIge1xuICAgICAgICByZXR1cm4gbmV3IFJvdWdoQ2FudmFzV3JhcHBlcihjLCBzY2FsZSwgcmVzaXplVG9XaW5kb3cpO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgY29uc3QgZHJhZ2dpbmcgPSB0aGlzLmRyYWdDb250cm9sbGVyLmlzRHJhZ2dpbmcgfHwgdGhpcy5kb21haW5Db250cm9sbGVyLmlzU2Nyb2xsaW5nO1xuICAgICAgICBpZiAoIWRyYWdnaW5nICYmIHRoaXMuZHJhZ2dpbmcpIHRoaXMuY2FudmFzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGRyYWdnaW5nO1xuICAgIH1cblxuICAgIGRyYXcoY2FudmFzPXRoaXMuY2FudmFzIGFzIFJvdWdoQ2FudmFzV3JhcHBlcik6IHZvaWQge1xuICAgICAgICBjYW52YXMuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICBmaWxsOiB0aGlzLmNvbG91clNjaGVtZS5iZ0NvbG91cixcbiAgICAgICAgICAgIHJvdWdobmVzczogMSxcbiAgICAgICAgICAgIGJvd2luZzogMSxcbiAgICAgICAgICAgIGZpbGxTdHlsZTogJ3NvbGlkJyxcbiAgICAgICAgICAgIHN0cm9rZTogXCJub25lXCIsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNhbnZhcy5jbGVhckNhbnZhcygpO1xuXG4gICAgICAgIC8vIFNlYVxuICAgICAgICBjYW52YXMuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICByb3VnaG5lc3M6IDAsXG4gICAgICAgICAgICBmaWxsV2VpZ2h0OiAxLFxuICAgICAgICAgICAgZmlsbDogdGhpcy5jb2xvdXJTY2hlbWUuc2VhQ29sb3VyLFxuICAgICAgICAgICAgZmlsbFN0eWxlOiAnc29saWQnLFxuICAgICAgICAgICAgc3Ryb2tlOiBcIm5vbmVcIixcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICB9KTtcblxuICAgICAgICBjYW52YXMuZHJhd1BvbHlnb24odGhpcy5zZWFQb2x5Z29uKTtcblxuICAgICAgICBjYW52YXMuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICBzdHJva2U6IHRoaXMuY29sb3VyU2NoZW1lLmJnQ29sb3VyLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDMwLFxuICAgICAgICB9KTtcbiAgICAgICAgY2FudmFzLmRyYXdQb2x5bGluZSh0aGlzLmNvYXN0bGluZSk7XG5cbiAgICAgICAgY2FudmFzLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgcm91Z2huZXNzOiAwLFxuICAgICAgICAgICAgZmlsbFdlaWdodDogMSxcbiAgICAgICAgICAgIGZpbGw6IHRoaXMuY29sb3VyU2NoZW1lLnNlYUNvbG91cixcbiAgICAgICAgICAgIGZpbGxTdHlsZTogJ3NvbGlkJyxcbiAgICAgICAgICAgIHN0cm9rZTogXCJub25lXCIsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2FudmFzLmRyYXdQb2x5Z29uKHRoaXMucml2ZXIpO1xuXG4gICAgICAgIC8vIFBhcmtzXG4gICAgICAgIGNhbnZhcy5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgIGZpbGw6IHRoaXMuY29sb3VyU2NoZW1lLmdyYXNzQ29sb3VyLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wYXJrcy5mb3JFYWNoKHAgPT4gY2FudmFzLmRyYXdQb2x5Z29uKHApKTtcblxuICAgICAgICAvLyBSb2Fkc1xuICAgICAgICBjYW52YXMuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICBzdHJva2U6IHRoaXMuY29sb3VyU2NoZW1lLm1pbm9yUm9hZENvbG91cixcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm1pbm9yUm9hZHMuZm9yRWFjaChzID0+IGNhbnZhcy5kcmF3UG9seWxpbmUocykpO1xuXG4gICAgICAgIGNhbnZhcy5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgICAgICAgICAgc3Ryb2tlOiB0aGlzLmNvbG91clNjaGVtZS5tYWpvclJvYWRDb2xvdXIsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubWFqb3JSb2Fkcy5mb3JFYWNoKHMgPT4gY2FudmFzLmRyYXdQb2x5bGluZShzKSk7XG4gICAgICAgIGNhbnZhcy5kcmF3UG9seWxpbmUodGhpcy5zZWNvbmRhcnlSaXZlcik7XG5cbiAgICAgICAgY2FudmFzLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDMsXG4gICAgICAgICAgICBzdHJva2U6IHRoaXMuY29sb3VyU2NoZW1lLm1haW5Sb2FkQ29sb3VyLFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm1haW5Sb2Fkcy5mb3JFYWNoKHMgPT4gY2FudmFzLmRyYXdQb2x5bGluZShzKSk7XG4gICAgICAgIHRoaXMuY29hc3RsaW5lUm9hZHMuZm9yRWFjaChzID0+IGNhbnZhcy5kcmF3UG9seWxpbmUocykpO1xuXG4gICAgICAgIC8vIEJ1aWxkaW5nc1xuICAgICAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIC8vIExvdHNcbiAgICAgICAgICAgIGlmICghdGhpcy5jb2xvdXJTY2hlbWUuem9vbUJ1aWxkaW5ncyB8fCB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSA+PSAyKSB7XG4gICAgICAgICAgICAgICAgLy8gTG90c1xuICAgICAgICAgICAgICAgIGNhbnZhcy5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgICAgICAgICAgcm91Z2huZXNzOiAxLjIsXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogdGhpcy5jb2xvdXJTY2hlbWUuYnVpbGRpbmdTdHJva2UsXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiAnJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGIgb2YgdGhpcy5sb3RzKSBjYW52YXMuZHJhd1BvbHlnb24oYik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFBzZXVkby0zRFxuICAgICAgICAgICAgaWYgKHRoaXMuY29sb3VyU2NoZW1lLmJ1aWxkaW5nTW9kZWxzICYmICghdGhpcy5jb2xvdXJTY2hlbWUuem9vbUJ1aWxkaW5ncyB8fCB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSA+PSAyLjUpKSB7XG4gICAgICAgICAgICAgICAgLy8gUHNldWRvLTNEXG4gICAgICAgICAgICAgICAgY2FudmFzLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgICAgICAgICByb3VnaG5lc3M6IDEuMixcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiB0aGlzLmNvbG91clNjaGVtZS5idWlsZGluZ1N0cm9rZSxcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IHRoaXMuY29sb3VyU2NoZW1lLmJ1aWxkaW5nU2lkZUNvbG91cixcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBjYW4gYmUgaHVnZWx5IGltcHJvdmVkXG4gICAgICAgICAgICAgICAgY29uc3QgYWxsU2lkZXNEaXN0YW5jZXM6IGFueVtdID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgY2FtZXJhID0gdGhpcy5kb21haW5Db250cm9sbGVyLmdldENhbWVyYVBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBiIG9mIHRoaXMuYnVpbGRpbmdNb2RlbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzIG9mIGIuc2lkZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF2ZXJhZ2VQb2ludCA9IHNbMF0uY2xvbmUoKS5hZGQoc1sxXSkuZGl2aWRlU2NhbGFyKDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsU2lkZXNEaXN0YW5jZXMucHVzaChbYXZlcmFnZVBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKGNhbWVyYSksIHNdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbGxTaWRlc0Rpc3RhbmNlcy5zb3J0KChhLCBiKSA9PiBiWzBdIC0gYVswXSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwIG9mIGFsbFNpZGVzRGlzdGFuY2VzKSBjYW52YXMuZHJhd1BvbHlnb24ocFsxXSk7XG5cbiAgICAgICAgICAgICAgICBjYW52YXMuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgICAgIHJvdWdobmVzczogMS4yLFxuICAgICAgICAgICAgICAgICAgICBzdHJva2U6IHRoaXMuY29sb3VyU2NoZW1lLmJ1aWxkaW5nU3Ryb2tlLFxuICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogdGhpcy5jb2xvdXJTY2hlbWUuYnVpbGRpbmdDb2xvdXIsXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGIgb2YgdGhpcy5idWlsZGluZ01vZGVscykgY2FudmFzLmRyYXdQb2x5Z29uKGIucm9vZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IHtEZWZhdWx0Q2FudmFzV3JhcHBlcn0gZnJvbSAnLi9jYW52YXNfd3JhcHBlcic7XG5pbXBvcnQgRG9tYWluQ29udHJvbGxlciBmcm9tICcuL2RvbWFpbl9jb250cm9sbGVyJztcbmltcG9ydCBEcmFnQ29udHJvbGxlciBmcm9tICcuL2RyYWdfY29udHJvbGxlcic7XG5pbXBvcnQgVGVuc29yRmllbGQgZnJvbSAnLi4vaW1wbC90ZW5zb3JfZmllbGQnO1xuaW1wb3J0IHtOb2lzZVBhcmFtc30gZnJvbSAnLi4vaW1wbC90ZW5zb3JfZmllbGQnO1xuaW1wb3J0IHtCYXNpc0ZpZWxkLCBGSUVMRF9UWVBFfSBmcm9tICcuLi9pbXBsL2Jhc2lzX2ZpZWxkJztcbmltcG9ydCBVdGlsIGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xuXG4vKipcbiAqIEV4dGVuc2lvbiBvZiBUZW5zb3JGaWVsZCB0aGF0IGhhbmRsZXMgaW50ZXJhY3Rpb24gd2l0aCBkYXQuR1VJXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlbnNvckZpZWxkR1VJIGV4dGVuZHMgVGVuc29yRmllbGQge1xuICAgIHByaXZhdGUgVEVOU09SX0xJTkVfRElBTUVURVIgPSAyMDtcbiAgICBwcml2YXRlIFRFTlNPUl9TUEFXTl9TQ0FMRSA9IDAuNzsgIC8vIEhvdyBtdWNoIHRvIHNocmluayB3b3JsZERpbWVuc2lvbnMgdG8gZmluZCBzcGF3biBwb2ludFxuICAgIHByaXZhdGUgZG9tYWluQ29udHJvbGxlciA9IERvbWFpbkNvbnRyb2xsZXIuZ2V0SW5zdGFuY2UoKTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZ3VpRm9sZGVyOiBkYXQuR1VJLCBwcml2YXRlIGRyYWdDb250cm9sbGVyOiBEcmFnQ29udHJvbGxlcixcbiAgICAgICAgcHVibGljIGRyYXdDZW50cmU6IGJvb2xlYW4sIG5vaXNlUGFyYW1zOiBOb2lzZVBhcmFtcykge1xuICAgICAgICBzdXBlcihub2lzZVBhcmFtcyk7XG4gICAgICAgIC8vIEZvciBjdXN0b20gbmFtaW5nIG9mIGd1aSBidXR0b25zXG4gICAgICAgIGNvbnN0IHRlbnNvckZpZWxkR3VpT2JqID0ge1xuICAgICAgICAgICAgcmVzZXQ6ICgpOiB2b2lkID0+IHRoaXMucmVzZXQoKSxcbiAgICAgICAgICAgIHNldFJlY29tbWVuZGVkOiAoKTogdm9pZCA9PiB0aGlzLnNldFJlY29tbWVuZGVkKCksXG4gICAgICAgICAgICBhZGRSYWRpYWw6ICgpOiB2b2lkID0+IHRoaXMuYWRkUmFkaWFsUmFuZG9tKCksXG4gICAgICAgICAgICBhZGRHcmlkOiAoKTogdm9pZCA9PiB0aGlzLmFkZEdyaWRSYW5kb20oKSxcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmd1aUZvbGRlci5hZGQodGVuc29yRmllbGRHdWlPYmosICdyZXNldCcpO1xuICAgICAgICB0aGlzLmd1aUZvbGRlci5hZGQodGhpcywgJ3Ntb290aCcpO1xuICAgICAgICB0aGlzLmd1aUZvbGRlci5hZGQodGVuc29yRmllbGRHdWlPYmosICdzZXRSZWNvbW1lbmRlZCcpO1xuICAgICAgICB0aGlzLmd1aUZvbGRlci5hZGQodGVuc29yRmllbGRHdWlPYmosICdhZGRSYWRpYWwnKTtcbiAgICAgICAgdGhpcy5ndWlGb2xkZXIuYWRkKHRlbnNvckZpZWxkR3VpT2JqLCAnYWRkR3JpZCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIDQgR3JpZHMsIG9uZSByYWRpYWxcbiAgICAgKi9cbiAgICBzZXRSZWNvbW1lbmRlZCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkRGltZW5zaW9ucy5tdWx0aXBseVNjYWxhcih0aGlzLlRFTlNPUl9TUEFXTl9TQ0FMRSk7XG4gICAgICAgIGNvbnN0IG5ld09yaWdpbiA9IHRoaXMuZG9tYWluQ29udHJvbGxlci53b3JsZERpbWVuc2lvbnNcbiAgICAgICAgICAgIC5tdWx0aXBseVNjYWxhcigoMSAtIHRoaXMuVEVOU09SX1NQQVdOX1NDQUxFKSAvIDIpXG4gICAgICAgICAgICAuYWRkKHRoaXMuZG9tYWluQ29udHJvbGxlci5vcmlnaW4pO1xuICAgICAgICB0aGlzLmFkZEdyaWRBdExvY2F0aW9uKG5ld09yaWdpbik7XG4gICAgICAgIHRoaXMuYWRkR3JpZEF0TG9jYXRpb24obmV3T3JpZ2luLmNsb25lKCkuYWRkKHNpemUpKTtcbiAgICAgICAgdGhpcy5hZGRHcmlkQXRMb2NhdGlvbihuZXdPcmlnaW4uY2xvbmUoKS5hZGQobmV3IFZlY3RvcihzaXplLngsIDApKSk7XG4gICAgICAgIHRoaXMuYWRkR3JpZEF0TG9jYXRpb24obmV3T3JpZ2luLmNsb25lKCkuYWRkKG5ldyBWZWN0b3IoMCwgc2l6ZS55KSkpO1xuICAgICAgICB0aGlzLmFkZFJhZGlhbFJhbmRvbSgpO1xuICAgIH1cblxuICAgIGFkZFJhZGlhbFJhbmRvbSgpOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGREaW1lbnNpb25zLng7XG4gICAgICAgIHRoaXMuYWRkUmFkaWFsKHRoaXMucmFuZG9tTG9jYXRpb24oKSxcbiAgICAgICAgICAgIFV0aWwucmFuZG9tUmFuZ2Uod2lkdGggLyAxMCwgd2lkdGggLyA1KSwgIC8vIFNpemVcbiAgICAgICAgICAgIFV0aWwucmFuZG9tUmFuZ2UoNTApKTsgIC8vIERlY2F5XG4gICAgfVxuXG4gICAgYWRkR3JpZFJhbmRvbSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5hZGRHcmlkQXRMb2NhdGlvbih0aGlzLnJhbmRvbUxvY2F0aW9uKCkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgYWRkR3JpZEF0TG9jYXRpb24obG9jYXRpb246IFZlY3Rvcik6IHZvaWQge1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZG9tYWluQ29udHJvbGxlci53b3JsZERpbWVuc2lvbnMueDtcbiAgICAgICAgdGhpcy5hZGRHcmlkKGxvY2F0aW9uLFxuICAgICAgICAgICAgVXRpbC5yYW5kb21SYW5nZSh3aWR0aCAvIDQsIHdpZHRoKSwgIC8vIFNpemVcbiAgICAgICAgICAgIFV0aWwucmFuZG9tUmFuZ2UoNTApLCAgLy8gRGVjYXlcbiAgICAgICAgICAgIFV0aWwucmFuZG9tUmFuZ2UoTWF0aC5QSSAvIDIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXb3JsZC1zcGFjZSByYW5kb20gbG9jYXRpb24gZm9yIHRlbnNvciBmaWVsZCBzcGF3blxuICAgICAqIFNhbXBsZWQgZnJvbSBtaWRkbGUgb2Ygc2NyZWVuIChzaHJ1bmsgcmVjdGFuZ2xlKVxuICAgICAqL1xuICAgIHByaXZhdGUgcmFuZG9tTG9jYXRpb24oKTogVmVjdG9yIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuZG9tYWluQ29udHJvbGxlci53b3JsZERpbWVuc2lvbnMubXVsdGlwbHlTY2FsYXIodGhpcy5URU5TT1JfU1BBV05fU0NBTEUpO1xuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IG5ldyBWZWN0b3IoTWF0aC5yYW5kb20oKSwgTWF0aC5yYW5kb20oKSkubXVsdGlwbHkoc2l6ZSk7XG4gICAgICAgIGNvbnN0IG5ld09yaWdpbiA9IHRoaXMuZG9tYWluQ29udHJvbGxlci53b3JsZERpbWVuc2lvbnMubXVsdGlwbHlTY2FsYXIoKDEgLSB0aGlzLlRFTlNPUl9TUEFXTl9TQ0FMRSkgLyAyKTtcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uLmFkZCh0aGlzLmRvbWFpbkNvbnRyb2xsZXIub3JpZ2luKS5hZGQobmV3T3JpZ2luKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldENyb3NzTG9jYXRpb25zKCk6IFZlY3RvcltdIHtcbiAgICAgICAgLy8gR2V0cyBncmlkIG9mIHBvaW50cyBmb3IgdmVjdG9yIGZpZWxkIHZpcyBpbiB3b3JsZCBzcGFjZVxuICAgICAgICBjb25zdCBkaWFtZXRlciA9IHRoaXMuVEVOU09SX0xJTkVfRElBTUVURVIgLyB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbTtcbiAgICAgICAgY29uc3Qgd29ybGREaW1lbnNpb25zID0gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkRGltZW5zaW9ucztcbiAgICAgICAgY29uc3QgbkhvciA9IE1hdGguY2VpbCh3b3JsZERpbWVuc2lvbnMueCAvIGRpYW1ldGVyKSArIDE7IC8vIFByZXZlbnQgcG9wLWluXG4gICAgICAgIGNvbnN0IG5WZXIgPSBNYXRoLmNlaWwod29ybGREaW1lbnNpb25zLnkgLyBkaWFtZXRlcikgKyAxO1xuICAgICAgICBjb25zdCBvcmlnaW5YID0gZGlhbWV0ZXIgKiBNYXRoLmZsb29yKHRoaXMuZG9tYWluQ29udHJvbGxlci5vcmlnaW4ueCAvIGRpYW1ldGVyKTtcbiAgICAgICAgY29uc3Qgb3JpZ2luWSA9IGRpYW1ldGVyICogTWF0aC5mbG9vcih0aGlzLmRvbWFpbkNvbnRyb2xsZXIub3JpZ2luLnkgLyBkaWFtZXRlcik7XG5cbiAgICAgICAgY29uc3Qgb3V0ID0gW107XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDw9IG5Ib3I7IHgrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPD0gblZlcjsgeSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2gobmV3IFZlY3RvcihvcmlnaW5YICsgKHggKiBkaWFtZXRlciksIG9yaWdpblkgKyAoeSAqIGRpYW1ldGVyKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFRlbnNvckxpbmUocG9pbnQ6IFZlY3RvciwgdGVuc29yVjogVmVjdG9yKTogVmVjdG9yW10ge1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFBvaW50ID0gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkVG9TY3JlZW4ocG9pbnQuY2xvbmUoKSk7XG5cbiAgICAgICAgY29uc3QgZGlmZiA9IHRlbnNvclYubXVsdGlwbHlTY2FsYXIodGhpcy5URU5TT1JfTElORV9ESUFNRVRFUiAvIDIpOyAgLy8gQXNzdW1lcyBub3JtYWxpc2VkXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdHJhbnNmb3JtZWRQb2ludC5jbG9uZSgpLnN1YihkaWZmKTtcbiAgICAgICAgY29uc3QgZW5kID0gdHJhbnNmb3JtZWRQb2ludC5jbG9uZSgpLmFkZChkaWZmKTtcbiAgICAgICAgcmV0dXJuIFtzdGFydCwgZW5kXTtcbiAgICB9XG5cbiAgICBkcmF3KGNhbnZhczogRGVmYXVsdENhbnZhc1dyYXBwZXIpOiB2b2lkIHtcbiAgICAgICAgLy8gRHJhdyB0ZW5zb3IgZmllbGRcbiAgICAgICAgY2FudmFzLnNldEZpbGxTdHlsZSgnYmxhY2snKTtcbiAgICAgICAgY2FudmFzLmNsZWFyQ2FudmFzKCk7XG5cbiAgICAgICAgY2FudmFzLnNldFN0cm9rZVN0eWxlKCd3aGl0ZScpO1xuICAgICAgICBjYW52YXMuc2V0TGluZVdpZHRoKDEpO1xuICAgICAgICBjb25zdCB0ZW5zb3JQb2ludHMgPSB0aGlzLmdldENyb3NzTG9jYXRpb25zKCk7XG4gICAgICAgIHRlbnNvclBvaW50cy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICAgICAgY29uc3QgdCA9IHRoaXMuc2FtcGxlUG9pbnQocCk7XG4gICAgICAgICAgICBjYW52YXMuZHJhd1BvbHlsaW5lKHRoaXMuZ2V0VGVuc29yTGluZShwLCB0LmdldE1ham9yKCkpKTtcbiAgICAgICAgICAgIGNhbnZhcy5kcmF3UG9seWxpbmUodGhpcy5nZXRUZW5zb3JMaW5lKHAsIHQuZ2V0TWlub3IoKSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBEcmF3IGNlbnRyZSBwb2ludHMgb2YgZmllbGRzXG4gICAgICAgIGlmICh0aGlzLmRyYXdDZW50cmUpIHtcbiAgICAgICAgICAgIGNhbnZhcy5zZXRGaWxsU3R5bGUoJ3JlZCcpO1xuICAgICAgICAgICAgdGhpcy5nZXRCYXNpc0ZpZWxkcygpLmZvckVhY2goZmllbGQgPT4gXG4gICAgICAgICAgICAgICAgZmllbGQuRklFTERfVFlQRSA9PT0gRklFTERfVFlQRS5HcmlkID9cbiAgICAgICAgICAgICAgICBjYW52YXMuZHJhd1NxdWFyZSh0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGRUb1NjcmVlbihmaWVsZC5jZW50cmUpLCA3KSA6XG4gICAgICAgICAgICAgICAgY2FudmFzLmRyYXdDaXJjbGUodGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkVG9TY3JlZW4oZmllbGQuY2VudHJlKSwgNykpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgYWRkRmllbGQoZmllbGQ6IEJhc2lzRmllbGQpOiB2b2lkIHtcbiAgICAgICAgc3VwZXIuYWRkRmllbGQoZmllbGQpO1xuICAgICAgICBjb25zdCBmb2xkZXIgPSB0aGlzLmd1aUZvbGRlci5hZGRGb2xkZXIoYCR7ZmllbGQuRk9MREVSX05BTUV9YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBGdW5jdGlvbiB0byBkZXJlZ2lzdGVyIGZyb20gZHJhZyBjb250cm9sbGVyXG4gICAgICAgIGNvbnN0IGRlcmVnaXN0ZXJEcmFnID0gdGhpcy5kcmFnQ29udHJvbGxlci5yZWdpc3RlcihcbiAgICAgICAgICAgICgpID0+IGZpZWxkLmNlbnRyZSxcbiAgICAgICAgICAgIGZpZWxkLmRyYWdNb3ZlTGlzdGVuZXIuYmluZChmaWVsZCksXG4gICAgICAgICAgICBmaWVsZC5kcmFnU3RhcnRMaXN0ZW5lci5iaW5kKGZpZWxkKVxuICAgICAgICApO1xuICAgICAgICBjb25zdCByZW1vdmVGaWVsZE9iaiA9IHtyZW1vdmU6ICgpID0+IHRoaXMucmVtb3ZlRmllbGRHVUkoZmllbGQsIGRlcmVnaXN0ZXJEcmFnKX07XG4gICAgICAgIFxuICAgICAgICAvLyBHaXZlIGRhdCBndWkgcmVtb3ZlRmllbGQgYnV0dG9uXG4gICAgICAgIGZvbGRlci5hZGQocmVtb3ZlRmllbGRPYmosICdyZW1vdmUnKTtcbiAgICAgICAgZmllbGQuc2V0R3VpKHRoaXMuZ3VpRm9sZGVyLCBmb2xkZXIpO1xuICAgIH1cblxuICAgIHByaXZhdGUgcmVtb3ZlRmllbGRHVUkoZmllbGQ6IEJhc2lzRmllbGQsIGRlcmVnaXN0ZXJEcmFnOiAoKCkgPT4gdm9pZCkpOiB2b2lkIHtcbiAgICAgICAgc3VwZXIucmVtb3ZlRmllbGQoZmllbGQpO1xuICAgICAgICBmaWVsZC5yZW1vdmVGb2xkZXJGcm9tUGFyZW50KCk7XG4gICAgICAgIC8vIERlcmVnaXN0ZXIgZnJvbSBkcmFnIGNvbnRyb2xsZXJcbiAgICAgICAgZGVyZWdpc3RlckRyYWcoKTtcbiAgICB9XG5cbiAgICByZXNldCgpOiB2b2lkIHtcbiAgICAgICAgLy8gVE9ETyBraW5kIG9mIGhhY2t5IC0gY2FsbGluZyByZW1vdmUgY2FsbGJhY2tzIGZyb20gZ3VpIG9iamVjdCwgc2hvdWxkIHN0b3JlIGNhbGxiYWNrc1xuICAgICAgICAvLyBpbiBhZGRmaWVsZCBhbmQgY2FsbCB0aGVtIChyZXF1aXJlcyBtYWtpbmcgc3VyZSB0aGV5J3JlIGlkZW1wb3RlbnQpXG4gICAgICAgIGZvciAoY29uc3QgZmllbGRGb2xkZXJOYW1lIGluIHRoaXMuZ3VpRm9sZGVyLl9fZm9sZGVycykge1xuICAgICAgICAgICAgY29uc3QgZmllbGRGb2xkZXIgPSB0aGlzLmd1aUZvbGRlci5fX2ZvbGRlcnNbZmllbGRGb2xkZXJOYW1lXTtcbiAgICAgICAgICAgIChmaWVsZEZvbGRlci5fX2NvbnRyb2xsZXJzWzBdIGFzIGFueSkuaW5pdGlhbFZhbHVlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzdXBlci5yZXNldCgpO1xuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCAqIGFzIGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgQ2FudmFzV3JhcHBlciBmcm9tICcuL2NhbnZhc193cmFwcGVyJztcbmltcG9ydCBEb21haW5Db250cm9sbGVyIGZyb20gJy4vZG9tYWluX2NvbnRyb2xsZXInO1xuaW1wb3J0IFV0aWwgZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgRmllbGRJbnRlZ3JhdG9yIGZyb20gJy4uL2ltcGwvaW50ZWdyYXRvcic7XG5pbXBvcnQge1N0cmVhbWxpbmVQYXJhbXN9IGZyb20gJy4uL2ltcGwvc3RyZWFtbGluZXMnO1xuaW1wb3J0IHtXYXRlclBhcmFtc30gZnJvbSAnLi4vaW1wbC93YXRlcl9nZW5lcmF0b3InO1xuaW1wb3J0IFdhdGVyR2VuZXJhdG9yIGZyb20gJy4uL2ltcGwvd2F0ZXJfZ2VuZXJhdG9yJztcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcbmltcG9ydCBQb2x5Z29uRmluZGVyIGZyb20gJy4uL2ltcGwvcG9seWdvbl9maW5kZXInO1xuaW1wb3J0IFBvbHlnb25VdGlsIGZyb20gJy4uL2ltcGwvcG9seWdvbl91dGlsJztcbmltcG9ydCBSb2FkR1VJIGZyb20gJy4vcm9hZF9ndWknO1xuaW1wb3J0IHtOb2lzZVBhcmFtc30gZnJvbSAnLi4vaW1wbC90ZW5zb3JfZmllbGQnO1xuaW1wb3J0IFRlbnNvckZpZWxkIGZyb20gJy4uL2ltcGwvdGVuc29yX2ZpZWxkJztcblxuLy9SaXZlciBhbmQgQ29hc3RsaW5lXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXYXRlckdVSSBleHRlbmRzIFJvYWRHVUkge1xuICAgIHByb3RlY3RlZCBzdHJlYW1saW5lczogV2F0ZXJHZW5lcmF0b3I7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHRlbnNvckZpZWxkOiBUZW5zb3JGaWVsZCxcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyYW1zOiBXYXRlclBhcmFtcyxcbiAgICAgICAgICAgICAgICBpbnRlZ3JhdG9yOiBGaWVsZEludGVncmF0b3IsXG4gICAgICAgICAgICAgICAgZ3VpRm9sZGVyOiBkYXQuR1VJLFxuICAgICAgICAgICAgICAgIGNsb3NlVGVuc29yRm9sZGVyOiAoKSA9PiB2b2lkLFxuICAgICAgICAgICAgICAgIGZvbGRlck5hbWU6IHN0cmluZyxcbiAgICAgICAgICAgICAgICByZWRyYXc6ICgpID0+IHZvaWQpIHtcbiAgICAgICAgc3VwZXIocGFyYW1zLCBpbnRlZ3JhdG9yLCBndWlGb2xkZXIsIGNsb3NlVGVuc29yRm9sZGVyLCBmb2xkZXJOYW1lLCByZWRyYXcpO1xuICAgICAgICB0aGlzLnN0cmVhbWxpbmVzID0gbmV3IFdhdGVyR2VuZXJhdG9yKFxuICAgICAgICAgICAgdGhpcy5pbnRlZ3JhdG9yLCB0aGlzLmRvbWFpbkNvbnRyb2xsZXIub3JpZ2luLFxuICAgICAgICAgICAgdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkRGltZW5zaW9ucyxcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sdGhpcy5wYXJhbXMpLCB0aGlzLnRlbnNvckZpZWxkKTtcbiAgICB9XG5cbiAgICBpbml0Rm9sZGVyKCk6IFdhdGVyR1VJIHtcbiAgICAgICAgY29uc3QgZm9sZGVyID0gdGhpcy5ndWlGb2xkZXIuYWRkRm9sZGVyKHRoaXMuZm9sZGVyTmFtZSk7XG4gICAgICAgIGZvbGRlci5hZGQoe0dlbmVyYXRlOiAoKSA9PiB0aGlzLmdlbmVyYXRlUm9hZHMoKX0sICdHZW5lcmF0ZScpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgY29hc3RQYXJhbXNGb2xkZXIgPSBmb2xkZXIuYWRkRm9sZGVyKCdDb2FzdFBhcmFtcycpO1xuICAgICAgICBjb2FzdFBhcmFtc0ZvbGRlci5hZGQodGhpcy5wYXJhbXMuY29hc3ROb2lzZSwgJ25vaXNlRW5hYmxlZCcpO1xuICAgICAgICBjb2FzdFBhcmFtc0ZvbGRlci5hZGQodGhpcy5wYXJhbXMuY29hc3ROb2lzZSwgJ25vaXNlU2l6ZScpO1xuICAgICAgICBjb2FzdFBhcmFtc0ZvbGRlci5hZGQodGhpcy5wYXJhbXMuY29hc3ROb2lzZSwgJ25vaXNlQW5nbGUnKTtcbiAgICAgICAgY29uc3Qgcml2ZXJQYXJhbXNGb2xkZXIgPSBmb2xkZXIuYWRkRm9sZGVyKCdSaXZlclBhcmFtcycpO1xuICAgICAgICByaXZlclBhcmFtc0ZvbGRlci5hZGQodGhpcy5wYXJhbXMucml2ZXJOb2lzZSwgJ25vaXNlRW5hYmxlZCcpO1xuICAgICAgICByaXZlclBhcmFtc0ZvbGRlci5hZGQodGhpcy5wYXJhbXMucml2ZXJOb2lzZSwgJ25vaXNlU2l6ZScpO1xuICAgICAgICByaXZlclBhcmFtc0ZvbGRlci5hZGQodGhpcy5wYXJhbXMucml2ZXJOb2lzZSwgJ25vaXNlQW5nbGUnKTtcbiAgICAgICAgXG4gICAgICAgIGZvbGRlci5hZGQodGhpcy5wYXJhbXMsICdzaW1wbGlmeVRvbGVyYW5jZScpO1xuICAgICAgICBjb25zdCBkZXZQYXJhbXNGb2xkZXIgPSBmb2xkZXIuYWRkRm9sZGVyKCdEZXYnKTtcbiAgICAgICAgdGhpcy5hZGREZXZQYXJhbXNUb0ZvbGRlcih0aGlzLnBhcmFtcywgZGV2UGFyYW1zRm9sZGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2VuZXJhdGVSb2FkcygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgdGhpcy5wcmVHZW5lcmF0ZUNhbGxiYWNrKCk7XG5cbiAgICAgICAgdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20gPSB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSAvIFV0aWwuRFJBV19JTkZMQVRFX0FNT1VOVDtcbiAgICAgICAgdGhpcy5zdHJlYW1saW5lcyA9IG5ldyBXYXRlckdlbmVyYXRvcihcbiAgICAgICAgICAgIHRoaXMuaW50ZWdyYXRvciwgdGhpcy5kb21haW5Db250cm9sbGVyLm9yaWdpbixcbiAgICAgICAgICAgIHRoaXMuZG9tYWluQ29udHJvbGxlci53b3JsZERpbWVuc2lvbnMsXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LHRoaXMucGFyYW1zKSwgdGhpcy50ZW5zb3JGaWVsZCk7XG4gICAgICAgIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tID0gdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20gKiBVdGlsLkRSQVdfSU5GTEFURV9BTU9VTlQ7XG5cbiAgICAgICAgdGhpcy5zdHJlYW1saW5lcy5jcmVhdGVDb2FzdCgpO1xuICAgICAgICB0aGlzLnN0cmVhbWxpbmVzLmNyZWF0ZVJpdmVyKCk7XG4gICAgICAgXG4gICAgICAgIHRoaXMuY2xvc2VUZW5zb3JGb2xkZXIoKTtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgICAgdGhpcy5wb3N0R2VuZXJhdGVDYWxsYmFjaygpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4ocmVzb2x2ZSA9PiByZXNvbHZlKCkpO1xuICAgIH1cbiAgICAvL1NlY29uZGFyeSByb2FkIHJ1bnMgYWxvbmcgb3RoZXIgc2lkZSBvZiByaXZlclxuICAgIGdldCBzdHJlYW1saW5lc1dpdGhTZWNvbmRhcnlSb2FkKCk6IFZlY3RvcltdW10ge1xuICAgICAgICBjb25zdCB3aXRoU2Vjb25kYXJ5ID0gdGhpcy5zdHJlYW1saW5lcy5hbGxTdHJlYW1saW5lc1NpbXBsZS5zbGljZSgpO1xuICAgICAgICB3aXRoU2Vjb25kYXJ5LnB1c2godGhpcy5zdHJlYW1saW5lcy5yaXZlclNlY29uZGFyeVJvYWQpO1xuICAgICAgICByZXR1cm4gd2l0aFNlY29uZGFyeTtcbiAgICB9XG5cbiAgICBnZXQgcml2ZXIoKTogVmVjdG9yW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1saW5lcy5yaXZlclBvbHlnb24ubWFwKHYgPT4gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkVG9TY3JlZW4odi5jbG9uZSgpKSk7XG4gICAgfVxuXG4gICAgZ2V0IHNlY29uZGFyeVJpdmVyKCk6IFZlY3RvcltdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtbGluZXMucml2ZXJTZWNvbmRhcnlSb2FkLm1hcCh2ID0+IHRoaXMuZG9tYWluQ29udHJvbGxlci53b3JsZFRvU2NyZWVuKHYuY2xvbmUoKSkpO1xuICAgIH1cblxuICAgIGdldCBjb2FzdGxpbmUoKTogVmVjdG9yW10ge1xuICAgICAgICAvLyBVc2UgdW5zaW1wbGlmaWVkIG5vaXN5IHN0cmVhbWxpbmUgYXMgY29hc3RsaW5lXG4gICAgICAgIC8vIFZpc3VhbCBvbmx5LCBubyByb2FkIGxvZ2ljIHBlcmZvcm1lZCB1c2luZyB0aGlzXG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbWxpbmVzLmNvYXN0bGluZS5tYXAodiA9PiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGRUb1NjcmVlbih2LmNsb25lKCkpKTtcbiAgICB9XG5cbiAgICBnZXQgc2VhUG9seWdvbigpOiBWZWN0b3JbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbWxpbmVzLnNlYVBvbHlnb24ubWFwKHYgPT4gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkVG9TY3JlZW4odi5jbG9uZSgpKSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGFkZERldlBhcmFtc1RvRm9sZGVyKHBhcmFtczogU3RyZWFtbGluZVBhcmFtcywgZm9sZGVyOiBkYXQuR1VJKTogdm9pZCB7XG4gICAgICAgIGZvbGRlci5hZGQocGFyYW1zLCAnZHNlcCcpO1xuICAgICAgICBmb2xkZXIuYWRkKHBhcmFtcywgJ2R0ZXN0Jyk7XG4gICAgICAgIGZvbGRlci5hZGQocGFyYW1zLCAncGF0aEl0ZXJhdGlvbnMnKTtcbiAgICAgICAgZm9sZGVyLmFkZChwYXJhbXMsICdzZWVkVHJpZXMnKTtcbiAgICAgICAgZm9sZGVyLmFkZChwYXJhbXMsICdkc3RlcCcpO1xuICAgICAgICBmb2xkZXIuYWRkKHBhcmFtcywgJ2Rsb29rYWhlYWQnKTtcbiAgICAgICAgZm9sZGVyLmFkZChwYXJhbXMsICdkY2lyY2xlam9pbicpO1xuICAgICAgICBmb2xkZXIuYWRkKHBhcmFtcywgJ2pvaW5hbmdsZScpO1xuICAgIH1cbiAgICBcbn1cbiIsImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmV4cG9ydCBpbnRlcmZhY2UgUmFuZG9tUmFuZ2Uge1xuICAgIG1pbj86IG51bWJlcjtcbiAgICBtYXg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVXRpbCB7XG4gICAgLy8gTXVzdCBtYXRjaCBzdHlsZS5jc3MgYW5kIGluZGV4Lmh0bWxcbiAgICBzdGF0aWMgcmVhZG9ubHkgQ0FOVkFTX0lEID0gJ21hcC1jYW52YXMnO1xuICAgIHN0YXRpYyByZWFkb25seSBJTUdfQ0FOVkFTX0lEID0gJ2ltZy1jYW52YXMnO1xuICAgIHN0YXRpYyByZWFkb25seSBTVkdfSUQgPSAnbWFwLXN2Zyc7XG5cbiAgICAvLyBIb3cgZmFyIHRvIGludGVncmF0ZSBzdHJlYW1saW5lcyBiZXlvbmQgc2NyZWVuIC0gZm9yIG1ha2luZyBidWlsZGluZ3MgcmVhY2ggdGhlIGVkZ2VcbiAgICBzdGF0aWMgcmVhZG9ubHkgRFJBV19JTkZMQVRFX0FNT1VOVCA9IDEuMjtcblxuICAgIC8vIFJlZnJlc2ggZGF0LkdVSSB2YWx1ZXNcbiAgICBzdGF0aWMgdXBkYXRlR3VpKGd1aTogZGF0LkdVSSk6IHZvaWQge1xuICAgICAgICBpZiAoZ3VpLl9fY29udHJvbGxlcnMpIHtcbiAgICAgICAgICAgIGd1aS5fX2NvbnRyb2xsZXJzLmZvckVhY2goYyA9PiBjLnVwZGF0ZURpc3BsYXkoKSk7ICAgIFxuICAgICAgICB9XG4gICAgICAgIGlmIChndWkuX19mb2xkZXJzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZvbGRlck5hbWUgaW4gZ3VpLl9fZm9sZGVycykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlR3VpKGd1aS5fX2ZvbGRlcnNbZm9sZGVyTmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHJlbW92ZUFsbEZvbGRlcnMoZ3VpOiBkYXQuR1VJKTogdm9pZCB7XG4gICAgICAgIGlmIChndWkuX19mb2xkZXJzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZvbGRlck5hbWUgaW4gZ3VpLl9fZm9sZGVycykge1xuICAgICAgICAgICAgICAgIGd1aS5yZW1vdmVGb2xkZXIoZ3VpLl9fZm9sZGVyc1tmb2xkZXJOYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgcmFuZG9tUmFuZ2UobWF4OiBudW1iZXIsIG1pbj0wKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIChNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikpICsgbWluO1xuICAgIH1cblxuICAgIC8vIENTUyBjb2xvdXIgcGFyc2VyOmh0dHBzOi8vZ2l0aHViLmNvbS9kZWFubS9jc3MtY29sb3ItcGFyc2VyLWpzXG4gICAgLy8oYykgRGVhbiBNY05hbWVlIDxkZWFuQGdtYWlsLmNvbT4sIDIwMTIuXG4gICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci9cbiAgICAgICAgXG4gICAgcHJpdmF0ZSBzdGF0aWMga0NTU0NvbG9yVGFibGU6IGFueSA9IHtcbiAgICAgICAgXCJ0cmFuc3BhcmVudFwiOiBbMCwwLDAsMF0sIFwiYWxpY2VibHVlXCI6IFsyNDAsMjQ4LDI1NSwxXSxcbiAgICAgICAgXCJhbnRpcXVld2hpdGVcIjogWzI1MCwyMzUsMjE1LDFdLCBcImFxdWFcIjogWzAsMjU1LDI1NSwxXSxcbiAgICAgICAgXCJhcXVhbWFyaW5lXCI6IFsxMjcsMjU1LDIxMiwxXSwgXCJhenVyZVwiOiBbMjQwLDI1NSwyNTUsMV0sXG4gICAgICAgIFwiYmVpZ2VcIjogWzI0NSwyNDUsMjIwLDFdLCBcImJpc3F1ZVwiOiBbMjU1LDIyOCwxOTYsMV0sXG4gICAgICAgIFwiYmxhY2tcIjogWzAsMCwwLDFdLCBcImJsYW5jaGVkYWxtb25kXCI6IFsyNTUsMjM1LDIwNSwxXSxcbiAgICAgICAgXCJibHVlXCI6IFswLDAsMjU1LDFdLCBcImJsdWV2aW9sZXRcIjogWzEzOCw0MywyMjYsMV0sXG4gICAgICAgIFwiYnJvd25cIjogWzE2NSw0Miw0MiwxXSwgXCJidXJseXdvb2RcIjogWzIyMiwxODQsMTM1LDFdLFxuICAgICAgICBcImNhZGV0Ymx1ZVwiOiBbOTUsMTU4LDE2MCwxXSwgXCJjaGFydHJldXNlXCI6IFsxMjcsMjU1LDAsMV0sXG4gICAgICAgIFwiY2hvY29sYXRlXCI6IFsyMTAsMTA1LDMwLDFdLCBcImNvcmFsXCI6IFsyNTUsMTI3LDgwLDFdLFxuICAgICAgICBcImNvcm5mbG93ZXJibHVlXCI6IFsxMDAsMTQ5LDIzNywxXSwgXCJjb3Juc2lsa1wiOiBbMjU1LDI0OCwyMjAsMV0sXG4gICAgICAgIFwiY3JpbXNvblwiOiBbMjIwLDIwLDYwLDFdLCBcImN5YW5cIjogWzAsMjU1LDI1NSwxXSxcbiAgICAgICAgXCJkYXJrYmx1ZVwiOiBbMCwwLDEzOSwxXSwgXCJkYXJrY3lhblwiOiBbMCwxMzksMTM5LDFdLFxuICAgICAgICBcImRhcmtnb2xkZW5yb2RcIjogWzE4NCwxMzQsMTEsMV0sIFwiZGFya2dyYXlcIjogWzE2OSwxNjksMTY5LDFdLFxuICAgICAgICBcImRhcmtncmVlblwiOiBbMCwxMDAsMCwxXSwgXCJkYXJrZ3JleVwiOiBbMTY5LDE2OSwxNjksMV0sXG4gICAgICAgIFwiZGFya2toYWtpXCI6IFsxODksMTgzLDEwNywxXSwgXCJkYXJrbWFnZW50YVwiOiBbMTM5LDAsMTM5LDFdLFxuICAgICAgICBcImRhcmtvbGl2ZWdyZWVuXCI6IFs4NSwxMDcsNDcsMV0sIFwiZGFya29yYW5nZVwiOiBbMjU1LDE0MCwwLDFdLFxuICAgICAgICBcImRhcmtvcmNoaWRcIjogWzE1Myw1MCwyMDQsMV0sIFwiZGFya3JlZFwiOiBbMTM5LDAsMCwxXSxcbiAgICAgICAgXCJkYXJrc2FsbW9uXCI6IFsyMzMsMTUwLDEyMiwxXSwgXCJkYXJrc2VhZ3JlZW5cIjogWzE0MywxODgsMTQzLDFdLFxuICAgICAgICBcImRhcmtzbGF0ZWJsdWVcIjogWzcyLDYxLDEzOSwxXSwgXCJkYXJrc2xhdGVncmF5XCI6IFs0Nyw3OSw3OSwxXSxcbiAgICAgICAgXCJkYXJrc2xhdGVncmV5XCI6IFs0Nyw3OSw3OSwxXSwgXCJkYXJrdHVycXVvaXNlXCI6IFswLDIwNiwyMDksMV0sXG4gICAgICAgIFwiZGFya3Zpb2xldFwiOiBbMTQ4LDAsMjExLDFdLCBcImRlZXBwaW5rXCI6IFsyNTUsMjAsMTQ3LDFdLFxuICAgICAgICBcImRlZXBza3libHVlXCI6IFswLDE5MSwyNTUsMV0sIFwiZGltZ3JheVwiOiBbMTA1LDEwNSwxMDUsMV0sXG4gICAgICAgIFwiZGltZ3JleVwiOiBbMTA1LDEwNSwxMDUsMV0sIFwiZG9kZ2VyYmx1ZVwiOiBbMzAsMTQ0LDI1NSwxXSxcbiAgICAgICAgXCJmaXJlYnJpY2tcIjogWzE3OCwzNCwzNCwxXSwgXCJmbG9yYWx3aGl0ZVwiOiBbMjU1LDI1MCwyNDAsMV0sXG4gICAgICAgIFwiZm9yZXN0Z3JlZW5cIjogWzM0LDEzOSwzNCwxXSwgXCJmdWNoc2lhXCI6IFsyNTUsMCwyNTUsMV0sXG4gICAgICAgIFwiZ2FpbnNib3JvXCI6IFsyMjAsMjIwLDIyMCwxXSwgXCJnaG9zdHdoaXRlXCI6IFsyNDgsMjQ4LDI1NSwxXSxcbiAgICAgICAgXCJnb2xkXCI6IFsyNTUsMjE1LDAsMV0sIFwiZ29sZGVucm9kXCI6IFsyMTgsMTY1LDMyLDFdLFxuICAgICAgICBcImdyYXlcIjogWzEyOCwxMjgsMTI4LDFdLCBcImdyZWVuXCI6IFswLDEyOCwwLDFdLFxuICAgICAgICBcImdyZWVueWVsbG93XCI6IFsxNzMsMjU1LDQ3LDFdLCBcImdyZXlcIjogWzEyOCwxMjgsMTI4LDFdLFxuICAgICAgICBcImhvbmV5ZGV3XCI6IFsyNDAsMjU1LDI0MCwxXSwgXCJob3RwaW5rXCI6IFsyNTUsMTA1LDE4MCwxXSxcbiAgICAgICAgXCJpbmRpYW5yZWRcIjogWzIwNSw5Miw5MiwxXSwgXCJpbmRpZ29cIjogWzc1LDAsMTMwLDFdLFxuICAgICAgICBcIml2b3J5XCI6IFsyNTUsMjU1LDI0MCwxXSwgXCJraGFraVwiOiBbMjQwLDIzMCwxNDAsMV0sXG4gICAgICAgIFwibGF2ZW5kZXJcIjogWzIzMCwyMzAsMjUwLDFdLCBcImxhdmVuZGVyYmx1c2hcIjogWzI1NSwyNDAsMjQ1LDFdLFxuICAgICAgICBcImxhd25ncmVlblwiOiBbMTI0LDI1MiwwLDFdLCBcImxlbW9uY2hpZmZvblwiOiBbMjU1LDI1MCwyMDUsMV0sXG4gICAgICAgIFwibGlnaHRibHVlXCI6IFsxNzMsMjE2LDIzMCwxXSwgXCJsaWdodGNvcmFsXCI6IFsyNDAsMTI4LDEyOCwxXSxcbiAgICAgICAgXCJsaWdodGN5YW5cIjogWzIyNCwyNTUsMjU1LDFdLCBcImxpZ2h0Z29sZGVucm9keWVsbG93XCI6IFsyNTAsMjUwLDIxMCwxXSxcbiAgICAgICAgXCJsaWdodGdyYXlcIjogWzIxMSwyMTEsMjExLDFdLCBcImxpZ2h0Z3JlZW5cIjogWzE0NCwyMzgsMTQ0LDFdLFxuICAgICAgICBcImxpZ2h0Z3JleVwiOiBbMjExLDIxMSwyMTEsMV0sIFwibGlnaHRwaW5rXCI6IFsyNTUsMTgyLDE5MywxXSxcbiAgICAgICAgXCJsaWdodHNhbG1vblwiOiBbMjU1LDE2MCwxMjIsMV0sIFwibGlnaHRzZWFncmVlblwiOiBbMzIsMTc4LDE3MCwxXSxcbiAgICAgICAgXCJsaWdodHNreWJsdWVcIjogWzEzNSwyMDYsMjUwLDFdLCBcImxpZ2h0c2xhdGVncmF5XCI6IFsxMTksMTM2LDE1MywxXSxcbiAgICAgICAgXCJsaWdodHNsYXRlZ3JleVwiOiBbMTE5LDEzNiwxNTMsMV0sIFwibGlnaHRzdGVlbGJsdWVcIjogWzE3NiwxOTYsMjIyLDFdLFxuICAgICAgICBcImxpZ2h0eWVsbG93XCI6IFsyNTUsMjU1LDIyNCwxXSwgXCJsaW1lXCI6IFswLDI1NSwwLDFdLFxuICAgICAgICBcImxpbWVncmVlblwiOiBbNTAsMjA1LDUwLDFdLCBcImxpbmVuXCI6IFsyNTAsMjQwLDIzMCwxXSxcbiAgICAgICAgXCJtYWdlbnRhXCI6IFsyNTUsMCwyNTUsMV0sIFwibWFyb29uXCI6IFsxMjgsMCwwLDFdLFxuICAgICAgICBcIm1lZGl1bWFxdWFtYXJpbmVcIjogWzEwMiwyMDUsMTcwLDFdLCBcIm1lZGl1bWJsdWVcIjogWzAsMCwyMDUsMV0sXG4gICAgICAgIFwibWVkaXVtb3JjaGlkXCI6IFsxODYsODUsMjExLDFdLCBcIm1lZGl1bXB1cnBsZVwiOiBbMTQ3LDExMiwyMTksMV0sXG4gICAgICAgIFwibWVkaXVtc2VhZ3JlZW5cIjogWzYwLDE3OSwxMTMsMV0sIFwibWVkaXVtc2xhdGVibHVlXCI6IFsxMjMsMTA0LDIzOCwxXSxcbiAgICAgICAgXCJtZWRpdW1zcHJpbmdncmVlblwiOiBbMCwyNTAsMTU0LDFdLCBcIm1lZGl1bXR1cnF1b2lzZVwiOiBbNzIsMjA5LDIwNCwxXSxcbiAgICAgICAgXCJtZWRpdW12aW9sZXRyZWRcIjogWzE5OSwyMSwxMzMsMV0sIFwibWlkbmlnaHRibHVlXCI6IFsyNSwyNSwxMTIsMV0sXG4gICAgICAgIFwibWludGNyZWFtXCI6IFsyNDUsMjU1LDI1MCwxXSwgXCJtaXN0eXJvc2VcIjogWzI1NSwyMjgsMjI1LDFdLFxuICAgICAgICBcIm1vY2Nhc2luXCI6IFsyNTUsMjI4LDE4MSwxXSwgXCJuYXZham93aGl0ZVwiOiBbMjU1LDIyMiwxNzMsMV0sXG4gICAgICAgIFwibmF2eVwiOiBbMCwwLDEyOCwxXSwgXCJvbGRsYWNlXCI6IFsyNTMsMjQ1LDIzMCwxXSxcbiAgICAgICAgXCJvbGl2ZVwiOiBbMTI4LDEyOCwwLDFdLCBcIm9saXZlZHJhYlwiOiBbMTA3LDE0MiwzNSwxXSxcbiAgICAgICAgXCJvcmFuZ2VcIjogWzI1NSwxNjUsMCwxXSwgXCJvcmFuZ2VyZWRcIjogWzI1NSw2OSwwLDFdLFxuICAgICAgICBcIm9yY2hpZFwiOiBbMjE4LDExMiwyMTQsMV0sIFwicGFsZWdvbGRlbnJvZFwiOiBbMjM4LDIzMiwxNzAsMV0sXG4gICAgICAgIFwicGFsZWdyZWVuXCI6IFsxNTIsMjUxLDE1MiwxXSwgXCJwYWxldHVycXVvaXNlXCI6IFsxNzUsMjM4LDIzOCwxXSxcbiAgICAgICAgXCJwYWxldmlvbGV0cmVkXCI6IFsyMTksMTEyLDE0NywxXSwgXCJwYXBheWF3aGlwXCI6IFsyNTUsMjM5LDIxMywxXSxcbiAgICAgICAgXCJwZWFjaHB1ZmZcIjogWzI1NSwyMTgsMTg1LDFdLCBcInBlcnVcIjogWzIwNSwxMzMsNjMsMV0sXG4gICAgICAgIFwicGlua1wiOiBbMjU1LDE5MiwyMDMsMV0sIFwicGx1bVwiOiBbMjIxLDE2MCwyMjEsMV0sXG4gICAgICAgIFwicG93ZGVyYmx1ZVwiOiBbMTc2LDIyNCwyMzAsMV0sIFwicHVycGxlXCI6IFsxMjgsMCwxMjgsMV0sXG4gICAgICAgIFwicmViZWNjYXB1cnBsZVwiOiBbMTAyLDUxLDE1MywxXSxcbiAgICAgICAgXCJyZWRcIjogWzI1NSwwLDAsMV0sIFwicm9zeWJyb3duXCI6IFsxODgsMTQzLDE0MywxXSxcbiAgICAgICAgXCJyb3lhbGJsdWVcIjogWzY1LDEwNSwyMjUsMV0sIFwic2FkZGxlYnJvd25cIjogWzEzOSw2OSwxOSwxXSxcbiAgICAgICAgXCJzYWxtb25cIjogWzI1MCwxMjgsMTE0LDFdLCBcInNhbmR5YnJvd25cIjogWzI0NCwxNjQsOTYsMV0sXG4gICAgICAgIFwic2VhZ3JlZW5cIjogWzQ2LDEzOSw4NywxXSwgXCJzZWFzaGVsbFwiOiBbMjU1LDI0NSwyMzgsMV0sXG4gICAgICAgIFwic2llbm5hXCI6IFsxNjAsODIsNDUsMV0sIFwic2lsdmVyXCI6IFsxOTIsMTkyLDE5MiwxXSxcbiAgICAgICAgXCJza3libHVlXCI6IFsxMzUsMjA2LDIzNSwxXSwgXCJzbGF0ZWJsdWVcIjogWzEwNiw5MCwyMDUsMV0sXG4gICAgICAgIFwic2xhdGVncmF5XCI6IFsxMTIsMTI4LDE0NCwxXSwgXCJzbGF0ZWdyZXlcIjogWzExMiwxMjgsMTQ0LDFdLFxuICAgICAgICBcInNub3dcIjogWzI1NSwyNTAsMjUwLDFdLCBcInNwcmluZ2dyZWVuXCI6IFswLDI1NSwxMjcsMV0sXG4gICAgICAgIFwic3RlZWxibHVlXCI6IFs3MCwxMzAsMTgwLDFdLCBcInRhblwiOiBbMjEwLDE4MCwxNDAsMV0sXG4gICAgICAgIFwidGVhbFwiOiBbMCwxMjgsMTI4LDFdLCBcInRoaXN0bGVcIjogWzIxNiwxOTEsMjE2LDFdLFxuICAgICAgICBcInRvbWF0b1wiOiBbMjU1LDk5LDcxLDFdLCBcInR1cnF1b2lzZVwiOiBbNjQsMjI0LDIwOCwxXSxcbiAgICAgICAgXCJ2aW9sZXRcIjogWzIzOCwxMzAsMjM4LDFdLCBcIndoZWF0XCI6IFsyNDUsMjIyLDE3OSwxXSxcbiAgICAgICAgXCJ3aGl0ZVwiOiBbMjU1LDI1NSwyNTUsMV0sIFwid2hpdGVzbW9rZVwiOiBbMjQ1LDI0NSwyNDUsMV0sXG4gICAgICAgIFwieWVsbG93XCI6IFsyNTUsMjU1LDAsMV0sIFwieWVsbG93Z3JlZW5cIjogWzE1NCwyMDUsNTAsMV19XG5cbiAgICBwcml2YXRlIHN0YXRpYyBjbGFtcF9jc3NfYnl0ZShpOiBudW1iZXIpOiBudW1iZXIgeyAgLy8gQ2xhbXAgdG8gaW50ZWdlciAwIC4uIDI1NS5cbiAgICAgICAgaSA9IE1hdGgucm91bmQoaSk7ICAvLyBTZWVtcyB0byBiZSB3aGF0IENocm9tZSBkb2VzICh2cyB0cnVuY2F0aW9uKS5cbiAgICAgICAgcmV0dXJuIGkgPCAwID8gMCA6IGkgPiAyNTUgPyAyNTUgOiBpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGNsYW1wX2Nzc19mbG9hdChmOiBudW1iZXIpOiBudW1iZXIgeyAgLy8gQ2xhbXAgdG8gZmxvYXQgMC4wIC4uIDEuMC5cbiAgICAgICAgcmV0dXJuIGYgPCAwID8gMCA6IGYgPiAxID8gMSA6IGY7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgcGFyc2VfY3NzX2ludChzdHI6IHN0cmluZyk6IG51bWJlciB7ICAvLyBpbnQgb3IgcGVyY2VudGFnZS5cbiAgICAgICAgaWYgKHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICclJylcbiAgICAgICAgcmV0dXJuIFV0aWwuY2xhbXBfY3NzX2J5dGUocGFyc2VGbG9hdChzdHIpIC8gMTAwICogMjU1KTtcbiAgICAgICAgcmV0dXJuIFV0aWwuY2xhbXBfY3NzX2J5dGUocGFyc2VJbnQoc3RyKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgcGFyc2VfY3NzX2Zsb2F0KHN0cjogc3RyaW5nKTogbnVtYmVyIHsgIC8vIGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gICAgICAgIGlmIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnJScpXG4gICAgICAgIHJldHVybiBVdGlsLmNsYW1wX2Nzc19mbG9hdChwYXJzZUZsb2F0KHN0cikgLyAxMDApO1xuICAgICAgICByZXR1cm4gVXRpbC5jbGFtcF9jc3NfZmxvYXQocGFyc2VGbG9hdChzdHIpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBjc3NfaHVlX3RvX3JnYihtMTogbnVtYmVyLCBtMjogbnVtYmVyLCBoOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKGggPCAwKSBoICs9IDE7XG4gICAgICAgIGVsc2UgaWYgKGggPiAxKSBoIC09IDE7XG5cbiAgICAgICAgaWYgKGggKiA2IDwgMSkgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogaCAqIDY7XG4gICAgICAgIGlmIChoICogMiA8IDEpIHJldHVybiBtMjtcbiAgICAgICAgaWYgKGggKiAzIDwgMikgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogKDIvMyAtIGgpICogNjtcbiAgICAgICAgcmV0dXJuIG0xO1xuICAgIH1cblxuICAgIHN0YXRpYyBwYXJzZUNTU0NvbG9yKGNzc19zdHI6IHN0cmluZyk6IG51bWJlcltdIHtcbiAgICAgICAgLy8gUmVtb3ZlIGFsbCB3aGl0ZXNwYWNlLCBub3QgY29tcGxpYW50LCBidXQgc2hvdWxkIGp1c3QgYmUgbW9yZSBhY2NlcHRpbmcuXG4gICAgICAgIHZhciBzdHIgPSBjc3Nfc3RyLnJlcGxhY2UoLyAvZywgJycpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgLy8gQ29sb3Iga2V5d29yZHMgKGFuZCB0cmFuc3BhcmVudCkgbG9va3VwLlxuICAgICAgICBpZiAoc3RyIGluIFV0aWwua0NTU0NvbG9yVGFibGUpIHJldHVybiBVdGlsLmtDU1NDb2xvclRhYmxlW3N0cl0uc2xpY2UoKTsgIC8vIGR1cC5cblxuICAgICAgICAvLyAjYWJjIGFuZCAjYWJjMTIzIHN5bnRheC5cbiAgICAgICAgaWYgKHN0clswXSA9PT0gJyMnKSB7XG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgIC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuICAgICAgICAgICAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmYpKSByZXR1cm4gbnVsbDsgIC8vIENvdmVycyBOYU4uXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsoKGl2ICYgMHhmMDApID4+IDQpIHwgKChpdiAmIDB4ZjAwKSA+PiA4KSxcbiAgICAgICAgICAgICAgICAgICAgICAoaXYgJiAweGYwKSB8ICgoaXYgJiAweGYwKSA+PiA0KSxcbiAgICAgICAgICAgICAgICAgICAgICAoaXYgJiAweGYpIHwgKChpdiAmIDB4ZikgPDwgNCksXG4gICAgICAgICAgICAgICAgICAgICAgMV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0ci5sZW5ndGggPT09IDcpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7ICAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cbiAgICAgICAgICAgICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmZmZmKSkgcmV0dXJuIG51bGw7ICAvLyBDb3ZlcnMgTmFOLlxuICAgICAgICAgICAgICAgIHJldHVybiBbKGl2ICYgMHhmZjAwMDApID4+IDE2LFxuICAgICAgICAgICAgICAgICAgICAgIChpdiAmIDB4ZmYwMCkgPj4gOCxcbiAgICAgICAgICAgICAgICAgICAgICBpdiAmIDB4ZmYsXG4gICAgICAgICAgICAgICAgICAgICAgMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9wID0gc3RyLmluZGV4T2YoJygnKSwgZXAgPSBzdHIuaW5kZXhPZignKScpO1xuICAgICAgICBpZiAob3AgIT09IC0xICYmIGVwICsgMSA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGZuYW1lID0gc3RyLnN1YnN0cigwLCBvcCk7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gc3RyLnN1YnN0cihvcCsxLCBlcC0ob3ArMSkpLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSAxOyAgLy8gVG8gYWxsb3cgY2FzZSBmYWxsdGhyb3VnaC5cbiAgICAgICAgICAgIHN3aXRjaCAoZm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdyZ2JhJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IFV0aWwucGFyc2VfY3NzX2Zsb2F0KHBhcmFtcy5wb3AoKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZhbGwgdGhyb3VnaC5cbiAgICAgICAgICAgICAgICBjYXNlICdyZ2InOlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbVXRpbC5wYXJzZV9jc3NfaW50KHBhcmFtc1swXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVXRpbC5wYXJzZV9jc3NfaW50KHBhcmFtc1sxXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVXRpbC5wYXJzZV9jc3NfaW50KHBhcmFtc1syXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdoc2xhJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IFV0aWwucGFyc2VfY3NzX2Zsb2F0KHBhcmFtcy5wb3AoKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZhbGwgdGhyb3VnaC5cbiAgICAgICAgICAgICAgICBjYXNlICdoc2wnOlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoID0gKCgocGFyc2VGbG9hdChwYXJhbXNbMF0pICUgMzYwKSArIDM2MCkgJSAzNjApIC8gMzYwOyAgLy8gMCAuLiAxXG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEUoZGVhbm0pOiBBY2NvcmRpbmcgdG8gdGhlIENTUyBzcGVjIHMvbCBzaG91bGQgb25seSBiZVxuICAgICAgICAgICAgICAgICAgICAvLyBwZXJjZW50YWdlcywgYnV0IHdlIGRvbid0IGJvdGhlciBhbmQgbGV0IGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gVXRpbC5wYXJzZV9jc3NfZmxvYXQocGFyYW1zWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBVdGlsLnBhcnNlX2Nzc19mbG9hdChwYXJhbXNbMl0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbTIgPSBsIDw9IDAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIG0xID0gbCAqIDIgLSBtMjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtVdGlsLmNsYW1wX2Nzc19ieXRlKFV0aWwuY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoKzEvMykgKiAyNTUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFV0aWwuY2xhbXBfY3NzX2J5dGUoVXRpbC5jc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgpICogMjU1KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBVdGlsLmNsYW1wX2Nzc19ieXRlKFV0aWwuY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoLTEvMykgKiAyNTUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhXTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCAqIGFzIGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlY3RvciB7XG4gICAgY29uc3RydWN0b3IocHVibGljIHg6IG51bWJlciwgcHVibGljIHk6IG51bWJlcikge31cblxuICAgIHN0YXRpYyB6ZXJvVmVjdG9yKCk6IFZlY3RvciB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKDAsIDApO1xuICAgIH1cblxuICAgIHN0YXRpYyBmcm9tU2NhbGFyKHM6IG51bWJlcik6IFZlY3RvciB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHMsIHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIC1waSB0byBwaVxuICAgICAqL1xuICAgIHN0YXRpYyBhbmdsZUJldHdlZW4odjE6IFZlY3RvciwgdjI6IFZlY3Rvcik6IG51bWJlciB7XG4gICAgICAgIC8vIC0ycGkgdG8gMnBpXG4gICAgICAgIGxldCBhbmdsZUJldHdlZW4gPSB2MS5hbmdsZSgpIC0gdjIuYW5nbGUoKTtcbiAgICAgICAgaWYgKGFuZ2xlQmV0d2VlbiA+IE1hdGguUEkpIHtcbiAgICAgICAgICAgIGFuZ2xlQmV0d2VlbiAtPSAyICogTWF0aC5QSTtcbiAgICAgICAgfSBlbHNlIGlmIChhbmdsZUJldHdlZW4gPD0gLU1hdGguUEkpIHtcbiAgICAgICAgICAgIGFuZ2xlQmV0d2VlbiArPSAyICogTWF0aC5QSTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYW5nbGVCZXR3ZWVuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3RzIHdoZXRoZXIgYSBwb2ludCBsaWVzIHRvIHRoZSBsZWZ0IG9mIGEgbGluZVxuICAgICAqIEBwYXJhbSAge1ZlY3Rvcn0gbGluZVBvaW50ICAgICBQb2ludCBvbiB0aGUgbGluZVxuICAgICAqIEBwYXJhbSAge1ZlY3Rvcn0gbGluZURpcmVjdGlvbiBcbiAgICAgKiBAcGFyYW0gIHtWZWN0b3J9IHBvaW50XG4gICAgICogQHJldHVybiB7VmVjdG9yfSAgICAgICAgICAgICAgIHRydWUgaWYgbGVmdCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgc3RhdGljIGlzTGVmdChsaW5lUG9pbnQ6IFZlY3RvciwgbGluZURpcmVjdGlvbjogVmVjdG9yLCBwb2ludDogVmVjdG9yKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IHBlcnBlbmRpY3VsYXJWZWN0b3IgPSBuZXcgVmVjdG9yKGxpbmVEaXJlY3Rpb24ueSwgLWxpbmVEaXJlY3Rpb24ueCk7XG4gICAgICAgIHJldHVybiBwb2ludC5jbG9uZSgpLnN1YihsaW5lUG9pbnQpLmRvdChwZXJwZW5kaWN1bGFyVmVjdG9yKSA8IDA7XG4gICAgfVxuXG4gICAgYWRkKHY6IFZlY3Rvcik6IFZlY3RvciB7XG4gICAgICAgIHRoaXMueCArPSB2Lng7XG4gICAgICAgIHRoaXMueSArPSB2Lnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuZ2xlIGluIHJhZGlhbnMgdG8gcG9zaXRpdmUgeC1heGlzIGJldHdlZW4gLXBpIGFuZCBwaVxuICAgICAqL1xuICAgIGFuZ2xlKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMueSwgdGhpcy54KTtcbiAgICB9XG5cbiAgICBjbG9uZSgpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuXG4gICAgY29weSh2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICB0aGlzLnggPSB2Lng7XG4gICAgICAgIHRoaXMueSA9IHYueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY3Jvc3ModjogVmVjdG9yKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIHYueSAtIHRoaXMueSAqIHYueDtcbiAgICB9XG5cbiAgICBkaXN0YW5jZVRvKHY6IFZlY3Rvcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0YW5jZVRvU3F1YXJlZCh2KSk7XG4gICAgfVxuXG4gICAgZGlzdGFuY2VUb1NxdWFyZWQgKHY6IFZlY3Rvcik6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IGR4ID0gdGhpcy54IC0gdi54XG4gICAgICAgIGNvbnN0IGR5ID0gdGhpcy55IC0gdi55O1xuICAgICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG4gICAgfVxuXG4gICAgZGl2aWRlKHY6IFZlY3Rvcik6IFZlY3RvciB7XG4gICAgICAgIGlmICh2LnggPT09IDAgfHwgdi55ID09PSAwKSB7XG4gICAgICAgICAgICBsb2cud2FybihcIkRpdmlzaW9uIGJ5IHplcm9cIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMueCAvPSB2Lng7XG4gICAgICAgIHRoaXMueSAvPSB2Lnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGRpdmlkZVNjYWxhcihzOiBudW1iZXIpOiBWZWN0b3Ige1xuICAgICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICAgICAgbG9nLndhcm4oXCJEaXZpc2lvbiBieSB6ZXJvXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoMSAvIHMpO1xuICAgIH1cblxuICAgIGRvdCh2OiBWZWN0b3IpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55O1xuICAgIH1cblxuICAgIGVxdWFscyh2OiBWZWN0b3IpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICgodi54ID09PSB0aGlzLngpICYmICh2LnkgPT09IHRoaXMueSkpO1xuICAgIH1cblxuICAgIGxlbmd0aCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMubGVuZ3RoU3EoKSk7XG4gICAgfVxuXG4gICAgbGVuZ3RoU3EoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueTtcbiAgICB9XG5cbiAgICBtdWx0aXBseSh2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICB0aGlzLnggKj0gdi54O1xuICAgICAgICB0aGlzLnkgKj0gdi55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBtdWx0aXBseVNjYWxhcihzOiBudW1iZXIpOiBWZWN0b3Ige1xuICAgICAgICB0aGlzLnggKj0gcztcbiAgICAgICAgdGhpcy55ICo9IHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIG5lZ2F0ZSgpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhcigtMSk7XG4gICAgfVxuXG4gICAgbm9ybWFsaXplKCk6IFZlY3RvciB7XG4gICAgICAgIGNvbnN0IGwgPSB0aGlzLmxlbmd0aCgpO1xuICAgICAgICBpZiAobCA9PT0gMCkge1xuICAgICAgICAgICAgbG9nLndhcm4oXCJaZXJvIFZlY3RvclwiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIodGhpcy5sZW5ndGgoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5nbGUgaW4gcmFkaWFuc1xuICAgICAqL1xuICAgIHJvdGF0ZUFyb3VuZChjZW50ZXI6IFZlY3RvciwgYW5nbGU6IG51bWJlcik6IFZlY3RvciB7XG4gICAgICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKGFuZ2xlKVxuICAgICAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG5cbiAgICAgICAgY29uc3QgeCA9IHRoaXMueCAtIGNlbnRlci54O1xuICAgICAgICBjb25zdCB5ID0gdGhpcy55IC0gY2VudGVyLnk7XG5cbiAgICAgICAgdGhpcy54ID0geCAqIGNvcyAtIHkgKiBzaW4gKyBjZW50ZXIueDtcbiAgICAgICAgdGhpcy55ID0geCAqIHNpbiArIHkgKiBjb3MgKyBjZW50ZXIueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0KHY6IFZlY3Rvcik6IFZlY3RvciB7XG4gICAgICAgIHRoaXMueCA9IHYueDtcbiAgICAgICAgdGhpcy55ID0gdi55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXRYKHg6IG51bWJlcik6IFZlY3RvciB7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldFkoeTogbnVtYmVyKTogVmVjdG9yIHtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0TGVuZ3RoIChsZW5ndGg6IG51bWJlcik6IFZlY3RvciB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKGxlbmd0aCk7XG4gICAgfVxuXG4gICAgc3ViKHY6IFZlY3Rvcik6IFZlY3RvciB7XG4gICAgICAgIHRoaXMueCAtPSB2Lng7XG4gICAgICAgIHRoaXMueSAtPSB2Lnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGQpIHtcbiAgY29uc3QgeCA9ICt0aGlzLl94LmNhbGwobnVsbCwgZCksXG4gICAgICB5ID0gK3RoaXMuX3kuY2FsbChudWxsLCBkKTtcbiAgcmV0dXJuIGFkZCh0aGlzLmNvdmVyKHgsIHkpLCB4LCB5LCBkKTtcbn1cblxuZnVuY3Rpb24gYWRkKHRyZWUsIHgsIHksIGQpIHtcbiAgaWYgKGlzTmFOKHgpIHx8IGlzTmFOKHkpKSByZXR1cm4gdHJlZTsgLy8gaWdub3JlIGludmFsaWQgcG9pbnRzXG5cbiAgdmFyIHBhcmVudCxcbiAgICAgIG5vZGUgPSB0cmVlLl9yb290LFxuICAgICAgbGVhZiA9IHtkYXRhOiBkfSxcbiAgICAgIHgwID0gdHJlZS5feDAsXG4gICAgICB5MCA9IHRyZWUuX3kwLFxuICAgICAgeDEgPSB0cmVlLl94MSxcbiAgICAgIHkxID0gdHJlZS5feTEsXG4gICAgICB4bSxcbiAgICAgIHltLFxuICAgICAgeHAsXG4gICAgICB5cCxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tLFxuICAgICAgaSxcbiAgICAgIGo7XG5cbiAgLy8gSWYgdGhlIHRyZWUgaXMgZW1wdHksIGluaXRpYWxpemUgdGhlIHJvb3QgYXMgYSBsZWFmLlxuICBpZiAoIW5vZGUpIHJldHVybiB0cmVlLl9yb290ID0gbGVhZiwgdHJlZTtcblxuICAvLyBGaW5kIHRoZSBleGlzdGluZyBsZWFmIGZvciB0aGUgbmV3IHBvaW50LCBvciBhZGQgaXQuXG4gIHdoaWxlIChub2RlLmxlbmd0aCkge1xuICAgIGlmIChyaWdodCA9IHggPj0gKHhtID0gKHgwICsgeDEpIC8gMikpIHgwID0geG07IGVsc2UgeDEgPSB4bTtcbiAgICBpZiAoYm90dG9tID0geSA+PSAoeW0gPSAoeTAgKyB5MSkgLyAyKSkgeTAgPSB5bTsgZWxzZSB5MSA9IHltO1xuICAgIGlmIChwYXJlbnQgPSBub2RlLCAhKG5vZGUgPSBub2RlW2kgPSBib3R0b20gPDwgMSB8IHJpZ2h0XSkpIHJldHVybiBwYXJlbnRbaV0gPSBsZWFmLCB0cmVlO1xuICB9XG5cbiAgLy8gSXMgdGhlIG5ldyBwb2ludCBpcyBleGFjdGx5IGNvaW5jaWRlbnQgd2l0aCB0aGUgZXhpc3RpbmcgcG9pbnQ/XG4gIHhwID0gK3RyZWUuX3guY2FsbChudWxsLCBub2RlLmRhdGEpO1xuICB5cCA9ICt0cmVlLl95LmNhbGwobnVsbCwgbm9kZS5kYXRhKTtcbiAgaWYgKHggPT09IHhwICYmIHkgPT09IHlwKSByZXR1cm4gbGVhZi5uZXh0ID0gbm9kZSwgcGFyZW50ID8gcGFyZW50W2ldID0gbGVhZiA6IHRyZWUuX3Jvb3QgPSBsZWFmLCB0cmVlO1xuXG4gIC8vIE90aGVyd2lzZSwgc3BsaXQgdGhlIGxlYWYgbm9kZSB1bnRpbCB0aGUgb2xkIGFuZCBuZXcgcG9pbnQgYXJlIHNlcGFyYXRlZC5cbiAgZG8ge1xuICAgIHBhcmVudCA9IHBhcmVudCA/IHBhcmVudFtpXSA9IG5ldyBBcnJheSg0KSA6IHRyZWUuX3Jvb3QgPSBuZXcgQXJyYXkoNCk7XG4gICAgaWYgKHJpZ2h0ID0geCA+PSAoeG0gPSAoeDAgKyB4MSkgLyAyKSkgeDAgPSB4bTsgZWxzZSB4MSA9IHhtO1xuICAgIGlmIChib3R0b20gPSB5ID49ICh5bSA9ICh5MCArIHkxKSAvIDIpKSB5MCA9IHltOyBlbHNlIHkxID0geW07XG4gIH0gd2hpbGUgKChpID0gYm90dG9tIDw8IDEgfCByaWdodCkgPT09IChqID0gKHlwID49IHltKSA8PCAxIHwgKHhwID49IHhtKSkpO1xuICByZXR1cm4gcGFyZW50W2pdID0gbm9kZSwgcGFyZW50W2ldID0gbGVhZiwgdHJlZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEFsbChkYXRhKSB7XG4gIHZhciBkLCBpLCBuID0gZGF0YS5sZW5ndGgsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHh6ID0gbmV3IEFycmF5KG4pLFxuICAgICAgeXogPSBuZXcgQXJyYXkobiksXG4gICAgICB4MCA9IEluZmluaXR5LFxuICAgICAgeTAgPSBJbmZpbml0eSxcbiAgICAgIHgxID0gLUluZmluaXR5LFxuICAgICAgeTEgPSAtSW5maW5pdHk7XG5cbiAgLy8gQ29tcHV0ZSB0aGUgcG9pbnRzIGFuZCB0aGVpciBleHRlbnQuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoaXNOYU4oeCA9ICt0aGlzLl94LmNhbGwobnVsbCwgZCA9IGRhdGFbaV0pKSB8fCBpc05hTih5ID0gK3RoaXMuX3kuY2FsbChudWxsLCBkKSkpIGNvbnRpbnVlO1xuICAgIHh6W2ldID0geDtcbiAgICB5eltpXSA9IHk7XG4gICAgaWYgKHggPCB4MCkgeDAgPSB4O1xuICAgIGlmICh4ID4geDEpIHgxID0geDtcbiAgICBpZiAoeSA8IHkwKSB5MCA9IHk7XG4gICAgaWYgKHkgPiB5MSkgeTEgPSB5O1xuICB9XG5cbiAgLy8gSWYgdGhlcmUgd2VyZSBubyAodmFsaWQpIHBvaW50cywgYWJvcnQuXG4gIGlmICh4MCA+IHgxIHx8IHkwID4geTEpIHJldHVybiB0aGlzO1xuXG4gIC8vIEV4cGFuZCB0aGUgdHJlZSB0byBjb3ZlciB0aGUgbmV3IHBvaW50cy5cbiAgdGhpcy5jb3Zlcih4MCwgeTApLmNvdmVyKHgxLCB5MSk7XG5cbiAgLy8gQWRkIHRoZSBuZXcgcG9pbnRzLlxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgYWRkKHRoaXMsIHh6W2ldLCB5eltpXSwgZGF0YVtpXSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgsIHkpIHtcbiAgaWYgKGlzTmFOKHggPSAreCkgfHwgaXNOYU4oeSA9ICt5KSkgcmV0dXJuIHRoaXM7IC8vIGlnbm9yZSBpbnZhbGlkIHBvaW50c1xuXG4gIHZhciB4MCA9IHRoaXMuX3gwLFxuICAgICAgeTAgPSB0aGlzLl95MCxcbiAgICAgIHgxID0gdGhpcy5feDEsXG4gICAgICB5MSA9IHRoaXMuX3kxO1xuXG4gIC8vIElmIHRoZSBxdWFkdHJlZSBoYXMgbm8gZXh0ZW50LCBpbml0aWFsaXplIHRoZW0uXG4gIC8vIEludGVnZXIgZXh0ZW50IGFyZSBuZWNlc3Nhcnkgc28gdGhhdCBpZiB3ZSBsYXRlciBkb3VibGUgdGhlIGV4dGVudCxcbiAgLy8gdGhlIGV4aXN0aW5nIHF1YWRyYW50IGJvdW5kYXJpZXMgZG9u4oCZdCBjaGFuZ2UgZHVlIHRvIGZsb2F0aW5nIHBvaW50IGVycm9yIVxuICBpZiAoaXNOYU4oeDApKSB7XG4gICAgeDEgPSAoeDAgPSBNYXRoLmZsb29yKHgpKSArIDE7XG4gICAgeTEgPSAoeTAgPSBNYXRoLmZsb29yKHkpKSArIDE7XG4gIH1cblxuICAvLyBPdGhlcndpc2UsIGRvdWJsZSByZXBlYXRlZGx5IHRvIGNvdmVyLlxuICBlbHNlIHtcbiAgICB2YXIgeiA9IHgxIC0geDAgfHwgMSxcbiAgICAgICAgbm9kZSA9IHRoaXMuX3Jvb3QsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgaTtcblxuICAgIHdoaWxlICh4MCA+IHggfHwgeCA+PSB4MSB8fCB5MCA+IHkgfHwgeSA+PSB5MSkge1xuICAgICAgaSA9ICh5IDwgeTApIDw8IDEgfCAoeCA8IHgwKTtcbiAgICAgIHBhcmVudCA9IG5ldyBBcnJheSg0KSwgcGFyZW50W2ldID0gbm9kZSwgbm9kZSA9IHBhcmVudCwgeiAqPSAyO1xuICAgICAgc3dpdGNoIChpKSB7XG4gICAgICAgIGNhc2UgMDogeDEgPSB4MCArIHosIHkxID0geTAgKyB6OyBicmVhaztcbiAgICAgICAgY2FzZSAxOiB4MCA9IHgxIC0geiwgeTEgPSB5MCArIHo7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IHgxID0geDAgKyB6LCB5MCA9IHkxIC0gejsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogeDAgPSB4MSAtIHosIHkwID0geTEgLSB6OyBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcm9vdCAmJiB0aGlzLl9yb290Lmxlbmd0aCkgdGhpcy5fcm9vdCA9IG5vZGU7XG4gIH1cblxuICB0aGlzLl94MCA9IHgwO1xuICB0aGlzLl95MCA9IHkwO1xuICB0aGlzLl94MSA9IHgxO1xuICB0aGlzLl95MSA9IHkxO1xuICByZXR1cm4gdGhpcztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgZGF0YSA9IFtdO1xuICB0aGlzLnZpc2l0KGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUubGVuZ3RoKSBkbyBkYXRhLnB1c2gobm9kZS5kYXRhKTsgd2hpbGUgKG5vZGUgPSBub2RlLm5leHQpXG4gIH0pO1xuICByZXR1cm4gZGF0YTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKF8pIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5jb3ZlcigrX1swXVswXSwgK19bMF1bMV0pLmNvdmVyKCtfWzFdWzBdLCArX1sxXVsxXSlcbiAgICAgIDogaXNOYU4odGhpcy5feDApID8gdW5kZWZpbmVkIDogW1t0aGlzLl94MCwgdGhpcy5feTBdLCBbdGhpcy5feDEsIHRoaXMuX3kxXV07XG59XG4iLCJpbXBvcnQgUXVhZCBmcm9tIFwiLi9xdWFkLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgsIHksIHJhZGl1cykge1xuICB2YXIgZGF0YSxcbiAgICAgIHgwID0gdGhpcy5feDAsXG4gICAgICB5MCA9IHRoaXMuX3kwLFxuICAgICAgeDEsXG4gICAgICB5MSxcbiAgICAgIHgyLFxuICAgICAgeTIsXG4gICAgICB4MyA9IHRoaXMuX3gxLFxuICAgICAgeTMgPSB0aGlzLl95MSxcbiAgICAgIHF1YWRzID0gW10sXG4gICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgIHEsXG4gICAgICBpO1xuXG4gIGlmIChub2RlKSBxdWFkcy5wdXNoKG5ldyBRdWFkKG5vZGUsIHgwLCB5MCwgeDMsIHkzKSk7XG4gIGlmIChyYWRpdXMgPT0gbnVsbCkgcmFkaXVzID0gSW5maW5pdHk7XG4gIGVsc2Uge1xuICAgIHgwID0geCAtIHJhZGl1cywgeTAgPSB5IC0gcmFkaXVzO1xuICAgIHgzID0geCArIHJhZGl1cywgeTMgPSB5ICsgcmFkaXVzO1xuICAgIHJhZGl1cyAqPSByYWRpdXM7XG4gIH1cblxuICB3aGlsZSAocSA9IHF1YWRzLnBvcCgpKSB7XG5cbiAgICAvLyBTdG9wIHNlYXJjaGluZyBpZiB0aGlzIHF1YWRyYW50IGNhbuKAmXQgY29udGFpbiBhIGNsb3NlciBub2RlLlxuICAgIGlmICghKG5vZGUgPSBxLm5vZGUpXG4gICAgICAgIHx8ICh4MSA9IHEueDApID4geDNcbiAgICAgICAgfHwgKHkxID0gcS55MCkgPiB5M1xuICAgICAgICB8fCAoeDIgPSBxLngxKSA8IHgwXG4gICAgICAgIHx8ICh5MiA9IHEueTEpIDwgeTApIGNvbnRpbnVlO1xuXG4gICAgLy8gQmlzZWN0IHRoZSBjdXJyZW50IHF1YWRyYW50LlxuICAgIGlmIChub2RlLmxlbmd0aCkge1xuICAgICAgdmFyIHhtID0gKHgxICsgeDIpIC8gMixcbiAgICAgICAgICB5bSA9ICh5MSArIHkyKSAvIDI7XG5cbiAgICAgIHF1YWRzLnB1c2goXG4gICAgICAgIG5ldyBRdWFkKG5vZGVbM10sIHhtLCB5bSwgeDIsIHkyKSxcbiAgICAgICAgbmV3IFF1YWQobm9kZVsyXSwgeDEsIHltLCB4bSwgeTIpLFxuICAgICAgICBuZXcgUXVhZChub2RlWzFdLCB4bSwgeTEsIHgyLCB5bSksXG4gICAgICAgIG5ldyBRdWFkKG5vZGVbMF0sIHgxLCB5MSwgeG0sIHltKVxuICAgICAgKTtcblxuICAgICAgLy8gVmlzaXQgdGhlIGNsb3Nlc3QgcXVhZHJhbnQgZmlyc3QuXG4gICAgICBpZiAoaSA9ICh5ID49IHltKSA8PCAxIHwgKHggPj0geG0pKSB7XG4gICAgICAgIHEgPSBxdWFkc1txdWFkcy5sZW5ndGggLSAxXTtcbiAgICAgICAgcXVhZHNbcXVhZHMubGVuZ3RoIC0gMV0gPSBxdWFkc1txdWFkcy5sZW5ndGggLSAxIC0gaV07XG4gICAgICAgIHF1YWRzW3F1YWRzLmxlbmd0aCAtIDEgLSBpXSA9IHE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmlzaXQgdGhpcyBwb2ludC4gKFZpc2l0aW5nIGNvaW5jaWRlbnQgcG9pbnRzIGlzbuKAmXQgbmVjZXNzYXJ5ISlcbiAgICBlbHNlIHtcbiAgICAgIHZhciBkeCA9IHggLSArdGhpcy5feC5jYWxsKG51bGwsIG5vZGUuZGF0YSksXG4gICAgICAgICAgZHkgPSB5IC0gK3RoaXMuX3kuY2FsbChudWxsLCBub2RlLmRhdGEpLFxuICAgICAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICBpZiAoZDIgPCByYWRpdXMpIHtcbiAgICAgICAgdmFyIGQgPSBNYXRoLnNxcnQocmFkaXVzID0gZDIpO1xuICAgICAgICB4MCA9IHggLSBkLCB5MCA9IHkgLSBkO1xuICAgICAgICB4MyA9IHggKyBkLCB5MyA9IHkgKyBkO1xuICAgICAgICBkYXRhID0gbm9kZS5kYXRhO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuIiwiZXhwb3J0IHtkZWZhdWx0IGFzIHF1YWR0cmVlfSBmcm9tIFwiLi9xdWFkdHJlZS5qc1wiO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obm9kZSwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy54MCA9IHgwO1xuICB0aGlzLnkwID0geTA7XG4gIHRoaXMueDEgPSB4MTtcbiAgdGhpcy55MSA9IHkxO1xufVxuIiwiaW1wb3J0IHRyZWVfYWRkLCB7YWRkQWxsIGFzIHRyZWVfYWRkQWxsfSBmcm9tIFwiLi9hZGQuanNcIjtcbmltcG9ydCB0cmVlX2NvdmVyIGZyb20gXCIuL2NvdmVyLmpzXCI7XG5pbXBvcnQgdHJlZV9kYXRhIGZyb20gXCIuL2RhdGEuanNcIjtcbmltcG9ydCB0cmVlX2V4dGVudCBmcm9tIFwiLi9leHRlbnQuanNcIjtcbmltcG9ydCB0cmVlX2ZpbmQgZnJvbSBcIi4vZmluZC5qc1wiO1xuaW1wb3J0IHRyZWVfcmVtb3ZlLCB7cmVtb3ZlQWxsIGFzIHRyZWVfcmVtb3ZlQWxsfSBmcm9tIFwiLi9yZW1vdmUuanNcIjtcbmltcG9ydCB0cmVlX3Jvb3QgZnJvbSBcIi4vcm9vdC5qc1wiO1xuaW1wb3J0IHRyZWVfc2l6ZSBmcm9tIFwiLi9zaXplLmpzXCI7XG5pbXBvcnQgdHJlZV92aXNpdCBmcm9tIFwiLi92aXNpdC5qc1wiO1xuaW1wb3J0IHRyZWVfdmlzaXRBZnRlciBmcm9tIFwiLi92aXNpdEFmdGVyLmpzXCI7XG5pbXBvcnQgdHJlZV94LCB7ZGVmYXVsdFh9IGZyb20gXCIuL3guanNcIjtcbmltcG9ydCB0cmVlX3ksIHtkZWZhdWx0WX0gZnJvbSBcIi4veS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBxdWFkdHJlZShub2RlcywgeCwgeSkge1xuICB2YXIgdHJlZSA9IG5ldyBRdWFkdHJlZSh4ID09IG51bGwgPyBkZWZhdWx0WCA6IHgsIHkgPT0gbnVsbCA/IGRlZmF1bHRZIDogeSwgTmFOLCBOYU4sIE5hTiwgTmFOKTtcbiAgcmV0dXJuIG5vZGVzID09IG51bGwgPyB0cmVlIDogdHJlZS5hZGRBbGwobm9kZXMpO1xufVxuXG5mdW5jdGlvbiBRdWFkdHJlZSh4LCB5LCB4MCwgeTAsIHgxLCB5MSkge1xuICB0aGlzLl94ID0geDtcbiAgdGhpcy5feSA9IHk7XG4gIHRoaXMuX3gwID0geDA7XG4gIHRoaXMuX3kwID0geTA7XG4gIHRoaXMuX3gxID0geDE7XG4gIHRoaXMuX3kxID0geTE7XG4gIHRoaXMuX3Jvb3QgPSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGxlYWZfY29weShsZWFmKSB7XG4gIHZhciBjb3B5ID0ge2RhdGE6IGxlYWYuZGF0YX0sIG5leHQgPSBjb3B5O1xuICB3aGlsZSAobGVhZiA9IGxlYWYubmV4dCkgbmV4dCA9IG5leHQubmV4dCA9IHtkYXRhOiBsZWFmLmRhdGF9O1xuICByZXR1cm4gY29weTtcbn1cblxudmFyIHRyZWVQcm90byA9IHF1YWR0cmVlLnByb3RvdHlwZSA9IFF1YWR0cmVlLnByb3RvdHlwZTtcblxudHJlZVByb3RvLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvcHkgPSBuZXcgUXVhZHRyZWUodGhpcy5feCwgdGhpcy5feSwgdGhpcy5feDAsIHRoaXMuX3kwLCB0aGlzLl94MSwgdGhpcy5feTEpLFxuICAgICAgbm9kZSA9IHRoaXMuX3Jvb3QsXG4gICAgICBub2RlcyxcbiAgICAgIGNoaWxkO1xuXG4gIGlmICghbm9kZSkgcmV0dXJuIGNvcHk7XG5cbiAgaWYgKCFub2RlLmxlbmd0aCkgcmV0dXJuIGNvcHkuX3Jvb3QgPSBsZWFmX2NvcHkobm9kZSksIGNvcHk7XG5cbiAgbm9kZXMgPSBbe3NvdXJjZTogbm9kZSwgdGFyZ2V0OiBjb3B5Ll9yb290ID0gbmV3IEFycmF5KDQpfV07XG4gIHdoaWxlIChub2RlID0gbm9kZXMucG9wKCkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgaWYgKGNoaWxkID0gbm9kZS5zb3VyY2VbaV0pIHtcbiAgICAgICAgaWYgKGNoaWxkLmxlbmd0aCkgbm9kZXMucHVzaCh7c291cmNlOiBjaGlsZCwgdGFyZ2V0OiBub2RlLnRhcmdldFtpXSA9IG5ldyBBcnJheSg0KX0pO1xuICAgICAgICBlbHNlIG5vZGUudGFyZ2V0W2ldID0gbGVhZl9jb3B5KGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29weTtcbn07XG5cbnRyZWVQcm90by5hZGQgPSB0cmVlX2FkZDtcbnRyZWVQcm90by5hZGRBbGwgPSB0cmVlX2FkZEFsbDtcbnRyZWVQcm90by5jb3ZlciA9IHRyZWVfY292ZXI7XG50cmVlUHJvdG8uZGF0YSA9IHRyZWVfZGF0YTtcbnRyZWVQcm90by5leHRlbnQgPSB0cmVlX2V4dGVudDtcbnRyZWVQcm90by5maW5kID0gdHJlZV9maW5kO1xudHJlZVByb3RvLnJlbW92ZSA9IHRyZWVfcmVtb3ZlO1xudHJlZVByb3RvLnJlbW92ZUFsbCA9IHRyZWVfcmVtb3ZlQWxsO1xudHJlZVByb3RvLnJvb3QgPSB0cmVlX3Jvb3Q7XG50cmVlUHJvdG8uc2l6ZSA9IHRyZWVfc2l6ZTtcbnRyZWVQcm90by52aXNpdCA9IHRyZWVfdmlzaXQ7XG50cmVlUHJvdG8udmlzaXRBZnRlciA9IHRyZWVfdmlzaXRBZnRlcjtcbnRyZWVQcm90by54ID0gdHJlZV94O1xudHJlZVByb3RvLnkgPSB0cmVlX3k7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkKSB7XG4gIGlmIChpc05hTih4ID0gK3RoaXMuX3guY2FsbChudWxsLCBkKSkgfHwgaXNOYU4oeSA9ICt0aGlzLl95LmNhbGwobnVsbCwgZCkpKSByZXR1cm4gdGhpczsgLy8gaWdub3JlIGludmFsaWQgcG9pbnRzXG5cbiAgdmFyIHBhcmVudCxcbiAgICAgIG5vZGUgPSB0aGlzLl9yb290LFxuICAgICAgcmV0YWluZXIsXG4gICAgICBwcmV2aW91cyxcbiAgICAgIG5leHQsXG4gICAgICB4MCA9IHRoaXMuX3gwLFxuICAgICAgeTAgPSB0aGlzLl95MCxcbiAgICAgIHgxID0gdGhpcy5feDEsXG4gICAgICB5MSA9IHRoaXMuX3kxLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB4bSxcbiAgICAgIHltLFxuICAgICAgcmlnaHQsXG4gICAgICBib3R0b20sXG4gICAgICBpLFxuICAgICAgajtcblxuICAvLyBJZiB0aGUgdHJlZSBpcyBlbXB0eSwgaW5pdGlhbGl6ZSB0aGUgcm9vdCBhcyBhIGxlYWYuXG4gIGlmICghbm9kZSkgcmV0dXJuIHRoaXM7XG5cbiAgLy8gRmluZCB0aGUgbGVhZiBub2RlIGZvciB0aGUgcG9pbnQuXG4gIC8vIFdoaWxlIGRlc2NlbmRpbmcsIGFsc28gcmV0YWluIHRoZSBkZWVwZXN0IHBhcmVudCB3aXRoIGEgbm9uLXJlbW92ZWQgc2libGluZy5cbiAgaWYgKG5vZGUubGVuZ3RoKSB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChyaWdodCA9IHggPj0gKHhtID0gKHgwICsgeDEpIC8gMikpIHgwID0geG07IGVsc2UgeDEgPSB4bTtcbiAgICBpZiAoYm90dG9tID0geSA+PSAoeW0gPSAoeTAgKyB5MSkgLyAyKSkgeTAgPSB5bTsgZWxzZSB5MSA9IHltO1xuICAgIGlmICghKHBhcmVudCA9IG5vZGUsIG5vZGUgPSBub2RlW2kgPSBib3R0b20gPDwgMSB8IHJpZ2h0XSkpIHJldHVybiB0aGlzO1xuICAgIGlmICghbm9kZS5sZW5ndGgpIGJyZWFrO1xuICAgIGlmIChwYXJlbnRbKGkgKyAxKSAmIDNdIHx8IHBhcmVudFsoaSArIDIpICYgM10gfHwgcGFyZW50WyhpICsgMykgJiAzXSkgcmV0YWluZXIgPSBwYXJlbnQsIGogPSBpO1xuICB9XG5cbiAgLy8gRmluZCB0aGUgcG9pbnQgdG8gcmVtb3ZlLlxuICB3aGlsZSAobm9kZS5kYXRhICE9PSBkKSBpZiAoIShwcmV2aW91cyA9IG5vZGUsIG5vZGUgPSBub2RlLm5leHQpKSByZXR1cm4gdGhpcztcbiAgaWYgKG5leHQgPSBub2RlLm5leHQpIGRlbGV0ZSBub2RlLm5leHQ7XG5cbiAgLy8gSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNvaW5jaWRlbnQgcG9pbnRzLCByZW1vdmUganVzdCB0aGUgcG9pbnQuXG4gIGlmIChwcmV2aW91cykgcmV0dXJuIChuZXh0ID8gcHJldmlvdXMubmV4dCA9IG5leHQgOiBkZWxldGUgcHJldmlvdXMubmV4dCksIHRoaXM7XG5cbiAgLy8gSWYgdGhpcyBpcyB0aGUgcm9vdCBwb2ludCwgcmVtb3ZlIGl0LlxuICBpZiAoIXBhcmVudCkgcmV0dXJuIHRoaXMuX3Jvb3QgPSBuZXh0LCB0aGlzO1xuXG4gIC8vIFJlbW92ZSB0aGlzIGxlYWYuXG4gIG5leHQgPyBwYXJlbnRbaV0gPSBuZXh0IDogZGVsZXRlIHBhcmVudFtpXTtcblxuICAvLyBJZiB0aGUgcGFyZW50IG5vdyBjb250YWlucyBleGFjdGx5IG9uZSBsZWFmLCBjb2xsYXBzZSBzdXBlcmZsdW91cyBwYXJlbnRzLlxuICBpZiAoKG5vZGUgPSBwYXJlbnRbMF0gfHwgcGFyZW50WzFdIHx8IHBhcmVudFsyXSB8fCBwYXJlbnRbM10pXG4gICAgICAmJiBub2RlID09PSAocGFyZW50WzNdIHx8IHBhcmVudFsyXSB8fCBwYXJlbnRbMV0gfHwgcGFyZW50WzBdKVxuICAgICAgJiYgIW5vZGUubGVuZ3RoKSB7XG4gICAgaWYgKHJldGFpbmVyKSByZXRhaW5lcltqXSA9IG5vZGU7XG4gICAgZWxzZSB0aGlzLl9yb290ID0gbm9kZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQWxsKGRhdGEpIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSBkYXRhLmxlbmd0aDsgaSA8IG47ICsraSkgdGhpcy5yZW1vdmUoZGF0YVtpXSk7XG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9yb290O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBzaXplID0gMDtcbiAgdGhpcy52aXNpdChmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKCFub2RlLmxlbmd0aCkgZG8gKytzaXplOyB3aGlsZSAobm9kZSA9IG5vZGUubmV4dClcbiAgfSk7XG4gIHJldHVybiBzaXplO1xufVxuIiwiaW1wb3J0IFF1YWQgZnJvbSBcIi4vcXVhZC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgcXVhZHMgPSBbXSwgcSwgbm9kZSA9IHRoaXMuX3Jvb3QsIGNoaWxkLCB4MCwgeTAsIHgxLCB5MTtcbiAgaWYgKG5vZGUpIHF1YWRzLnB1c2gobmV3IFF1YWQobm9kZSwgdGhpcy5feDAsIHRoaXMuX3kwLCB0aGlzLl94MSwgdGhpcy5feTEpKTtcbiAgd2hpbGUgKHEgPSBxdWFkcy5wb3AoKSkge1xuICAgIGlmICghY2FsbGJhY2sobm9kZSA9IHEubm9kZSwgeDAgPSBxLngwLCB5MCA9IHEueTAsIHgxID0gcS54MSwgeTEgPSBxLnkxKSAmJiBub2RlLmxlbmd0aCkge1xuICAgICAgdmFyIHhtID0gKHgwICsgeDEpIC8gMiwgeW0gPSAoeTAgKyB5MSkgLyAyO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVszXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeG0sIHltLCB4MSwgeTEpKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMl0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHgwLCB5bSwgeG0sIHkxKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzFdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4bSwgeTAsIHgxLCB5bSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVswXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeDAsIHkwLCB4bSwgeW0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJpbXBvcnQgUXVhZCBmcm9tIFwiLi9xdWFkLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBxdWFkcyA9IFtdLCBuZXh0ID0gW10sIHE7XG4gIGlmICh0aGlzLl9yb290KSBxdWFkcy5wdXNoKG5ldyBRdWFkKHRoaXMuX3Jvb3QsIHRoaXMuX3gwLCB0aGlzLl95MCwgdGhpcy5feDEsIHRoaXMuX3kxKSk7XG4gIHdoaWxlIChxID0gcXVhZHMucG9wKCkpIHtcbiAgICB2YXIgbm9kZSA9IHEubm9kZTtcbiAgICBpZiAobm9kZS5sZW5ndGgpIHtcbiAgICAgIHZhciBjaGlsZCwgeDAgPSBxLngwLCB5MCA9IHEueTAsIHgxID0gcS54MSwgeTEgPSBxLnkxLCB4bSA9ICh4MCArIHgxKSAvIDIsIHltID0gKHkwICsgeTEpIC8gMjtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMF0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHgwLCB5MCwgeG0sIHltKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzFdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4bSwgeTAsIHgxLCB5bSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVsyXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeDAsIHltLCB4bSwgeTEpKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbM10pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHhtLCB5bSwgeDEsIHkxKSk7XG4gICAgfVxuICAgIG5leHQucHVzaChxKTtcbiAgfVxuICB3aGlsZSAocSA9IG5leHQucG9wKCkpIHtcbiAgICBjYWxsYmFjayhxLm5vZGUsIHEueDAsIHEueTAsIHEueDEsIHEueTEpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRYKGQpIHtcbiAgcmV0dXJuIGRbMF07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKF8pIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGhpcy5feCA9IF8sIHRoaXMpIDogdGhpcy5feDtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0WShkKSB7XG4gIHJldHVybiBkWzFdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihfKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRoaXMuX3kgPSBfLCB0aGlzKSA6IHRoaXMuX3k7XG59XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHRsb2FkZWQ6IGZhbHNlLFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm5tZCA9IChtb2R1bGUpID0+IHtcblx0bW9kdWxlLnBhdGhzID0gW107XG5cdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0cmV0dXJuIG1vZHVsZTtcbn07IiwiIiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvaW5kZXgudHNcIik7XG4iLCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=