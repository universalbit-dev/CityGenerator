<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>CityGenerator</title>
  <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.161.4/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/",
        "jsts": "https://cdn.jsdelivr.net/npm/jsts@2.11.3/dist/jsts.min.js"
      }
    }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mnist@1.1.0/dist/mnist.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/ol@9.2.3/ol.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/ol@9.2.3/index.min.js"></script>
</head>

<body>
  
<script src="./deepqlearn.js"></script>

<script>
var num_inputs = 27; // 9 eyes, each sees 3 numbers (wall, green, red thing proximity)
var num_actions = 5; // 5 possible angles agent can turn
var temporal_window = 1; // amount of temporal memory. 0 = agent lives in-the-moment :)
var network_size = num_inputs*temporal_window + num_actions*temporal_window + num_inputs;

// the value function network computes a value of taking any of the possible actions
// given an input state. Here we specify one explicitly the hard way
// but user could also equivalently instead use opt.hidden_layer_sizes = [20,20]
// to just insert simple relu hidden layers.
var layer_defs = [];
layer_defs.push({type:'input', out_sx:1, out_sy:1, out_depth:network_size});
layer_defs.push({type:'fc', num_neurons: 50, activation:'relu'});
layer_defs.push({type:'fc', num_neurons: 50, activation:'relu'});
layer_defs.push({type:'regression', num_neurons:num_actions});

// options for the Temporal Difference learner that trains the above net
// by backpropping the temporal difference learning rule.
var tdtrainer_options = {learning_rate:0.001, momentum:0.0, batch_size:64, l2_decay:0.01};

var opt = {};
opt.temporal_window = temporal_window;
opt.experience_size = 30000;
opt.start_learn_threshold = 1000;
opt.gamma = 0.7;
opt.learning_steps_total = 200000;
opt.learning_steps_burnin = 3000;
opt.epsilon_min = 0.05;
opt.epsilon_test_time = 0.05;
opt.layer_defs = layer_defs;
opt.tdtrainer_options = tdtrainer_options;

var brain = new deepqlearn.Brain(num_inputs, num_actions, opt); // woohoo
</script>

<script src="./convnet.js">
  var t = "/* */";
  var layer_defs = [];
  /*  */
  var x=Math.floor((Math.random() * 24) + 1); //random whole number between 1 and 24
  var y=Math.floor((Math.random() * 24) + 1); //random whole number between 1 and 24
  var neuro = Math.floor((Math.random() * 144) + 1); //random whole number between 1 and 144
  layer_defs.push({type:'input', out_sx:x, out_sy:y, out_depth:1});
  layer_defs.push({type:'fc', num_neurons:neuro, activation:'relu'});
  layer_defs.push({type:'conv', num_neurons:neuro, activation:'sigmoid'});
  layer_defs.push({type:'softmax', num_classes:8});

  var LR = 0.01;
  var BS = 8;
  var L2 = 0.001;
  nets = [];
  trainer_defs = [];
  trainer_defs.push({learning_rate:10*LR, method: 'sgd', momentum: 0.0, batch_size:BS, l2_decay:L2});
  trainer_defs.push({learning_rate:LR, method: 'sgd', momentum: 0.9, batch_size:BS, l2_decay:L2});
  trainer_defs.push({learning_rate:LR, method: 'adagrad', eps: 1e-6, batch_size:BS, l2_decay:L2});
  trainer_defs.push({learning_rate:LR, method: 'windowgrad', eps: 1e-6, ro: 0.95, batch_size:BS, l2_decay:L2});
  trainer_defs.push({learning_rate:1.0, method: 'adadelta', eps: 1e-6, ro:0.95, batch_size:BS, l2_decay:L2});
  trainer_defs.push({learning_rate:LR, method: 'nesterov', momentum: 0.9, batch_size:BS, l2_decay:L2});

  legend = ['sgd', 'sgd+momentum', 'adagrad', 'windowgrad', 'adadelta', 'nesterov'];

  // --------------------------
  // BEGIN MNIST SPECIFIC STUFF
  // --------------------------
  classes_txt = ['0','1','2','3','4','5','6','7','8','9'];

  var use_validation_data = false;
  var sample_training_instance = function() {

    var bi = Math.floor(Math.random()*loaded_train_batches.length);
    var b = loaded_train_batches[bi];
    var k = Math.floor(Math.random()*3000); // sample within the batch
    var n = b*3000+k;

    if(step_num%5000===0 && step_num>0) {
      for(var i=0;i<num_batches;i++) {
        if(!loaded[i]) {
          load_data_batch(i);
          break;
        }
      }
    }

    var p = img_data[b].data;
    var x = new convnetjs.Vol(28,28,1,0.0);
    var W = 28*28;
    for(var i=0;i<W;i++) {
      var ix = ((W * k) + i) * 4;
      x.w[i] = p[ix]/255.0;
    }
    x = convnetjs.augment(x, 24);

    var isval = use_validation_data && n%10===0 ? true : false;
    return {x:x, label:labels[n], isval:isval};
  }
    var sample_test_instance = function() {
    var b = 20;
    var k = Math.floor(Math.random()*3000);
    var n = b*3000+k;
    var p = img_data[b].data;
    var x = new convnetjs.Vol(28,28,1,0.0);
    var W = 28*28;
    for(var i=0;i<W;i++) {
      var ix = ((W * k) + i) * 4;
      x.w[i] = p[ix]/255.0;
    }
    x = convnetjs.augment(x, 24);
    return {x:x, label:labels[n]};
  }

  var num_batches = 21; // 20 training batches, 1 test
  var data_img_elts = new Array(num_batches);
  var img_data = new Array(num_batches);
  var loaded = new Array(num_batches);
  var loaded_train_batches = [];
  var step_num = 0;

  var lossWindows = [];
  var trainAccWindows = [];
  var testAccWindows = [];
  var lossGraph, trainGraph, testGraph;
  var reload = function() {

    var N = trainer_defs.length;
    nets = [];trainers = [];
    for(var i=0;i<N;i++) {
      var net = new convnetjs.Net();
      net.makeLayers(layer_defs);
      var trainer = new convnetjs.Trainer(net, trainer_defs[i]);
      nets.push(net);
      trainers.push(trainer);
    }

    step_num = 0;

    lossWindows = [];
    trainAccWindows = [];
    testAccWindows = [];
    for(var i=0;i<N;i++) {
      lossWindows.push(new cnnutil.Window(800));
      trainAccWindows.push(new cnnutil.Window(800));
      testAccWindows.push(new cnnutil.Window(800));
    }
    lossGraph = new cnnvis.MultiGraph(legend);
    trainGraph = new cnnvis.MultiGraph(legend);
    testGraph = new cnnvis.MultiGraph(legend);
  }

  var start_fun = function() {
    if(loaded[0] && loaded[20]) {
      console.log('starting!');
      setInterval(load_and_step, 0);
    }
    else { setTimeout(start_fun, 200); }
  }

  var load_data_batch = function(batch_num) {
    // Load the dataset with JS in background
    data_img_elts[batch_num] = new Image();
    var data_img_elt = data_img_elts[batch_num];
    data_img_elt.onload = function() {
      var data_canvas = document.createElement('canvas');
      data_canvas.width = data_img_elt.width;
      data_canvas.height = data_img_elt.height;
      var data_ctx = data_canvas.getContext("2d");
      data_ctx.drawImage(data_img_elt, 0, 0); // copy it over... bit wasteful :(
      img_data[batch_num] = data_ctx.getImageData(0, 0, data_canvas.width, data_canvas.height);
      loaded[batch_num] = true;
      if(batch_num < 20) { loaded_train_batches.push(batch_num); }
      console.log('finished loading data batch ' + batch_num);
    };
    data_img_elt.src = "mnist/mnist_batch_" + batch_num + ".png";
  }

  // ------------------------
  // END MNIST SPECIFIC STUFF
  // ------------------------

  var load_and_step = function() {
    step_num++;
    var sample = sample_training_instance();
    var test_sample = sample_test_instance();
    var N = nets.length;
    var losses = [];
    var trainacc = [];
    testacc = [];
    for(var i=0;i<N;i++) {

    var stats = trainers[i].train(sample.x, sample.label);
    var yhat = nets[i].getPrediction();
    trainAccWindows[i].add(yhat === sample.label ? 1.0 : 0.0);
    lossWindows[i].add(stats.loss);


    nets[i].forward(test_sample.x);
    var yhat_test = nets[i].getPrediction();
    testAccWindows[i].add(yhat_test === test_sample.label ? 1.0 : 0.0);

    if(step_num % 100 === 0) {
    losses.push(lossWindows[i].get_average());
    trainacc.push(trainAccWindows[i].get_average());
    testacc.push(testAccWindows[i].get_average());
    }
  }
    if(step_num % 100 === 0) {
    lossGraph.add(step_num, losses);
    lossGraph.drawSelf(document.getElementById("lossgraph"));
    trainGraph.add(step_num, trainacc);
    trainGraph.drawSelf(document.getElementById("trainaccgraph"));
    testGraph.add(step_num, testacc);
    testGraph.drawSelf(document.getElementById("testaccgraph"));
    }
  }
  </script>

 <svg id="map-svg"></svg>
  <div>
    <canvas id="map-canvas" width="300" height="150"></canvas>  <!-- Must match util.ts and style.css -->
    <canvas id="img-canvas" width="300" height="150"></canvas>
  </div>
  <script src="bundle_edit.js"></script>

<!-- Backend OpenLayers API--> <div id="mapdiv"></div>

</body>

</html>
